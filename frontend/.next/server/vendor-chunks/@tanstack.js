"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexports[\"extends\"] = _extends;\n//# sourceMappingURL=_rollupPluginBabelHelpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvYnVpbGQvbGliL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9idWlsZC9saWIvX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcz8wYzExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3QtdmlydHVhbFxuICpcbiAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0c1tcImV4dGVuZHNcIl0gPSBfZXh0ZW5kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/build/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/build/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_virtual/_rollupPluginBabelHelpers.js */ \"(ssr)/./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar virtualCore = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/build/lib/index.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n//\n\nvar useIsomorphicLayoutEffect = typeof document !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;\nfunction useVirtualizerBase(options) {\n  var rerender = React__namespace.useReducer(function () {\n    return {};\n  }, {})[1];\n  var resolvedOptions = _rollupPluginBabelHelpers[\"extends\"]({}, options, {\n    onChange: function onChange(instance) {\n      rerender();\n      options.onChange == null ? void 0 : options.onChange(instance);\n    }\n  });\n  var _React$useState = React__namespace.useState(function () {\n      return new virtualCore.Virtualizer(resolvedOptions);\n    }),\n    instance = _React$useState[0];\n  instance.setOptions(resolvedOptions);\n  React__namespace.useEffect(function () {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase(_rollupPluginBabelHelpers[\"extends\"]({\n    observeElementRect: virtualCore.observeElementRect,\n    observeElementOffset: virtualCore.observeElementOffset,\n    scrollToFn: virtualCore.elementScroll\n  }, options));\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase(_rollupPluginBabelHelpers[\"extends\"]({\n    getScrollElement: function getScrollElement() {\n      return typeof document !== 'undefined' ? window : null;\n    },\n    observeElementRect: virtualCore.observeWindowRect,\n    observeElementOffset: virtualCore.observeWindowOffset,\n    scrollToFn: virtualCore.windowScroll\n  }, options));\n}\n\nexports.useVirtualizer = useVirtualizer;\nexports.useWindowVirtualizer = useWindowVirtualizer;\nObject.keys(virtualCore).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return virtualCore[k]; }\n  });\n});\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvYnVpbGQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw2SUFBeUM7QUFDakYsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLDhGQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyZXltYXR0ZXItdjIvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvYnVpbGQvbGliL2luZGV4LmpzP2NjN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWFjdC12aXJ0dWFsXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzID0gcmVxdWlyZSgnLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHZpcnR1YWxDb3JlID0gcmVxdWlyZSgnQHRhbnN0YWNrL3ZpcnR1YWwtY29yZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbi8vXG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0IDogUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplckJhc2Uob3B0aW9ucykge1xuICB2YXIgcmVyZW5kZXIgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZHVjZXIoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSwge30pWzFdO1xuICB2YXIgcmVzb2x2ZWRPcHRpb25zID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVyc1tcImV4dGVuZHNcIl0oe30sIG9wdGlvbnMsIHtcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoaW5zdGFuY2UpIHtcbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgICBvcHRpb25zLm9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uQ2hhbmdlKGluc3RhbmNlKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IHZpcnR1YWxDb3JlLlZpcnR1YWxpemVyKHJlc29sdmVkT3B0aW9ucyk7XG4gICAgfSksXG4gICAgaW5zdGFuY2UgPSBfUmVhY3QkdXNlU3RhdGVbMF07XG4gIGluc3RhbmNlLnNldE9wdGlvbnMocmVzb2x2ZWRPcHRpb25zKTtcbiAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fZGlkTW91bnQoKTtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX3dpbGxVcGRhdGUoKTtcbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHVzZVZpcnR1YWxpemVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZVZpcnR1YWxpemVyQmFzZShfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzW1wiZXh0ZW5kc1wiXSh7XG4gICAgb2JzZXJ2ZUVsZW1lbnRSZWN0OiB2aXJ0dWFsQ29yZS5vYnNlcnZlRWxlbWVudFJlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IHZpcnR1YWxDb3JlLm9ic2VydmVFbGVtZW50T2Zmc2V0LFxuICAgIHNjcm9sbFRvRm46IHZpcnR1YWxDb3JlLmVsZW1lbnRTY3JvbGxcbiAgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gdXNlV2luZG93VmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnNbXCJleHRlbmRzXCJdKHtcbiAgICBnZXRTY3JvbGxFbGVtZW50OiBmdW5jdGlvbiBnZXRTY3JvbGxFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xuICAgIH0sXG4gICAgb2JzZXJ2ZUVsZW1lbnRSZWN0OiB2aXJ0dWFsQ29yZS5vYnNlcnZlV2luZG93UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogdmlydHVhbENvcmUub2JzZXJ2ZVdpbmRvd09mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiB2aXJ0dWFsQ29yZS53aW5kb3dTY3JvbGxcbiAgfSwgb3B0aW9ucykpO1xufVxuXG5leHBvcnRzLnVzZVZpcnR1YWxpemVyID0gdXNlVmlydHVhbGl6ZXI7XG5leHBvcnRzLnVzZVdpbmRvd1ZpcnR1YWxpemVyID0gdXNlV2luZG93VmlydHVhbGl6ZXI7XG5PYmplY3Qua2V5cyh2aXJ0dWFsQ29yZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2aXJ0dWFsQ29yZVtrXTsgfVxuICB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/build/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexports[\"extends\"] = _extends;\n//# sourceMappingURL=_rollupPluginBabelHelpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmV5bWF0dGVyLXYyLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvYnVpbGQvbGliL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanM/YmYxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZpcnR1YWwtY29yZVxuICpcbiAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0c1tcImV4dGVuZHNcIl0gPSBfZXh0ZW5kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/build/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/build/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar _rollupPluginBabelHelpers = __webpack_require__(/*! ./_virtual/_rollupPluginBabelHelpers.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/build/lib/utils.js\");\n\n//\n\n//\n\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.startIndex - range.overscan, 0);\n  var end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  var arr = [];\n  for (var _i = start; _i <= end; _i++) {\n    arr.push(_i);\n  }\n  return arr;\n};\nvar observeElementRect = function observeElementRect(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var handler = function handler(rect) {\n    var width = rect.width,\n      height = rect.height;\n    cb({\n      width: Math.round(width),\n      height: Math.round(height)\n    });\n  };\n  handler(element.getBoundingClientRect());\n  var observer = new ResizeObserver(function (entries) {\n    var entry = entries[0];\n    if (entry != null && entry.borderBoxSize) {\n      var box = entry.borderBoxSize[0];\n      if (box) {\n        handler({\n          width: box.inlineSize,\n          height: box.blockSize\n        });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, {\n    box: 'border-box'\n  });\n  return function () {\n    observer.unobserve(element);\n  };\n};\nvar observeWindowRect = function observeWindowRect(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var handler = function handler() {\n    cb({\n      width: element.innerWidth,\n      height: element.innerHeight\n    });\n  };\n  handler();\n  element.addEventListener('resize', handler, {\n    passive: true\n  });\n  return function () {\n    element.removeEventListener('resize', handler);\n  };\n};\nvar observeElementOffset = function observeElementOffset(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var handler = function handler() {\n    cb(element[instance.options.horizontal ? 'scrollLeft' : 'scrollTop']);\n  };\n  handler();\n  element.addEventListener('scroll', handler, {\n    passive: true\n  });\n  return function () {\n    element.removeEventListener('scroll', handler);\n  };\n};\nvar observeWindowOffset = function observeWindowOffset(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var handler = function handler() {\n    cb(element[instance.options.horizontal ? 'scrollX' : 'scrollY']);\n  };\n  handler();\n  element.addEventListener('scroll', handler, {\n    passive: true\n  });\n  return function () {\n    element.removeEventListener('scroll', handler);\n  };\n};\nvar measureElement = function measureElement(element, entry, instance) {\n  if (entry != null && entry.borderBoxSize) {\n    var box = entry.borderBoxSize[0];\n    if (box) {\n      var size = Math.round(box[instance.options.horizontal ? 'inlineSize' : 'blockSize']);\n      return size;\n    }\n  }\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height']);\n};\nvar windowScroll = function windowScroll(offset, _ref, instance) {\n  var _instance$scrollEleme, _instance$scrollEleme2;\n  var _ref$adjustments = _ref.adjustments,\n    adjustments = _ref$adjustments === void 0 ? 0 : _ref$adjustments,\n    behavior = _ref.behavior;\n  var toOffset = offset + adjustments;\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo((_instance$scrollEleme2 = {}, _instance$scrollEleme2[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme2.behavior = behavior, _instance$scrollEleme2));\n};\nvar elementScroll = function elementScroll(offset, _ref2, instance) {\n  var _instance$scrollEleme3, _instance$scrollEleme4;\n  var _ref2$adjustments = _ref2.adjustments,\n    adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments,\n    behavior = _ref2.behavior;\n  var toOffset = offset + adjustments;\n  (_instance$scrollEleme3 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme3.scrollTo == null ? void 0 : _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));\n};\nvar Virtualizer = function Virtualizer(_opts) {\n  var _this = this;\n  this.unsubs = [];\n  this.scrollElement = null;\n  this.isScrolling = false;\n  this.isScrollingTimeoutId = null;\n  this.scrollToIndexTimeoutId = null;\n  this.measurementsCache = [];\n  this.itemSizeCache = new Map();\n  this.pendingMeasuredCacheIndexes = [];\n  this.scrollDirection = null;\n  this.scrollAdjustments = 0;\n  this.measureElementCache = new Map();\n  this.observer = function () {\n    var _ro = null;\n    var get = function get() {\n      if (_ro) {\n        return _ro;\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return _ro = new ResizeObserver(function (entries) {\n          entries.forEach(function (entry) {\n            _this._measureElement(entry.target, entry);\n          });\n        });\n      } else {\n        return null;\n      }\n    };\n    return {\n      disconnect: function disconnect() {\n        var _get;\n        return (_get = get()) == null ? void 0 : _get.disconnect();\n      },\n      observe: function observe(target) {\n        var _get2;\n        return (_get2 = get()) == null ? void 0 : _get2.observe(target, {\n          box: 'border-box'\n        });\n      },\n      unobserve: function unobserve(target) {\n        var _get3;\n        return (_get3 = get()) == null ? void 0 : _get3.unobserve(target);\n      }\n    };\n  }();\n  this.range = {\n    startIndex: 0,\n    endIndex: 0\n  };\n  this.setOptions = function (opts) {\n    Object.entries(opts).forEach(function (_ref3) {\n      var key = _ref3[0],\n        value = _ref3[1];\n      if (typeof value === 'undefined') delete opts[key];\n    });\n    _this.options = _rollupPluginBabelHelpers[\"extends\"]({\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: function onChange() {},\n      measureElement: measureElement,\n      initialRect: {\n        width: 0,\n        height: 0\n      },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1\n    }, opts);\n  };\n  this.notify = function () {\n    _this.options.onChange == null ? void 0 : _this.options.onChange(_this);\n  };\n  this.cleanup = function () {\n    _this.unsubs.filter(Boolean).forEach(function (d) {\n      return d();\n    });\n    _this.unsubs = [];\n    _this.scrollElement = null;\n  };\n  this._didMount = function () {\n    _this.measureElementCache.forEach(_this.observer.observe);\n    return function () {\n      _this.observer.disconnect();\n      _this.cleanup();\n    };\n  };\n  this._willUpdate = function () {\n    var scrollElement = _this.options.getScrollElement();\n    if (_this.scrollElement !== scrollElement) {\n      _this.cleanup();\n      _this.scrollElement = scrollElement;\n      _this._scrollToOffset(_this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined\n      });\n      _this.unsubs.push(_this.options.observeElementRect(_this, function (rect) {\n        var prev = _this.scrollRect;\n        _this.scrollRect = rect;\n        if (_this.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n          _this.maybeNotify();\n        }\n      }));\n      _this.unsubs.push(_this.options.observeElementOffset(_this, function (offset) {\n        _this.scrollAdjustments = 0;\n        if (_this.scrollOffset === offset) {\n          return;\n        }\n        if (_this.isScrollingTimeoutId !== null) {\n          clearTimeout(_this.isScrollingTimeoutId);\n          _this.isScrollingTimeoutId = null;\n        }\n        _this.isScrolling = true;\n        _this.scrollDirection = _this.scrollOffset < offset ? 'forward' : 'backward';\n        _this.scrollOffset = offset;\n        _this.maybeNotify();\n        _this.isScrollingTimeoutId = setTimeout(function () {\n          _this.isScrollingTimeoutId = null;\n          _this.isScrolling = false;\n          _this.scrollDirection = null;\n          _this.maybeNotify();\n        }, _this.options.scrollingDelay);\n      }));\n    }\n  };\n  this.getSize = function () {\n    return _this.scrollRect[_this.options.horizontal ? 'width' : 'height'];\n  };\n  this.memoOptions = utils.memo(function () {\n    return [_this.options.count, _this.options.paddingStart, _this.options.scrollMargin, _this.options.getItemKey];\n  }, function (count, paddingStart, scrollMargin, getItemKey) {\n    _this.pendingMeasuredCacheIndexes = [];\n    return {\n      count: count,\n      paddingStart: paddingStart,\n      scrollMargin: scrollMargin,\n      getItemKey: getItemKey\n    };\n  }, {\n    key: false\n  });\n  this.getFurthestMeasurement = function (measurements, index) {\n    var furthestMeasurementsFound = new Map();\n    var furthestMeasurements = new Map();\n    for (var m = index - 1; m >= 0; m--) {\n      var measurement = measurements[m];\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue;\n      }\n      var previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n      if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n        furthestMeasurements.set(measurement.lane, measurement);\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true);\n      }\n      if (furthestMeasurementsFound.size === _this.options.lanes) {\n        break;\n      }\n    }\n    return furthestMeasurements.size === _this.options.lanes ? Array.from(furthestMeasurements.values()).sort(function (a, b) {\n      return a.end - b.end;\n    })[0] : undefined;\n  };\n  this.getMeasurements = utils.memo(function () {\n    return [_this.memoOptions(), _this.itemSizeCache];\n  }, function (_ref4, itemSizeCache) {\n    var count = _ref4.count,\n      paddingStart = _ref4.paddingStart,\n      scrollMargin = _ref4.scrollMargin,\n      getItemKey = _ref4.getItemKey;\n    var min = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;\n    _this.pendingMeasuredCacheIndexes = [];\n    var measurements = _this.measurementsCache.slice(0, min);\n    for (var _i2 = min; _i2 < count; _i2++) {\n      var key = getItemKey(_i2);\n      var furthestMeasurement = _this.options.lanes === 1 ? measurements[_i2 - 1] : _this.getFurthestMeasurement(measurements, _i2);\n      var start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;\n      var measuredSize = itemSizeCache.get(key);\n      var size = typeof measuredSize === 'number' ? measuredSize : _this.options.estimateSize(_i2);\n      var end = start + size;\n      var lane = furthestMeasurement ? furthestMeasurement.lane : _i2 % _this.options.lanes;\n      measurements[_i2] = {\n        index: _i2,\n        start: start,\n        size: size,\n        end: end,\n        key: key,\n        lane: lane\n      };\n    }\n    _this.measurementsCache = measurements;\n    return measurements;\n  }, {\n    key:  true && 'getMeasurements',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.calculateRange = utils.memo(function () {\n    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];\n  }, function (measurements, outerSize, scrollOffset) {\n    return _this.range = calculateRange({\n      measurements: measurements,\n      outerSize: outerSize,\n      scrollOffset: scrollOffset\n    });\n  }, {\n    key:  true && 'calculateRange',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.maybeNotify = utils.memo(function () {\n    var range = _this.calculateRange();\n    return [range.startIndex, range.endIndex, _this.isScrolling];\n  }, function () {\n    _this.notify();\n  }, {\n    key:  true && 'maybeNotify',\n    debug: function debug() {\n      return _this.options.debug;\n    },\n    initialDeps: [this.range.startIndex, this.range.endIndex, this.isScrolling]\n  });\n  this.getIndexes = utils.memo(function () {\n    return [_this.options.rangeExtractor, _this.calculateRange(), _this.options.overscan, _this.options.count];\n  }, function (rangeExtractor, range, overscan, count) {\n    return rangeExtractor(_rollupPluginBabelHelpers[\"extends\"]({}, range, {\n      overscan: overscan,\n      count: count\n    }));\n  }, {\n    key:  true && 'getIndexes',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.indexFromElement = function (node) {\n    var attributeName = _this.options.indexAttribute;\n    var indexStr = node.getAttribute(attributeName);\n    if (!indexStr) {\n      console.warn(\"Missing attribute name '\" + attributeName + \"={index}' on measured element.\");\n      return -1;\n    }\n    return parseInt(indexStr, 10);\n  };\n  this._measureElement = function (node, entry) {\n    var _this$itemSizeCache$g;\n    var index = _this.indexFromElement(node);\n    var item = _this.measurementsCache[index];\n    if (!item) {\n      return;\n    }\n    var prevNode = _this.measureElementCache.get(item.key);\n    if (!node.isConnected) {\n      _this.observer.unobserve(node);\n      if (node === prevNode) {\n        _this.measureElementCache[\"delete\"](item.key);\n      }\n      return;\n    }\n    if (prevNode !== node) {\n      if (prevNode) {\n        _this.observer.unobserve(prevNode);\n      }\n      _this.observer.observe(node);\n      _this.measureElementCache.set(item.key, node);\n    }\n    var measuredItemSize = _this.options.measureElement(node, entry, _this);\n    var itemSize = (_this$itemSizeCache$g = _this.itemSizeCache.get(item.key)) != null ? _this$itemSizeCache$g : item.size;\n    var delta = measuredItemSize - itemSize;\n    if (delta !== 0) {\n      if (item.start < _this.scrollOffset) {\n        if ( true && _this.options.debug) {\n          console.info('correction', delta);\n        }\n        _this._scrollToOffset(_this.scrollOffset, {\n          adjustments: _this.scrollAdjustments += delta,\n          behavior: undefined\n        });\n      }\n      _this.pendingMeasuredCacheIndexes.push(index);\n      _this.itemSizeCache = new Map(_this.itemSizeCache.set(item.key, measuredItemSize));\n      _this.notify();\n    }\n  };\n  this.measureElement = function (node) {\n    if (!node) {\n      return;\n    }\n    _this._measureElement(node, undefined);\n  };\n  this.getVirtualItems = utils.memo(function () {\n    return [_this.getIndexes(), _this.getMeasurements()];\n  }, function (indexes, measurements) {\n    var virtualItems = [];\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      var _i3 = indexes[k];\n      var measurement = measurements[_i3];\n      virtualItems.push(measurement);\n    }\n    return virtualItems;\n  }, {\n    key:  true && 'getIndexes',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.getVirtualItemForOffset = function (offset) {\n    var measurements = _this.getMeasurements();\n    return utils.notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, function (index) {\n      return utils.notUndefined(measurements[index]).start;\n    }, offset)]);\n  };\n  this.getOffsetForAlignment = function (toOffset, align) {\n    var size = _this.getSize();\n    if (align === 'auto') {\n      if (toOffset <= _this.scrollOffset) {\n        align = 'start';\n      } else if (toOffset >= _this.scrollOffset + size) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n    if (align === 'start') {\n      toOffset = toOffset;\n    } else if (align === 'end') {\n      toOffset = toOffset - size;\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2;\n    }\n    var scrollSizeProp = _this.options.horizontal ? 'scrollWidth' : 'scrollHeight';\n    var scrollSize = _this.scrollElement ? 'document' in _this.scrollElement ? _this.scrollElement.document.documentElement[scrollSizeProp] : _this.scrollElement[scrollSizeProp] : 0;\n    var maxOffset = scrollSize - _this.getSize();\n    return Math.max(Math.min(maxOffset, toOffset), 0);\n  };\n  this.getOffsetForIndex = function (index, align) {\n    if (align === void 0) {\n      align = 'auto';\n    }\n    index = Math.max(0, Math.min(index, _this.options.count - 1));\n    var measurement = utils.notUndefined(_this.getMeasurements()[index]);\n    if (align === 'auto') {\n      if (measurement.end >= _this.scrollOffset + _this.getSize() - _this.options.scrollPaddingEnd) {\n        align = 'end';\n      } else if (measurement.start <= _this.scrollOffset + _this.options.scrollPaddingStart) {\n        align = 'start';\n      } else {\n        return [_this.scrollOffset, align];\n      }\n    }\n    var toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n    return [_this.getOffsetForAlignment(toOffset, align), align];\n  };\n  this.isDynamicMode = function () {\n    return _this.measureElementCache.size > 0;\n  };\n  this.cancelScrollToIndex = function () {\n    if (_this.scrollToIndexTimeoutId !== null) {\n      clearTimeout(_this.scrollToIndexTimeoutId);\n      _this.scrollToIndexTimeoutId = null;\n    }\n  };\n  this.scrollToOffset = function (toOffset, _temp) {\n    var _ref5 = _temp === void 0 ? {} : _temp,\n      _ref5$align = _ref5.align,\n      align = _ref5$align === void 0 ? 'start' : _ref5$align,\n      behavior = _ref5.behavior;\n    _this.cancelScrollToIndex();\n    if (behavior === 'smooth' && _this.isDynamicMode()) {\n      console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.');\n    }\n    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior: behavior\n    });\n  };\n  this.scrollToIndex = function (index, _temp2) {\n    var _ref6 = _temp2 === void 0 ? {} : _temp2,\n      _ref6$align = _ref6.align,\n      initialAlign = _ref6$align === void 0 ? 'auto' : _ref6$align,\n      behavior = _ref6.behavior;\n    index = Math.max(0, Math.min(index, _this.options.count - 1));\n    _this.cancelScrollToIndex();\n    if (behavior === 'smooth' && _this.isDynamicMode()) {\n      console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.');\n    }\n    var _this$getOffsetForInd = _this.getOffsetForIndex(index, initialAlign),\n      toOffset = _this$getOffsetForInd[0],\n      align = _this$getOffsetForInd[1];\n    _this._scrollToOffset(toOffset, {\n      adjustments: undefined,\n      behavior: behavior\n    });\n    if (behavior !== 'smooth' && _this.isDynamicMode()) {\n      _this.scrollToIndexTimeoutId = setTimeout(function () {\n        _this.scrollToIndexTimeoutId = null;\n        var elementInDOM = _this.measureElementCache.has(_this.options.getItemKey(index));\n        if (elementInDOM) {\n          var _this$getOffsetForInd2 = _this.getOffsetForIndex(index, align),\n            _toOffset = _this$getOffsetForInd2[0];\n          if (!utils.approxEqual(_toOffset, _this.scrollOffset)) {\n            _this.scrollToIndex(index, {\n              align: align,\n              behavior: behavior\n            });\n          }\n        } else {\n          _this.scrollToIndex(index, {\n            align: align,\n            behavior: behavior\n          });\n        }\n      });\n    }\n  };\n  this.scrollBy = function (delta, _temp3) {\n    var _ref7 = _temp3 === void 0 ? {} : _temp3,\n      behavior = _ref7.behavior;\n    _this.cancelScrollToIndex();\n    if (behavior === 'smooth' && _this.isDynamicMode()) {\n      console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.');\n    }\n    _this._scrollToOffset(_this.scrollOffset + delta, {\n      adjustments: undefined,\n      behavior: behavior\n    });\n  };\n  this.getTotalSize = function () {\n    var _this$getMeasurements;\n    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) - _this.options.scrollMargin + _this.options.paddingEnd;\n  };\n  this._scrollToOffset = function (offset, _ref8) {\n    var adjustments = _ref8.adjustments,\n      behavior = _ref8.behavior;\n    _this.options.scrollToFn(offset, {\n      behavior: behavior,\n      adjustments: adjustments\n    }, _this);\n  };\n  this.measure = function () {\n    _this.itemSizeCache = new Map();\n    _this.notify();\n  };\n  this.setOptions(_opts);\n  this.scrollRect = this.options.initialRect;\n  this.scrollOffset = this.options.initialOffset;\n  this.measurementsCache = this.options.initialMeasurementsCache;\n  this.measurementsCache.forEach(function (item) {\n    _this.itemSizeCache.set(item.key, item.size);\n  });\n  this.maybeNotify();\n};\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange(_ref9) {\n  var measurements = _ref9.measurements,\n    outerSize = _ref9.outerSize,\n    scrollOffset = _ref9.scrollOffset;\n  var count = measurements.length - 1;\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n  var startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  var endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return {\n    startIndex: startIndex,\n    endIndex: endIndex\n  };\n}\n\nexports.approxEqual = utils.approxEqual;\nexports.memo = utils.memo;\nexports.notUndefined = utils.notUndefined;\nexports.Virtualizer = Virtualizer;\nexports.defaultKeyExtractor = defaultKeyExtractor;\nexports.defaultRangeExtractor = defaultRangeExtractor;\nexports.elementScroll = elementScroll;\nexports.measureElement = measureElement;\nexports.observeElementOffset = observeElementOffset;\nexports.observeElementRect = observeElementRect;\nexports.observeWindowOffset = observeWindowOffset;\nexports.observeWindowRect = observeWindowRect;\nexports.windowScroll = windowScroll;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdDQUFnQyxtQkFBTyxDQUFDLDRJQUF5QztBQUNqRixZQUFZLG1CQUFPLENBQUMsa0ZBQVk7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUxBQW1MO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0xBQXNMO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLFlBQVk7QUFDWixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2J1aWxkL2xpYi9pbmRleC5qcz80YzlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdmlydHVhbC1jb3JlXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzID0gcmVxdWlyZSgnLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5cbi8vXG5cbi8vXG5cbnZhciBkZWZhdWx0S2V5RXh0cmFjdG9yID0gZnVuY3Rpb24gZGVmYXVsdEtleUV4dHJhY3RvcihpbmRleCkge1xuICByZXR1cm4gaW5kZXg7XG59O1xudmFyIGRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IGZ1bmN0aW9uIGRlZmF1bHRSYW5nZUV4dHJhY3RvcihyYW5nZSkge1xuICB2YXIgc3RhcnQgPSBNYXRoLm1heChyYW5nZS5zdGFydEluZGV4IC0gcmFuZ2Uub3ZlcnNjYW4sIDApO1xuICB2YXIgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kSW5kZXggKyByYW5nZS5vdmVyc2NhbiwgcmFuZ2UuY291bnQgLSAxKTtcbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBfaSA9IHN0YXJ0OyBfaSA8PSBlbmQ7IF9pKyspIHtcbiAgICBhcnIucHVzaChfaSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG52YXIgb2JzZXJ2ZUVsZW1lbnRSZWN0ID0gZnVuY3Rpb24gb2JzZXJ2ZUVsZW1lbnRSZWN0KGluc3RhbmNlLCBjYikge1xuICB2YXIgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIocmVjdCkge1xuICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICBjYih7XG4gICAgICB3aWR0aDogTWF0aC5yb3VuZCh3aWR0aCksXG4gICAgICBoZWlnaHQ6IE1hdGgucm91bmQoaGVpZ2h0KVxuICAgIH0pO1xuICB9O1xuICBoYW5kbGVyKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGlmIChlbnRyeSAhPSBudWxsICYmIGVudHJ5LmJvcmRlckJveFNpemUpIHtcbiAgICAgIHZhciBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgICAgaWYgKGJveCkge1xuICAgICAgICBoYW5kbGVyKHtcbiAgICAgICAgICB3aWR0aDogYm94LmlubGluZVNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBib3guYmxvY2tTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGhhbmRsZXIoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICBib3g6ICdib3JkZXItYm94J1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gIH07XG59O1xudmFyIG9ic2VydmVXaW5kb3dSZWN0ID0gZnVuY3Rpb24gb2JzZXJ2ZVdpbmRvd1JlY3QoaW5zdGFuY2UsIGNiKSB7XG4gIHZhciBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICBjYih7XG4gICAgICB3aWR0aDogZWxlbWVudC5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0XG4gICAgfSk7XG4gIH07XG4gIGhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICB9O1xufTtcbnZhciBvYnNlcnZlRWxlbWVudE9mZnNldCA9IGZ1bmN0aW9uIG9ic2VydmVFbGVtZW50T2Zmc2V0KGluc3RhbmNlLCBjYikge1xuICB2YXIgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgY2IoZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKTtcbiAgfTtcbn07XG52YXIgb2JzZXJ2ZVdpbmRvd09mZnNldCA9IGZ1bmN0aW9uIG9ic2VydmVXaW5kb3dPZmZzZXQoaW5zdGFuY2UsIGNiKSB7XG4gIHZhciBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICBjYihlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICdzY3JvbGxYJyA6ICdzY3JvbGxZJ10pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKTtcbiAgfTtcbn07XG52YXIgbWVhc3VyZUVsZW1lbnQgPSBmdW5jdGlvbiBtZWFzdXJlRWxlbWVudChlbGVtZW50LCBlbnRyeSwgaW5zdGFuY2UpIHtcbiAgaWYgKGVudHJ5ICE9IG51bGwgJiYgZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIHZhciBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgIGlmIChib3gpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5yb3VuZChib3hbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gJ2lubGluZVNpemUnIDogJ2Jsb2NrU2l6ZSddKTtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10pO1xufTtcbnZhciB3aW5kb3dTY3JvbGwgPSBmdW5jdGlvbiB3aW5kb3dTY3JvbGwob2Zmc2V0LCBfcmVmLCBpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJHNjcm9sbEVsZW1lLCBfaW5zdGFuY2Ukc2Nyb2xsRWxlbWUyO1xuICB2YXIgX3JlZiRhZGp1c3RtZW50cyA9IF9yZWYuYWRqdXN0bWVudHMsXG4gICAgYWRqdXN0bWVudHMgPSBfcmVmJGFkanVzdG1lbnRzID09PSB2b2lkIDAgPyAwIDogX3JlZiRhZGp1c3RtZW50cyxcbiAgICBiZWhhdmlvciA9IF9yZWYuYmVoYXZpb3I7XG4gIHZhciB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2luc3RhbmNlJHNjcm9sbEVsZW1lID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRzY3JvbGxFbGVtZS5zY3JvbGxUbyA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHNjcm9sbEVsZW1lLnNjcm9sbFRvKChfaW5zdGFuY2Ukc2Nyb2xsRWxlbWUyID0ge30sIF9pbnN0YW5jZSRzY3JvbGxFbGVtZTJbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCddID0gdG9PZmZzZXQsIF9pbnN0YW5jZSRzY3JvbGxFbGVtZTIuYmVoYXZpb3IgPSBiZWhhdmlvciwgX2luc3RhbmNlJHNjcm9sbEVsZW1lMikpO1xufTtcbnZhciBlbGVtZW50U2Nyb2xsID0gZnVuY3Rpb24gZWxlbWVudFNjcm9sbChvZmZzZXQsIF9yZWYyLCBpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJHNjcm9sbEVsZW1lMywgX2luc3RhbmNlJHNjcm9sbEVsZW1lNDtcbiAgdmFyIF9yZWYyJGFkanVzdG1lbnRzID0gX3JlZjIuYWRqdXN0bWVudHMsXG4gICAgYWRqdXN0bWVudHMgPSBfcmVmMiRhZGp1c3RtZW50cyA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJGFkanVzdG1lbnRzLFxuICAgIGJlaGF2aW9yID0gX3JlZjIuYmVoYXZpb3I7XG4gIHZhciB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2luc3RhbmNlJHNjcm9sbEVsZW1lMyA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2Ukc2Nyb2xsRWxlbWUzLnNjcm9sbFRvID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2Ukc2Nyb2xsRWxlbWUzLnNjcm9sbFRvKChfaW5zdGFuY2Ukc2Nyb2xsRWxlbWU0ID0ge30sIF9pbnN0YW5jZSRzY3JvbGxFbGVtZTRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCddID0gdG9PZmZzZXQsIF9pbnN0YW5jZSRzY3JvbGxFbGVtZTQuYmVoYXZpb3IgPSBiZWhhdmlvciwgX2luc3RhbmNlJHNjcm9sbEVsZW1lNCkpO1xufTtcbnZhciBWaXJ0dWFsaXplciA9IGZ1bmN0aW9uIFZpcnR1YWxpemVyKF9vcHRzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHRoaXMudW5zdWJzID0gW107XG4gIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgdGhpcy5pc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gbmV3IE1hcCgpO1xuICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gIHRoaXMub2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9ybyA9IG51bGw7XG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmIChfcm8pIHtcbiAgICAgICAgcmV0dXJuIF9ybztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gX3JvID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgX3RoaXMuX21lYXN1cmVFbGVtZW50KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHZhciBfZ2V0O1xuICAgICAgICByZXR1cm4gKF9nZXQgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXQuZGlzY29ubmVjdCgpO1xuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IGZ1bmN0aW9uIG9ic2VydmUodGFyZ2V0KSB7XG4gICAgICAgIHZhciBfZ2V0MjtcbiAgICAgICAgcmV0dXJuIChfZ2V0MiA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldDIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgICAgICBib3g6ICdib3JkZXItYm94J1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1bm9ic2VydmU6IGZ1bmN0aW9uIHVub2JzZXJ2ZSh0YXJnZXQpIHtcbiAgICAgICAgdmFyIF9nZXQzO1xuICAgICAgICByZXR1cm4gKF9nZXQzID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0My51bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHRoaXMucmFuZ2UgPSB7XG4gICAgc3RhcnRJbmRleDogMCxcbiAgICBlbmRJbmRleDogMFxuICB9O1xuICB0aGlzLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIE9iamVjdC5lbnRyaWVzKG9wdHMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIga2V5ID0gX3JlZjNbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZjNbMV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgZGVsZXRlIG9wdHNba2V5XTtcbiAgICB9KTtcbiAgICBfdGhpcy5vcHRpb25zID0gX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVyc1tcImV4dGVuZHNcIl0oe1xuICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgaW5pdGlhbE9mZnNldDogMCxcbiAgICAgIG92ZXJzY2FuOiAxLFxuICAgICAgcGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgcGFkZGluZ0VuZDogMCxcbiAgICAgIHNjcm9sbFBhZGRpbmdTdGFydDogMCxcbiAgICAgIHNjcm9sbFBhZGRpbmdFbmQ6IDAsXG4gICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgIGdldEl0ZW1LZXk6IGRlZmF1bHRLZXlFeHRyYWN0b3IsXG4gICAgICByYW5nZUV4dHJhY3RvcjogZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge30sXG4gICAgICBtZWFzdXJlRWxlbWVudDogbWVhc3VyZUVsZW1lbnQsXG4gICAgICBpbml0aWFsUmVjdDoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LFxuICAgICAgc2Nyb2xsTWFyZ2luOiAwLFxuICAgICAgc2Nyb2xsaW5nRGVsYXk6IDE1MCxcbiAgICAgIGluZGV4QXR0cmlidXRlOiAnZGF0YS1pbmRleCcsXG4gICAgICBpbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU6IFtdLFxuICAgICAgbGFuZXM6IDFcbiAgICB9LCBvcHRzKTtcbiAgfTtcbiAgdGhpcy5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMub3B0aW9ucy5vbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMub3B0aW9ucy5vbkNoYW5nZShfdGhpcyk7XG4gIH07XG4gIHRoaXMuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkKCk7XG4gICAgfSk7XG4gICAgX3RoaXMudW5zdWJzID0gW107XG4gICAgX3RoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIH07XG4gIHRoaXMuX2RpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZm9yRWFjaChfdGhpcy5vYnNlcnZlci5vYnNlcnZlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgIH07XG4gIH07XG4gIHRoaXMuX3dpbGxVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbEVsZW1lbnQgPSBfdGhpcy5vcHRpb25zLmdldFNjcm9sbEVsZW1lbnQoKTtcbiAgICBpZiAoX3RoaXMuc2Nyb2xsRWxlbWVudCAhPT0gc2Nyb2xsRWxlbWVudCkge1xuICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgICAgX3RoaXMuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICBfdGhpcy5fc2Nyb2xsVG9PZmZzZXQoX3RoaXMuc2Nyb2xsT2Zmc2V0LCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB1bmRlZmluZWQsXG4gICAgICAgIGJlaGF2aW9yOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgX3RoaXMudW5zdWJzLnB1c2goX3RoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QoX3RoaXMsIGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIHZhciBwcmV2ID0gX3RoaXMuc2Nyb2xsUmVjdDtcbiAgICAgICAgX3RoaXMuc2Nyb2xsUmVjdCA9IHJlY3Q7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyByZWN0LndpZHRoICE9PSBwcmV2LndpZHRoIDogcmVjdC5oZWlnaHQgIT09IHByZXYuaGVpZ2h0KSB7XG4gICAgICAgICAgX3RoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgX3RoaXMudW5zdWJzLnB1c2goX3RoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudE9mZnNldChfdGhpcywgZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBfdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgICAgIGlmIChfdGhpcy5zY3JvbGxPZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQpO1xuICAgICAgICAgIF90aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgIF90aGlzLnNjcm9sbERpcmVjdGlvbiA9IF90aGlzLnNjcm9sbE9mZnNldCA8IG9mZnNldCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCc7XG4gICAgICAgIF90aGlzLnNjcm9sbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgX3RoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgX3RoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5pc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgX3RoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIF90aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgIH0sIF90aGlzLm9wdGlvbnMuc2Nyb2xsaW5nRGVsYXkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5zY3JvbGxSZWN0W190aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J107XG4gIH07XG4gIHRoaXMubWVtb09wdGlvbnMgPSB1dGlscy5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW190aGlzLm9wdGlvbnMuY291bnQsIF90aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0LCBfdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbiwgX3RoaXMub3B0aW9ucy5nZXRJdGVtS2V5XTtcbiAgfSwgZnVuY3Rpb24gKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSkge1xuICAgIF90aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudDogY291bnQsXG4gICAgICBwYWRkaW5nU3RhcnQ6IHBhZGRpbmdTdGFydCxcbiAgICAgIHNjcm9sbE1hcmdpbjogc2Nyb2xsTWFyZ2luLFxuICAgICAgZ2V0SXRlbUtleTogZ2V0SXRlbUtleVxuICAgIH07XG4gIH0sIHtcbiAgICBrZXk6IGZhbHNlXG4gIH0pO1xuICB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAobWVhc3VyZW1lbnRzLCBpbmRleCkge1xuICAgIHZhciBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kID0gbmV3IE1hcCgpO1xuICAgIHZhciBmdXJ0aGVzdE1lYXN1cmVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBtID0gaW5kZXggLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dO1xuICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuaGFzKG1lYXN1cmVtZW50LmxhbmUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnRzLmdldChtZWFzdXJlbWVudC5sYW5lKTtcbiAgICAgIGlmIChwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPT0gbnVsbCB8fCBtZWFzdXJlbWVudC5lbmQgPiBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNldChtZWFzdXJlbWVudC5sYW5lLCBtZWFzdXJlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LmVuZCA8IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zZXQobWVhc3VyZW1lbnQubGFuZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zaXplID09PSBfdGhpcy5vcHRpb25zLmxhbmVzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVydGhlc3RNZWFzdXJlbWVudHMuc2l6ZSA9PT0gX3RoaXMub3B0aW9ucy5sYW5lcyA/IEFycmF5LmZyb20oZnVydGhlc3RNZWFzdXJlbWVudHMudmFsdWVzKCkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kO1xuICAgIH0pWzBdIDogdW5kZWZpbmVkO1xuICB9O1xuICB0aGlzLmdldE1lYXN1cmVtZW50cyA9IHV0aWxzLm1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbX3RoaXMubWVtb09wdGlvbnMoKSwgX3RoaXMuaXRlbVNpemVDYWNoZV07XG4gIH0sIGZ1bmN0aW9uIChfcmVmNCwgaXRlbVNpemVDYWNoZSkge1xuICAgIHZhciBjb3VudCA9IF9yZWY0LmNvdW50LFxuICAgICAgcGFkZGluZ1N0YXJ0ID0gX3JlZjQucGFkZGluZ1N0YXJ0LFxuICAgICAgc2Nyb2xsTWFyZ2luID0gX3JlZjQuc2Nyb2xsTWFyZ2luLFxuICAgICAgZ2V0SXRlbUtleSA9IF9yZWY0LmdldEl0ZW1LZXk7XG4gICAgdmFyIG1pbiA9IF90aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5sZW5ndGggPiAwID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzKSA6IDA7XG4gICAgX3RoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IF90aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgZm9yICh2YXIgX2kyID0gbWluOyBfaTIgPCBjb3VudDsgX2kyKyspIHtcbiAgICAgIHZhciBrZXkgPSBnZXRJdGVtS2V5KF9pMik7XG4gICAgICB2YXIgZnVydGhlc3RNZWFzdXJlbWVudCA9IF90aGlzLm9wdGlvbnMubGFuZXMgPT09IDEgPyBtZWFzdXJlbWVudHNbX2kyIC0gMV0gOiBfdGhpcy5nZXRGdXJ0aGVzdE1lYXN1cmVtZW50KG1lYXN1cmVtZW50cywgX2kyKTtcbiAgICAgIHZhciBzdGFydCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgIHZhciBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgdmFyIHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSAnbnVtYmVyJyA/IG1lYXN1cmVkU2l6ZSA6IF90aGlzLm9wdGlvbnMuZXN0aW1hdGVTaXplKF9pMik7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyBzaXplO1xuICAgICAgdmFyIGxhbmUgPSBmdXJ0aGVzdE1lYXN1cmVtZW50ID8gZnVydGhlc3RNZWFzdXJlbWVudC5sYW5lIDogX2kyICUgX3RoaXMub3B0aW9ucy5sYW5lcztcbiAgICAgIG1lYXN1cmVtZW50c1tfaTJdID0ge1xuICAgICAgICBpbmRleDogX2kyLFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgbGFuZTogbGFuZVxuICAgICAgfTtcbiAgICB9XG4gICAgX3RoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBtZWFzdXJlbWVudHM7XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAnZ2V0TWVhc3VyZW1lbnRzJyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9XG4gIH0pO1xuICB0aGlzLmNhbGN1bGF0ZVJhbmdlID0gdXRpbHMubWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtfdGhpcy5nZXRNZWFzdXJlbWVudHMoKSwgX3RoaXMuZ2V0U2l6ZSgpLCBfdGhpcy5zY3JvbGxPZmZzZXRdO1xuICB9LCBmdW5jdGlvbiAobWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCkge1xuICAgIHJldHVybiBfdGhpcy5yYW5nZSA9IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgIG1lYXN1cmVtZW50czogbWVhc3VyZW1lbnRzLFxuICAgICAgb3V0ZXJTaXplOiBvdXRlclNpemUsXG4gICAgICBzY3JvbGxPZmZzZXQ6IHNjcm9sbE9mZnNldFxuICAgIH0pO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICdjYWxjdWxhdGVSYW5nZScsXG4gICAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuZGVidWc7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5tYXliZU5vdGlmeSA9IHV0aWxzLm1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5nZSA9IF90aGlzLmNhbGN1bGF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIFtyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCwgX3RoaXMuaXNTY3JvbGxpbmddO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMubm90aWZ5KCk7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgJ21heWJlTm90aWZ5JyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9LFxuICAgIGluaXRpYWxEZXBzOiBbdGhpcy5yYW5nZS5zdGFydEluZGV4LCB0aGlzLnJhbmdlLmVuZEluZGV4LCB0aGlzLmlzU2Nyb2xsaW5nXVxuICB9KTtcbiAgdGhpcy5nZXRJbmRleGVzID0gdXRpbHMubWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtfdGhpcy5vcHRpb25zLnJhbmdlRXh0cmFjdG9yLCBfdGhpcy5jYWxjdWxhdGVSYW5nZSgpLCBfdGhpcy5vcHRpb25zLm92ZXJzY2FuLCBfdGhpcy5vcHRpb25zLmNvdW50XTtcbiAgfSwgZnVuY3Rpb24gKHJhbmdlRXh0cmFjdG9yLCByYW5nZSwgb3ZlcnNjYW4sIGNvdW50KSB7XG4gICAgcmV0dXJuIHJhbmdlRXh0cmFjdG9yKF9yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnNbXCJleHRlbmRzXCJdKHt9LCByYW5nZSwge1xuICAgICAgb3ZlcnNjYW46IG92ZXJzY2FuLFxuICAgICAgY291bnQ6IGNvdW50XG4gICAgfSkpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRJbmRleGVzJyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9XG4gIH0pO1xuICB0aGlzLmluZGV4RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gX3RoaXMub3B0aW9ucy5pbmRleEF0dHJpYnV0ZTtcbiAgICB2YXIgaW5kZXhTdHIgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICBpZiAoIWluZGV4U3RyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lICdcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIj17aW5kZXh9JyBvbiBtZWFzdXJlZCBlbGVtZW50LlwiKTtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGluZGV4U3RyLCAxMCk7XG4gIH07XG4gIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGVudHJ5KSB7XG4gICAgdmFyIF90aGlzJGl0ZW1TaXplQ2FjaGUkZztcbiAgICB2YXIgaW5kZXggPSBfdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpO1xuICAgIHZhciBpdGVtID0gX3RoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldk5vZGUgPSBfdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmdldChpdGVtLmtleSk7XG4gICAgaWYgKCFub2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICBfdGhpcy5vYnNlcnZlci51bm9ic2VydmUobm9kZSk7XG4gICAgICBpZiAobm9kZSA9PT0gcHJldk5vZGUpIHtcbiAgICAgICAgX3RoaXMubWVhc3VyZUVsZW1lbnRDYWNoZVtcImRlbGV0ZVwiXShpdGVtLmtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmV2Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgIF90aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShwcmV2Tm9kZSk7XG4gICAgICB9XG4gICAgICBfdGhpcy5vYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgX3RoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5zZXQoaXRlbS5rZXksIG5vZGUpO1xuICAgIH1cbiAgICB2YXIgbWVhc3VyZWRJdGVtU2l6ZSA9IF90aGlzLm9wdGlvbnMubWVhc3VyZUVsZW1lbnQobm9kZSwgZW50cnksIF90aGlzKTtcbiAgICB2YXIgaXRlbVNpemUgPSAoX3RoaXMkaXRlbVNpemVDYWNoZSRnID0gX3RoaXMuaXRlbVNpemVDYWNoZS5nZXQoaXRlbS5rZXkpKSAhPSBudWxsID8gX3RoaXMkaXRlbVNpemVDYWNoZSRnIDogaXRlbS5zaXplO1xuICAgIHZhciBkZWx0YSA9IG1lYXN1cmVkSXRlbVNpemUgLSBpdGVtU2l6ZTtcbiAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgIGlmIChpdGVtLnN0YXJ0IDwgX3RoaXMuc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF90aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJ2NvcnJlY3Rpb24nLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3Njcm9sbFRvT2Zmc2V0KF90aGlzLnNjcm9sbE9mZnNldCwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiBfdGhpcy5zY3JvbGxBZGp1c3RtZW50cyArPSBkZWx0YSxcbiAgICAgICAgICBiZWhhdmlvcjogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX3RoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgX3RoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAoX3RoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIG1lYXN1cmVkSXRlbVNpemUpKTtcbiAgICAgIF90aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5tZWFzdXJlRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF90aGlzLl9tZWFzdXJlRWxlbWVudChub2RlLCB1bmRlZmluZWQpO1xuICB9O1xuICB0aGlzLmdldFZpcnR1YWxJdGVtcyA9IHV0aWxzLm1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbX3RoaXMuZ2V0SW5kZXhlcygpLCBfdGhpcy5nZXRNZWFzdXJlbWVudHMoKV07XG4gIH0sIGZ1bmN0aW9uIChpbmRleGVzLCBtZWFzdXJlbWVudHMpIHtcbiAgICB2YXIgdmlydHVhbEl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgayA9IDAsIGxlbiA9IGluZGV4ZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIHZhciBfaTMgPSBpbmRleGVzW2tdO1xuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW19pM107XG4gICAgICB2aXJ0dWFsSXRlbXMucHVzaChtZWFzdXJlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB2aXJ0dWFsSXRlbXM7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgJ2dldEluZGV4ZXMnLFxuICAgIGRlYnVnOiBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLmRlYnVnO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IF90aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgIHJldHVybiB1dGlscy5ub3RVbmRlZmluZWQobWVhc3VyZW1lbnRzW2ZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKDAsIG1lYXN1cmVtZW50cy5sZW5ndGggLSAxLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiB1dGlscy5ub3RVbmRlZmluZWQobWVhc3VyZW1lbnRzW2luZGV4XSkuc3RhcnQ7XG4gICAgfSwgb2Zmc2V0KV0pO1xuICB9O1xuICB0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCA9IGZ1bmN0aW9uICh0b09mZnNldCwgYWxpZ24pIHtcbiAgICB2YXIgc2l6ZSA9IF90aGlzLmdldFNpemUoKTtcbiAgICBpZiAoYWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgaWYgKHRvT2Zmc2V0IDw9IF90aGlzLnNjcm9sbE9mZnNldCkge1xuICAgICAgICBhbGlnbiA9ICdzdGFydCc7XG4gICAgICB9IGVsc2UgaWYgKHRvT2Zmc2V0ID49IF90aGlzLnNjcm9sbE9mZnNldCArIHNpemUpIHtcbiAgICAgICAgYWxpZ24gPSAnZW5kJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduID0gJ3N0YXJ0JztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICB0b09mZnNldCA9IHRvT2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICB0b09mZnNldCA9IHRvT2Zmc2V0IC0gc2l6ZTtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgdG9PZmZzZXQgPSB0b09mZnNldCAtIHNpemUgLyAyO1xuICAgIH1cbiAgICB2YXIgc2Nyb2xsU2l6ZVByb3AgPSBfdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyAnc2Nyb2xsV2lkdGgnIDogJ3Njcm9sbEhlaWdodCc7XG4gICAgdmFyIHNjcm9sbFNpemUgPSBfdGhpcy5zY3JvbGxFbGVtZW50ID8gJ2RvY3VtZW50JyBpbiBfdGhpcy5zY3JvbGxFbGVtZW50ID8gX3RoaXMuc2Nyb2xsRWxlbWVudC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbc2Nyb2xsU2l6ZVByb3BdIDogX3RoaXMuc2Nyb2xsRWxlbWVudFtzY3JvbGxTaXplUHJvcF0gOiAwO1xuICAgIHZhciBtYXhPZmZzZXQgPSBzY3JvbGxTaXplIC0gX3RoaXMuZ2V0U2l6ZSgpO1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXhPZmZzZXQsIHRvT2Zmc2V0KSwgMCk7XG4gIH07XG4gIHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGFsaWduKSB7XG4gICAgaWYgKGFsaWduID09PSB2b2lkIDApIHtcbiAgICAgIGFsaWduID0gJ2F1dG8nO1xuICAgIH1cbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBfdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IHV0aWxzLm5vdFVuZGVmaW5lZChfdGhpcy5nZXRNZWFzdXJlbWVudHMoKVtpbmRleF0pO1xuICAgIGlmIChhbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBpZiAobWVhc3VyZW1lbnQuZW5kID49IF90aGlzLnNjcm9sbE9mZnNldCArIF90aGlzLmdldFNpemUoKSAtIF90aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCkge1xuICAgICAgICBhbGlnbiA9ICdlbmQnO1xuICAgICAgfSBlbHNlIGlmIChtZWFzdXJlbWVudC5zdGFydCA8PSBfdGhpcy5zY3JvbGxPZmZzZXQgKyBfdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydCkge1xuICAgICAgICBhbGlnbiA9ICdzdGFydCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW190aGlzLnNjcm9sbE9mZnNldCwgYWxpZ25dO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdG9PZmZzZXQgPSBhbGlnbiA9PT0gJ2VuZCcgPyBtZWFzdXJlbWVudC5lbmQgKyBfdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQgOiBtZWFzdXJlbWVudC5zdGFydCAtIF90aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0O1xuICAgIHJldHVybiBbX3RoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIGFsaWduXTtcbiAgfTtcbiAgdGhpcy5pc0R5bmFtaWNNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLnNpemUgPiAwO1xuICB9O1xuICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkKTtcbiAgICAgIF90aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5zY3JvbGxUb09mZnNldCA9IGZ1bmN0aW9uICh0b09mZnNldCwgX3RlbXApIHtcbiAgICB2YXIgX3JlZjUgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgIF9yZWY1JGFsaWduID0gX3JlZjUuYWxpZ24sXG4gICAgICBhbGlnbiA9IF9yZWY1JGFsaWduID09PSB2b2lkIDAgPyAnc3RhcnQnIDogX3JlZjUkYWxpZ24sXG4gICAgICBiZWhhdmlvciA9IF9yZWY1LmJlaGF2aW9yO1xuICAgIF90aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdzbW9vdGgnICYmIF90aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgY29uc29sZS53YXJuKCdUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuJyk7XG4gICAgfVxuICAgIF90aGlzLl9zY3JvbGxUb09mZnNldChfdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwge1xuICAgICAgYWRqdXN0bWVudHM6IHVuZGVmaW5lZCxcbiAgICAgIGJlaGF2aW9yOiBiZWhhdmlvclxuICAgIH0pO1xuICB9O1xuICB0aGlzLnNjcm9sbFRvSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIF90ZW1wMikge1xuICAgIHZhciBfcmVmNiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICBfcmVmNiRhbGlnbiA9IF9yZWY2LmFsaWduLFxuICAgICAgaW5pdGlhbEFsaWduID0gX3JlZjYkYWxpZ24gPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9yZWY2JGFsaWduLFxuICAgICAgYmVoYXZpb3IgPSBfcmVmNi5iZWhhdmlvcjtcbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBfdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgIF90aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdzbW9vdGgnICYmIF90aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgY29uc29sZS53YXJuKCdUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuJyk7XG4gICAgfVxuICAgIHZhciBfdGhpcyRnZXRPZmZzZXRGb3JJbmQgPSBfdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgaW5pdGlhbEFsaWduKSxcbiAgICAgIHRvT2Zmc2V0ID0gX3RoaXMkZ2V0T2Zmc2V0Rm9ySW5kWzBdLFxuICAgICAgYWxpZ24gPSBfdGhpcyRnZXRPZmZzZXRGb3JJbmRbMV07XG4gICAgX3RoaXMuX3Njcm9sbFRvT2Zmc2V0KHRvT2Zmc2V0LCB7XG4gICAgICBhZGp1c3RtZW50czogdW5kZWZpbmVkLFxuICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgfSk7XG4gICAgaWYgKGJlaGF2aW9yICE9PSAnc21vb3RoJyAmJiBfdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgIF90aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHZhciBlbGVtZW50SW5ET00gPSBfdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmhhcyhfdGhpcy5vcHRpb25zLmdldEl0ZW1LZXkoaW5kZXgpKTtcbiAgICAgICAgaWYgKGVsZW1lbnRJbkRPTSkge1xuICAgICAgICAgIHZhciBfdGhpcyRnZXRPZmZzZXRGb3JJbmQyID0gX3RoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGFsaWduKSxcbiAgICAgICAgICAgIF90b09mZnNldCA9IF90aGlzJGdldE9mZnNldEZvckluZDJbMF07XG4gICAgICAgICAgaWYgKCF1dGlscy5hcHByb3hFcXVhbChfdG9PZmZzZXQsIF90aGlzLnNjcm9sbE9mZnNldCkpIHtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvSW5kZXgoaW5kZXgsIHtcbiAgICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgICBiZWhhdmlvcjogYmVoYXZpb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7XG4gICAgICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgICAgICBiZWhhdmlvcjogYmVoYXZpb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB0aGlzLnNjcm9sbEJ5ID0gZnVuY3Rpb24gKGRlbHRhLCBfdGVtcDMpIHtcbiAgICB2YXIgX3JlZjcgPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzLFxuICAgICAgYmVoYXZpb3IgPSBfcmVmNy5iZWhhdmlvcjtcbiAgICBfdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgaWYgKGJlaGF2aW9yID09PSAnc21vb3RoJyAmJiBfdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLicpO1xuICAgIH1cbiAgICBfdGhpcy5fc2Nyb2xsVG9PZmZzZXQoX3RoaXMuc2Nyb2xsT2Zmc2V0ICsgZGVsdGEsIHtcbiAgICAgIGFkanVzdG1lbnRzOiB1bmRlZmluZWQsXG4gICAgICBiZWhhdmlvcjogYmVoYXZpb3JcbiAgICB9KTtcbiAgfTtcbiAgdGhpcy5nZXRUb3RhbFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzJGdldE1lYXN1cmVtZW50cztcbiAgICByZXR1cm4gKCgoX3RoaXMkZ2V0TWVhc3VyZW1lbnRzID0gX3RoaXMuZ2V0TWVhc3VyZW1lbnRzKClbX3RoaXMub3B0aW9ucy5jb3VudCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ2V0TWVhc3VyZW1lbnRzLmVuZCkgfHwgX3RoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQpIC0gX3RoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gKyBfdGhpcy5vcHRpb25zLnBhZGRpbmdFbmQ7XG4gIH07XG4gIHRoaXMuX3Njcm9sbFRvT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCwgX3JlZjgpIHtcbiAgICB2YXIgYWRqdXN0bWVudHMgPSBfcmVmOC5hZGp1c3RtZW50cyxcbiAgICAgIGJlaGF2aW9yID0gX3JlZjguYmVoYXZpb3I7XG4gICAgX3RoaXMub3B0aW9ucy5zY3JvbGxUb0ZuKG9mZnNldCwge1xuICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgICAgYWRqdXN0bWVudHM6IGFkanVzdG1lbnRzXG4gICAgfSwgX3RoaXMpO1xuICB9O1xuICB0aGlzLm1lYXN1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBfdGhpcy5ub3RpZnkoKTtcbiAgfTtcbiAgdGhpcy5zZXRPcHRpb25zKF9vcHRzKTtcbiAgdGhpcy5zY3JvbGxSZWN0ID0gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICB0aGlzLnNjcm9sbE9mZnNldCA9IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0O1xuICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gdGhpcy5vcHRpb25zLmluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTtcbiAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgX3RoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIGl0ZW0uc2l6ZSk7XG4gIH0pO1xuICB0aGlzLm1heWJlTm90aWZ5KCk7XG59O1xudmFyIGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gZnVuY3Rpb24gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2gobG93LCBoaWdoLCBnZXRDdXJyZW50VmFsdWUsIHZhbHVlKSB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2UoX3JlZjkpIHtcbiAgdmFyIG1lYXN1cmVtZW50cyA9IF9yZWY5Lm1lYXN1cmVtZW50cyxcbiAgICBvdXRlclNpemUgPSBfcmVmOS5vdXRlclNpemUsXG4gICAgc2Nyb2xsT2Zmc2V0ID0gX3JlZjkuc2Nyb2xsT2Zmc2V0O1xuICB2YXIgY291bnQgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgdmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIGdldE9mZnNldChpbmRleCkge1xuICAgIHJldHVybiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICB9O1xuICB2YXIgc3RhcnRJbmRleCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKDAsIGNvdW50LCBnZXRPZmZzZXQsIHNjcm9sbE9mZnNldCk7XG4gIHZhciBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHdoaWxlIChlbmRJbmRleCA8IGNvdW50ICYmIG1lYXN1cmVtZW50c1tlbmRJbmRleF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgZW5kSW5kZXgrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgZW5kSW5kZXg6IGVuZEluZGV4XG4gIH07XG59XG5cbmV4cG9ydHMuYXBwcm94RXF1YWwgPSB1dGlscy5hcHByb3hFcXVhbDtcbmV4cG9ydHMubWVtbyA9IHV0aWxzLm1lbW87XG5leHBvcnRzLm5vdFVuZGVmaW5lZCA9IHV0aWxzLm5vdFVuZGVmaW5lZDtcbmV4cG9ydHMuVmlydHVhbGl6ZXIgPSBWaXJ0dWFsaXplcjtcbmV4cG9ydHMuZGVmYXVsdEtleUV4dHJhY3RvciA9IGRlZmF1bHRLZXlFeHRyYWN0b3I7XG5leHBvcnRzLmRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IGRlZmF1bHRSYW5nZUV4dHJhY3RvcjtcbmV4cG9ydHMuZWxlbWVudFNjcm9sbCA9IGVsZW1lbnRTY3JvbGw7XG5leHBvcnRzLm1lYXN1cmVFbGVtZW50ID0gbWVhc3VyZUVsZW1lbnQ7XG5leHBvcnRzLm9ic2VydmVFbGVtZW50T2Zmc2V0ID0gb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ7XG5leHBvcnRzLm9ic2VydmVFbGVtZW50UmVjdCA9IG9ic2VydmVFbGVtZW50UmVjdDtcbmV4cG9ydHMub2JzZXJ2ZVdpbmRvd09mZnNldCA9IG9ic2VydmVXaW5kb3dPZmZzZXQ7XG5leHBvcnRzLm9ic2VydmVXaW5kb3dSZWN0ID0gb2JzZXJ2ZVdpbmRvd1JlY3Q7XG5leHBvcnRzLndpbmRvd1Njcm9sbCA9IHdpbmRvd1Njcm9sbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/build/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/build/lib/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/build/lib/utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction memo(getDeps, fn, opts) {\n  var _opts$initialDeps;\n  var deps = (_opts$initialDeps = opts.initialDeps) != null ? _opts$initialDeps : [];\n  var result;\n  return function () {\n    var depTime;\n    if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();\n    var newDeps = getDeps();\n    var depsChanged = newDeps.length !== deps.length || newDeps.some(function (dep, index) {\n      return deps[index] !== dep;\n    });\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    var resultTime;\n    if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();\n    result = fn.apply(void 0, newDeps);\n    if (opts.key && opts.debug != null && opts.debug()) {\n      var depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      var resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      var resultFpsPercentage = resultEndTime / 16;\n      var pad = function pad(str, num) {\n        str = String(str);\n        while (str.length < num) {\n          str = ' ' + str;\n        }\n        return str;\n      };\n      console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n    }\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n    return result;\n  };\n}\nfunction notUndefined(value, msg) {\n  if (value === undefined) {\n    throw new Error(\"Unexpected undefined\" + (msg ? \": \" + msg : ''));\n  } else {\n    return value;\n  }\n}\nvar approxEqual = function approxEqual(a, b) {\n  return Math.abs(a - b) < 1;\n};\n\nexports.approxEqual = approxEqual;\nexports.memo = memo;\nexports.notUndefined = notUndefined;\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxnQ0FBZ0MsMEdBQTBHO0FBQ3RRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2J1aWxkL2xpYi91dGlscy5qcz8zZmY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdmlydHVhbC1jb3JlXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgdmFyIF9vcHRzJGluaXRpYWxEZXBzO1xuICB2YXIgZGVwcyA9IChfb3B0cyRpbml0aWFsRGVwcyA9IG9wdHMuaW5pdGlhbERlcHMpICE9IG51bGwgPyBfb3B0cyRpbml0aWFsRGVwcyA6IFtdO1xuICB2YXIgcmVzdWx0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnICE9IG51bGwgJiYgb3B0cy5kZWJ1ZygpKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICB2YXIgZGVwc0NoYW5nZWQgPSBuZXdEZXBzLmxlbmd0aCAhPT0gZGVwcy5sZW5ndGggfHwgbmV3RGVwcy5zb21lKGZ1bmN0aW9uIChkZXAsIGluZGV4KSB7XG4gICAgICByZXR1cm4gZGVwc1tpbmRleF0gIT09IGRlcDtcbiAgICB9KTtcbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkZXBzID0gbmV3RGVwcztcbiAgICB2YXIgcmVzdWx0VGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkgcmVzdWx0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmVzdWx0ID0gZm4uYXBwbHkodm9pZCAwLCBuZXdEZXBzKTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkge1xuICAgICAgdmFyIGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgdmFyIHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgdmFyIHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKHN0ciwgbnVtKSB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgIHN0ciA9ICcgJyArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfTtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIiVjXFx1MjNGMSBcIiArIHBhZChyZXN1bHRFbmRUaW1lLCA1KSArIFwiIC9cIiArIHBhZChkZXBFbmRUaW1lLCA1KSArIFwiIG1zXCIsIFwiXFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgICAgICAgICBjb2xvcjogaHNsKFwiICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSkgKyBcImRlZyAxMDAlIDMxJSk7XCIsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5KTtcbiAgICB9XG4gICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vbkNoYW5nZShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBub3RVbmRlZmluZWQodmFsdWUsIG1zZykge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdW5kZWZpbmVkXCIgKyAobXNnID8gXCI6IFwiICsgbXNnIDogJycpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbnZhciBhcHByb3hFcXVhbCA9IGZ1bmN0aW9uIGFwcHJveEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IDE7XG59O1xuXG5leHBvcnRzLmFwcHJveEVxdWFsID0gYXBwcm94RXF1YWw7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy5ub3RVbmRlZmluZWQgPSBub3RVbmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/build/lib/utils.js\n");

/***/ })

};
;