/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-react";
exports.ids = ["vendor-chunks/slate-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-react/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/slate-react/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar getDirection = __webpack_require__(/*! direction */ \"(ssr)/./node_modules/direction/index.js\");\nvar debounce = __webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\");\nvar throttle = __webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar scrollIntoView = __webpack_require__(/*! scroll-into-view-if-needed */ \"(ssr)/./node_modules/slate-react/node_modules/scroll-into-view-if-needed/index.js\");\nvar slate = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.js\");\nvar resizeObserver = __webpack_require__(/*! @juggle/resize-observer */ \"(ssr)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js\");\nvar isHotkey = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/is-hotkey/lib/index.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar getDirection__default = /*#__PURE__*/_interopDefaultLegacy(getDirection);\nvar debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);\nvar throttle__default = /*#__PURE__*/_interopDefaultLegacy(throttle);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar scrollIntoView__default = /*#__PURE__*/_interopDefaultLegacy(scrollIntoView);\nvar ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/React.createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = function useSlateStatic() {\n  var editor = React.useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\nvar REACT_MAJOR_VERSION = parseInt(React__default['default'].version.split('.')[0], 10);\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\n\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\n\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */\n\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */\n\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(iterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\n\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = function getDefaultView(value) {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = function isDOMComment(value) {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = function isDOMElement(value) {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = function isDOMNode(value) {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = function isDOMSelection(value) {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = function isDOMText(value) {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = function isPlainTextOnlyPaste(event) {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = function normalizeDOMPoint(domPoint) {\n  var _domPoint = _slicedToArray(domPoint, 2),\n      node = _domPoint[0],\n      offset = _domPoint[1]; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n\n    var _getEditableChildAndI = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n\n    var _getEditableChildAndI2 = _slicedToArray(_getEditableChildAndI, 2);\n\n    node = _getEditableChildAndI2[0];\n    index = _getEditableChildAndI2[1];\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Determines whether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = function hasShadowRoot(node) {\n  var parent = node && node.parentNode;\n\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = function getEditableChildAndIndex(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = function getEditableChild(parent, index, direction) {\n  var _getEditableChildAndI3 = getEditableChildAndIndex(parent, index, direction),\n      _getEditableChildAndI4 = _slicedToArray(_getEditableChildAndI3, 1),\n      child = _getEditableChildAndI4[0];\n\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = function getPlainText(domNode) {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var _i = 0, _Array$from = Array.from(domNode.childNodes); _i < _Array$from.length; _i++) {\n      var childNode = _Array$from[_i];\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */\n\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = function getSlateFragmentAttribute(dataTransfer) {\n  var htmlData = dataTransfer.getData('text/html');\n\n  var _ref = htmlData.match(catchSlateFragment) || [],\n      _ref2 = _slicedToArray(_ref, 2),\n      fragment = _ref2[1];\n\n  return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */\n\nvar isTrackedMutation = function isTrackedMutation(editor, mutation, batch) {\n  var target = mutation.target;\n\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n\n  var _ReactEditor$getWindo = ReactEditor.getWindow(editor),\n      document = _ReactEditor$getWindo.document;\n\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n\n  var parentMutation = batch.find(function (_ref3) {\n    var addedNodes = _ref3.addedNodes,\n        removedNodes = _ref3.removedNodes;\n\n    var _iterator = _createForOfIteratorHelper$3(addedNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n\n        if (node === target || node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper$3(removedNodes),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _node = _step2.value;\n\n        if (_node === target || _node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n\n\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n\nvar classCallCheck = createCommonjsModule(function (module) {\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _classCallCheck = unwrapExports(classCallCheck);\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nvar Key = function Key() {\n  _classCallCheck(this, Key);\n\n  this.id = \"\".concat(n++);\n};\n\nvar ReactEditor = {\n  androidPendingDiffs: function androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  },\n  androidScheduleFlush: function androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: function blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      slate.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: function findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n\n    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n      return root;\n    }\n\n    return el.ownerDocument;\n  },\n  findEventRange: function findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var _event = event,\n        x = _event.clientX,\n        y = _event.clientY,\n        target = _event.target;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (slate.Element.isElement(node) && slate.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate.Editor.before(editor, edge) : slate.Editor.after(editor, edge);\n\n      if (point) {\n        var _range = slate.Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n\n    var _ReactEditor$getWindo = ReactEditor.getWindow(editor),\n        document = _ReactEditor$getWindo.document; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: function findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n  findPath: function findPath(editor, node) {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (slate.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate.Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (root.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: function getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$editable = options.editable,\n        editable = _options$editable === void 0 ? false : _options$editable;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!targetEl) {\n      return false;\n    }\n\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: function hasEditableTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n  hasRange: function hasRange(editor, range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return slate.Editor.hasPath(editor, anchor.path) && slate.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: function hasSelectableTarget(editor, target) {\n    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n  hasTarget: function hasTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n  },\n  insertData: function insertData(editor, data) {\n    editor.insertData(data);\n  },\n  insertFragmentData: function insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n  insertTextData: function insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n  isComposing: function isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: function isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n  isReadOnly: function isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n  isTargetInsideNonReadonlyVoid: function isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n    return slate.Element.isElement(slateNode) && slate.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: function setFragmentData(editor, data, originEvent) {\n    return editor.setFragmentData(data, originEvent);\n  },\n  toDOMNode: function toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate.Scrubber.stringify(node)));\n    }\n\n    return domNode;\n  },\n  toDOMPoint: function toDOMPoint(editor, point) {\n    var _Editor$node = slate.Editor.node(editor, point.path),\n        _Editor$node2 = _slicedToArray(_Editor$node, 1),\n        node = _Editor$node2[0];\n\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (slate.Editor[\"void\"](editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var length = domNode.textContent.length;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n\n      var nextText = texts[i + 1];\n\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n\n        var domText = nextText.childNodes[0];\n        domPoint = [// COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0];\n        break;\n      }\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate.Scrubber.stringify(point)));\n    }\n\n    return domPoint;\n  },\n  toDOMRange: function toDOMRange(editor, range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    var isBackward = slate.Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate.Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n\n    var _ref = isBackward ? domFocus : domAnchor,\n        _ref2 = _slicedToArray(_ref, 2),\n        startNode = _ref2[0],\n        startOffset = _ref2[1];\n\n    var _ref3 = isBackward ? domAnchor : domFocus,\n        _ref4 = _slicedToArray(_ref3, 2),\n        endNode = _ref4[0],\n        endOffset = _ref4[1]; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: function toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n  toSlatePoint: function toSlatePoint(editor, domPoint, options) {\n    var exactMatch = options.exactMatch,\n        suppressThrow = options.suppressThrow;\n\n    var _ref5 = exactMatch ? domPoint : normalizeDOMPoint(domPoint),\n        _ref6 = _slicedToArray(_ref5, 2),\n        nearestNode = _ref6[0],\n        nearestOffset = _ref6[1];\n\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n\n        if (textNode) {\n          var window = ReactEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [].concat(_toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]'))), _toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))));\n          removals.forEach(function (el) {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n              if (el.textContent.startsWith(\"\\uFEFF\")) {\n                el.textContent = el.textContent.slice(1);\n              }\n\n              return;\n            }\n\n            el.parentNode.removeChild(el);\n          }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        } // COMPAT: In read-only editors the leaf is not rendered.\n\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(function (el) {\n            offset -= el.textContent.length;\n          });\n        }\n      }\n\n      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n\n        var _Editor$start = slate.Editor.start(editor, ReactEditor.findPath(editor, _slateNode)),\n            _path = _Editor$start.path,\n            _offset = _Editor$start.offset;\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path: path,\n      offset: offset\n    };\n  },\n  toSlateRange: function toSlateRange(editor, domRange, options) {\n    var exactMatch = options.exactMatch,\n        suppressThrow = options.suppressThrow;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1); // Here we are in the contenteditable mode of a table in firefox\n\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            var getLastChildren = function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            };\n\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer; // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]); // Zero, as we allways take the right one as the anchor point\n\n            focusOffset = 0;\n\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        } // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n\n\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    } // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n    // inside a `contenteditable=\"false\"` DOM node following the word, which\n    // will cause `toSlatePoint` to throw an error. (2023/03/07)\n\n\n    if ('getAttribute' in focusNode && focusNode.getAttribute('contenteditable') === 'false' && focusNode.getAttribute('data-slate-void') !== 'true') {\n      var _anchorNode$textConte;\n\n      focusNode = anchorNode;\n      focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow\n    });\n\n    if (!anchor) {\n      return null;\n    }\n\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow\n    });\n\n    if (!focus) {\n      return null;\n    }\n\n    var range = {\n      anchor: anchor,\n      focus: focus\n    }; // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n\n    if (slate.Range.isExpanded(range) && slate.Range.isForward(range) && isDOMElement(focusNode) && slate.Editor[\"void\"](editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n\n    return range;\n  }\n};\n\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */\n\nfunction verifyDiffState(editor, textDiff) {\n  var path = textDiff.path,\n      diff = textDiff.diff;\n\n  if (!slate.Editor.hasPath(editor, path)) {\n    return false;\n  }\n\n  var node = slate.Node.get(editor, path);\n\n  if (!slate.Text.isText(node)) {\n    return false;\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n\n  var nextPath = slate.Path.next(path);\n\n  if (!slate.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n\n  var nextNode = slate.Node.get(editor, nextPath);\n  return slate.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n\n  return diffs.reduce(function (text, diff) {\n    return text.slice(0, diff.start) + diff.text + text.slice(diff.end);\n  }, text);\n}\n\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */\n\n\nfunction normalizeStringDiff(targetText, diff) {\n  var start = diff.start,\n      end = diff.end,\n      text = diff.text;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n\n  return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */\n\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start: start,\n    end: end,\n    text: text\n  });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */\n\nfunction targetRange(textDiff) {\n  var path = textDiff.path,\n      diff = textDiff.diff;\n  return {\n    anchor: {\n      path: path,\n      offset: diff.start\n    },\n    focus: {\n      path: path,\n      offset: diff.end\n    }\n  };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */\n\nfunction normalizePoint(editor, point) {\n  var path = point.path,\n      offset = point.offset;\n\n  if (!slate.Editor.hasPath(editor, path)) {\n    return null;\n  }\n\n  var leaf = slate.Node.get(editor, path);\n\n  if (!slate.Text.isText(leaf)) {\n    return null;\n  }\n\n  var parentBlock = slate.Editor.above(editor, {\n    match: function match(n) {\n      return slate.Element.isElement(n) && slate.Editor.isBlock(editor, n);\n    },\n    at: path\n  });\n\n  if (!parentBlock) {\n    return null;\n  }\n\n  while (offset > leaf.text.length) {\n    var entry = slate.Editor.next(editor, {\n      at: path,\n      match: slate.Text.isText\n    });\n\n    if (!entry || !slate.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n\n  return {\n    path: path,\n    offset: offset\n  };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */\n\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (slate.Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = normalizePoint(editor, range.focus);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(function (_ref) {\n    var path = _ref.path;\n    return slate.Path.equals(path, point.path);\n  });\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n\n  var diff = textDiff.diff; // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n\n    var _transformed = slate.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n\n    if (!_transformed) {\n      return null;\n    }\n\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  } // Point references location after the diff\n\n\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n\n  if (!transformed) {\n    return null;\n  }\n\n  if (op.type === 'split_node' && slate.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (slate.Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = transformPendingPoint(editor, range.focus, op);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var path = textDiff.path,\n      diff = textDiff.diff,\n      id = textDiff.id;\n\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n\n    case 'remove_text':\n      {\n        if (!slate.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n\n    case 'split_node':\n      {\n        if (!slate.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff: diff,\n            id: id,\n            path: slate.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id: id,\n          path: slate.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n\n    case 'merge_node':\n      {\n        if (!slate.Path.equals(op.path, path)) {\n          return {\n            diff: diff,\n            id: id,\n            path: slate.Path.transform(path, op)\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id: id,\n          path: slate.Path.transform(path, op)\n        };\n      }\n  }\n\n  var newPath = slate.Path.transform(path, op);\n\n  if (!newPath) {\n    return null;\n  }\n\n  return {\n    diff: diff,\n    path: newPath,\n    id: id\n  };\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\n\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\n\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\n\nvar debug = function debug() {}; // Type guard to check if a value is a DataTransfer\n\n\nvar isDataTransfer = function isDataTransfer(value) {\n  return (value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';\n};\n\nfunction createAndroidInputManager(_ref) {\n  var editor = _ref.editor,\n      scheduleOnDOMSelectionChange = _ref.scheduleOnDOMSelectionChange,\n      onDOMSelectionChange = _ref.onDOMSelectionChange;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n\n  var applyPendingSelection = function applyPendingSelection() {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION[\"delete\"](editor);\n\n    if (pendingSelection) {\n      var selection = editor.selection;\n      var normalized = normalizeRange(editor, pendingSelection);\n\n      if (normalized && (!selection || !slate.Range.equals(normalized, selection))) {\n        slate.Transforms.select(editor, normalized);\n      }\n    }\n  };\n\n  var performAction = function performAction() {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION[\"delete\"](editor);\n\n    if (!action) {\n      return;\n    }\n\n    if (action.at) {\n      var target = slate.Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n\n      if (!target) {\n        return;\n      }\n\n      var _targetRange = slate.Editor.range(editor, target);\n\n      if (!editor.selection || !slate.Range.equals(editor.selection, _targetRange)) {\n        slate.Transforms.select(editor, target);\n      }\n    }\n\n    action.run();\n  };\n\n  var flush = function flush() {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n\n    if (!flushing) {\n      flushing = true;\n      setTimeout(function () {\n        return flushing = false;\n      });\n    }\n\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n\n    var selectionRef = editor.selection && slate.Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = hasPendingDiffs();\n    var diff;\n\n    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {\n      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS[\"delete\"](editor);\n        editor.marks = pendingMarks;\n      }\n\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n\n      var range = targetRange(diff);\n\n      if (!editor.selection || !slate.Range.equals(editor.selection, range)) {\n        slate.Transforms.select(editor, range);\n      }\n\n      if (diff.diff.text) {\n        slate.Editor.insertText(editor, diff.diff.text);\n      } else {\n        slate.Editor.deleteFragment(editor);\n      } // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n\n\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter(function (_ref2) {\n        var id = _ref2.id;\n        return id !== diff.id;\n      }));\n\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION[\"delete\"](editor);\n        EDITOR_TO_USER_MARKS[\"delete\"](editor);\n        flushing = 'action'; // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n\n        EDITOR_TO_PENDING_SELECTION[\"delete\"](editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate.Range.equals(selection, editor.selection))) {\n      slate.Transforms.select(editor, selection);\n    }\n\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    } // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n\n\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS[\"delete\"](editor);\n\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n\n  var handleCompositionEnd = function handleCompositionEnd(_event) {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n\n    compositionEndTimeoutId = setTimeout(function () {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n\n  var handleCompositionStart = function handleCompositionStart(_event) {\n    IS_COMPOSING.set(editor, true);\n\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n\n    if (!placeholderElement) {\n      return;\n    }\n\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n\n    placeholderElement.style.removeProperty('display');\n  };\n\n  var storeDiff = function storeDiff(path, diff) {\n    var _EDITOR_TO_PENDING_DI3;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = slate.Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(function (change) {\n      return slate.Path.equals(change.path, path);\n    });\n\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n\n      if (normalized) {\n        pendingDiffs.push({\n          path: path,\n          diff: diff,\n          id: idCounter++\n        });\n      }\n\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n\n  var scheduleAction = function scheduleAction(run) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        at = _ref3.at;\n\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION[\"delete\"](editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n\n    if (hasPendingAction()) {\n      flush();\n    }\n\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at: at,\n      run: run\n    }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n\n    actionTimeoutId = setTimeout(flush);\n  };\n\n  var handleDOMBeforeInput = function handleDOMBeforeInput(event) {\n    var _targetRange2;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var type = event.inputType;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n\n    var _event$getTargetRange = event.getTargetRanges(),\n        _event$getTargetRange2 = _slicedToArray(_event$getTargetRange, 1),\n        nativeTargetRange = _event$getTargetRange2[0];\n\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    } // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n\n\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n\n    if (!targetRange) {\n      return;\n    } // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n\n\n    var canStoreDiff = true;\n\n    if (type.startsWith('delete')) {\n      if (slate.Range.isExpanded(targetRange)) {\n        var _Range$edges = slate.Range.edges(targetRange),\n            _Range$edges2 = _slicedToArray(_Range$edges, 2),\n            _start = _Range$edges2[0],\n            _end = _Range$edges2[1];\n\n        var _leaf = slate.Node.leaf(editor, _start.path);\n\n        if (_leaf.text.length === _start.offset && _end.offset === 0) {\n          var next = slate.Editor.next(editor, {\n            at: _start.path,\n            match: slate.Text.isText\n          });\n\n          if (next && slate.Path.equals(next[1], _end.path)) {\n            targetRange = {\n              anchor: _end,\n              focus: _end\n            };\n          }\n        }\n      }\n\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n\n      var _Range$edges3 = slate.Range.edges(targetRange),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          start = _Range$edges4[0],\n          end = _Range$edges4[1];\n\n      var _Editor$leaf = slate.Editor.leaf(editor, start.path),\n          _Editor$leaf2 = _slicedToArray(_Editor$leaf, 2),\n          leaf = _Editor$leaf2[0],\n          path = _Editor$leaf2[1];\n\n      var diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset\n      };\n      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(function (change) {\n        return slate.Path.equals(change.path, path);\n      });\n      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];\n      var text = applyStringDiff.apply(void 0, [leaf.text].concat(diffs));\n\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false;\n      }\n\n      if (slate.Range.isExpanded(targetRange)) {\n        if (canStoreDiff && slate.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          var point = {\n            path: targetRange.anchor.path,\n            offset: start.offset\n          };\n          var range = slate.Editor.range(editor, point, point);\n          handleUserSelect(range);\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset\n          });\n        }\n\n        return scheduleAction(function () {\n          return slate.Editor.deleteFragment(editor, {\n            direction: direction\n          });\n        }, {\n          at: targetRange\n        });\n      }\n    }\n\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteFragment(editor);\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var _targetRange3 = targetRange,\n              anchor = _targetRange3.anchor;\n\n          if (canStoreDiff && slate.Range.isCollapsed(targetRange)) {\n            var targetNode = slate.Node.leaf(editor, anchor.path);\n\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n\n          return scheduleAction(function () {\n            return slate.Editor.deleteForward(editor);\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n\n          var _targetRange4 = targetRange,\n              _anchor = _targetRange4.anchor; // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n\n          if (canStoreDiff && nativeCollapsed && slate.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n\n          return scheduleAction(function () {\n            return slate.Editor.deleteBackward(editor);\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(function () {\n            slate.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordForward':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'insertLineBreak':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.insertSoftBreak(editor);\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'insertParagraph':\n        {\n          return scheduleAction(function () {\n            return slate.Editor.insertBreak(editor);\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if (isDataTransfer(data)) {\n            return scheduleAction(function () {\n              return ReactEditor.insertData(editor, data);\n            }, {\n              at: targetRange\n            });\n          }\n\n          var _text = data !== null && data !== void 0 ? data : ''; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n\n\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            _text = _text.replace(\"\\uFEFF\", '');\n          } // Pastes from the Android clipboard will generate `insertText` events.\n          // If the copied text contains any newlines, Android will append an\n          // extra newline to the end of the copied text.\n\n\n          if (type === 'insertText' && /.*\\n.*\\n$/.test(_text)) {\n            _text = _text.slice(0, -1);\n          } // If the text includes a newline, split it at newlines and paste each component\n          // string, with soft breaks in between each.\n\n\n          if (_text.includes('\\n')) {\n            return scheduleAction(function () {\n              var parts = _text.split('\\n');\n\n              parts.forEach(function (line, i) {\n                if (line) {\n                  slate.Editor.insertText(editor, line);\n                }\n\n                if (i !== parts.length - 1) {\n                  slate.Editor.insertSoftBreak(editor);\n                }\n              });\n            }, {\n              at: targetRange\n            });\n          }\n\n          if (slate.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var _Range$edges5 = slate.Range.edges(targetRange),\n                _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n                _start2 = _Range$edges6[0],\n                _end2 = _Range$edges6[1];\n\n            var _diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text: _text\n            }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n\n            if (_text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n\n              var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n\n              if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                _diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = _diff;\n              } else if (insertPositionHint && slate.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + _text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n\n            if (canStoreDiff) {\n              storeDiff(_start2.path, _diff);\n              return;\n            }\n          }\n\n          return scheduleAction(function () {\n            return slate.Editor.insertText(editor, _text);\n          }, {\n            at: targetRange\n          });\n        }\n    }\n  };\n\n  var hasPendingAction = function hasPendingAction() {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n\n  var hasPendingDiffs = function hasPendingDiffs() {\n    var _EDITOR_TO_PENDING_DI4;\n\n    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n  };\n\n  var hasPendingChanges = function hasPendingChanges() {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n\n  var isFlushing = function isFlushing() {\n    return flushing;\n  };\n\n  var handleUserSelect = function handleUserSelect(range) {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var selection = editor.selection;\n\n    if (!range) {\n      return;\n    }\n\n    var pathChanged = !selection || !slate.Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !slate.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n\n  var handleInput = function handleInput() {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n\n  var handleKeyDown = function handleKeyDown(_) {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n\n  var scheduleFlush = function scheduleFlush() {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n\n  var handleDomMutations = function handleDomMutations(mutations) {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n\n    if (mutations.some(function (mutation) {\n      return isTrackedMutation(editor, mutation, mutations);\n    })) {\n      var _EDITOR_TO_FORCE_REND;\n\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n\n  return {\n    flush: flush,\n    scheduleFlush: scheduleFlush,\n    hasPendingDiffs: hasPendingDiffs,\n    hasPendingAction: hasPendingAction,\n    hasPendingChanges: hasPendingChanges,\n    isFlushing: isFlushing,\n    handleUserSelect: handleUserSelect,\n    handleCompositionEnd: handleCompositionEnd,\n    handleCompositionStart: handleCompositionStart,\n    handleDOMBeforeInput: handleDOMBeforeInput,\n    handleKeyDown: handleKeyDown,\n    handleDomMutations: handleDomMutations,\n    handleInput: handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = React.useRef(false);\n  React.useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\n\nfunction useMutationObserver(node, callback, options) {\n  var _useState = React.useState(function () {\n    return new MutationObserver(callback);\n  }),\n      _useState2 = _slicedToArray(_useState, 1),\n      mutationObserver = _useState2[0];\n\n  useIsomorphicLayoutEffect(function () {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  React.useEffect(function () {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    mutationObserver.observe(node.current, options);\n    return function () {\n      return mutationObserver.disconnect();\n    };\n  }, [mutationObserver, node, options]);\n}\n\nvar _excluded$3 = [\"node\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nvar useAndroidInputManager = !IS_ANDROID ? function () {\n  return null;\n} : function (_ref) {\n  var node = _ref.node,\n      options = _objectWithoutProperties(_ref, _excluded$3);\n\n  if (!IS_ANDROID) {\n    return null;\n  }\n\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n\n  var _useState = React.useState(function () {\n    return createAndroidInputManager(_objectSpread$2({\n      editor: editor\n    }, options));\n  }),\n      _useState2 = _slicedToArray(_useState, 1),\n      inputManager = _useState2[0];\n\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n\n  if (isMounted) {\n    inputManager.flush();\n  }\n\n  return inputManager;\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\n\nvar isDecorationFlagsEqual = function isDecorationFlagsEqual(range, other) {\n  range.anchor;\n      range.focus;\n      var rangeOwnProps = _objectWithoutProperties(range, _excluded$2);\n\n  other.anchor;\n      other.focus;\n      var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\n\nvar isElementDecorationsEqual = function isElementDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    if (!slate.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isTextDecorationsEqual = function isTextDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i]; // compare only offsets because paths doesn't matter for text\n\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = function String(props) {\n  var isLast = props.isLast,\n      leaf = props.leaf,\n      parent = props.parent,\n      text = props.text;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = slate.Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/React__default['default'].createElement(ZeroWidthString, {\n      length: slate.Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate.Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/React__default['default'].createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/React__default['default'].createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/React__default['default'].createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return /*#__PURE__*/React__default['default'].createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = function TextString(props) {\n  var text = props.text,\n      _props$isTrailing = props.isTrailing,\n      isTrailing = _props$isTrailing === void 0 ? false : _props$isTrailing;\n  var ref = React.useRef(null);\n\n  var getTextContent = function getTextContent() {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  };\n\n  var _useState = React.useState(getTextContent),\n      _useState2 = _slicedToArray(_useState, 1),\n      initialText = _useState2[0]; // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n\n\n  useIsomorphicLayoutEffect(function () {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n\n  }); // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n\n  return /*#__PURE__*/React__default['default'].createElement(MemoizedText$1, {\n    ref: ref\n  }, initialText);\n};\n\nvar MemoizedText$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React__default['default'].createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  }, props.children);\n}));\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\nvar ZeroWidthString = function ZeroWidthString(props) {\n  var _props$length = props.length,\n      length = _props$length === void 0 ? 0 : _props$length,\n      _props$isLineBreak = props.isLineBreak,\n      isLineBreak = _props$isLineBreak === void 0 ? false : _props$isLineBreak,\n      _props$isMarkPlacehol = props.isMarkPlaceholder,\n      isMarkPlaceholder = _props$isMarkPlacehol === void 0 ? false : _props$isMarkPlacehol;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n\n  return /*#__PURE__*/React__default['default'].createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /*#__PURE__*/React__default['default'].createElement(\"br\", null) : null);\n};\n\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect();\n\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null;\n    }\n  }\n}\n\nfunction clearTimeoutRef(timeoutRef) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = null;\n  }\n}\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\n\nvar Leaf = function Leaf(props) {\n  var leaf = props.leaf,\n      isLast = props.isLast,\n      text = props.text,\n      parent = props.parent,\n      renderPlaceholder = props.renderPlaceholder,\n      _props$renderLeaf = props.renderLeaf,\n      renderLeaf = _props$renderLeaf === void 0 ? function (props) {\n    return /*#__PURE__*/React__default['default'].createElement(DefaultLeaf, Object.assign({}, props));\n  } : _props$renderLeaf;\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = React.useRef(null);\n  var placeholderRef = React.useRef(null);\n\n  var _useState = React.useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      showPlaceholder = _useState2[0],\n      setShowPlaceholder = _useState2[1];\n\n  var showPlaceholderTimeoutRef = React.useRef(null);\n  var callbackPlaceholderRef = React.useCallback(function (placeholderEl) {\n    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n\n    if (placeholderEl == null) {\n      var _leaf$onPlaceholderRe;\n\n      EDITOR_TO_PLACEHOLDER_ELEMENT[\"delete\"](editor);\n      (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 ? void 0 : _leaf$onPlaceholderRe.call(leaf, null);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n\n      if (!placeholderResizeObserver.current) {\n        // Create a new observer and observe the placeholder element.\n        var ResizeObserver = window.ResizeObserver || resizeObserver.ResizeObserver;\n        placeholderResizeObserver.current = new ResizeObserver(function () {\n          var _leaf$onPlaceholderRe2;\n\n          (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 ? void 0 : _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n        });\n      }\n\n      placeholderResizeObserver.current.observe(placeholderEl);\n      placeholderRef.current = placeholderEl;\n    }\n  }, [placeholderRef, leaf, editor]);\n  var children = /*#__PURE__*/React__default['default'].createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n  var leafIsPlaceholder = leaf[PLACEHOLDER_SYMBOL];\n  React.useEffect(function () {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(function () {\n          setShowPlaceholder(true);\n          showPlaceholderTimeoutRef.current = null;\n        }, 300);\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef);\n      setShowPlaceholder(false);\n    }\n\n    return function () {\n      return clearTimeoutRef(showPlaceholderTimeoutRef);\n    };\n  }, [leafIsPlaceholder, setShowPlaceholder]);\n\n  if (leafIsPlaceholder && showPlaceholder) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n          // Fixes https://github.com/udecode/plate/issues/2315\n          WebkitUserModify: IS_WEBKIT ? 'inherit' : undefined\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef\n      }\n    };\n    children = /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, renderPlaceholder(placeholderProps), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes: attributes,\n    children: children,\n    leaf: leaf,\n    text: text\n  });\n};\n\nvar MemoizedLeaf = /*#__PURE__*/React__default['default'].memo(Leaf, function (prev, next) {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate.Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = function DefaultLeaf(props) {\n  var attributes = props.attributes,\n      children = props.children;\n  return /*#__PURE__*/React__default['default'].createElement(\"span\", Object.assign({}, attributes), children);\n};\n\n/**\r\n * Text.\r\n */\n\nvar Text = function Text(props) {\n  var decorations = props.decorations,\n      isLast = props.isLast,\n      parent = props.parent,\n      renderPlaceholder = props.renderPlaceholder,\n      renderLeaf = props.renderLeaf,\n      text = props.text;\n  var editor = useSlateStatic();\n  var ref = React.useRef(null);\n  var leaves = slate.Text.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/React__default['default'].createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  var callbackRef = React.useCallback(function (span) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (span) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);\n      NODE_TO_ELEMENT.set(text, span);\n      ELEMENT_TO_NODE.set(span, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT[\"delete\"](key);\n      NODE_TO_ELEMENT[\"delete\"](text);\n\n      if (ref.current) {\n        ELEMENT_TO_NODE[\"delete\"](ref.current);\n      }\n    }\n\n    ref.current = span;\n  }, [ref, editor, key, text]);\n  return /*#__PURE__*/React__default['default'].createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: callbackRef\n  }, children);\n};\n\nvar MemoizedText = /*#__PURE__*/React__default['default'].memo(Text, function (prev, next) {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * Element.\r\n */\n\nvar Element = function Element(props) {\n  var decorations = props.decorations,\n      element = props.element,\n      _props$renderElement = props.renderElement,\n      renderElement = _props$renderElement === void 0 ? function (p) {\n    return /*#__PURE__*/React__default['default'].createElement(DefaultElement, Object.assign({}, p));\n  } : _props$renderElement,\n      renderPlaceholder = props.renderPlaceholder,\n      renderLeaf = props.renderLeaf,\n      selection = props.selection;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = React.useCallback(function (ref) {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT[\"delete\"](key);\n      NODE_TO_ELEMENT[\"delete\"](element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations: decorations,\n    node: element,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref: ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && slate.Editor.hasInlines(editor, element)) {\n    var text = slate.Node.string(element);\n    var dir = getDirection__default['default'](text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (slate.Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n\n    var _Node$texts = slate.Node.texts(element),\n        _Node$texts2 = _slicedToArray(_Node$texts, 1),\n        _Node$texts2$ = _slicedToArray(_Node$texts2[0], 1),\n        _text = _Node$texts2$[0];\n\n    children = /*#__PURE__*/React__default['default'].createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/React__default['default'].createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n\n  return renderElement({\n    attributes: attributes,\n    children: children,\n    element: element\n  });\n};\n\nvar MemoizedElement = /*#__PURE__*/React__default['default'].memo(Element, function (prev, next) {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate.Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = function DefaultElement(props) {\n  var attributes = props.attributes,\n      children = props.children,\n      element = props.element;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/React__default['default'].createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/React.createContext(function () {\n  return [];\n});\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = function useDecorate() {\n  return React.useContext(DecorateContext);\n};\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/React.createContext(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = function useSelected() {\n  return React.useContext(SelectedContext);\n};\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\n\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/**\r\n * Children.\r\n */\n\nvar useChildren = function useChildren(props) {\n  var decorations = props.decorations,\n      node = props.node,\n      renderElement = props.renderElement,\n      renderPlaceholder = props.renderPlaceholder,\n      renderLeaf = props.renderLeaf,\n      selection = props.selection;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = slate.Element.isElement(node) && !editor.isInline(node) && slate.Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = slate.Editor.range(editor, p);\n    var sel = selection && slate.Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n\n    var _iterator = _createForOfIteratorHelper$2(decorations),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dec = _step.value;\n        var d = slate.Range.intersection(dec, range);\n\n        if (d) {\n          ds.push(d);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (slate.Element.isElement(n)) {\n      children.push( /*#__PURE__*/React__default['default'].createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/React__default['default'].createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/React__default['default'].createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n\n  return children;\n};\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/React.createContext(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = function useReadOnly() {\n  return React.useContext(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/React.createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = function useSlate() {\n  var context = React.useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var editor = context.editor;\n  return editor;\n};\nvar useSlateWithV = function useSlateWithV() {\n  var context = React.useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return context;\n};\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = React.useRef(false);\n  var animationFrameIdRef = React.useRef(0);\n  var onUserInput = React.useCallback(function () {\n    if (receivedUserInput.current) {\n      return;\n    }\n\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(function () {\n      receivedUserInput.current = false;\n    });\n  }, [editor]);\n  React.useEffect(function () {\n    return function () {\n      return cancelAnimationFrame(animationFrameIdRef.current);\n    };\n  }, []);\n  return {\n    receivedUserInput: receivedUserInput,\n    onUserInput: onUserInput\n  };\n}\n\nvar TRIPLE_CLICK = 3;\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = function create(key) {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isHotkey.isHotkey(generic);\n  var isApple = apple && isHotkey.isHotkey(apple);\n  var isWindows = windows && isHotkey.isHotkey(windows);\n  return function (event) {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar createClass = createCommonjsModule(function (module) {\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _createClass = unwrapExports(createClass);\n\nvar setPrototypeOf = createCommonjsModule(function (module) {\nfunction _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(setPrototypeOf);\n\nvar inherits = createCommonjsModule(function (module) {\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _inherits = unwrapExports(inherits);\n\nvar _typeof_1 = createCommonjsModule(function (module) {\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(_typeof_1);\n\nvar assertThisInitialized = createCommonjsModule(function (module) {\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(assertThisInitialized);\n\nvar possibleConstructorReturn = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\n\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _possibleConstructorReturn = unwrapExports(possibleConstructorReturn);\n\nvar getPrototypeOf = createCommonjsModule(function (module) {\nfunction _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _getPrototypeOf = unwrapExports(getPrototypeOf);\n\nvar createRestoreDomManager = function createRestoreDomManager(editor, receivedUserInput) {\n  var bufferedMutations = [];\n\n  var clear = function clear() {\n    bufferedMutations = [];\n  };\n\n  var registerMutations = function registerMutations(mutations) {\n    var _bufferedMutations;\n\n    if (!receivedUserInput.current) {\n      return;\n    }\n\n    var trackedMutations = mutations.filter(function (mutation) {\n      return isTrackedMutation(editor, mutation, mutations);\n    });\n\n    (_bufferedMutations = bufferedMutations).push.apply(_bufferedMutations, _toConsumableArray(trackedMutations));\n  };\n\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(function (mutation) {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return;\n        }\n\n        mutation.removedNodes.forEach(function (node) {\n          mutation.target.insertBefore(node, mutation.nextSibling);\n        });\n        mutation.addedNodes.forEach(function (node) {\n          mutation.target.removeChild(node);\n        });\n      }); // Clear buffered mutations to ensure we don't undo them twice\n\n      clear();\n    }\n  }\n\n  return {\n    registerMutations: registerMutations,\n    restoreDOM: restoreDOM,\n    clear: clear\n  };\n};\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\n\nvar RestoreDOMComponent = /*#__PURE__*/function (_Component) {\n  _inherits(RestoreDOMComponent, _Component);\n\n  var _super = _createSuper(RestoreDOMComponent);\n\n  function RestoreDOMComponent() {\n    var _this;\n\n    _classCallCheck(this, RestoreDOMComponent);\n\n    _this = _super.apply(this, arguments);\n    _this.context = null;\n    _this.manager = null;\n    _this.mutationObserver = null;\n    return _this;\n  }\n\n  _createClass(RestoreDOMComponent, [{\n    key: \"observe\",\n    value: function observe() {\n      var _this$mutationObserve;\n\n      var node = this.props.node;\n\n      if (!node.current) {\n        throw new Error('Failed to attach MutationObserver, `node` is undefined');\n      }\n\n      (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var receivedUserInput = this.props.receivedUserInput;\n      var editor = this.context;\n      this.manager = createRestoreDomManager(editor, receivedUserInput);\n      this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n      this.observe();\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate() {\n      var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n\n      var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n\n      if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n        var _this$manager;\n\n        (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n      }\n\n      (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n      (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n      return null;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this$manager3;\n\n      (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n      this.observe();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$mutationObserve4;\n\n      (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n\n  return RestoreDOMComponent;\n}(React.Component);\n\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : function (_ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, children);\n};\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\", \"disableDefaultStyles\"],\n    _excluded2 = [\"text\"];\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\n\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Children = function Children(props) {\n  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, useChildren(props));\n};\n/**\r\n * Editable.\r\n */\n\n\nvar Editable = function Editable(props) {\n  var defaultRenderPlaceholder = React.useCallback(function (props) {\n    return /*#__PURE__*/React__default['default'].createElement(DefaultPlaceholder, Object.assign({}, props));\n  }, []);\n\n  var autoFocus = props.autoFocus,\n      _props$decorate = props.decorate,\n      decorate = _props$decorate === void 0 ? defaultDecorate : _props$decorate,\n      propsOnDOMBeforeInput = props.onDOMBeforeInput,\n      placeholder = props.placeholder,\n      _props$readOnly = props.readOnly,\n      readOnly = _props$readOnly === void 0 ? false : _props$readOnly,\n      renderElement = props.renderElement,\n      renderLeaf = props.renderLeaf,\n      _props$renderPlacehol = props.renderPlaceholder,\n      renderPlaceholder = _props$renderPlacehol === void 0 ? defaultRenderPlaceholder : _props$renderPlacehol,\n      _props$scrollSelectio = props.scrollSelectionIntoView,\n      scrollSelectionIntoView = _props$scrollSelectio === void 0 ? defaultScrollSelectionIntoView : _props$scrollSelectio,\n      _props$style = props.style,\n      userStyle = _props$style === void 0 ? {} : _props$style,\n      _props$as = props.as,\n      Component = _props$as === void 0 ? 'div' : _props$as,\n      _props$disableDefault = props.disableDefaultStyles,\n      disableDefaultStyles = _props$disableDefault === void 0 ? false : _props$disableDefault,\n      attributes = _objectWithoutProperties(props, _excluded$1);\n\n  var editor = useSlate(); // Rerender editor when composition status changed\n\n  var _useState = React.useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isComposing = _useState2[0],\n      setIsComposing = _useState2[1];\n\n  var ref = React.useRef(null);\n  var deferredOperations = React.useRef([]);\n\n  var _useState3 = React.useState(),\n      _useState4 = _slicedToArray(_useState3, 2),\n      placeholderHeight = _useState4[0],\n      setPlaceholderHeight = _useState4[1];\n\n  var _useTrackUserInput = useTrackUserInput(),\n      onUserInput = _useTrackUserInput.onUserInput,\n      receivedUserInput = _useTrackUserInput.receivedUserInput;\n\n  var _useReducer = React.useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      forceRender = _useReducer2[1];\n\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = React.useMemo(function () {\n    return {\n      isDraggingInternally: false,\n      isUpdatingSelection: false,\n      latestElement: null,\n      hasMarkPlaceholder: false\n    };\n  }, []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  React.useEffect(function () {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  /**\r\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\r\n   *\r\n   * It is defined as a reference to simplify hook dependencies and clarify that\r\n   * it needs to be initialized.\r\n   */\n\n  var androidInputManagerRef = React.useRef(); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = React.useMemo(function () {\n    return throttle__default['default'](function () {\n      var androidInputManager = androidInputManagerRef.current;\n\n      if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var activeElement = root.activeElement;\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var domSelection = root.getSelection();\n\n        if (activeElement === el) {\n          state.latestElement = activeElement;\n          IS_FOCUSED.set(editor, true);\n        } else {\n          IS_FOCUSED[\"delete\"](editor);\n        }\n\n        if (!domSelection) {\n          return slate.Transforms.deselect(editor);\n        }\n\n        var anchorNode = domSelection.anchorNode,\n            focusNode = domSelection.focusNode;\n        var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n        var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n\n        if (anchorNodeSelectable && focusNodeSelectable) {\n          var range = ReactEditor.toSlateRange(editor, domSelection, {\n            exactMatch: false,\n            suppressThrow: true\n          });\n\n          if (range) {\n            if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n              slate.Transforms.select(editor, range);\n            } else {\n              androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n            }\n          }\n        } // Deselect the editor if the dom selection is not selectable in readonly mode\n\n\n        if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n          slate.Transforms.deselect(editor);\n        }\n      }\n    }, 100);\n  }, [editor, readOnly, state]);\n  var scheduleOnDOMSelectionChange = React.useMemo(function () {\n    return debounce__default['default'](onDOMSelectionChange, 0);\n  }, [onDOMSelectionChange]);\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange: onDOMSelectionChange,\n    scheduleOnDOMSelectionChange: scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(function () {\n    var _androidInputManagerR, _androidInputManagerR2;\n\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT[\"delete\"](editor);\n    } // Make sure the DOM selection state is in sync.\n\n\n    var selection = editor.selection;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n      return;\n    }\n\n    var setDomSelection = function setDomSelection(forceChange) {\n      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n      if (!selection && !hasDomSelection) {\n        return;\n      } // Get anchorNode and focusNode\n\n\n      var focusNode = domSelection.focusNode;\n      var anchorNode; // COMPAT: In firefox the normal seletion way does not work\n      // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n\n      if (IS_FIREFOX && domSelection.rangeCount > 1) {\n        var firstRange = domSelection.getRangeAt(0);\n        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1); // Right to left\n\n        if (firstRange.startContainer === focusNode) {\n          anchorNode = lastRange.endContainer;\n        } else {\n          // Left to right\n          anchorNode = firstRange.startContainer;\n        }\n      } else {\n        anchorNode = domSelection.anchorNode;\n      } // verify that the dom selection is in the editor\n\n\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n\n      if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n        hasDomSelectionInEditor = true;\n      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n\n        if (slateRange && slate.Range.equals(slateRange, selection)) {\n          var _anchorNode, _anchorNode$parentEle;\n\n          if (!state.hasMarkPlaceholder) {\n            return;\n          } // Ensure selection is inside the mark placeholder\n\n\n          if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode$parentEle = _anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      } // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n\n\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      } // Otherwise the DOM selection is out of sync, so update it.\n\n\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n\n      if (newDomRange) {\n        if (ReactEditor.isComposing(editor) && !IS_ANDROID) {\n          domSelection.collapseToEnd();\n        } else if (slate.Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n\n      return newDomRange;\n    }; // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n\n\n    if (domSelection.rangeCount <= 1) {\n      setDomSelection();\n    }\n\n    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';\n\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(function () {\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(function () {\n      if (ensureSelection) {\n        var ensureDomSelection = function ensureDomSelection(forceChange) {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {// Ignore, dom and state might be out of sync\n          }\n        }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n\n\n        ensureDomSelection();\n        timeoutId = setTimeout(function () {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return function () {\n      cancelAnimationFrame(animationFrameId);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = React.useCallback(function (event) {\n    onUserInput();\n\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManagerRef.current) {\n        return androidInputManagerRef.current.handleDOMBeforeInput(event);\n      } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n\n\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var selection = editor.selection;\n      var type = event.inputType;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText'; // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n\n      var _native = false;\n\n      if (type === 'insertText' && selection && slate.Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n\n        _native = true; // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n\n        if (editor.marks) {\n          _native = false;\n        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n        // Therefore we don't allow native events to insert text at the end of anchor nodes.\n\n\n        var anchor = selection.anchor;\n\n        var _ReactEditor$toDOMPoi = ReactEditor.toDOMPoint(editor, anchor),\n            _ReactEditor$toDOMPoi2 = _slicedToArray(_ReactEditor$toDOMPoi, 2),\n            node = _ReactEditor$toDOMPoi2[0],\n            offset = _ReactEditor$toDOMPoi2[1];\n\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n        var window = ReactEditor.getWindow(editor);\n\n        if (_native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n\n          // Find the last text node inside the anchor.\n          var lastText = window === null || window === void 0 ? void 0 : window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n            _native = false;\n          }\n        } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n\n\n        if (_native && node.parentElement && (window === null || window === void 0 ? void 0 : (_window$getComputedSt = window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n          var block = slate.Editor.above(editor, {\n            at: anchor.path,\n            match: function match(n) {\n              return slate.Element.isElement(n) && slate.Editor.isBlock(editor, n);\n            }\n          });\n\n          if (block && slate.Node.string(block[0]).includes('\\t')) {\n            _native = false;\n          }\n        }\n      } // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var _event$getTargetRange = event.getTargetRanges(),\n            _event$getTargetRange2 = _slicedToArray(_event$getTargetRange, 1),\n            targetRange = _event$getTargetRange2[0];\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n\n          if (!selection || !slate.Range.equals(selection, range)) {\n            _native = false;\n            var selectionRef = !isCompositionChange && editor.selection && slate.Editor.rangeRef(editor, editor.selection);\n            slate.Transforms.select(editor, range);\n\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      } // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n\n      if (isCompositionChange) {\n        return;\n      }\n\n      if (!_native) {\n        event.preventDefault();\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && slate.Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        slate.Editor.deleteFragment(editor, {\n          direction: direction\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            slate.Editor.deleteFragment(editor);\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            slate.Editor.deleteForward(editor);\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            slate.Editor.deleteBackward(editor);\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            slate.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            slate.Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            slate.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            slate.Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            slate.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            slate.Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            slate.Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n          slate.Editor.insertSoftBreak(editor);\n          break;\n\n        case 'insertParagraph':\n          {\n            slate.Editor.insertBreak(editor);\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            } // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n\n\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (_native) {\n                deferredOperations.current.push(function () {\n                  return slate.Editor.insertText(editor, data);\n                });\n              } else {\n                slate.Editor.insertText(editor, data);\n              }\n            }\n\n            break;\n          }\n      } // Restore the actual user section if nothing manually set it.\n\n\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION[\"delete\"](editor);\n\n      if (toRestore && (!editor.selection || !slate.Range.equals(editor.selection, toRestore))) {\n        slate.Transforms.select(editor, toRestore);\n      }\n    }\n  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);\n  var callbackRef = React.useCallback(function (node) {\n    if (node == null) {\n      onDOMSelectionChange.cancel();\n      scheduleOnDOMSelectionChange.cancel();\n      EDITOR_TO_ELEMENT[\"delete\"](editor);\n      NODE_TO_ELEMENT[\"delete\"](editor);\n\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    } else {\n      // Attach a native DOM event handler for `beforeinput` events, because React's\n      // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n      // real `beforeinput` events sadly... (2019/11/04)\n      // https://github.com/facebook/react/issues/11211\n      if (HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        node.addEventListener('beforeinput', onDOMBeforeInput);\n      }\n    }\n\n    ref.current = node;\n  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(function () {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    return function () {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(slate.Node.texts(editor)).length === 1 && slate.Node.string(editor) === '' && !isComposing;\n  var placeHolderResizeHandler = React.useCallback(function (placeholderEl) {\n    if (placeholderEl && showPlaceholder) {\n      var _placeholderEl$getBou;\n\n      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n    } else {\n      setPlaceholderHeight(undefined);\n    }\n  }, [showPlaceholder]);\n\n  if (showPlaceholder) {\n    var _decorations$push;\n\n    var start = slate.Editor.start(editor, []);\n    decorations.push((_decorations$push = {}, _defineProperty(_decorations$push, PLACEHOLDER_SYMBOL, true), _defineProperty(_decorations$push, \"placeholder\", placeholder), _defineProperty(_decorations$push, \"onPlaceholderResize\", placeHolderResizeHandler), _defineProperty(_decorations$push, \"anchor\", start), _defineProperty(_decorations$push, \"focus\", start), _decorations$push));\n  }\n\n  var marks = editor.marks;\n  state.hasMarkPlaceholder = false;\n\n  if (editor.selection && slate.Range.isCollapsed(editor.selection) && marks) {\n    var anchor = editor.selection.anchor;\n    var leaf = slate.Node.leaf(editor, anchor.path);\n\n    leaf.text;\n        var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n\n\n    if (!slate.Text.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(function (mark) {\n        return [mark, null];\n      }));\n      decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1(_defineProperty({}, MARK_PLACEHOLDER_SYMBOL, true), unset), marks), {}, {\n        anchor: anchor,\n        focus: anchor\n      }));\n    }\n  } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n\n\n  React.useEffect(function () {\n    setTimeout(function () {\n      var selection = editor.selection;\n\n      if (selection) {\n        var _anchor = selection.anchor;\n\n        var _text = slate.Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n\n\n        if (marks && !slate.Text.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n\n      EDITOR_TO_PENDING_INSERTION_MARKS[\"delete\"](editor);\n    });\n  });\n  return /*#__PURE__*/React__default['default'].createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/React__default['default'].createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/React__default['default'].createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/React__default['default'].createElement(Component, Object.assign({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: callbackRef,\n    style: _objectSpread$1(_objectSpread$1({}, disableDefaultStyles ? {} : _objectSpread$1({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, placeholderHeight ? {\n      minHeight: placeholderHeight\n    } : {})), userStyle),\n    onBeforeInput: React.useCallback(function (event) {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          slate.Editor.insertText(editor, _text2);\n        }\n      }\n    }, [attributes.onBeforeInput, editor, readOnly]),\n    onInput: React.useCallback(function (event) {\n      if (isEventHandled(event, attributes.onInput)) {\n        return;\n      }\n\n      if (androidInputManagerRef.current) {\n        androidInputManagerRef.current.handleInput();\n        return;\n      } // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n\n\n      var _iterator = _createForOfIteratorHelper$1(deferredOperations.current),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var op = _step.value;\n          op();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      deferredOperations.current = [];\n    }, [attributes.onInput]),\n    onBlur: React.useCallback(function (event) {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n\n      var relatedTarget = event.relatedTarget;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (slate.Element.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      } // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n\n\n      if (IS_WEBKIT) {\n        var domSelection = root.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n\n      IS_FOCUSED[\"delete\"](editor);\n    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),\n    onClick: React.useCallback(function (event) {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n\n        if (!slate.Editor.hasPath(editor, path) || slate.Node.get(editor, path) !== node) {\n          return;\n        }\n\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n\n          if (!(slate.Element.isElement(node) && slate.Editor.isBlock(editor, node))) {\n            var _block$;\n\n            var block = slate.Editor.above(editor, {\n              match: function match(n) {\n                return slate.Element.isElement(n) && slate.Editor.isBlock(editor, n);\n              },\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n\n          var range = slate.Editor.range(editor, blockPath);\n          slate.Transforms.select(editor, range);\n          return;\n        }\n\n        if (readOnly) {\n          return;\n        }\n\n        var _start = slate.Editor.start(editor, path);\n\n        var end = slate.Editor.end(editor, path);\n        var startVoid = slate.Editor[\"void\"](editor, {\n          at: _start\n        });\n        var endVoid = slate.Editor[\"void\"](editor, {\n          at: end\n        });\n\n        if (startVoid && endVoid && slate.Path.equals(startVoid[1], endVoid[1])) {\n          var _range = slate.Editor.range(editor, _start);\n\n          slate.Transforms.select(editor, _range);\n        }\n      }\n    }, [editor, attributes.onClick, readOnly]),\n    onCompositionEnd: React.useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR3;\n\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n\n        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 ? void 0 : _androidInputManagerR3.handleCompositionEnd(event);\n\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        } // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n\n        if (!IS_WEBKIT && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS[\"delete\"](editor); // Ensure we insert text with the marks the user was actually seeing\n\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n\n          slate.Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS[\"delete\"](editor);\n\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd, editor]),\n    onCompositionUpdate: React.useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate, editor]),\n    onCompositionStart: React.useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR4;\n\n        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 ? void 0 : _androidInputManagerR4.handleCompositionStart(event);\n\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n\n        setIsComposing(true);\n        var selection = editor.selection;\n\n        if (selection) {\n          if (slate.Range.isExpanded(selection)) {\n            slate.Editor.deleteFragment(editor);\n            return;\n          }\n\n          var inline = slate.Editor.above(editor, {\n            match: function match(n) {\n              return slate.Element.isElement(n) && slate.Editor.isInline(editor, n);\n            },\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var _inline = _slicedToArray(inline, 2),\n                inlinePath = _inline[1];\n\n            if (slate.Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = slate.Editor.after(editor, inlinePath);\n              slate.Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart, editor]),\n    onCopy: React.useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy, editor]),\n    onCut: React.useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var selection = editor.selection;\n\n        if (selection) {\n          if (slate.Range.isExpanded(selection)) {\n            slate.Editor.deleteFragment(editor);\n          } else {\n            var node = slate.Node.parent(editor, selection.anchor.path);\n\n            if (slate.Editor.isVoid(editor, node)) {\n              slate.Transforms[\"delete\"](editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onCut]),\n    onDragOver: React.useCallback(function (event) {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (slate.Element.isElement(node) && slate.Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver, editor]),\n    onDragStart: React.useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = slate.Element.isElement(node) && slate.Editor.isVoid(editor, node) || slate.Editor[\"void\"](editor, {\n          at: path,\n          voids: true\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = slate.Editor.range(editor, path);\n          slate.Transforms.select(editor, range);\n        }\n\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, editor, attributes.onDragStart, state]),\n    onDrop: React.useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault(); // Keep a reference to the dragged range before updating selection\n\n        var draggedRange = editor.selection; // Find the range where the drop happened\n\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        slate.Transforms.select(editor, range);\n\n        if (state.isDraggingInternally) {\n          if (draggedRange && !slate.Range.equals(draggedRange, range) && !slate.Editor[\"void\"](editor, {\n            at: range,\n            voids: true\n          })) {\n            slate.Transforms[\"delete\"](editor, {\n              at: draggedRange\n            });\n          }\n        }\n\n        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n\n      state.isDraggingInternally = false;\n    }, [readOnly, editor, attributes.onDrop, state]),\n    onDragEnd: React.useCallback(function (event) {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      } // When dropping on a different droppable element than the current editor,\n      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n      // Note: `onDragEnd` is only called when `onDrop` is not called\n\n\n      state.isDraggingInternally = false;\n    }, [readOnly, state, attributes, editor]),\n    onFocus: React.useCallback(function (event) {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, state, editor, attributes.onFocus]),\n    onKeyDown: React.useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        var _androidInputManagerR5;\n\n        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 ? void 0 : _androidInputManagerR5.handleKeyDown(event);\n        var nativeEvent = event.nativeEvent; // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n\n        var selection = editor.selection;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = getDirection__default['default'](slate.Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate.Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate.Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate.Range.isCollapsed(selection)) {\n            slate.Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            slate.Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate.Range.isCollapsed(selection)) {\n            slate.Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            slate.Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate.Range.isExpanded(selection)) {\n            slate.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          slate.Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate.Range.isExpanded(selection)) {\n            slate.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          slate.Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            slate.Editor.insertSoftBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            slate.Editor.insertBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate.Range.isExpanded(selection)) {\n              slate.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate.Editor.deleteBackward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate.Range.isExpanded(selection)) {\n              slate.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate.Editor.deleteForward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate.Range.isExpanded(selection)) {\n              slate.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate.Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate.Range.isExpanded(selection)) {\n              slate.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate.Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate.Range.isExpanded(selection)) {\n              slate.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate.Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate.Range.isExpanded(selection)) {\n              slate.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate.Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_WEBKIT) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && slate.Range.isCollapsed(selection)) {\n              var currentNode = slate.Node.parent(editor, selection.anchor.path);\n\n              if (slate.Element.isElement(currentNode) && slate.Editor.isVoid(editor, currentNode) && (slate.Editor.isInline(editor, currentNode) || slate.Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                slate.Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onKeyDown]),\n    onPaste: React.useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        // COMPAT: Safari InputEvents generated by pasting won't include\n        // application/x-slate-fragment items, so use the\n        // ClipboardEvent here. (2023/03/15)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_WEBKIT) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, editor, attributes.onPaste])\n  }), /*#__PURE__*/React__default['default'].createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  })))));\n};\n/**\r\n * The default placeholder element\r\n */\n\nvar DefaultPlaceholder = function DefaultPlaceholder(_ref) {\n  var attributes = _ref.attributes,\n      children = _ref.children;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    React__default['default'].createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/React__default['default'].createElement(\"br\", null))\n  );\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = function defaultDecorate() {\n  return [];\n};\n/**\r\n * A default implement to scroll dom range into view.\r\n */\n\nvar defaultScrollSelectionIntoView = function defaultScrollSelectionIntoView(editor, domRange) {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate.Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoView__default['default'](leafEl, {\n      scrollMode: 'if-needed'\n    }); // @ts-expect-error an unorthodox delete D:\n\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = function isEventHandled(event, handler) {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if the event's target is an input element\r\n */\n\nvar isDOMEventTargetInput = function isDOMEventTargetInput(event) {\n  return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\nvar isDOMEventHandled = function isDOMEventHandled(event, handler) {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.defaultPrevented;\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/React.createContext(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = function useFocused() {\n  return React.useContext(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */\n\n\nvar SlateSelectorContext = /*#__PURE__*/React.createContext({});\n\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */\n\n\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n\n  var _useReducer = React.useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      forceRender = _useReducer2[1];\n\n  var context = React.useContext(SlateSelectorContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var getSlate = context.getSlate,\n      addEventListener = context.addEventListener;\n  var latestSubscriptionCallbackError = React.useRef();\n  var latestSelector = React.useRef(function () {\n    return null;\n  });\n  var latestSelectedState = React.useRef(null);\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return function () {\n      return unsubscribe();\n    };\n  }, // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */\n\nfunction useSelectorContext(editor) {\n  var eventListeners = React.useRef([]).current;\n  var slateRef = React.useRef({\n    editor: editor\n  }).current;\n  var onChange = React.useCallback(function (editor) {\n    slateRef.editor = editor;\n    eventListeners.forEach(function (listener) {\n      return listener(editor);\n    });\n  }, [eventListeners, slateRef]);\n  var selectorContext = React.useMemo(function () {\n    return {\n      getSlate: function getSlate() {\n        return slateRef.editor;\n      },\n      addEventListener: function addEventListener(callback) {\n        eventListeners.push(callback);\n        return function () {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext: selectorContext,\n    onChange: onChange\n  };\n}\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"initialValue\"];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = function Slate(props) {\n  var editor = props.editor,\n      children = props.children,\n      onChange = props.onChange,\n      initialValue = props.initialValue,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var unmountRef = React.useRef(false);\n\n  var _React$useState = React__default['default'].useState(function () {\n    if (!slate.Node.isNodeList(initialValue)) {\n      throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(slate.Scrubber.stringify(initialValue)));\n    }\n\n    if (!slate.Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate.Scrubber.stringify(editor)));\n    }\n\n    editor.children = initialValue;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor: editor\n    };\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      context = _React$useState2[0],\n      setContext = _React$useState2[1];\n\n  var _useSelectorContext = useSelectorContext(editor),\n      selectorContext = _useSelectorContext.selectorContext,\n      handleSelectorChange = _useSelectorContext.onChange;\n\n  var onContextChange = React.useCallback(function () {\n    if (onChange) {\n      onChange(editor.children);\n    }\n\n    setContext(function (prevContext) {\n      return {\n        v: prevContext.v + 1,\n        editor: editor\n      };\n    });\n    handleSelectorChange(editor);\n  }, [editor, handleSelectorChange, onChange]);\n  React.useEffect(function () {\n    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n    return function () {\n      EDITOR_TO_ON_CHANGE.set(editor, function () {});\n      unmountRef.current = true;\n    };\n  }, [editor, onContextChange]);\n\n  var _useState = React.useState(ReactEditor.isFocused(editor)),\n      _useState2 = _slicedToArray(_useState, 2),\n      isFocused = _useState2[0],\n      setIsFocused = _useState2[1];\n\n  React.useEffect(function () {\n    setIsFocused(ReactEditor.isFocused(editor));\n  }, [editor]);\n  useIsomorphicLayoutEffect(function () {\n    var fn = function fn() {\n      return setIsFocused(ReactEditor.isFocused(editor));\n    };\n\n    if (REACT_MAJOR_VERSION >= 17) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return function () {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return function () {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/React__default['default'].createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/React__default['default'].createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React__default['default'].createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/React__default['default'].createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = function useEditor() {\n  var editor = React.useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */\n\nvar useSlateSelection = function useSlateSelection() {\n  return useSlateSelector(function (editor) {\n    return editor.selection;\n  }, isSelectionEqual);\n};\n\nvar isSelectionEqual = function isSelectionEqual(a, b) {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return slate.Range.equals(a, b);\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = function doRectsIntersect(rect, compareRect) {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\n\nvar areRangesSameLine = function areRangesSameLine(editor, range1, range2) {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\n\nvar findCurrentLineRange = function findCurrentLineRange(editor, parentRange) {\n  var parentRangeBoundary = slate.Editor.range(editor, slate.Range.end(parentRange));\n  var positions = Array.from(slate.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n\n  if (areRangesSameLine(editor, slate.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n\n  if (positions.length < 2) {\n    return slate.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n\n    middle = Math.floor((left + right) / 2);\n  }\n\n  return slate.Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = function withReact(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var apply = e.apply,\n      onChange = e.onChange,\n      deleteBackward = e.deleteBackward,\n      addMark = e.addMark,\n      removeMark = e.removeMark; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n\n  e.addMark = function (key, value) {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS[\"delete\"](e);\n    addMark(key, value);\n  };\n\n  e.removeMark = function (key) {\n    var _EDITOR_TO_PENDING_DI2;\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS[\"delete\"](e);\n    removeMark(key);\n  };\n\n  e.deleteBackward = function (unit) {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n\n    if (e.selection && slate.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate.Editor.above(e, {\n        match: function match(n) {\n          return slate.Element.isElement(n) && slate.Editor.isBlock(e, n);\n        },\n        at: e.selection\n      });\n\n      if (parentBlockEntry) {\n        var _parentBlockEntry = _slicedToArray(parentBlockEntry, 2),\n            parentBlockPath = _parentBlockEntry[1];\n\n        var parentElementRange = slate.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n\n        if (!slate.Range.isCollapsed(currentLineRange)) {\n          slate.Transforms[\"delete\"](e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n\n\n  e.apply = function (op) {\n    var matches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(function (textDiff) {\n        return transformTextDiff(textDiff, op);\n      }).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at: at\n      }) : null);\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, op.path)));\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION[\"delete\"](e);\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.path))));\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var prevPath = slate.Path.previous(op.path);\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, prevPath)));\n          break;\n        }\n\n      case 'move_node':\n        {\n          var commonPath = slate.Path.common(slate.Path.parent(op.path), slate.Path.parent(op.newPath));\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, commonPath)));\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n      var _matches$_i = _slicedToArray(_matches[_i], 2),\n          path = _matches$_i[0],\n          key = _matches$_i[1];\n\n      var _Editor$node = slate.Editor.node(e, path),\n          _Editor$node2 = _slicedToArray(_Editor$node, 1),\n          node = _Editor$node2[0];\n\n      NODE_TO_KEY.set(node, key);\n    }\n  };\n\n  e.setFragmentData = function (data) {\n    var selection = e.selection;\n\n    if (!selection) {\n      return;\n    }\n\n    var _Range$edges = slate.Range.edges(selection),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n\n    var startVoid = slate.Editor[\"void\"](e, {\n      at: start.path\n    });\n    var endVoid = slate.Editor[\"void\"](e, {\n      at: end.path\n    });\n\n    if (slate.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(function (node) {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var _endVoid = _slicedToArray(endVoid, 1),\n          voidNode = _endVoid[0];\n\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n\n  e.insertData = function (data) {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n\n  e.insertFragmentData = function (data) {\n    /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n\n    return false;\n  };\n\n  e.insertTextData = function (data) {\n    var text = data.getData('text/plain');\n\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n\n      var _iterator = _createForOfIteratorHelper(lines),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n\n          if (split) {\n            slate.Transforms.splitNodes(e, {\n              always: true\n            });\n          }\n\n          e.insertText(line);\n          split = true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  e.onChange = function (options) {\n    // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n    // that the children and selection can get out of sync for one render\n    // pass. So we have to use this unstable API to ensure it batches them.\n    // (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? ReactDOM__default['default'].unstable_batchedUpdates : function (callback) {\n      return callback();\n    };\n    maybeBatchUpdates(function () {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n\n      if (onContextChange) {\n        onContextChange();\n      }\n\n      onChange(options);\n    });\n  };\n\n  return e;\n};\n\nvar getMatches = function getMatches(e, path) {\n  var matches = [];\n\n  var _iterator2 = _createForOfIteratorHelper(slate.Editor.levels(e, {\n    at: path\n  })),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          n = _step2$value[0],\n          p = _step2$value[1];\n\n      var key = ReactEditor.findKey(e, n);\n      matches.push([p, key]);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return matches;\n};\n\nexports.DefaultElement = DefaultElement;\nexports.DefaultLeaf = DefaultLeaf;\nexports.DefaultPlaceholder = DefaultPlaceholder;\nexports.Editable = Editable;\nexports.ReactEditor = ReactEditor;\nexports.Slate = Slate;\nexports.useEditor = useEditor;\nexports.useFocused = useFocused;\nexports.useReadOnly = useReadOnly;\nexports.useSelected = useSelected;\nexports.useSlate = useSlate;\nexports.useSlateSelection = useSlateSelection;\nexports.useSlateSelector = useSlateSelector;\nexports.useSlateStatic = useSlateStatic;\nexports.useSlateWithV = useSlateWithV;\nexports.withReact = withReact;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLGdFQUFpQjtBQUN4QyxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0IscUJBQXFCLG1CQUFPLENBQUMscUhBQTRCO0FBQ3pELFlBQVksbUJBQU8sQ0FBQyx1REFBTztBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyxnSEFBeUI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLDhEQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxnSEFBVzs7QUFFbEMscUNBQXFDLDREQUE0RDs7QUFFakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUUseUJBQXlCO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0EsbURBQW1EOzs7QUFHbkQ7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esc0ZBQXNGO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0Es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UjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLG1GQUFtRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5RkFBeUYsb0RBQW9EO0FBQzdJO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyZXltYXR0ZXItdjIvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5qcz8xNGRjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdldERpcmVjdGlvbiA9IHJlcXVpcmUoJ2RpcmVjdGlvbicpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnbG9kYXNoL2RlYm91bmNlJyk7XG52YXIgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gvdGhyb3R0bGUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgc2Nyb2xsSW50b1ZpZXcgPSByZXF1aXJlKCdzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZCcpO1xudmFyIHNsYXRlID0gcmVxdWlyZSgnc2xhdGUnKTtcbnZhciByZXNpemVPYnNlcnZlciA9IHJlcXVpcmUoJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJyk7XG52YXIgaXNIb3RrZXkgPSByZXF1aXJlKCdpcy1ob3RrZXknKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGdldERpcmVjdGlvbl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koZ2V0RGlyZWN0aW9uKTtcbnZhciBkZWJvdW5jZV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koZGVib3VuY2UpO1xudmFyIHRocm90dGxlX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeSh0aHJvdHRsZSk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJlYWN0KTtcbnZhciBzY3JvbGxJbnRvVmlld19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koc2Nyb2xsSW50b1ZpZXcpO1xudmFyIFJlYWN0RE9NX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdERPTSk7XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gdW53cmFwRXhwb3J0cyhkZWZpbmVQcm9wZXJ0eSk7XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhpdGVyYWJsZVRvQXJyYXlMaW1pdCk7XG5cbnZhciBhcnJheUxpa2VUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlMaWtlVG9BcnJheSk7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHModW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVSZXN0KTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IHVud3JhcEV4cG9ydHMoc2xpY2VkVG9BcnJheSk7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gdW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllcyk7XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBvYmplY3QuXHJcbiAqL1xuXG52YXIgRWRpdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXHJcbiAqL1xuXG52YXIgdXNlU2xhdGVTdGF0aWMgPSBmdW5jdGlvbiB1c2VTbGF0ZVN0YXRpYygpIHtcbiAgdmFyIGVkaXRvciA9IFJlYWN0LnVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU3RhdGljYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxudmFyIFJFQUNUX01BSk9SX1ZFUlNJT04gPSBwYXJzZUludChSZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLnZlcnNpb24uc3BsaXQoJy4nKVswXSwgMTApO1xudmFyIElTX0lPUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG52YXIgSVNfQVBQTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvTWFjIE9TIFgvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0ZJUkVGT1ggPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfV0VCS0lUID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FwcGxlV2ViS2l0KD8hLipDaHJvbWUpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gXCJtb2Rlcm5cIiBFZGdlIHdhcyByZWxlYXNlZCBhdCA3OS54XG5cbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19DSFJPTUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gTmF0aXZlIGBiZWZvcmVJbnB1dGAgZXZlbnRzIGRvbid0IHdvcmsgd2VsbCB3aXRoIHJlYWN0IG9uIENocm9tZSA3NVxuLy8gYW5kIG9sZGVyLCBDaHJvbWUgNzYrIGNhbiB1c2UgYGJlZm9yZUlucHV0YCB0aG91Z2guXG5cbnZhciBJU19DSFJPTUVfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC03XVswLTVdfFswLTZdWzAtOV0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZID0gSVNfQU5EUk9JRCAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTVdP1xcZCkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cblxudmFyIElTX0ZJUkVGT1hfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3hcXC8oPzpbMC03XVswLTldfFswLThdWzAtNl0pKD86XFwuKSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFVDIG1vYmlsZSBicm93c2VyXG5cbnZhciBJU19VQ19NT0JJTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipVQ0Jyb3dzZXIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFdlY2hhdCBicm93c2VyXG5cbnZhciBJU19XRUNIQVRCUk9XU0VSID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBDaGVjayBpZiBET00gaXMgYXZhaWxhYmxlIGFzIFJlYWN0IGRvZXMgaW50ZXJuYWxseS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcblxudmFyIENBTl9VU0VfRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7IC8vIENPTVBBVDogRmlyZWZveC9FZGdlIExlZ2FjeSBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50XG4vLyBDaHJvbWUgTGVnYWN5IGRvZXNuJ3Qgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGNvcnJlY3RseVxuXG52YXIgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID0gKCFJU19DSFJPTUVfTEVHQUNZIHx8ICFJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kpICYmICFJU19FREdFX0xFR0FDWSAmJiAvLyBnbG9iYWxUaGlzIGlzIHVuZGVmaW5lZCBpbiBvbGRlciBicm93c2Vyc1xudHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuSW5wdXRFdmVudCAmJiAvLyBAdHMtaWdub3JlIFRoZSBgZ2V0VGFyZ2V0UmFuZ2VzYCBwcm9wZXJ0eSBpc24ndCByZWNvZ25pemVkLlxudHlwZW9mIGdsb2JhbFRoaXMuSW5wdXRFdmVudC5wcm90b3R5cGUuZ2V0VGFyZ2V0UmFuZ2VzID09PSAnZnVuY3Rpb24nO1xuXG4vKipcclxuICogVHdvIHdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHJlYnVpbGQgYSBwYXRoIGdpdmVuIGEgbm9kZS4gVGhleSBhcmUgcG9wdWxhdGVkXHJcbiAqIGF0IHJlbmRlciB0aW1lIHN1Y2ggdGhhdCBhZnRlciBhIHJlbmRlciBvY2N1cnMgd2UgY2FuIGFsd2F5cyBiYWNrdHJhY2suXHJcbiAqL1xudmFyIE5PREVfVE9fSU5ERVggPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fUEFSRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyB0byBnbyBiZXR3ZWVuIFNsYXRlIG5vZGVzIGFuZCBET00gbm9kZXMuIFRoZXNlXHJcbiAqIGFyZSB1c2VkIHRvIHJlc29sdmUgRE9NIGV2ZW50LXJlbGF0ZWQgbG9naWMgaW50byBTbGF0ZSBhY3Rpb25zLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19XSU5ET1cgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRUxFTUVOVF9UT19OT0RFID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fS0VZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyBmb3Igc3RvcmluZyBlZGl0b3ItcmVsYXRlZCBzdGF0ZS5cclxuICovXG5cbnZhciBJU19SRUFEX09OTFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0ZPQ1VTRUQgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0NPTVBPU0lORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcCBmb3IgYXNzb2NpYXRpbmcgdGhlIGNvbnRleHQgYG9uQ2hhbmdlYCBjb250ZXh0IHdpdGggdGhlIHBsdWdpbi5cclxuICovXG5cbnZhciBFRElUT1JfVE9fT05fQ0hBTkdFID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgZm9yIHNhdmluZyBwZW5kaW5nIHN0YXRlIG9uIGNvbXBvc2l0aW9uIHN0YWdlLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQW5kcm9pZCBpbnB1dCBoYW5kbGluZyBzcGVjaWZpYyB3ZWFrLW1hcHNcclxuICovXG5cbnZhciBFRElUT1JfVE9fUEVORElOR19ESUZGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19GT1JDRV9SRU5ERVIgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFN5bWJvbHMuXHJcbiAqL1xuXG52YXIgUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdwbGFjZWhvbGRlcicpO1xudmFyIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdtYXJrLXBsYWNlaG9sZGVyJyk7XG5cbnZhciBhcnJheVdpdGhvdXRIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhvdXRIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVTcHJlYWQpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IHVud3JhcEV4cG9ydHModG9Db25zdW1hYmxlQXJyYXkpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxudmFyIERPTVRleHQgPSBnbG9iYWxUaGlzLlRleHQ7XG4vKipcclxuICogUmV0dXJucyB0aGUgaG9zdCB3aW5kb3cgb2YgYSBET00gbm9kZVxyXG4gKi9cblxudmFyIGdldERlZmF1bHRWaWV3ID0gZnVuY3Rpb24gZ2V0RGVmYXVsdFZpZXcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm93bmVyRG9jdW1lbnQgJiYgdmFsdWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBudWxsO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NQ29tbWVudCA9IGZ1bmN0aW9uIGlzRE9NQ29tbWVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gODtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gaXNET01FbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01Ob2RlID0gZnVuY3Rpb24gaXNET01Ob2RlKHZhbHVlKSB7XG4gIHZhciB3aW5kb3cgPSBnZXREZWZhdWx0Vmlldyh2YWx1ZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIHNlbGVjdGlvbi5cclxuICovXG5cbnZhciBpc0RPTVNlbGVjdGlvbiA9IGZ1bmN0aW9uIGlzRE9NU2VsZWN0aW9uKHZhbHVlKSB7XG4gIHZhciB3aW5kb3cgPSB2YWx1ZSAmJiB2YWx1ZS5hbmNob3JOb2RlICYmIGdldERlZmF1bHRWaWV3KHZhbHVlLmFuY2hvck5vZGUpO1xuICByZXR1cm4gISF3aW5kb3cgJiYgdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuU2VsZWN0aW9uO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cclxuICovXG5cbnZhciBpc0RPTVRleHQgPSBmdW5jdGlvbiBpc0RPTVRleHQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDM7XG59O1xuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cclxuICovXG5cbnZhciBpc1BsYWluVGV4dE9ubHlQYXN0ZSA9IGZ1bmN0aW9uIGlzUGxhaW5UZXh0T25seVBhc3RlKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5jbGlwYm9hcmREYXRhICYmIGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpICE9PSAnJyAmJiBldmVudC5jbGlwYm9hcmREYXRhLnR5cGVzLmxlbmd0aCA9PT0gMTtcbn07XG4vKipcclxuICogTm9ybWFsaXplIGEgRE9NIHBvaW50IHNvIHRoYXQgaXQgYWx3YXlzIHJlZmVycyB0byBhIHRleHQgbm9kZS5cclxuICovXG5cbnZhciBub3JtYWxpemVET01Qb2ludCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZURPTVBvaW50KGRvbVBvaW50KSB7XG4gIHZhciBfZG9tUG9pbnQgPSBfc2xpY2VkVG9BcnJheShkb21Qb2ludCwgMiksXG4gICAgICBub2RlID0gX2RvbVBvaW50WzBdLFxuICAgICAgb2Zmc2V0ID0gX2RvbVBvaW50WzFdOyAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cblxuXG4gIGlmIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBpc0xhc3QgPSBvZmZzZXQgPT09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gaXNMYXN0ID8gb2Zmc2V0IC0gMSA6IG9mZnNldDtcblxuICAgIHZhciBfZ2V0RWRpdGFibGVDaGlsZEFuZEkgPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgobm9kZSwgaW5kZXgsIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpO1xuXG4gICAgdmFyIF9nZXRFZGl0YWJsZUNoaWxkQW5kSTIgPSBfc2xpY2VkVG9BcnJheShfZ2V0RWRpdGFibGVDaGlsZEFuZEksIDIpO1xuXG4gICAgbm9kZSA9IF9nZXRFZGl0YWJsZUNoaWxkQW5kSTJbMF07XG4gICAgaW5kZXggPSBfZ2V0RWRpdGFibGVDaGlsZEFuZEkyWzFdO1xuICAgIC8vIElmIHRoZSBlZGl0YWJsZSBjaGlsZCBmb3VuZCBpcyBpbiBmcm9udCBvZiBpbnB1dCBvZmZzZXQsIHdlIGluc3RlYWQgc2VlayB0byBpdHMgZW5kXG4gICAgaXNMYXN0ID0gaW5kZXggPCBvZmZzZXQ7IC8vIElmIHRoZSBub2RlIGhhcyBjaGlsZHJlbiwgdHJhdmVyc2UgdW50aWwgd2UgaGF2ZSBhIGxlYWYgbm9kZS4gTGVhZiBub2Rlc1xuICAgIC8vIGNhbiBiZSBlaXRoZXIgdGV4dCBub2Rlcywgb3Igb3RoZXIgdm9pZCBET00gbm9kZXMuXG5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgfSAvLyBEZXRlcm1pbmUgdGhlIG5ldyBvZmZzZXQgaW5zaWRlIHRoZSB0ZXh0IG5vZGUuXG5cblxuICAgIG9mZnNldCA9IGlzTGFzdCAmJiBub2RlLnRleHRDb250ZW50ICE9IG51bGwgPyBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA6IDA7XG4gIH0gLy8gUmV0dXJuIHRoZSBub2RlIGFuZCBvZmZzZXQuXG5cblxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgbmVzdGVkIHdpdGhpbiBhIHNoYWRvd1Jvb3RcclxuICovXG5cbnZhciBoYXNTaGFkb3dSb290ID0gZnVuY3Rpb24gaGFzU2hhZG93Um9vdChub2RlKSB7XG4gIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxyXG4gKiBHZXQgdGhlIG5lYXJlc3QgZWRpdGFibGUgY2hpbGQgYW5kIGluZGV4IGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xyXG4gKiBgZGlyZWN0aW9uYC5cclxuICovXG5cbnZhciBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXggPSBmdW5jdGlvbiBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gIHZhciBjaGlsZE5vZGVzID0gcGFyZW50LmNoaWxkTm9kZXM7XG4gIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbaW5kZXhdO1xuICB2YXIgaSA9IGluZGV4O1xuICB2YXIgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gIHZhciB0cmllZEJhY2t3YXJkID0gZmFsc2U7IC8vIFdoaWxlIHRoZSBjaGlsZCBpcyBhIGNvbW1lbnQgbm9kZSwgb3IgYW4gZWxlbWVudCBub2RlIHdpdGggbm8gY2hpbGRyZW4sXG4gIC8vIGtlZXAgaXRlcmF0aW5nIHRvIGZpbmQgYSBzaWJsaW5nIG5vbi12b2lkLCBub24tY29tbWVudCBub2RlLlxuXG4gIHdoaWxlIChpc0RPTUNvbW1lbnQoY2hpbGQpIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgaWYgKHRyaWVkRm9yd2FyZCAmJiB0cmllZEJhY2t3YXJkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdHJpZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCAtIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0cmllZEJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCArIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgaW5kZXggPSBpO1xuICAgIGkgKz0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyAxIDogLTE7XG4gIH1cblxuICByZXR1cm4gW2NoaWxkLCBpbmRleF07XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZCA9IGZ1bmN0aW9uIGdldEVkaXRhYmxlQ2hpbGQocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gIHZhciBfZ2V0RWRpdGFibGVDaGlsZEFuZEkzID0gZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4KHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbiksXG4gICAgICBfZ2V0RWRpdGFibGVDaGlsZEFuZEk0ID0gX3NsaWNlZFRvQXJyYXkoX2dldEVkaXRhYmxlQ2hpbGRBbmRJMywgMSksXG4gICAgICBjaGlsZCA9IF9nZXRFZGl0YWJsZUNoaWxkQW5kSTRbMF07XG5cbiAgcmV0dXJuIGNoaWxkO1xufTtcbi8qKlxyXG4gKiBHZXQgYSBwbGFpbnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRlbnQgb2YgYSBub2RlLCBhY2NvdW50aW5nIGZvciBibG9ja1xyXG4gKiBlbGVtZW50cyB3aGljaCBnZXQgYSBuZXdsaW5lIGFwcGVuZGVkLlxyXG4gKlxyXG4gKiBUaGUgZG9tTm9kZSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uXHJcbiAqL1xuXG52YXIgZ2V0UGxhaW5UZXh0ID0gZnVuY3Rpb24gZ2V0UGxhaW5UZXh0KGRvbU5vZGUpIHtcbiAgdmFyIHRleHQgPSAnJztcblxuICBpZiAoaXNET01UZXh0KGRvbU5vZGUpICYmIGRvbU5vZGUubm9kZVZhbHVlKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUubm9kZVZhbHVlO1xuICB9XG5cbiAgaWYgKGlzRE9NRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX0FycmF5JGZyb20gPSBBcnJheS5mcm9tKGRvbU5vZGUuY2hpbGROb2Rlcyk7IF9pIDwgX0FycmF5JGZyb20ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgY2hpbGROb2RlID0gX0FycmF5JGZyb21bX2ldO1xuICAgICAgdGV4dCArPSBnZXRQbGFpblRleHQoY2hpbGROb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpO1xuXG4gICAgaWYgKGRpc3BsYXkgPT09ICdibG9jaycgfHwgZGlzcGxheSA9PT0gJ2xpc3QnIHx8IGRvbU5vZGUudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgdGV4dCArPSAnXFxuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn07XG4vKipcclxuICogR2V0IHgtc2xhdGUtZnJhZ21lbnQgYXR0cmlidXRlIGZyb20gZGF0YS1zbGF0ZS1mcmFnbWVudFxyXG4gKi9cblxudmFyIGNhdGNoU2xhdGVGcmFnbWVudCA9IC9kYXRhLXNsYXRlLWZyYWdtZW50PVwiKC4rPylcIi9tO1xudmFyIGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlKGRhdGFUcmFuc2Zlcikge1xuICB2YXIgaHRtbERhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG5cbiAgdmFyIF9yZWYgPSBodG1sRGF0YS5tYXRjaChjYXRjaFNsYXRlRnJhZ21lbnQpIHx8IFtdLFxuICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgIGZyYWdtZW50ID0gX3JlZjJbMV07XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBpc1RyYWNrZWRNdXRhdGlvbiA9IGZ1bmN0aW9uIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIGJhdGNoKSB7XG4gIHZhciB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XG5cbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfUmVhY3RFZGl0b3IkZ2V0V2luZG8gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKSxcbiAgICAgIGRvY3VtZW50ID0gX1JlYWN0RWRpdG9yJGdldFdpbmRvLmRvY3VtZW50O1xuXG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGFyZW50TXV0YXRpb24gPSBiYXRjaC5maW5kKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBhZGRlZE5vZGVzID0gX3JlZjMuYWRkZWROb2RlcyxcbiAgICAgICAgcmVtb3ZlZE5vZGVzID0gX3JlZjMucmVtb3ZlZE5vZGVzO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoYWRkZWROb2RlcyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBub2RlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRhcmdldCB8fCBub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMocmVtb3ZlZE5vZGVzKSxcbiAgICAgICAgX3N0ZXAyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfbm9kZSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICBpZiAoX25vZGUgPT09IHRhcmdldCB8fCBfbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghcGFyZW50TXV0YXRpb24gfHwgcGFyZW50TXV0YXRpb24gPT09IG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRhcmdldCBhZGQvcmVtb3ZlIGlzIHRyYWNrZWQuIFRyYWNrIHRoZSBtdXRhdGlvbiBpZiB3ZSB0cmFjayB0aGUgcGFyZW50IG11dGF0aW9uLlxuXG5cbiAgcmV0dXJuIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgcGFyZW50TXV0YXRpb24sIGJhdGNoKTtcbn07XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSB1bndyYXBFeHBvcnRzKGNsYXNzQ2FsbENoZWNrKTtcblxuLyoqXHJcbiAqIEFuIGF1dG8taW5jcmVtZW50aW5nIGlkZW50aWZpZXIgZm9yIGtleXMuXHJcbiAqL1xudmFyIG4gPSAwO1xuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBhIGtleSBzdHJpbmcuIFdlIHVzZSBhIGZ1bGwgY2xhc3MgaGVyZSBiZWNhdXNlIHdlXHJcbiAqIHdhbnQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbSBhcyBrZXlzIGluIGBXZWFrTWFwYCBvYmplY3RzLlxyXG4gKi9cblxudmFyIEtleSA9IGZ1bmN0aW9uIEtleSgpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleSk7XG5cbiAgdGhpcy5pZCA9IFwiXCIuY29uY2F0KG4rKyk7XG59O1xuXG52YXIgUmVhY3RFZGl0b3IgPSB7XG4gIGFuZHJvaWRQZW5kaW5nRGlmZnM6IGZ1bmN0aW9uIGFuZHJvaWRQZW5kaW5nRGlmZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB9LFxuICBhbmRyb2lkU2NoZWR1bGVGbHVzaDogZnVuY3Rpb24gYW5kcm9pZFNjaGVkdWxlRmx1c2goZWRpdG9yKSB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRjtcblxuICAgIChfRURJVE9SX1RPX1NDSEVEVUxFX0YgPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG4gIH0sXG4gIGJsdXI6IGZ1bmN0aW9uIGJsdXIoZWRpdG9yKSB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgZmFsc2UpO1xuXG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgIGVsLmJsdXIoKTtcbiAgICB9XG4gIH0sXG4gIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgfVxuICB9LFxuICBmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Q6IGZ1bmN0aW9uIGZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcblxuICAgIGlmICgocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50IHx8IHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSAmJiByb290LmdldFNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudDtcbiAgfSxcbiAgZmluZEV2ZW50UmFuZ2U6IGZ1bmN0aW9uIGZpbmRFdmVudFJhbmdlKGVkaXRvciwgZXZlbnQpIHtcbiAgICBpZiAoJ25hdGl2ZUV2ZW50JyBpbiBldmVudCkge1xuICAgICAgZXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICB9XG5cbiAgICB2YXIgX2V2ZW50ID0gZXZlbnQsXG4gICAgICAgIHggPSBfZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeSA9IF9ldmVudC5jbGllbnRZLFxuICAgICAgICB0YXJnZXQgPSBfZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSBldmVudDogXCIuY29uY2F0KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpOyAvLyBJZiB0aGUgZHJvcCB0YXJnZXQgaXMgaW5zaWRlIGEgdm9pZCBub2RlLCBtb3ZlIGl0IGludG8gZWl0aGVyIHRoZVxuICAgIC8vIG5leHQgb3IgcHJldmlvdXMgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGUgdGhlIGB4YCBhbmQgYHlgXG4gICAgLy8gY29vcmRpbmF0ZXMgYXJlIGNsb3Nlc3QgdG8uXG5cbiAgICBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgc2xhdGUuRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBpc1ByZXYgPSBlZGl0b3IuaXNJbmxpbmUobm9kZSkgPyB4IC0gcmVjdC5sZWZ0IDwgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAtIHggOiB5IC0gcmVjdC50b3AgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC0geTtcbiAgICAgIHZhciBlZGdlID0gc2xhdGUuRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCwge1xuICAgICAgICBlZGdlOiBpc1ByZXYgPyAnc3RhcnQnIDogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50ID0gaXNQcmV2ID8gc2xhdGUuRWRpdG9yLmJlZm9yZShlZGl0b3IsIGVkZ2UpIDogc2xhdGUuRWRpdG9yLmFmdGVyKGVkaXRvciwgZWRnZSk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgX3JhbmdlID0gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQpO1xuXG4gICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICB9XG4gICAgfSAvLyBFbHNlIHJlc29sdmUgYSByYW5nZSBmcm9tIHRoZSBjYXJldCBwb3NpdGlvbiB3aGVyZSB0aGUgZHJvcCBvY2N1cmVkLlxuXG5cbiAgICB2YXIgZG9tUmFuZ2U7XG5cbiAgICB2YXIgX1JlYWN0RWRpdG9yJGdldFdpbmRvID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvciksXG4gICAgICAgIGRvY3VtZW50ID0gX1JlYWN0RWRpdG9yJGdldFdpbmRvLmRvY3VtZW50OyAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGBjYXJldFJhbmdlRnJvbVBvaW50YCBkb2Vzbid0IGV4aXN0LiAoMjAxNi8wNy8yNSlcblxuXG4gICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcblxuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkb21SYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9IC8vIFJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIHRoZSBET00gcmFuZ2UuXG5cblxuICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCB7XG4gICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzVGhyb3c6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9LFxuICBmaW5kS2V5OiBmdW5jdGlvbiBmaW5kS2V5KGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBrZXkgPSBOT0RFX1RPX0tFWS5nZXQobm9kZSk7XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAga2V5ID0gbmV3IEtleSgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleTtcbiAgfSxcbiAgZmluZFBhdGg6IGZ1bmN0aW9uIGZpbmRQYXRoKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGNoaWxkID0gbm9kZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gTk9ERV9UT19QQVJFTlQuZ2V0KGNoaWxkKTtcblxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChzbGF0ZS5FZGl0b3IuaXNFZGl0b3IoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBOT0RFX1RPX0lOREVYLmdldChjaGlsZCk7XG5cbiAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBwYXRoIGZvciBTbGF0ZSBub2RlOiBcIi5jb25jYXQoc2xhdGUuU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gIH0sXG4gIGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgIT09IGVsKSB7XG4gICAgICBlbC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3coZWRpdG9yKSB7XG4gICAgdmFyIHdpbmRvdyA9IEVESVRPUl9UT19XSU5ET1cuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIGhvc3Qgd2luZG93IGVsZW1lbnQgZm9yIHRoaXMgZWRpdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSxcbiAgaGFzRE9NTm9kZTogZnVuY3Rpb24gaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZWRpdGFibGUgPSBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICBlZGl0YWJsZSA9IF9vcHRpb25zJGVkaXRhYmxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGVkaXRhYmxlO1xuICAgIHZhciBlZGl0b3JFbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHRhcmdldEVsOyAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIHJlYWRpbmcgYHRhcmdldC5ub2RlVHlwZWAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZlxuICAgIC8vIHRhcmdldCBpcyBvcmlnaW5hdGluZyBmcm9tIGFuIGludGVybmFsIFwicmVzdHJpY3RlZFwiIGVsZW1lbnQgKGUuZy4gYVxuICAgIC8vIHN0ZXBwZXIgYXJyb3cgb24gYSBudW1iZXIgaW5wdXQpLiAoMjAxOC8wNS8wNClcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvaXNzdWVzLzE4MTlcblxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRFbCA9IGlzRE9NRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJub2RlVHlwZVwiJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0RWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLWVkaXRvcl1cIikgPT09IGVkaXRvckVsICYmICghZWRpdGFibGUgfHwgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPyB0cnVlIDogdHlwZW9mIHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID09PSAnYm9vbGVhbicgJiYgLy8gaXNDb250ZW50RWRpdGFibGUgZXhpc3RzIG9ubHkgb24gSFRNTEVsZW1lbnQsIGFuZCBvbiBvdGhlciBub2RlcyBpdCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIC8vIHRoaXMgaXMgdGhlIGNvcmUgbG9naWMgdGhhdCBsZXRzIHlvdSBrbm93IHlvdSBnb3QgdGhlIHJpZ2h0IGVkaXRvci5zZWxlY3Rpb24gaW5zdGVhZCBvZiBudWxsIHdoZW4gZWRpdG9yIGlzIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIocmVhZE9ubHkpXG4gICAgdGFyZ2V0RWwuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJykgPT09IGVkaXRvckVsIHx8ICEhdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSk7XG4gIH0sXG4gIGhhc0VkaXRhYmxlVGFyZ2V0OiBmdW5jdGlvbiBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9LFxuICBoYXNSYW5nZTogZnVuY3Rpb24gaGFzUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgcmV0dXJuIHNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgYW5jaG9yLnBhdGgpICYmIHNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgZm9jdXMucGF0aCk7XG4gIH0sXG4gIGhhc1NlbGVjdGFibGVUYXJnZXQ6IGZ1bmN0aW9uIGhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgdGFyZ2V0KTtcbiAgfSxcbiAgaGFzVGFyZ2V0OiBmdW5jdGlvbiBoYXNUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNET01Ob2RlKHRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gIH0sXG4gIGluc2VydERhdGE6IGZ1bmN0aW9uIGluc2VydERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgZWRpdG9yLmluc2VydERhdGEoZGF0YSk7XG4gIH0sXG4gIGluc2VydEZyYWdtZW50RGF0YTogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpO1xuICB9LFxuICBpbnNlcnRUZXh0RGF0YTogZnVuY3Rpb24gaW5zZXJ0VGV4dERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgfSxcbiAgaXNDb21wb3Npbmc6IGZ1bmN0aW9uIGlzQ29tcG9zaW5nKGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX0NPTVBPU0lORy5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgaXNGb2N1c2VkOiBmdW5jdGlvbiBpc0ZvY3VzZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfRk9DVVNFRC5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgaXNSZWFkT25seTogZnVuY3Rpb24gaXNSZWFkT25seShlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19SRUFEX09OTFkuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIGlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkOiBmdW5jdGlvbiBpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCkge1xuICAgIGlmIChJU19SRUFEX09OTFkuZ2V0KGVkaXRvcikpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gICAgcmV0dXJuIHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KHNsYXRlTm9kZSkgJiYgc2xhdGUuRWRpdG9yLmlzVm9pZChlZGl0b3IsIHNsYXRlTm9kZSk7XG4gIH0sXG4gIHNldEZyYWdtZW50RGF0YTogZnVuY3Rpb24gc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZGF0YSwgb3JpZ2luRXZlbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLnNldEZyYWdtZW50RGF0YShkYXRhLCBvcmlnaW5FdmVudCk7XG4gIH0sXG4gIHRvRE9NTm9kZTogZnVuY3Rpb24gdG9ET01Ob2RlKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICB2YXIgZG9tTm9kZSA9IHNsYXRlLkVkaXRvci5pc0VkaXRvcihub2RlKSA/IEVESVRPUl9UT19FTEVNRU5ULmdldChlZGl0b3IpIDogS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmdldChSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuXG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBub2RlIGZyb20gU2xhdGUgbm9kZTogXCIuY29uY2F0KHNsYXRlLlNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb21Ob2RlO1xuICB9LFxuICB0b0RPTVBvaW50OiBmdW5jdGlvbiB0b0RPTVBvaW50KGVkaXRvciwgcG9pbnQpIHtcbiAgICB2YXIgX0VkaXRvciRub2RlID0gc2xhdGUuRWRpdG9yLm5vZGUoZWRpdG9yLCBwb2ludC5wYXRoKSxcbiAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdO1xuXG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgdmFyIGRvbVBvaW50OyAvLyBJZiB3ZSdyZSBpbnNpZGUgYSB2b2lkIG5vZGUsIGZvcmNlIHRoZSBvZmZzZXQgdG8gMCwgb3RoZXJ3aXNlIHRoZSB6ZXJvXG4gICAgLy8gd2lkdGggc3BhY2luZyBjaGFyYWN0ZXIgd2lsbCByZXN1bHQgaW4gYW4gaW5jb3JyZWN0IG9mZnNldCBvZiAxXG5cbiAgICBpZiAoc2xhdGUuRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiBwb2ludFxuICAgIH0pKSB7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH0gLy8gRm9yIGVhY2ggbGVhZiwgd2UgbmVlZCB0byBpc29sYXRlIGl0cyBjb250ZW50LCB3aGljaCBtZWFucyBmaWx0ZXJpbmdcbiAgICAvLyB0byBpdHMgZGlyZWN0IHRleHQgYW5kIHplcm8td2lkdGggc3BhbnMuIChXZSBoYXZlIHRvIGZpbHRlciBvdXQgYW55XG4gICAgLy8gb3RoZXIgc2libGluZ3MgdGhhdCBtYXkgaGF2ZSBiZWVuIHJlbmRlcmVkIGFsb25nc2lkZSB0aGVtLilcblxuXG4gICAgdmFyIHNlbGVjdG9yID0gXCJbZGF0YS1zbGF0ZS1zdHJpbmddLCBbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiO1xuICAgIHZhciB0ZXh0cyA9IEFycmF5LmZyb20oZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dCA9IHRleHRzW2ldO1xuICAgICAgdmFyIGRvbU5vZGUgPSB0ZXh0LmNoaWxkTm9kZXNbMF07XG5cbiAgICAgIGlmIChkb21Ob2RlID09IG51bGwgfHwgZG9tTm9kZS50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICB2YXIgYXR0ciA9IHRleHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWxlbmd0aCcpO1xuICAgICAgdmFyIHRydWVMZW5ndGggPSBhdHRyID09IG51bGwgPyBsZW5ndGggOiBwYXJzZUludChhdHRyLCAxMCk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyB0cnVlTGVuZ3RoOyAvLyBQcmVmZXIgcHV0dGluZyB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlciB0byBlbnN1cmVcbiAgICAgIC8vIGNvbXBvc2VkIHRleHQgaXMgZGlzcGxheWVkIHdpdGggdGhlIGNvcnJlY3QgbWFya3MuXG5cbiAgICAgIHZhciBuZXh0VGV4dCA9IHRleHRzW2kgKyAxXTtcblxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA9PT0gZW5kICYmIG5leHRUZXh0ICE9PSBudWxsICYmIG5leHRUZXh0ICE9PSB2b2lkIDAgJiYgbmV4dFRleHQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICB2YXIgX25leHRUZXh0JHRleHRDb250ZW50O1xuXG4gICAgICAgIHZhciBkb21UZXh0ID0gbmV4dFRleHQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgZG9tUG9pbnQgPSBbLy8gQ09NUEFUOiBJZiB3ZSBkb24ndCBleHBsaWNpdHkgc2V0IHRoZSBkb20gcG9pbnQgdG8gYmUgb24gdGhlIGFjdHVhbFxuICAgICAgICAvLyBkb20gdGV4dCBlbGVtZW50LCBjaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiBiZWhpbmQgdGhlIGFjdHVhbCBkb21cbiAgICAgICAgLy8gdGV4dCBlbGVtZW50LCBjYXVzaW5nIGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGxzIG9uIGEgY29sbGFwc2VkXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byByZXR1cm4gaW5jb3JyZWN0IHplcm8gdmFsdWVzIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzgpXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzIHdoZW4gc2Nyb2xsaW5nIHRvIGl0LlxuICAgICAgICBkb21UZXh0IGluc3RhbmNlb2YgRE9NVGV4dCA/IGRvbVRleHQgOiBuZXh0VGV4dCwgKF9uZXh0VGV4dCR0ZXh0Q29udGVudCA9IG5leHRUZXh0LnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQuc3RhcnRzV2l0aChcIlxcdUZFRkZcIikgPyAxIDogMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnQub2Zmc2V0IDw9IGVuZCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBNYXRoLm1heCgwLCBwb2ludC5vZmZzZXQgLSBzdGFydCkpO1xuICAgICAgICBkb21Qb2ludCA9IFtkb21Ob2RlLCBvZmZzZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuXG4gICAgaWYgKCFkb21Qb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gcG9pbnQgZnJvbSBTbGF0ZSBwb2ludDogXCIuY29uY2F0KHNsYXRlLlNjcnViYmVyLnN0cmluZ2lmeShwb2ludCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tUG9pbnQ7XG4gIH0sXG4gIHRvRE9NUmFuZ2U6IGZ1bmN0aW9uIHRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBzbGF0ZS5SYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgICB2YXIgZG9tQW5jaG9yID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgdmFyIGRvbUZvY3VzID0gc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpID8gZG9tQW5jaG9yIDogUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGZvY3VzKTtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgdmFyIGRvbVJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICB2YXIgX3JlZiA9IGlzQmFja3dhcmQgPyBkb21Gb2N1cyA6IGRvbUFuY2hvcixcbiAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgc3RhcnROb2RlID0gX3JlZjJbMF0sXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gX3JlZjJbMV07XG5cbiAgICB2YXIgX3JlZjMgPSBpc0JhY2t3YXJkID8gZG9tQW5jaG9yIDogZG9tRm9jdXMsXG4gICAgICAgIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICBlbmROb2RlID0gX3JlZjRbMF0sXG4gICAgICAgIGVuZE9mZnNldCA9IF9yZWY0WzFdOyAvLyBBIHNsYXRlIFBvaW50IGF0IHplcm8td2lkdGggTGVhZiBhbHdheXMgaGFzIGFuIG9mZnNldCBvZiAwIGJ1dCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIGF0XG4gICAgLy8gemVyby13aWR0aCBub2RlIGhhcyBhbiBvZmZzZXQgb2YgMSBzbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIHdlIGFyZSBpbiBhIHplcm8td2lkdGggbm9kZSBhbmRcbiAgICAvLyBhZGp1c3QgdGhlIG9mZnNldCBhY2NvcmRpbmdseS5cblxuXG4gICAgdmFyIHN0YXJ0RWwgPSBpc0RPTUVsZW1lbnQoc3RhcnROb2RlKSA/IHN0YXJ0Tm9kZSA6IHN0YXJ0Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc1N0YXJ0QXRaZXJvV2lkdGggPSAhIXN0YXJ0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICB2YXIgZW5kRWwgPSBpc0RPTUVsZW1lbnQoZW5kTm9kZSkgPyBlbmROb2RlIDogZW5kTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc0VuZEF0WmVyb1dpZHRoID0gISFlbmRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIGRvbVJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgaXNTdGFydEF0WmVyb1dpZHRoID8gMSA6IHN0YXJ0T2Zmc2V0KTtcbiAgICBkb21SYW5nZS5zZXRFbmQoZW5kTm9kZSwgaXNFbmRBdFplcm9XaWR0aCA/IDEgOiBlbmRPZmZzZXQpO1xuICAgIHJldHVybiBkb21SYW5nZTtcbiAgfSxcbiAgdG9TbGF0ZU5vZGU6IGZ1bmN0aW9uIHRvU2xhdGVOb2RlKGVkaXRvciwgZG9tTm9kZSkge1xuICAgIHZhciBkb21FbCA9IGlzRE9NRWxlbWVudChkb21Ob2RlKSA/IGRvbU5vZGUgOiBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgICBpZiAoZG9tRWwgJiYgIWRvbUVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykpIHtcbiAgICAgIGRvbUVsID0gZG9tRWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLW5vZGVdXCIpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gZG9tRWwgPyBFTEVNRU5UX1RPX05PREUuZ2V0KGRvbUVsKSA6IG51bGw7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgbm9kZSBmcm9tIERPTSBub2RlOiBcIi5jb25jYXQoZG9tRWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgdG9TbGF0ZVBvaW50OiBmdW5jdGlvbiB0b1NsYXRlUG9pbnQoZWRpdG9yLCBkb21Qb2ludCwgb3B0aW9ucykge1xuICAgIHZhciBleGFjdE1hdGNoID0gb3B0aW9ucy5leGFjdE1hdGNoLFxuICAgICAgICBzdXBwcmVzc1Rocm93ID0gb3B0aW9ucy5zdXBwcmVzc1Rocm93O1xuXG4gICAgdmFyIF9yZWY1ID0gZXhhY3RNYXRjaCA/IGRvbVBvaW50IDogbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpLFxuICAgICAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgICAgbmVhcmVzdE5vZGUgPSBfcmVmNlswXSxcbiAgICAgICAgbmVhcmVzdE9mZnNldCA9IF9yZWY2WzFdO1xuXG4gICAgdmFyIHBhcmVudE5vZGUgPSBuZWFyZXN0Tm9kZS5wYXJlbnROb2RlO1xuICAgIHZhciB0ZXh0Tm9kZSA9IG51bGw7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgdmFyIF9kb21Ob2RlJHRleHRDb250ZW50LCBfZG9tTm9kZSR0ZXh0Q29udGVudDI7XG5cbiAgICAgIHZhciBlZGl0b3JFbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgcG90ZW50aWFsVm9pZE5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLXZvaWQ9XCJ0cnVlXCJdJyk7IC8vIE5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNsb3Nlc3Qgdm9pZCBub2RlIGlzIGFjdHVhbGx5IGEgdm9pZCBub2RlXG4gICAgICAvLyB3aXRoaW4gdGhpcyBlZGl0b3IsIGFuZCBub3QgYSB2b2lkIG5vZGUgd2l0aGluIHNvbWUgcGFyZW50IGVkaXRvci4gVGhpcyBjYW4gaGFwcGVuXG4gICAgICAvLyBpZiB0aGlzIGVkaXRvciBpcyB3aXRoaW4gYSB2b2lkIG5vZGUgb2YgYW5vdGhlciBlZGl0b3IgKFwibmVzdGVkIGVkaXRvcnNcIiwgbGlrZSBpblxuICAgICAgLy8gdGhlIFwiRWRpdGFibGUgVm9pZHNcIiBleGFtcGxlIG9uIHRoZSBkb2NzIHNpdGUpLlxuXG4gICAgICB2YXIgdm9pZE5vZGUgPSBwb3RlbnRpYWxWb2lkTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxWb2lkTm9kZSkgPyBwb3RlbnRpYWxWb2lkTm9kZSA6IG51bGw7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7IC8vIENhbGN1bGF0ZSBob3cgZmFyIGludG8gdGhlIHRleHQgbm9kZSB0aGUgYG5lYXJlc3ROb2RlYCBpcywgc28gdGhhdCB3ZVxuICAgICAgLy8gY2FuIGRldGVybWluZSB3aGF0IHRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHRleHQgbm9kZSBpcy5cblxuICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcblxuICAgICAgICBpZiAodGV4dE5vZGUpIHtcbiAgICAgICAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgICAgICAgdmFyIHJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldCk7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgIHZhciByZW1vdmFscyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSkpLCBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRlZGl0YWJsZT1mYWxzZV0nKSkpKTtcbiAgICAgICAgICByZW1vdmFscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBjb21wb3NpbmcgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlLCBzb21lIGtleWJvYXJkcyBwdXRcbiAgICAgICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnQgaW5zaWRlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlLlxuICAgICAgICAgICAgaWYgKElTX0FORFJPSUQgJiYgIWV4YWN0TWF0Y2ggJiYgZWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSAmJiBlbC50ZXh0Q29udGVudC5sZW5ndGggPiAwICYmIGVsLnRleHRDb250ZXh0ICE9PSBcIlxcdUZFRkZcIikge1xuICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQuc3RhcnRzV2l0aChcIlxcdUZFRkZcIikpIHtcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9KTsgLy8gQ09NUEFUOiBFZGdlIGhhcyBhIGJ1ZyB3aGVyZSBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcoKSB3aWxsXG4gICAgICAgICAgLy8gY29udmVydCBcXG4gaW50byBcXHJcXG4uIFRoZSBidWcgY2F1c2VzIGEgbG9vcCB3aGVuIHNsYXRlLXJlYWN0XG4gICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVwb3NpdGlvbiBpdHMgY3Vyc29yIHRvIG1hdGNoIHRoZSBuYXRpdmUgcG9zaXRpb24uIFVzZVxuICAgICAgICAgIC8vIHRleHRDb250ZW50Lmxlbmd0aCBpbnN0ZWFkLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMjkxMTE2L1xuXG4gICAgICAgICAgb2Zmc2V0ID0gY29udGVudHMudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2b2lkTm9kZSkge1xuICAgICAgICAvLyBGb3Igdm9pZCBub2RlcywgdGhlIGVsZW1lbnQgd2l0aCB0aGUgb2Zmc2V0IGtleSB3aWxsIGJlIGEgY291c2luLCBub3QgYW5cbiAgICAgICAgLy8gYW5jZXN0b3IsIHNvIGZpbmQgaXQgYnkgZ29pbmcgZG93biBmcm9tIHRoZSBuZWFyZXN0IHZvaWQgcGFyZW50IGFuZCB0YWtpbmcgdGhlXG4gICAgICAgIC8vIGZpcnN0IG9uZSB0aGF0IGlzbid0IGluc2lkZSBhIG5lc3RlZCBlZGl0b3IuXG4gICAgICAgIHZhciBsZWFmTm9kZXMgPSB2b2lkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZWFmTm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBsZWFmTm9kZXNbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgbGVhZk5vZGUgPSBjdXJyZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENPTVBBVDogSW4gcmVhZC1vbmx5IGVkaXRvcnMgdGhlIGxlYWYgaXMgbm90IHJlbmRlcmVkLlxuXG5cbiAgICAgICAgaWYgKCFsZWFmTm9kZSkge1xuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICAgIGRvbU5vZGUgPSBsZWFmTm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRvbU5vZGUgJiYgb2Zmc2V0ID09PSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aCAmJiAvLyBDT01QQVQ6IEFuZHJvaWQgSU1FcyBtaWdodCByZW1vdmUgdGhlIHplcm8gd2lkdGggc3BhY2Ugd2hpbGUgY29tcG9zaW5nLFxuICAgICAgLy8gYW5kIHdlIGRvbid0IGFkZCBpdCBmb3IgbGluZS1icmVha3MuXG4gICAgICBJU19BTkRST0lEICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ3onICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQuc3RhcnRzV2l0aChcIlxcdUZFRkZcIikgJiYgKHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSB8fCBJU19GSVJFRk9YICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudDIgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIuZW5kc1dpdGgoJ1xcblxcbicpKSkge1xuICAgICAgICBvZmZzZXQtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSVNfQU5EUk9JRCAmJiAhdGV4dE5vZGUgJiYgIWV4YWN0TWF0Y2gpIHtcbiAgICAgIHZhciBub2RlID0gcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpID8gcGFyZW50Tm9kZSA6IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZV0nKTtcblxuICAgICAgaWYgKG5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBfc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBub2RlKTtcblxuICAgICAgICB2YXIgX0VkaXRvciRzdGFydCA9IHNsYXRlLkVkaXRvci5zdGFydChlZGl0b3IsIFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX3NsYXRlTm9kZSkpLFxuICAgICAgICAgICAgX3BhdGggPSBfRWRpdG9yJHN0YXJ0LnBhdGgsXG4gICAgICAgICAgICBfb2Zmc2V0ID0gX0VkaXRvciRzdGFydC5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLWxlYWZdJykpIHtcbiAgICAgICAgICBfb2Zmc2V0ID0gbmVhcmVzdE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHN1cHByZXNzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcG9pbnQgZnJvbSBET00gcG9pbnQ6IFwiLmNvbmNhdChkb21Qb2ludCkpO1xuICAgIH0gLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcblxuXG4gICAgdmFyIHNsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICB9O1xuICB9LFxuICB0b1NsYXRlUmFuZ2U6IGZ1bmN0aW9uIHRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIGV4YWN0TWF0Y2ggPSBvcHRpb25zLmV4YWN0TWF0Y2gsXG4gICAgICAgIHN1cHByZXNzVGhyb3cgPSBvcHRpb25zLnN1cHByZXNzVGhyb3c7XG4gICAgdmFyIGVsID0gaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpID8gZG9tUmFuZ2UuYW5jaG9yTm9kZSA6IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBhbmNob3JOb2RlO1xuICAgIHZhciBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzTm9kZTtcbiAgICB2YXIgZm9jdXNPZmZzZXQ7XG4gICAgdmFyIGlzQ29sbGFwc2VkO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAoaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpKSB7XG4gICAgICAgIC8vIENPTVBBVDogSW4gZmlyZWZveCB0aGUgbm9ybWFsIHNlbGV0aW9uIHdheSBkb2VzIG5vdCB3b3JrXG4gICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81NDg2I2lzc3VlLTE4MjA3MjAyMjMpXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGRvbVJhbmdlLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZm9jdXNOb2RlOyAvLyBGb2N1cyBub2RlIHdvcmtzIGZpbmVcblxuICAgICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdChkb21SYW5nZS5yYW5nZUNvdW50IC0gMSk7IC8vIEhlcmUgd2UgYXJlIGluIHRoZSBjb250ZW50ZWRpdGFibGUgbW9kZSBvZiBhIHRhYmxlIGluIGZpcmVmb3hcblxuICAgICAgICAgIGlmIChmb2N1c05vZGUgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGxhc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEhUTUxFbGVtZW50LCBiZWNvdXNlIEVsZW1lbnQgaXMgYSBzbGF0ZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZ2V0TGFzdENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExhc3RDaGlsZHJlbihlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZVJvdyA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGVSb3cgPSBsYXN0UmFuZ2Uuc3RhcnRDb250YWluZXI7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGZhaWwgYXMgXCJUaGUgSFRNTEVsZW1lbnQgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW55IEhUTUwgZWxlbWVudC5cIlxuXG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGZpcnN0Tm9kZVJvdy5jaGlsZHJlbltmaXJzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSBnZXRMYXN0Q2hpbGRyZW4obGFzdE5vZGVSb3cuY2hpbGRyZW5bbGFzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7IC8vIFplcm8sIGFzIHdlIGFsbHdheXMgdGFrZSB0aGUgcmlnaHQgb25lIGFzIHRoZSBhbmNob3IgcG9pbnRcblxuICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBpZiAobGFzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3ROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE5vZGUuaW5uZXJIVE1MLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9wdGlvblxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByZWFkIG9ubHkgbW9kZSBvZiBhIGZpcmVmb3ggdGFibGVcbiAgICAgICAgICAgIC8vIFJpZ2h0IHRvIGxlZnRcbiAgICAgICAgICAgIGlmIChmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3RSYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3RSYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZmlyc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGZpcnN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLmFuY2hvck5vZGU7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IC8vIENPTVBBVDogVGhlcmUncyBhIGJ1ZyBpbiBjaHJvbWUgdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICAgIC8vIGBpc0NvbGxhcHNlZGAgZm9yIGEgU2VsZWN0aW9uIHRoYXQgY29tZXMgZnJvbSBhIFNoYWRvd1Jvb3QuXG4gICAgICAgIC8vICgyMDIwLzA4LzA4KVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbiAgICAgICAgLy8gSXNDb2xsYXBzZWQgbWlnaHQgbm90IHdvcmsgaW4gZmlyZWZveCwgYnV0IHRoaXMgd2lsbFxuXG5cbiAgICAgICAgaWYgKElTX0NIUk9NRSAmJiBoYXNTaGFkb3dSb290KGFuY2hvck5vZGUpIHx8IElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmFuY2hvck5vZGUgPT09IGRvbVJhbmdlLmZvY3VzTm9kZSAmJiBkb21SYW5nZS5hbmNob3JPZmZzZXQgPT09IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuaXNDb2xsYXBzZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuY29sbGFwc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZm9jdXNOb2RlID09IG51bGwgfHwgYW5jaG9yT2Zmc2V0ID09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIERPTSByYW5nZTogXCIuY29uY2F0KGRvbVJhbmdlKSk7XG4gICAgfSAvLyBDT01QQVQ6IFRyaXBsZS1jbGlja2luZyBhIHdvcmQgaW4gY2hyb21lIHdpbGwgc29tZXRpbWVzIHBsYWNlIHRoZSBmb2N1c1xuICAgIC8vIGluc2lkZSBhIGBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiYCBET00gbm9kZSBmb2xsb3dpbmcgdGhlIHdvcmQsIHdoaWNoXG4gICAgLy8gd2lsbCBjYXVzZSBgdG9TbGF0ZVBvaW50YCB0byB0aHJvdyBhbiBlcnJvci4gKDIwMjMvMDMvMDcpXG5cblxuICAgIGlmICgnZ2V0QXR0cmlidXRlJyBpbiBmb2N1c05vZGUgJiYgZm9jdXNOb2RlLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScgJiYgZm9jdXNOb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS12b2lkJykgIT09ICd0cnVlJykge1xuICAgICAgdmFyIF9hbmNob3JOb2RlJHRleHRDb250ZTtcblxuICAgICAgZm9jdXNOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gKChfYW5jaG9yTm9kZSR0ZXh0Q29udGUgPSBhbmNob3JOb2RlLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYW5jaG9yTm9kZSR0ZXh0Q29udGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbmNob3JOb2RlJHRleHRDb250ZS5sZW5ndGgpIHx8IDA7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoOiBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdzogc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuXG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmb2N1cyA9IGlzQ29sbGFwc2VkID8gYW5jaG9yIDogUmVhY3RFZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoOiBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdzogc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuXG4gICAgaWYgKCFmb2N1cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9OyAvLyBpZiB0aGUgc2VsZWN0aW9uIGlzIGEgaGFuZ2luZyByYW5nZSB0aGF0IGVuZHMgaW4gYSB2b2lkXG4gICAgLy8gYW5kIHRoZSBET00gZm9jdXMgaXMgYW4gRWxlbWVudFxuICAgIC8vIChtZWFuaW5nIHRoYXQgdGhlIHNlbGVjdGlvbiBlbmRzIGJlZm9yZSB0aGUgZWxlbWVudClcbiAgICAvLyB1bmhhbmcgdGhlIHJhbmdlIHRvIGF2b2lkIG1pc3Rha2VubHkgaW5jbHVkaW5nIHRoZSB2b2lkXG5cbiAgICBpZiAoc2xhdGUuUmFuZ2UuaXNFeHBhbmRlZChyYW5nZSkgJiYgc2xhdGUuUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSAmJiBpc0RPTUVsZW1lbnQoZm9jdXNOb2RlKSAmJiBzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLmZvY3VzLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpIHtcbiAgICAgIHJhbmdlID0gc2xhdGUuRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIHtcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgYSB0ZXh0IGRpZmYgd2FzIGFwcGxpZWQgaW4gYSB3YXkgd2UgY2FuIHBlcmZvcm0gdGhlIHBlbmRpbmcgYWN0aW9uIG9uIC9cclxuICogcmVjb3ZlciB0aGUgcGVuZGluZyBzZWxlY3Rpb24uXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCB0ZXh0RGlmZikge1xuICB2YXIgcGF0aCA9IHRleHREaWZmLnBhdGgsXG4gICAgICBkaWZmID0gdGV4dERpZmYuZGlmZjtcblxuICBpZiAoIXNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbm9kZSA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgaWYgKCFzbGF0ZS5UZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChkaWZmLnN0YXJ0ICE9PSBub2RlLnRleHQubGVuZ3RoIHx8IGRpZmYudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9kZS50ZXh0LnNsaWNlKGRpZmYuc3RhcnQsIGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSA9PT0gZGlmZi50ZXh0O1xuICB9XG5cbiAgdmFyIG5leHRQYXRoID0gc2xhdGUuUGF0aC5uZXh0KHBhdGgpO1xuXG4gIGlmICghc2xhdGUuRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBuZXh0UGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbmV4dE5vZGUgPSBzbGF0ZS5Ob2RlLmdldChlZGl0b3IsIG5leHRQYXRoKTtcbiAgcmV0dXJuIHNsYXRlLlRleHQuaXNUZXh0KG5leHROb2RlKSAmJiBuZXh0Tm9kZS50ZXh0LnN0YXJ0c1dpdGgoZGlmZi50ZXh0KTtcbn1cbmZ1bmN0aW9uIGFwcGx5U3RyaW5nRGlmZih0ZXh0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkaWZmcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZGlmZnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZGlmZikge1xuICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIGRpZmYuc3RhcnQpICsgZGlmZi50ZXh0ICsgdGV4dC5zbGljZShkaWZmLmVuZCk7XG4gIH0sIHRleHQpO1xufVxuXG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHN0ciwgYW5vdGhlcikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChpKSAhPT0gYW5vdGhlci5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgoc3RyLCBhbm90aGVyLCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoLCBtYXgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gaSAtIDEpICE9PSBhbm90aGVyLmNoYXJBdChhbm90aGVyLmxlbmd0aCAtIGkgLSAxKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxyXG4gKiBSZW1vdmUgcmVkdW5kYW50IGNoYW5nZXMgZnJvbSB0aGUgZGlmZiBzbyB0aGF0IGl0IHNwYW5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHJhbmdlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgZGlmZikge1xuICB2YXIgc3RhcnQgPSBkaWZmLnN0YXJ0LFxuICAgICAgZW5kID0gZGlmZi5lbmQsXG4gICAgICB0ZXh0ID0gZGlmZi50ZXh0O1xuICB2YXIgcmVtb3ZlZFRleHQgPSB0YXJnZXRUZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcHJlZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCk7XG4gIHZhciBtYXggPSBNYXRoLm1pbihyZW1vdmVkVGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoKTtcbiAgdmFyIHN1ZmZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQsIG1heCk7XG4gIHZhciBub3JtYWxpemVkID0ge1xuICAgIHN0YXJ0OiBzdGFydCArIHByZWZpeExlbmd0aCxcbiAgICBlbmQ6IGVuZCAtIHN1ZmZpeExlbmd0aCxcbiAgICB0ZXh0OiB0ZXh0LnNsaWNlKHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBzdWZmaXhMZW5ndGgpXG4gIH07XG5cbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnQgPT09IG5vcm1hbGl6ZWQuZW5kICYmIG5vcm1hbGl6ZWQudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXHJcbiAqIFJldHVybiBhIHN0cmluZyBkaWZmIHRoYXQgaXMgZXF1aXZhbGVudCB0byBhcHBseWluZyBiIGFmdGVyIGEgc3Bhbm5pbmcgdGhlIHJhbmdlIG9mXHJcbiAqIGJvdGggY2hhbmdlc1xyXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VTdHJpbmdEaWZmcyh0YXJnZXRUZXh0LCBhLCBiKSB7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKGEuc3RhcnQsIGIuc3RhcnQpO1xuICB2YXIgb3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoLCBiLmVuZCkgLSBiLnN0YXJ0KTtcbiAgdmFyIGFwcGxpZWQgPSBhcHBseVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgYSwgYik7XG4gIHZhciBzbGljZUVuZCA9IE1hdGgubWF4KGIuc3RhcnQgKyBiLnRleHQubGVuZ3RoLCBhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCArIChhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCA+IGIuc3RhcnQgPyBiLnRleHQubGVuZ3RoIDogMCkgLSBvdmVybGFwKTtcbiAgdmFyIHRleHQgPSBhcHBsaWVkLnNsaWNlKHN0YXJ0LCBzbGljZUVuZCk7XG4gIHZhciBlbmQgPSBNYXRoLm1heChhLmVuZCwgYi5lbmQgLSBhLnRleHQubGVuZ3RoICsgKGEuZW5kIC0gYS5zdGFydCkpO1xuICByZXR1cm4gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICAgIHRleHQ6IHRleHRcbiAgfSk7XG59XG4vKipcclxuICogR2V0IHRoZSBzbGF0ZSByYW5nZSB0aGUgdGV4dCBkaWZmIHNwYW5zLlxyXG4gKi9cblxuZnVuY3Rpb24gdGFyZ2V0UmFuZ2UodGV4dERpZmYpIHtcbiAgdmFyIHBhdGggPSB0ZXh0RGlmZi5wYXRoLFxuICAgICAgZGlmZiA9IHRleHREaWZmLmRpZmY7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5lbmRcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgcG9pbnQnIGEuay5hIGEgcG9pbnQgYmFzZWQgb24gdGhlIGRvbSBzdGF0ZSBiZWZvcmUgYXBwbHlpbmdcclxuICogdGhlIHBlbmRpbmcgZGlmZnMuIFNpbmNlIHRoZSBwZW5kaW5nIGRpZmZzIG1pZ2h0IGhhdmUgYmVlbiBpbnNlcnRlZCB3aXRoIGRpZmZlcmVudFxyXG4gKiBtYXJrcyB3ZSBoYXZlIHRvICd3YWxrJyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGVuc3VyZSB3ZSBzdGlsbFxyXG4gKiBoYXZlIGEgdmFsaWQgcG9pbnQgaW5zaWRlIHRoZSBkb2N1bWVudFxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICB2YXIgcGF0aCA9IHBvaW50LnBhdGgsXG4gICAgICBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG5cbiAgaWYgKCFzbGF0ZS5FZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGVhZiA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgaWYgKCFzbGF0ZS5UZXh0LmlzVGV4dChsZWFmKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhcmVudEJsb2NrID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICByZXR1cm4gc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobikgJiYgc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9LFxuICAgIGF0OiBwYXRoXG4gIH0pO1xuXG4gIGlmICghcGFyZW50QmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHdoaWxlIChvZmZzZXQgPiBsZWFmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gc2xhdGUuRWRpdG9yLm5leHQoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBzbGF0ZS5UZXh0LmlzVGV4dFxuICAgIH0pO1xuXG4gICAgaWYgKCFlbnRyeSB8fCAhc2xhdGUuUGF0aC5pc0Rlc2NlbmRhbnQoZW50cnlbMV0sIHBhcmVudEJsb2NrWzFdKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgb2Zmc2V0IC09IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgbGVhZiA9IGVudHJ5WzBdO1xuICAgIHBhdGggPSBlbnRyeVsxXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHNlbGVjdGlvbicgdG8gZW5zdXJlIGl0J3MgdmFsaWQgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQgc3RhdGUuXHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBhbmNob3IgPSBub3JtYWxpemVQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvcik7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb2N1cyA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMpO1xuXG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBhbmNob3IsXG4gICAgZm9jdXM6IGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCBwb2ludCwgb3ApIHtcbiAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB2YXIgdGV4dERpZmYgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBwYXRoID0gX3JlZi5wYXRoO1xuICAgIHJldHVybiBzbGF0ZS5QYXRoLmVxdWFscyhwYXRoLCBwb2ludC5wYXRoKTtcbiAgfSk7XG5cbiAgaWYgKCF0ZXh0RGlmZiB8fCBwb2ludC5vZmZzZXQgPD0gdGV4dERpZmYuZGlmZi5zdGFydCkge1xuICAgIHJldHVybiBzbGF0ZS5Qb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGRpZmYgPSB0ZXh0RGlmZi5kaWZmOyAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGluc2lkZSB0aGUgZGlmZiA9PiB0cmFuc2Zvcm0gdGhlIHBvaW50IGJhc2VkIG9uIHRoZSBsb2NhdGlvblxuICAvLyB0aGUgZGlmZiB3aWxsIGJlIGFwcGxpZWQgdG8gYW5kIGFkZCB0aGUgb2Zmc2V0IGluc2lkZSB0aGUgZGlmZi5cblxuICBpZiAocG9pbnQub2Zmc2V0IDw9IGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIF9hbmNob3IgPSB7XG4gICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfTtcblxuICAgIHZhciBfdHJhbnNmb3JtZWQgPSBzbGF0ZS5Qb2ludC50cmFuc2Zvcm0oX2FuY2hvciwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG5cbiAgICBpZiAoIV90cmFuc2Zvcm1lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IF90cmFuc2Zvcm1lZC5wYXRoLFxuICAgICAgb2Zmc2V0OiBfdHJhbnNmb3JtZWQub2Zmc2V0ICsgcG9pbnQub2Zmc2V0IC0gZGlmZi5zdGFydFxuICAgIH07XG4gIH0gLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBhZnRlciB0aGUgZGlmZlxuXG5cbiAgdmFyIGFuY2hvciA9IHtcbiAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgIG9mZnNldDogcG9pbnQub2Zmc2V0IC0gZGlmZi50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kIC0gZGlmZi5zdGFydFxuICB9O1xuICB2YXIgdHJhbnNmb3JtZWQgPSBzbGF0ZS5Qb2ludC50cmFuc2Zvcm0oYW5jaG9yLCBvcCwge1xuICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gIH0pO1xuXG4gIGlmICghdHJhbnNmb3JtZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChvcC50eXBlID09PSAnc3BsaXRfbm9kZScgJiYgc2xhdGUuUGF0aC5lcXVhbHMob3AucGF0aCwgcG9pbnQucGF0aCkgJiYgYW5jaG9yLm9mZnNldCA8IG9wLnBvc2l0aW9uICYmIGRpZmYuc3RhcnQgPCBvcC5wb3NpdGlvbikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogdHJhbnNmb3JtZWQucGF0aCxcbiAgICBvZmZzZXQ6IHRyYW5zZm9ybWVkLm9mZnNldCArIGRpZmYudGV4dC5sZW5ndGggLSBkaWZmLmVuZCArIGRpZmYuc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcCkge1xuICB2YXIgYW5jaG9yID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yLCBvcCk7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb2N1cyA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzLCBvcCk7XG5cbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IGFuY2hvcixcbiAgICBmb2N1czogZm9jdXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVRleHREaWZmKHRleHREaWZmLCBvcCkge1xuICB2YXIgcGF0aCA9IHRleHREaWZmLnBhdGgsXG4gICAgICBkaWZmID0gdGV4dERpZmYuZGlmZixcbiAgICAgIGlkID0gdGV4dERpZmYuaWQ7XG5cbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIXNsYXRlLlBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5vZmZzZXQgPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogb3AudGV4dC5sZW5ndGggKyBkaWZmLmVuZCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIXNsYXRlLlBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5wb3NpdGlvbiA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogc2xhdGUuUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5wb3NpdGlvbiA+IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBNYXRoLm1pbihvcC5wb3NpdGlvbiwgZGlmZi5lbmQpLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHNsYXRlLlBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICBpZiAoIXNsYXRlLlBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBzbGF0ZS5QYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogc2xhdGUuUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cblxuICB2YXIgbmV3UGF0aCA9IHNsYXRlLlBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcblxuICBpZiAoIW5ld1BhdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlmZjogZGlmZixcbiAgICBwYXRoOiBuZXdQYXRoLFxuICAgIGlkOiBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8vIFdoZW4gdXNpbmcga2V5Ym9hcmQgRW5nbGlzaCBhc3NvY2lhdGlvbiBmdW5jdGlvbiwgY29ucG9zaXRpb25FbmQgdHJpZ2dlcmVkIHRvbyBmYXN0LCByZXN1bHRpbmcgaW4gYWZ0ZXIgYGluc2VydFRleHRgIHN0aWxsIG1haW50YWluIGFzc29jaWF0aW9uIHN0YXRlLlxuXG52YXIgUkVTT0xWRV9ERUxBWSA9IDI1OyAvLyBUaW1lIHdpdGggbm8gdXNlciBpbnRlcmFjdGlvbiBiZWZvcmUgdGhlIGN1cnJlbnQgdXNlciBhY3Rpb24gaXMgY29uc2lkZXJlZCBhcyBkb25lLlxuXG52YXIgRkxVU0hfREVMQVkgPSAyMDA7IC8vIFJlcGxhY2Ugd2l0aCBgY29uc3QgZGVidWcgPSBjb25zb2xlLmxvZ2AgdG8gZGVidWdcblxudmFyIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTsgLy8gVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEgRGF0YVRyYW5zZmVyXG5cblxudmFyIGlzRGF0YVRyYW5zZmVyID0gZnVuY3Rpb24gaXNEYXRhVHJhbnNmZXIodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuY29uc3RydWN0b3IubmFtZSkgPT09ICdEYXRhVHJhbnNmZXInO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfcmVmKSB7XG4gIHZhciBlZGl0b3IgPSBfcmVmLmVkaXRvcixcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UgPSBfcmVmLnNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UsXG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSA9IF9yZWYub25ET01TZWxlY3Rpb25DaGFuZ2U7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgYWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIHZhciBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcblxuICB2YXIgYXBwbHlQZW5kaW5nU2VsZWN0aW9uID0gZnVuY3Rpb24gYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTltcImRlbGV0ZVwiXShlZGl0b3IpO1xuXG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVSYW5nZShlZGl0b3IsIHBlbmRpbmdTZWxlY3Rpb24pO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCAmJiAoIXNlbGVjdGlvbiB8fCAhc2xhdGUuUmFuZ2UuZXF1YWxzKG5vcm1hbGl6ZWQsIHNlbGVjdGlvbikpKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gcGVyZm9ybUFjdGlvbigpIHtcbiAgICB2YXIgYWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTltcImRlbGV0ZVwiXShlZGl0b3IpO1xuXG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLmF0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gc2xhdGUuUG9pbnQuaXNQb2ludChhY3Rpb24uYXQpID8gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBhY3Rpb24uYXQpIDogbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCBhY3Rpb24uYXQpO1xuXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGFyZ2V0UmFuZ2UgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIXNsYXRlLlJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCBfdGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb24ucnVuKCk7XG4gIH07XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChhY3Rpb25UaW1lb3V0SWQpO1xuICAgICAgYWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1BlbmRpbmdEaWZmcygpICYmICFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFwcGx5UGVuZGluZ1NlbGVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGZsdXNoaW5nID0gJ2FjdGlvbic7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvblJlZiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgc2xhdGUuRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgIH0pO1xuICAgIEVESVRPUl9UT19VU0VSX01BUktTLnNldChlZGl0b3IsIGVkaXRvci5tYXJrcyk7XG4gICAgZGVidWcoJ2ZsdXNoJywgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpLCBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSk7XG4gICAgdmFyIHNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlID0gaGFzUGVuZGluZ0RpZmZzKCk7XG4gICAgdmFyIGRpZmY7XG5cbiAgICB3aGlsZSAoZGlmZiA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BFTkRJTkdfRElbMF0pIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREksIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG5cbiAgICAgIHZhciBwZW5kaW5nTWFya3MgPSBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcik7XG5cbiAgICAgIGlmIChwZW5kaW5nTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1NbXCJkZWxldGVcIl0oZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVuZGluZ01hcmtzICYmIGluc2VydFBvc2l0aW9uSGludCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlID0gdGFyZ2V0UmFuZ2UoZGlmZik7XG5cbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhc2xhdGUuUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHJhbmdlKSkge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYuZGlmZi50ZXh0KSB7XG4gICAgICAgIHNsYXRlLkVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZGlmZi5kaWZmLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICB9IC8vIFJlbW92ZSBkaWZmIG9ubHkgYWZ0ZXIgd2UgaGF2ZSBhcHBsaWVkIGl0IHRvIGFjY291bnQgZm9yIGl0IHdoZW4gdHJhbnNmb3JtaW5nXG4gICAgICAvLyBwZW5kaW5nIHJhbmdlcy5cblxuXG4gICAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZWRpdG9yLCAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1BFTkRJTkdfREkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIGlkID0gX3JlZjIuaWQ7XG4gICAgICAgIHJldHVybiBpZCAhPT0gZGlmZi5pZDtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCF2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCBkaWZmKSkge1xuICAgICAgICBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT05bXCJkZWxldGVcIl0oZWRpdG9yKTtcbiAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1NbXCJkZWxldGVcIl0oZWRpdG9yKTtcbiAgICAgICAgZmx1c2hpbmcgPSAnYWN0aW9uJzsgLy8gRW5zdXJlIHdlIGRvbid0IHJlc3RvcmUgdGhlIHBlbmRpbmcgdXNlciAoZG9tKSBzZWxlY3Rpb25cbiAgICAgICAgLy8gc2luY2UgdGhlIGRvY3VtZW50IGFuZCBkb20gc3RhdGUgZG8gbm90IG1hdGNoLlxuXG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTltcImRlbGV0ZVwiXShlZGl0b3IpO1xuICAgICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgc2VsZWN0aW9uUmVmID09PSBudWxsIHx8IHNlbGVjdGlvblJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0aW9uUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhc2xhdGUuUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgZWRpdG9yLnNlbGVjdGlvbikpKSB7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcGVyZm9ybUFjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ09NUEFUOiBUaGUgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgc2NoZWR1bGUgaXQgdG8gZW5zdXJlIHdlIGRvbid0ICd0aHJvdyBhd2F5JyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gd2hpbGUgcmVuZGVyaW5nIGlmIHdlIGhhdmUgcGVuZGluZyBjaGFuZ2VzLlxuXG5cbiAgICBpZiAoc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICBhcHBseVBlbmRpbmdTZWxlY3Rpb24oKTtcbiAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1NbXCJkZWxldGVcIl0oZWRpdG9yKTtcblxuICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVDb21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uIGhhbmRsZUNvbXBvc2l0aW9uRW5kKF9ldmVudCkge1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICB9XG5cbiAgICBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSwgUkVTT0xWRV9ERUxBWSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvblN0YXJ0KF9ldmVudCkge1xuICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgZm9yY2VIaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGxhY2Vob2xkZXJFbGVtZW50ID0gRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXBsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBmb3JjZUhpZGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZGlzcGxheScpO1xuICB9O1xuXG4gIHZhciBzdG9yZURpZmYgPSBmdW5jdGlvbiBzdG9yZURpZmYocGF0aCwgZGlmZikge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkzO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJMyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkzICE9PSB2b2lkIDAgPyBfRURJVE9SX1RPX1BFTkRJTkdfREkzIDogW107XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgcGVuZGluZ0RpZmZzKTtcbiAgICB2YXIgdGFyZ2V0ID0gc2xhdGUuTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgdmFyIGlkeCA9IHBlbmRpbmdEaWZmcy5maW5kSW5kZXgoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgcmV0dXJuIHNsYXRlLlBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKTtcbiAgICB9KTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0LnRleHQsIGRpZmYpO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBwZW5kaW5nRGlmZnMucHVzaCh7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICAgIGlkOiBpZENvdW50ZXIrK1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlU3RyaW5nRGlmZnModGFyZ2V0LnRleHQsIHBlbmRpbmdEaWZmc1tpZHhdLmRpZmYsIGRpZmYpO1xuXG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIHBlbmRpbmdEaWZmcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBlbmRpbmdEaWZmc1tpZHhdID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgcGVuZGluZ0RpZmZzW2lkeF0pLCB7fSwge1xuICAgICAgZGlmZjogbWVyZ2VkXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHNjaGVkdWxlQWN0aW9uID0gZnVuY3Rpb24gc2NoZWR1bGVBY3Rpb24ocnVuKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgYXQgPSBfcmVmMy5hdDtcblxuICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTltcImRlbGV0ZVwiXShlZGl0b3IpO1xuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG5cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaCgpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICBydW46IHJ1blxuICAgIH0pOyAvLyBDT01QQVQ6IFdoZW4gZGVsZXRpbmcgYmVmb3JlIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IGNocm9tZSBvbmx5IGZpcmVzIGEgYmVmb3JlaW5wdXQsXG4gICAgLy8gKG5vIGlucHV0KSBhbmQgZG9lc24ndCBwZXJmb3JtIGFueSBkb20gbXV0YXRpb25zLiBXaXRob3V0IGEgZmx1c2ggdGltZW91dCB3ZSB3b3VsZCBuZXZlciBmbHVzaFxuICAgIC8vIGluIHRoaXMgY2FzZSBhbmQgdGh1cyBuZXZlciBhY3R1YWxseSBwZXJmb3JtIHRoZSBhY3Rpb24uXG5cbiAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlRE9NQmVmb3JlSW5wdXQgPSBmdW5jdGlvbiBoYW5kbGVET01CZWZvcmVJbnB1dChldmVudCkge1xuICAgIHZhciBfdGFyZ2V0UmFuZ2UyO1xuXG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZXZlbnQuaW5wdXRUeXBlO1xuICAgIHZhciB0YXJnZXRSYW5nZSA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ICE9PSBmYWxzZSAmJiB0eXBlICE9PSAnaW5zZXJ0VGV4dCcgJiYgdHlwZSAhPT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBfZXZlbnQkZ2V0VGFyZ2V0UmFuZ2UgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKSxcbiAgICAgICAgX2V2ZW50JGdldFRhcmdldFJhbmdlMiA9IF9zbGljZWRUb0FycmF5KF9ldmVudCRnZXRUYXJnZXRSYW5nZSwgMSksXG4gICAgICAgIG5hdGl2ZVRhcmdldFJhbmdlID0gX2V2ZW50JGdldFRhcmdldFJhbmdlMlswXTtcblxuICAgIGlmIChuYXRpdmVUYXJnZXRSYW5nZSkge1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuYXRpdmVUYXJnZXRSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBDT01QQVQ6IFNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCwgc28gd2VcbiAgICAvLyBoYXZlIHRvIG1hbnVhbGx5IGdldCB0aGUgc2VsZWN0aW9uIGhlcmUgdG8gZW5zdXJlIGl0J3MgdXAtdG8tZGF0ZS5cblxuXG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIXRhcmdldFJhbmdlICYmIGRvbVNlbGVjdGlvbikge1xuICAgICAgbmF0aXZlVGFyZ2V0UmFuZ2UgPSBkb21TZWxlY3Rpb247XG4gICAgICB0YXJnZXRSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGFyZ2V0UmFuZ2UgPSAoX3RhcmdldFJhbmdlMiA9IHRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfdGFyZ2V0UmFuZ2UyICE9PSB2b2lkIDAgPyBfdGFyZ2V0UmFuZ2UyIDogZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghdGFyZ2V0UmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBtYW5hZ2VyIHRyaWVzIHRvIHN0b3JlIHRleHQgZGlmZnMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBkZWZlciBmbHVzaGluZyB0aGVtIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZS4gV2UgZG9uJ3Qgd2FudCB0byBmbHVzaFxuICAgIC8vIGZvciBldmVyeSBpbnB1dCBldmVudCBhcyB0aGlzIGNhbiBiZSBleHBlbnNpdmUuIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lXG4gICAgLy8gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbm5vdCBzYWZlbHkgc3RvcmUgdGhlIHRleHQgZGlmZiBhbmQgbXVzdCBpbnN0ZWFkXG4gICAgLy8gc2NoZWR1bGUgYW4gYWN0aW9uIHRvIGxldCBTbGF0ZSBub3JtYWxpemUgdGhlIGVkaXRvciBzdGF0ZS5cblxuXG4gICAgdmFyIGNhblN0b3JlRGlmZiA9IHRydWU7XG5cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgaWYgKHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBzbGF0ZS5SYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSksXG4gICAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICAgIF9zdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgICBfZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgICB2YXIgX2xlYWYgPSBzbGF0ZS5Ob2RlLmxlYWYoZWRpdG9yLCBfc3RhcnQucGF0aCk7XG5cbiAgICAgICAgaWYgKF9sZWFmLnRleHQubGVuZ3RoID09PSBfc3RhcnQub2Zmc2V0ICYmIF9lbmQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBzbGF0ZS5FZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBfc3RhcnQucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBzbGF0ZS5UZXh0LmlzVGV4dFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG5leHQgJiYgc2xhdGUuUGF0aC5lcXVhbHMobmV4dFsxXSwgX2VuZC5wYXRoKSkge1xuICAgICAgICAgICAgdGFyZ2V0UmFuZ2UgPSB7XG4gICAgICAgICAgICAgIGFuY2hvcjogX2VuZCxcbiAgICAgICAgICAgICAgZm9jdXM6IF9lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlLmVuZHNXaXRoKCdCYWNrd2FyZCcpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcblxuICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBzbGF0ZS5SYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzNFswXSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICB2YXIgX0VkaXRvciRsZWFmID0gc2xhdGUuRWRpdG9yLmxlYWYoZWRpdG9yLCBzdGFydC5wYXRoKSxcbiAgICAgICAgICBfRWRpdG9yJGxlYWYyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsZWFmLCAyKSxcbiAgICAgICAgICBsZWFmID0gX0VkaXRvciRsZWFmMlswXSxcbiAgICAgICAgICBwYXRoID0gX0VkaXRvciRsZWFmMlsxXTtcblxuICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0LFxuICAgICAgICBlbmQ6IGVuZC5vZmZzZXRcbiAgICAgIH07XG4gICAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgcmVsZXZhbnRQZW5kaW5nRGlmZnMgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBzbGF0ZS5QYXRoLmVxdWFscyhjaGFuZ2UucGF0aCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBkaWZmcyA9IHJlbGV2YW50UGVuZGluZ0RpZmZzID8gW3JlbGV2YW50UGVuZGluZ0RpZmZzLmRpZmYsIGRpZmZdIDogW2RpZmZdO1xuICAgICAgdmFyIHRleHQgPSBhcHBseVN0cmluZ0RpZmYuYXBwbHkodm9pZCAwLCBbbGVhZi50ZXh0XS5jb25jYXQoZGlmZnMpKTtcblxuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRleHQgbGVhZiB3aWxsIGJlIHJlbW92ZWQsIHNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgYW5cbiAgICAgICAgLy8gYWN0aW9uIHRvIHJlbW92ZSBpdCBzbyB0aGF0IFNsYXRlIGNhbiBub3JtYWxpemUgaW5zdGVhZFxuICAgICAgICAvLyBvZiBzdG9yaW5nIGFzIGEgZGlmZlxuICAgICAgICBjYW5TdG9yZURpZmYgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgc2xhdGUuUGF0aC5lcXVhbHModGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHRhcmdldFJhbmdlLmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgICAgcGF0aDogdGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0Lm9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhbmdlID0gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQsIHBvaW50KTtcbiAgICAgICAgICBoYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIGVuZDogZW5kLm9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5vZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNsYXRlLkVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q3V0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsYXRlLkVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90YXJnZXRSYW5nZTMgPSB0YXJnZXRSYW5nZSxcbiAgICAgICAgICAgICAgYW5jaG9yID0gX3RhcmdldFJhbmdlMy5hbmNob3I7XG5cbiAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBzbGF0ZS5Ob2RlLmxlYWYoZWRpdG9yLCBhbmNob3IucGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChhbmNob3Iub2Zmc2V0IDwgdGFyZ2V0Tm9kZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKGFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGFuY2hvci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBhbmNob3Iub2Zmc2V0ICsgMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsYXRlLkVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbmF0aXZlVGFyZ2V0UmFuZ2U7XG5cbiAgICAgICAgICB2YXIgX3RhcmdldFJhbmdlNCA9IHRhcmdldFJhbmdlLFxuICAgICAgICAgICAgICBfYW5jaG9yID0gX3RhcmdldFJhbmdlNC5hbmNob3I7IC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBuYXRpdmUgYW5kIHNsYXRlIHNlbGVjdGlvbiBiZWluZyBjb2xsYXBzZWRcbiAgICAgICAgICAvLyB3ZSBhcmUgbW9zdCBsaWtlbHkgZGVsZXRpbmcgYSB6ZXJvLXdpZHRoIHBsYWNlaG9sZGVyIGFuZCB0aHVzIHNob3VsZCBwZXJmb3JtIGl0XG4gICAgICAgICAgLy8gYXMgYW4gYWN0aW9uIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yIChtb3N0bHkgaGFwcGVucyB3aXRoIG1hcmsgcGxhY2Vob2xkZXJzKVxuXG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbGxhcHNlZCA9IGlzRE9NU2VsZWN0aW9uKG5hdGl2ZVRhcmdldFJhbmdlKSA/IG5hdGl2ZVRhcmdldFJhbmdlLmlzQ29sbGFwc2VkIDogISEoKF9uYXRpdmVUYXJnZXRSYW5nZSA9IG5hdGl2ZVRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfbmF0aXZlVGFyZ2V0UmFuZ2UgIT09IHZvaWQgMCAmJiBfbmF0aXZlVGFyZ2V0UmFuZ2UuY29sbGFwc2VkKTtcblxuICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgbmF0aXZlQ29sbGFwc2VkICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSAmJiBfYW5jaG9yLm9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZURpZmYoX2FuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICBzdGFydDogX2FuY2hvci5vZmZzZXQgLSAxLFxuICAgICAgICAgICAgICBlbmQ6IF9hbmNob3Iub2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsYXRlLkVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xhdGUuRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xhdGUuRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsYXRlLkVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGF0ZS5FZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGF0ZS5FZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGF0ZS5FZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGF0ZS5FZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xhdGUuRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0RhdGFUcmFuc2ZlcihkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RleHQgPSBkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiAnJzsgLy8gQ09NUEFUOiBJZiB3ZSBhcmUgd3JpdGluZyBpbnNpZGUgYSBwbGFjZWhvbGRlciwgdGhlIGltZSBpbnNlcnRzIHRoZSB0ZXh0IGluc2lkZVxuICAgICAgICAgIC8vIHRoZSBwbGFjZWhvbGRlciBpdHNlbGYgYW5kIHRodXMgaW5jbHVkZXMgdGhlIHplcm8td2lkdGggc3BhY2UgaW5zaWRlIGVkaXQgZXZlbnRzLlxuXG5cbiAgICAgICAgICBpZiAoRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBfdGV4dCA9IF90ZXh0LnJlcGxhY2UoXCJcXHVGRUZGXCIsICcnKTtcbiAgICAgICAgICB9IC8vIFBhc3RlcyBmcm9tIHRoZSBBbmRyb2lkIGNsaXBib2FyZCB3aWxsIGdlbmVyYXRlIGBpbnNlcnRUZXh0YCBldmVudHMuXG4gICAgICAgICAgLy8gSWYgdGhlIGNvcGllZCB0ZXh0IGNvbnRhaW5zIGFueSBuZXdsaW5lcywgQW5kcm9pZCB3aWxsIGFwcGVuZCBhblxuICAgICAgICAgIC8vIGV4dHJhIG5ld2xpbmUgdG8gdGhlIGVuZCBvZiB0aGUgY29waWVkIHRleHQuXG5cblxuICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgLy4qXFxuLipcXG4kLy50ZXN0KF90ZXh0KSkge1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgdGV4dCBpbmNsdWRlcyBhIG5ld2xpbmUsIHNwbGl0IGl0IGF0IG5ld2xpbmVzIGFuZCBwYXN0ZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHN0cmluZywgd2l0aCBzb2Z0IGJyZWFrcyBpbiBiZXR3ZWVuIGVhY2guXG5cblxuICAgICAgICAgIGlmIChfdGV4dC5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IF90ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIHNsYXRlLkVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHNsYXRlLkVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzbGF0ZS5QYXRoLmVxdWFscyh0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwgdGFyZ2V0UmFuZ2UuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfUmFuZ2UkZWRnZXM1ID0gc2xhdGUuUmFuZ2UuZWRnZXModGFyZ2V0UmFuZ2UpLFxuICAgICAgICAgICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgICAgICAgICBfc3RhcnQyID0gX1JhbmdlJGVkZ2VzNlswXSxcbiAgICAgICAgICAgICAgICBfZW5kMiA9IF9SYW5nZSRlZGdlczZbMV07XG5cbiAgICAgICAgICAgIHZhciBfZGlmZiA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IF9zdGFydDIub2Zmc2V0LFxuICAgICAgICAgICAgICBlbmQ6IF9lbmQyLm9mZnNldCxcbiAgICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICAgIH07IC8vIENPTVBBVDogU3dpZnRrZXkgaGFzIGEgd2VpcmQgYnVnIHdoZXJlIHRoZSB0YXJnZXQgcmFuZ2Ugb2YgdGhlIDJuZCB3b3JkXG4gICAgICAgICAgICAvLyBpbnNlcnRlZCBhZnRlciBhIG1hcmsgcGxhY2Vob2xkZXIgaXMgaW5zZXJ0ZWQgd2l0aCBhbiBhbmNob3Igb2Zmc2V0IG9mZiBieSAxLlxuICAgICAgICAgICAgLy8gU28gd3JpdGluZyAnc29tZSB0ZXh0JyB3aWxsIHJlc3VsdCBpbiAnc29tZSB0dGV4dCcuIEx1Y2tpbHkgYWxsICdub3JtYWwnIGluc2VydFxuICAgICAgICAgICAgLy8gdGV4dCBldmVudHMgYXJlIGZpcmVkIHdpdGggdGhlIGNvcnJlY3QgdGFyZ2V0IHJhbmdlcywgb25seSB0aGUgZmluYWwgJ2luc2VydENvbXBvc2l0aW9uJ1xuICAgICAgICAgICAgLy8gaXNuJ3QsIHNvIHdlIGNhbiBhZGp1c3QgdGhlIHRhcmdldCByYW5nZSBzdGFydCBvZmZzZXQgaWYgd2UgYXJlIGNvbmZpZGVudCB0aGlzIGlzIHRoZVxuICAgICAgICAgICAgLy8gc3dpZnRrZXkgaW5zZXJ0IGNhdXNpbmcgdGhlIGlzc3VlLlxuXG4gICAgICAgICAgICBpZiAoX3RleHQgJiYgaW5zZXJ0UG9zaXRpb25IaW50ICYmIHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnKSB7XG4gICAgICAgICAgICAgIHZhciBoaW50UG9zaXRpb24gPSBpbnNlcnRQb3NpdGlvbkhpbnQuc3RhcnQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5zZWFyY2goL1xcU3wkLyk7XG5cbiAgICAgICAgICAgICAgdmFyIGRpZmZQb3NpdGlvbiA9IF9kaWZmLnN0YXJ0ICsgX2RpZmYudGV4dC5zZWFyY2goL1xcU3wkLyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZQb3NpdGlvbiA9PT0gaGludFBvc2l0aW9uICsgMSAmJiBfZGlmZi5lbmQgPT09IGluc2VydFBvc2l0aW9uSGludC5zdGFydCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF9kaWZmLnN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnKSB7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfZGlmZjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgJiYgc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIGluc2VydFBvc2l0aW9uSGludC5lbmQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGggPT09IF9zdGFydDIub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgaW5zZXJ0UG9zaXRpb25IaW50KSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGluc2VydFBvc2l0aW9uSGludC50ZXh0ICsgX3RleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYpIHtcbiAgICAgICAgICAgICAgc3RvcmVEaWZmKF9zdGFydDIucGF0aCwgX2RpZmYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGF0ZS5FZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0FjdGlvbiA9IGZ1bmN0aW9uIGhhc1BlbmRpbmdBY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpO1xuICB9O1xuXG4gIHZhciBoYXNQZW5kaW5nRGlmZnMgPSBmdW5jdGlvbiBoYXNQZW5kaW5nRGlmZnMoKSB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTQ7XG5cbiAgICByZXR1cm4gISEoKF9FRElUT1JfVE9fUEVORElOR19ESTQgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJNCAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQubGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0NoYW5nZXMgPSBmdW5jdGlvbiBoYXNQZW5kaW5nQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gaGFzUGVuZGluZ0FjdGlvbigpIHx8IGhhc1BlbmRpbmdEaWZmcygpO1xuICB9O1xuXG4gIHZhciBpc0ZsdXNoaW5nID0gZnVuY3Rpb24gaXNGbHVzaGluZygpIHtcbiAgICByZXR1cm4gZmx1c2hpbmc7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVVzZXJTZWxlY3QgPSBmdW5jdGlvbiBoYW5kbGVVc2VyU2VsZWN0KHJhbmdlKSB7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlZGl0b3IsIHJhbmdlKTtcblxuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aENoYW5nZWQgPSAhc2VsZWN0aW9uIHx8ICFzbGF0ZS5QYXRoLmVxdWFscyhzZWxlY3Rpb24uYW5jaG9yLnBhdGgsIHJhbmdlLmFuY2hvci5wYXRoKTtcbiAgICB2YXIgcGFyZW50UGF0aENoYW5nZWQgPSAhc2VsZWN0aW9uIHx8ICFzbGF0ZS5QYXRoLmVxdWFscyhzZWxlY3Rpb24uYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpLCByYW5nZS5hbmNob3IucGF0aC5zbGljZSgwLCAtMSkpO1xuXG4gICAgaWYgKHBhdGhDaGFuZ2VkICYmIGluc2VydFBvc2l0aW9uSGludCB8fCBwYXJlbnRQYXRoQ2hhbmdlZCkge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhDaGFuZ2VkIHx8IGhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gsIEZMVVNIX0RFTEFZKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0ID0gZnVuY3Rpb24gaGFuZGxlSW5wdXQoKSB7XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSB8fCAhaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihfKSB7XG4gICAgLy8gQ09NUEFUOiBTd2lmdGtleSBjbG9zZXMgdGhlIGtleWJvYXJkIHdoZW4gdHlwaW5nIGluc2lkZSBhIGVtcHR5IG5vZGVcbiAgICAvLyBkaXJlY3RseSBuZXh0IHRvIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50ICg9IHRoZSBwbGFjZWhvbGRlcikuXG4gICAgLy8gVGhlIG9ubHkgZXZlbnQgZmlyZWQgc29vbiBlbm91Z2ggZm9yIHVzIHRvIGFsbG93IGhpZGluZyB0aGUgcGxhY2Vob2xkZXJcbiAgICAvLyB3aXRob3V0IHN3aWZ0a2V5IHBpY2tpbmcgaXQgdXAgaXMgdGhlIGtleWRvd24gZXZlbnQsIHNvIHdlIGhhdmUgdG8gaGlkZSBpdFxuICAgIC8vIGhlcmUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC80OTg4I2lzc3VlY29tbWVudC0xMjAxMDUwNTM1XG4gICAgaWYgKCFoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgc2V0VGltZW91dCh1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2NoZWR1bGVGbHVzaCA9IGZ1bmN0aW9uIHNjaGVkdWxlRmx1c2goKSB7XG4gICAgaWYgKCFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFjdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRG9tTXV0YXRpb25zID0gZnVuY3Rpb24gaGFuZGxlRG9tTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICByZXR1cm4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKTtcbiAgICB9KSkge1xuICAgICAgdmFyIF9FRElUT1JfVE9fRk9SQ0VfUkVORDtcblxuICAgICAgLy8gQ2F1c2UgYSByZS1yZW5kZXIgdG8gcmVzdG9yZSB0aGUgZG9tIHN0YXRlIGlmIHdlIGVuY291bnRlciB0cmFja2VkIG11dGF0aW9ucyB3aXRob3V0XG4gICAgICAvLyBhIGNvcnJlc3BvbmRpbmcgcGVuZGluZyBhY3Rpb24uXG4gICAgICAoX0VESVRPUl9UT19GT1JDRV9SRU5EID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19GT1JDRV9SRU5EID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX0ZPUkNFX1JFTkQoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBmbHVzaDogZmx1c2gsXG4gICAgc2NoZWR1bGVGbHVzaDogc2NoZWR1bGVGbHVzaCxcbiAgICBoYXNQZW5kaW5nRGlmZnM6IGhhc1BlbmRpbmdEaWZmcyxcbiAgICBoYXNQZW5kaW5nQWN0aW9uOiBoYXNQZW5kaW5nQWN0aW9uLFxuICAgIGhhc1BlbmRpbmdDaGFuZ2VzOiBoYXNQZW5kaW5nQ2hhbmdlcyxcbiAgICBpc0ZsdXNoaW5nOiBpc0ZsdXNoaW5nLFxuICAgIGhhbmRsZVVzZXJTZWxlY3Q6IGhhbmRsZVVzZXJTZWxlY3QsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25FbmQ6IGhhbmRsZUNvbXBvc2l0aW9uRW5kLFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQ6IGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQsXG4gICAgaGFuZGxlRE9NQmVmb3JlSW5wdXQ6IGhhbmRsZURPTUJlZm9yZUlucHV0LFxuICAgIGhhbmRsZUtleURvd246IGhhbmRsZUtleURvd24sXG4gICAgaGFuZGxlRG9tTXV0YXRpb25zOiBoYW5kbGVEb21NdXRhdGlvbnMsXG4gICAgaGFuZGxlSW5wdXQ6IGhhbmRsZUlucHV0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpIHtcbiAgdmFyIGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzTW91bnRlZFJlZi5jdXJyZW50O1xufVxuXG4vKipcclxuICogUHJldmVudCB3YXJuaW5nIG9uIFNTUiBieSBmYWxsaW5nIGJhY2sgdG8gdXNlRWZmZWN0IHdoZW4gRE9NIGlzbid0IGF2YWlsYWJsZVxyXG4gKi9cblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBDQU5fVVNFX0RPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcihub2RlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gIH0pLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMSksXG4gICAgICBtdXRhdGlvbk9ic2VydmVyID0gX3VzZVN0YXRlMlswXTtcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEaXNjYXJkIG11dGF0aW9ucyBjYXVzZWQgZHVyaW5nIHJlbmRlciBwaGFzZS4gVGhpcyB3b3JrcyBkdWUgdG8gcmVhY3QgY2FsbGluZ1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSByZW5kZXIgcGhhc2UgYmVmb3JlIHRoZSBuZXh0IHRpY2suXG4gICAgbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUobm9kZS5jdXJyZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFttdXRhdGlvbk9ic2VydmVyLCBub2RlLCBvcHRpb25zXSk7XG59XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcIm5vZGVcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn07XG52YXIgdXNlQW5kcm9pZElucHV0TWFuYWdlciA9ICFJU19BTkRST0lEID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbDtcbn0gOiBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDMpO1xuXG4gIGlmICghSVNfQU5EUk9JRCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcblxuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9vYmplY3RTcHJlYWQkMih7XG4gICAgICBlZGl0b3I6IGVkaXRvclxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAxKSxcbiAgICAgIGlucHV0TWFuYWdlciA9IF91c2VTdGF0ZTJbMF07XG5cbiAgdXNlTXV0YXRpb25PYnNlcnZlcihub2RlLCBpbnB1dE1hbmFnZXIuaGFuZGxlRG9tTXV0YXRpb25zLCBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUckMSk7XG4gIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5zZXQoZWRpdG9yLCBpbnB1dE1hbmFnZXIuc2NoZWR1bGVGbHVzaCk7XG5cbiAgaWYgKGlzTW91bnRlZCkge1xuICAgIGlucHV0TWFuYWdlci5mbHVzaCgpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0TWFuYWdlcjtcbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xudmFyIHNoYWxsb3dDb21wYXJlID0gZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUob2JqMSwgb2JqMikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGggJiYgT2JqZWN0LmtleXMob2JqMSkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmoyLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqMVtrZXldID09PSBvYmoyW2tleV07XG4gIH0pO1xufTtcblxudmFyIGlzRGVjb3JhdGlvbkZsYWdzRXF1YWwgPSBmdW5jdGlvbiBpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikge1xuICByYW5nZS5hbmNob3I7XG4gICAgICByYW5nZS5mb2N1cztcbiAgICAgIHZhciByYW5nZU93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkMik7XG5cbiAgb3RoZXIuYW5jaG9yO1xuICAgICAgb3RoZXIuZm9jdXM7XG4gICAgICB2YXIgb3RoZXJPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdGhlciwgX2V4Y2x1ZGVkMiQxKTtcblxuICByZXR1cm4gcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSAmJiBzaGFsbG93Q29tcGFyZShyYW5nZU93blByb3BzLCBvdGhlck93blByb3BzKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcclxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcclxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXHJcbiAqL1xuXG5cbnZhciBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsID0gZnVuY3Rpb24gaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbChsaXN0LCBhbm90aGVyKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG5cbiAgICBpZiAoIXNsYXRlLlJhbmdlLmVxdWFscyhyYW5nZSwgb3RoZXIpIHx8ICFpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcclxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcclxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXHJcbiAqL1xuXG52YXIgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbCA9IGZ1bmN0aW9uIGlzVGV4dERlY29yYXRpb25zRXF1YWwobGlzdCwgYW5vdGhlcikge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldOyAvLyBjb21wYXJlIG9ubHkgb2Zmc2V0cyBiZWNhdXNlIHBhdGhzIGRvZXNuJ3QgbWF0dGVyIGZvciB0ZXh0XG5cbiAgICBpZiAocmFuZ2UuYW5jaG9yLm9mZnNldCAhPT0gb3RoZXIuYW5jaG9yLm9mZnNldCB8fCByYW5nZS5mb2N1cy5vZmZzZXQgIT09IG90aGVyLmZvY3VzLm9mZnNldCB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcclxuICogTGVhZiBjb250ZW50IHN0cmluZ3MuXHJcbiAqL1xuXG52YXIgU3RyaW5nID0gZnVuY3Rpb24gU3RyaW5nKHByb3BzKSB7XG4gIHZhciBpc0xhc3QgPSBwcm9wcy5pc0xhc3QsXG4gICAgICBsZWFmID0gcHJvcHMubGVhZixcbiAgICAgIHBhcmVudCA9IHByb3BzLnBhcmVudCxcbiAgICAgIHRleHQgPSBwcm9wcy50ZXh0O1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRleHQpO1xuICB2YXIgcGFyZW50UGF0aCA9IHNsYXRlLlBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgaXNNYXJrUGxhY2Vob2xkZXIgPSBsZWFmW01BUktfUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gdHJ1ZTsgLy8gQ09NUEFUOiBSZW5kZXIgdGV4dCBpbnNpZGUgdm9pZCBub2RlcyB3aXRoIGEgemVyby13aWR0aCBzcGFjZS5cbiAgLy8gU28gdGhlIG5vZGUgY2FuIGNvbnRhaW4gc2VsZWN0aW9uIGJ1dCB0aGUgdGV4dCBpcyBub3QgdmlzaWJsZS5cblxuICBpZiAoZWRpdG9yLmlzVm9pZChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBsZW5ndGg6IHNsYXRlLk5vZGUuc3RyaW5nKHBhcmVudCkubGVuZ3RoXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBhbiBlbXB0eSBibG9jaywgcmVuZGVyIGEgemVyby1cbiAgLy8gd2lkdGggc3BhY2UgdGhhdCB3aWxsIGNvbnZlcnQgaW50byBhIGxpbmUgYnJlYWsgd2hlbiBjb3B5aW5nIGFuZCBwYXN0aW5nXG4gIC8vIHRvIHN1cHBvcnQgZXhwZWN0ZWQgcGxhaW4gdGV4dC5cblxuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnICYmIHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPT09IHRleHQgJiYgIWVkaXRvci5pc0lubGluZShwYXJlbnQpICYmIHNsYXRlLkVkaXRvci5zdHJpbmcoZWRpdG9yLCBwYXJlbnRQYXRoKSA9PT0gJycpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTGluZUJyZWFrOiB0cnVlLFxuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgaXQncyBiZWNhdXNlIGl0J3Mgb24gdGhlIGVkZ2Ugb2YgYW4gaW5saW5lXG4gIC8vIG5vZGUsIHNvIHdlIHJlbmRlciBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB0aGUgc2VsZWN0aW9uIGNhbiBiZVxuICAvLyBpbnNlcnRlZCBuZXh0IHRvIGl0IHN0aWxsLlxuXG5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogQnJvd3NlcnMgd2lsbCBjb2xsYXBzZSB0cmFpbGluZyBuZXcgbGluZXMgYXQgdGhlIGVuZCBvZiBibG9ja3MsXG4gIC8vIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHRyYWlsaW5nIG5ldyBsaW5lcyB0byBwcmV2ZW50IHRoYXQuXG5cblxuICBpZiAoaXNMYXN0ICYmIGxlYWYudGV4dC5zbGljZSgtMSkgPT09ICdcXG4nKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgICAgaXNUcmFpbGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxlYWYudGV4dFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgIHRleHQ6IGxlYWYudGV4dFxuICB9KTtcbn07XG4vKipcclxuICogTGVhZiBzdHJpbmdzIHdpdGggdGV4dCBpbiB0aGVtLlxyXG4gKi9cblxuXG52YXIgVGV4dFN0cmluZyA9IGZ1bmN0aW9uIFRleHRTdHJpbmcocHJvcHMpIHtcbiAgdmFyIHRleHQgPSBwcm9wcy50ZXh0LFxuICAgICAgX3Byb3BzJGlzVHJhaWxpbmcgPSBwcm9wcy5pc1RyYWlsaW5nLFxuICAgICAgaXNUcmFpbGluZyA9IF9wcm9wcyRpc1RyYWlsaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpc1RyYWlsaW5nO1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBnZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiAnJykuY29uY2F0KGlzVHJhaWxpbmcgPyAnXFxuJyA6ICcnKTtcbiAgfTtcblxuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZ2V0VGV4dENvbnRlbnQpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMSksXG4gICAgICBpbml0aWFsVGV4dCA9IF91c2VTdGF0ZTJbMF07IC8vIFRoaXMgaXMgdGhlIGFjdHVhbCB0ZXh0IHJlbmRlcmluZyBib3VuZGFyeSB3aGVyZSB3ZSBpbnRlcmZhY2Ugd2l0aCB0aGUgRE9NXG4gIC8vIFRoZSB0ZXh0IGlzIG5vdCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSB2aXJ0dWFsIERPTSwgYXMgc2luY2Ugd2UgaGFuZGxlIGJhc2ljIGNoYXJhY3RlciBpbnNlcnRpb25zIG5hdGl2ZWx5LFxuICAvLyB1cGRhdGluZyB0aGUgRE9NIGlzIG5vdCBhIG9uZSB3YXkgZGF0YWZsb3cgYW55bW9yZS4gV2hhdCB3ZSBuZWVkIGhlcmUgaXMgbm90IHJlY29uY2lsaWF0aW9uIGFuZCBkaWZmaW5nXG4gIC8vIHdpdGggcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgdmlydHVhbCBET00sIGJ1dCByYXRoZXIgZGlmZmluZyB3aXRoIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnQsIGFuZCByZXBsYWNlIHRoZSBET00gPHNwYW4+IGNvbnRlbnRcbiAgLy8gZXhhY3RseSBpZiBhbmQgb25seSBpZiBpdHMgY3VycmVudCBjb250ZW50IGRvZXMgbm90IG1hdGNoIG91ciBjdXJyZW50IHZpcnR1YWwgRE9NLlxuICAvLyBPdGhlcndpc2UgdGhlIERPTSBUZXh0Tm9kZSB3b3VsZCBhbHdheXMgYmUgcmVwbGFjZWQgYnkgUmVhY3QgYXMgdGhlIHVzZXIgdHlwZXMsIHdoaWNoIGludGVyZmVyZXMgd2l0aCBuYXRpdmUgdGV4dCBmZWF0dXJlcyxcbiAgLy8gZWcgbWFrZXMgbmF0aXZlIHNwZWxsY2hlY2sgb3B0IG91dCBmcm9tIGNoZWNraW5nIHRoZSB0ZXh0IG5vZGUuXG4gIC8vIHVzZUxheW91dEVmZmVjdDogdXBkYXRpbmcgb3VyIHNwYW4gYmVmb3JlIGJyb3dzZXIgcGFpbnRcblxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIG51bGwgY29hbGVzY2luZyB0ZXh0IHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3Qgb3V0cHV0aW5nIFwibnVsbFwiIGFzIGEgc3RyaW5nIGluIHRoZSBleHRyZW1lIGNhc2UgaXQgaXMgbnVsbGlzaCBhdCBydW50aW1lXG4gICAgdmFyIHRleHRXaXRoVHJhaWxpbmcgPSBnZXRUZXh0Q29udGVudCgpO1xuXG4gICAgaWYgKHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnRleHRDb250ZW50ICE9PSB0ZXh0V2l0aFRyYWlsaW5nKSB7XG4gICAgICByZWYuY3VycmVudC50ZXh0Q29udGVudCA9IHRleHRXaXRoVHJhaWxpbmc7XG4gICAgfSAvLyBpbnRlbnRpb25hbGx5IG5vdCBzcGVjaWZ5aW5nIGRlcGVuZGVuY2llcywgc28gdGhhdCB0aGlzIGVmZmVjdCBydW5zIG9uIGV2ZXJ5IHJlbmRlclxuICAgIC8vIGFzIHRoaXMgZWZmZWN0aXZlbHkgcmVwbGFjZXMgXCJzcGVjaWZ5aW5nIHRoZSB0ZXh0IGluIHRoZSB2aXJ0dWFsIERPTSB1bmRlciB0aGUgPHNwYW4+IGJlbG93XCIgb24gZWFjaCByZW5kZXJcblxuICB9KTsgLy8gV2UgaW50ZW50aW9uYWxseSByZW5kZXIgYSBtZW1vaXplZCA8c3Bhbj4gdGhhdCBvbmx5IHJlY2VpdmVzIHRoZSBpbml0aWFsIHRleHQgY29udGVudCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgLy8gV2UgZGVmZXIgdG8gdGhlIGxheW91dCBlZmZlY3QgYWJvdmUgdG8gdXBkYXRlIHRoZSBgdGV4dENvbnRlbnRgIG9mIHRoZSBzcGFuIGVsZW1lbnQgd2hlbiBuZWVkZWQuXG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0JDEsIHtcbiAgICByZWY6IHJlZlxuICB9LCBpbml0aWFsVGV4dCk7XG59O1xuXG52YXIgTWVtb2l6ZWRUZXh0JDEgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyggLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtc3RyaW5nXCI6IHRydWUsXG4gICAgcmVmOiByZWZcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufSkpO1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXHJcbiAqL1xuXG52YXIgWmVyb1dpZHRoU3RyaW5nID0gZnVuY3Rpb24gWmVyb1dpZHRoU3RyaW5nKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gX3Byb3BzJGxlbmd0aCA9PT0gdm9pZCAwID8gMCA6IF9wcm9wcyRsZW5ndGgsXG4gICAgICBfcHJvcHMkaXNMaW5lQnJlYWsgPSBwcm9wcy5pc0xpbmVCcmVhayxcbiAgICAgIGlzTGluZUJyZWFrID0gX3Byb3BzJGlzTGluZUJyZWFrID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpc0xpbmVCcmVhayxcbiAgICAgIF9wcm9wcyRpc01hcmtQbGFjZWhvbCA9IHByb3BzLmlzTWFya1BsYWNlaG9sZGVyLFxuICAgICAgaXNNYXJrUGxhY2Vob2xkZXIgPSBfcHJvcHMkaXNNYXJrUGxhY2Vob2wgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGlzTWFya1BsYWNlaG9sO1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJzogaXNMaW5lQnJlYWsgPyAnbicgOiAneicsXG4gICAgJ2RhdGEtc2xhdGUtbGVuZ3RoJzogbGVuZ3RoXG4gIH07XG5cbiAgaWYgKGlzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJ10gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCAhSVNfQU5EUk9JRCB8fCAhaXNMaW5lQnJlYWsgPyBcIlxcdUZFRkZcIiA6IG51bGwsIGlzTGluZUJyZWFrID8gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpIDogbnVsbCk7XG59O1xuXG5mdW5jdGlvbiBkaXNjb25uZWN0UGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlcihwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLCByZWxlYXNlT2JzZXJ2ZXIpIHtcbiAgaWYgKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5kaXNjb25uZWN0KCk7XG5cbiAgICBpZiAocmVsZWFzZU9ic2VydmVyKSB7XG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhclRpbWVvdXRSZWYodGltZW91dFJlZikge1xuICBpZiAodGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfVxufVxuLyoqXHJcbiAqIEluZGl2aWR1YWwgbGVhdmVzIGluIGEgdGV4dCBub2RlIHdpdGggdW5pcXVlIGZvcm1hdHRpbmcuXHJcbiAqL1xuXG5cbnZhciBMZWFmID0gZnVuY3Rpb24gTGVhZihwcm9wcykge1xuICB2YXIgbGVhZiA9IHByb3BzLmxlYWYsXG4gICAgICBpc0xhc3QgPSBwcm9wcy5pc0xhc3QsXG4gICAgICB0ZXh0ID0gcHJvcHMudGV4dCxcbiAgICAgIHBhcmVudCA9IHByb3BzLnBhcmVudCxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyID0gcHJvcHMucmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBfcHJvcHMkcmVuZGVyTGVhZiA9IHByb3BzLnJlbmRlckxlYWYsXG4gICAgICByZW5kZXJMZWFmID0gX3Byb3BzJHJlbmRlckxlYWYgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KERlZmF1bHRMZWFmLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpO1xuICB9IDogX3Byb3BzJHJlbmRlckxlYWY7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNob3dQbGFjZWhvbGRlciA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRTaG93UGxhY2Vob2xkZXIgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgY2FsbGJhY2tQbGFjZWhvbGRlclJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwbGFjZWhvbGRlckVsKSB7XG4gICAgZGlzY29ubmVjdFBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciwgcGxhY2Vob2xkZXJFbCA9PSBudWxsKTtcblxuICAgIGlmIChwbGFjZWhvbGRlckVsID09IG51bGwpIHtcbiAgICAgIHZhciBfbGVhZiRvblBsYWNlaG9sZGVyUmU7XG5cbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UW1wiZGVsZXRlXCJdKGVkaXRvcik7XG4gICAgICAoX2xlYWYkb25QbGFjZWhvbGRlclJlID0gbGVhZi5vblBsYWNlaG9sZGVyUmVzaXplKSA9PT0gbnVsbCB8fCBfbGVhZiRvblBsYWNlaG9sZGVyUmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sZWFmJG9uUGxhY2Vob2xkZXJSZS5jYWxsKGxlYWYsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5zZXQoZWRpdG9yLCBwbGFjZWhvbGRlckVsKTtcblxuICAgICAgaWYgKCFwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9ic2VydmVyIGFuZCBvYnNlcnZlIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50LlxuICAgICAgICB2YXIgUmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgcmVzaXplT2JzZXJ2ZXIuUmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9sZWFmJG9uUGxhY2Vob2xkZXJSZTI7XG5cbiAgICAgICAgICAoX2xlYWYkb25QbGFjZWhvbGRlclJlMiA9IGxlYWYub25QbGFjZWhvbGRlclJlc2l6ZSkgPT09IG51bGwgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xlYWYkb25QbGFjZWhvbGRlclJlMi5jYWxsKGxlYWYsIHBsYWNlaG9sZGVyRWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUocGxhY2Vob2xkZXJFbCk7XG4gICAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gcGxhY2Vob2xkZXJFbDtcbiAgICB9XG4gIH0sIFtwbGFjZWhvbGRlclJlZiwgbGVhZiwgZWRpdG9yXSk7XG4gIHZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoU3RyaW5nLCB7XG4gICAgaXNMYXN0OiBpc0xhc3QsXG4gICAgbGVhZjogbGVhZixcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICB0ZXh0OiB0ZXh0XG4gIH0pO1xuICB2YXIgbGVhZklzUGxhY2Vob2xkZXIgPSBsZWFmW1BMQUNFSE9MREVSX1NZTUJPTF07XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGxlYWZJc1BsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAoIXNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBEZWxheSB0aGUgcGxhY2Vob2xkZXIgc28gaXQgd2lsbCBub3QgcmVuZGVyIGluIGEgc2VsZWN0aW9uXG4gICAgICAgIHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNldFNob3dQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgICBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9LCAzMDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXRSZWYoc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZik7XG4gICAgICBzZXRTaG93UGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0UmVmKHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYpO1xuICAgIH07XG4gIH0sIFtsZWFmSXNQbGFjZWhvbGRlciwgc2V0U2hvd1BsYWNlaG9sZGVyXSk7XG5cbiAgaWYgKGxlYWZJc1BsYWNlaG9sZGVyICYmIHNob3dQbGFjZWhvbGRlcikge1xuICAgIHZhciBwbGFjZWhvbGRlclByb3BzID0ge1xuICAgICAgY2hpbGRyZW46IGxlYWYucGxhY2Vob2xkZXIsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdkYXRhLXNsYXRlLXBsYWNlaG9sZGVyJzogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgIG9wYWNpdHk6ICcwLjMzMycsXG4gICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3VkZWNvZGUvcGxhdGUvaXNzdWVzLzIzMTVcbiAgICAgICAgICBXZWJraXRVc2VyTW9kaWZ5OiBJU19XRUJLSVQgPyAnaW5oZXJpdCcgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudEVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgcmVmOiBjYWxsYmFja1BsYWNlaG9sZGVyUmVmXG4gICAgICB9XG4gICAgfTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5GcmFnbWVudCwgbnVsbCwgcmVuZGVyUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJQcm9wcyksIGNoaWxkcmVuKTtcbiAgfSAvLyBDT01QQVQ6IEhhdmluZyB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVzIG9uIHRoZXNlIGxlYWYgZWxlbWVudHMgZW5zdXJlcyB0aGF0XG4gIC8vIGluIGNlcnRhaW4gbWlzYmVoYXZpbmcgYnJvd3NlcnMgdGhleSBhcmVuJ3Qgd2VpcmRseSBjbG9uZWQvZGVzdHJveWVkIGJ5XG4gIC8vIGNvbnRlbnRlZGl0YWJsZSBiZWhhdmlvcnMuICgyMDE5LzA1LzA4KVxuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbGVhZic6IHRydWVcbiAgfTtcbiAgcmV0dXJuIHJlbmRlckxlYWYoe1xuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxlYWY6IGxlYWYsXG4gICAgdGV4dDogdGV4dFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZExlYWYgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5tZW1vKExlYWYsIGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgc2xhdGUuVGV4dC5lcXVhbHMobmV4dC5sZWFmLCBwcmV2LmxlYWYpICYmIG5leHQubGVhZltQTEFDRUhPTERFUl9TWU1CT0xdID09PSBwcmV2LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXTtcbn0pO1xudmFyIERlZmF1bHRMZWFmID0gZnVuY3Rpb24gRGVmYXVsdExlYWYocHJvcHMpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBwcm9wcy5hdHRyaWJ1dGVzLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG59O1xuXG4vKipcclxuICogVGV4dC5cclxuICovXG5cbnZhciBUZXh0ID0gZnVuY3Rpb24gVGV4dChwcm9wcykge1xuICB2YXIgZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucyxcbiAgICAgIGlzTGFzdCA9IHByb3BzLmlzTGFzdCxcbiAgICAgIHBhcmVudCA9IHByb3BzLnBhcmVudCxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyID0gcHJvcHMucmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICByZW5kZXJMZWFmID0gcHJvcHMucmVuZGVyTGVhZixcbiAgICAgIHRleHQgPSBwcm9wcy50ZXh0O1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGxlYXZlcyA9IHNsYXRlLlRleHQuZGVjb3JhdGlvbnModGV4dCwgZGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIHRleHQpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZWFmID0gbGVhdmVzW2ldO1xuICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRMZWFmLCB7XG4gICAgICBpc0xhc3Q6IGlzTGFzdCAmJiBpID09PSBsZWF2ZXMubGVuZ3RoIC0gMSxcbiAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LmlkLCBcIi1cIikuY29uY2F0KGkpLFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgbGVhZjogbGVhZixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWZcbiAgICB9KSk7XG4gIH0gLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuXG5cbiAgdmFyIGNhbGxiYWNrUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNwYW4pIHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoc3Bhbikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHNwYW4pO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldCh0ZXh0LCBzcGFuKTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQoc3BhbiwgdGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVFtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5UW1wiZGVsZXRlXCJdKHRleHQpO1xuXG4gICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgRUxFTUVOVF9UT19OT0RFW1wiZGVsZXRlXCJdKHJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWYuY3VycmVudCA9IHNwYW47XG4gIH0sIFtyZWYsIGVkaXRvciwga2V5LCB0ZXh0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ0ZXh0XCIsXG4gICAgcmVmOiBjYWxsYmFja1JlZlxuICB9LCBjaGlsZHJlbik7XG59O1xuXG52YXIgTWVtb2l6ZWRUZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10ubWVtbyhUZXh0LCBmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICByZXR1cm4gbmV4dC5wYXJlbnQgPT09IHByZXYucGFyZW50ICYmIG5leHQuaXNMYXN0ID09PSBwcmV2LmlzTGFzdCAmJiBuZXh0LnJlbmRlckxlYWYgPT09IHByZXYucmVuZGVyTGVhZiAmJiBuZXh0LnJlbmRlclBsYWNlaG9sZGVyID09PSBwcmV2LnJlbmRlclBsYWNlaG9sZGVyICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0ICYmIGlzVGV4dERlY29yYXRpb25zRXF1YWwobmV4dC5kZWNvcmF0aW9ucywgcHJldi5kZWNvcmF0aW9ucyk7XG59KTtcblxuLyoqXHJcbiAqIEVsZW1lbnQuXHJcbiAqL1xuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIEVsZW1lbnQocHJvcHMpIHtcbiAgdmFyIGRlY29yYXRpb25zID0gcHJvcHMuZGVjb3JhdGlvbnMsXG4gICAgICBlbGVtZW50ID0gcHJvcHMuZWxlbWVudCxcbiAgICAgIF9wcm9wcyRyZW5kZXJFbGVtZW50ID0gcHJvcHMucmVuZGVyRWxlbWVudCxcbiAgICAgIHJlbmRlckVsZW1lbnQgPSBfcHJvcHMkcmVuZGVyRWxlbWVudCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChEZWZhdWx0RWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgcCkpO1xuICB9IDogX3Byb3BzJHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJQbGFjZWhvbGRlciA9IHByb3BzLnJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgcmVuZGVyTGVhZiA9IHByb3BzLnJlbmRlckxlYWYsXG4gICAgICBzZWxlY3Rpb24gPSBwcm9wcy5zZWxlY3Rpb247XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVhZE9ubHkgPSB1c2VSZWFkT25seSgpO1xuICB2YXIgaXNJbmxpbmUgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCk7XG4gIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgZWxlbWVudCk7XG4gIHZhciByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAocmVmKSB7XG4gICAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcblxuICAgIGlmIChyZWYpIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5zZXQoa2V5LCByZWYpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlbGVtZW50LCByZWYpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlRbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVFtcImRlbGV0ZVwiXShlbGVtZW50KTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIGtleSwgZWxlbWVudF0pO1xuICB2YXIgY2hpbGRyZW4gPSB1c2VDaGlsZHJlbih7XG4gICAgZGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxuICAgIG5vZGU6IGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb246IHNlbGVjdGlvblxuICB9KTsgLy8gQXR0cmlidXRlcyB0aGF0IHRoZSBkZXZlbG9wZXIgbXVzdCBtaXggaW50byB0aGUgZWxlbWVudCBpbiB0aGVpclxuICAvLyBjdXN0b20gbm9kZSByZW5kZXJlciBjb21wb25lbnQuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbm9kZSc6ICdlbGVtZW50JyxcbiAgICByZWY6IHJlZlxuICB9O1xuXG4gIGlmIChpc0lubGluZSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtaW5saW5lJ10gPSB0cnVlO1xuICB9IC8vIElmIGl0J3MgYSBibG9jayBub2RlIHdpdGggaW5saW5lIGNoaWxkcmVuLCBhZGQgdGhlIHByb3BlciBgZGlyYCBhdHRyaWJ1dGVcbiAgLy8gZm9yIHRleHQgZGlyZWN0aW9uLlxuXG5cbiAgaWYgKCFpc0lubGluZSAmJiBzbGF0ZS5FZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgdmFyIHRleHQgPSBzbGF0ZS5Ob2RlLnN0cmluZyhlbGVtZW50KTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uX19kZWZhdWx0WydkZWZhdWx0J10odGV4dCk7XG5cbiAgICBpZiAoZGlyID09PSAncnRsJykge1xuICAgICAgYXR0cmlidXRlcy5kaXIgPSBkaXI7XG4gICAgfVxuICB9IC8vIElmIGl0J3MgYSB2b2lkIG5vZGUsIHdyYXAgdGhlIGNoaWxkcmVuIGluIGV4dHJhIHZvaWQtc3BlY2lmaWMgZWxlbWVudHMuXG5cblxuICBpZiAoc2xhdGUuRWRpdG9yLmlzVm9pZChlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS12b2lkJ10gPSB0cnVlO1xuXG4gICAgaWYgKCFyZWFkT25seSAmJiBpc0lubGluZSkge1xuICAgICAgYXR0cmlidXRlcy5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgVGFnID0gaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcblxuICAgIHZhciBfTm9kZSR0ZXh0cyA9IHNsYXRlLk5vZGUudGV4dHMoZWxlbWVudCksXG4gICAgICAgIF9Ob2RlJHRleHRzMiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJHRleHRzLCAxKSxcbiAgICAgICAgX05vZGUkdGV4dHMyJCA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJHRleHRzMlswXSwgMSksXG4gICAgICAgIF90ZXh0ID0gX05vZGUkdGV4dHMyJFswXTtcblxuICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgIFwiZGF0YS1zbGF0ZS1zcGFjZXJcIjogdHJ1ZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogJzAnLFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBkZWNvcmF0aW9uczogW10sXG4gICAgICBpc0xhc3Q6IGZhbHNlLFxuICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgdGV4dDogX3RleHRcbiAgICB9KSk7XG4gICAgTk9ERV9UT19JTkRFWC5zZXQoX3RleHQsIDApO1xuICAgIE5PREVfVE9fUEFSRU5ULnNldChfdGV4dCwgZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyRWxlbWVudCh7XG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5tZW1vKEVsZW1lbnQsIGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gIHJldHVybiBwcmV2LmVsZW1lbnQgPT09IG5leHQuZWxlbWVudCAmJiBwcmV2LnJlbmRlckVsZW1lbnQgPT09IG5leHQucmVuZGVyRWxlbWVudCAmJiBwcmV2LnJlbmRlckxlYWYgPT09IG5leHQucmVuZGVyTGVhZiAmJiBwcmV2LnJlbmRlclBsYWNlaG9sZGVyID09PSBuZXh0LnJlbmRlclBsYWNlaG9sZGVyICYmIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwocHJldi5kZWNvcmF0aW9ucywgbmV4dC5kZWNvcmF0aW9ucykgJiYgKHByZXYuc2VsZWN0aW9uID09PSBuZXh0LnNlbGVjdGlvbiB8fCAhIXByZXYuc2VsZWN0aW9uICYmICEhbmV4dC5zZWxlY3Rpb24gJiYgc2xhdGUuUmFuZ2UuZXF1YWxzKHByZXYuc2VsZWN0aW9uLCBuZXh0LnNlbGVjdGlvbikpO1xufSk7XG4vKipcclxuICogVGhlIGRlZmF1bHQgZWxlbWVudCByZW5kZXJlci5cclxuICovXG5cbnZhciBEZWZhdWx0RWxlbWVudCA9IGZ1bmN0aW9uIERlZmF1bHRFbGVtZW50KHByb3BzKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gcHJvcHMuYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBlbGVtZW50ID0gcHJvcHMuZWxlbWVudDtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBUYWcgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyAnc3BhbicgOiAnZGl2JztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoVGFnLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGRlY29yYXRlYCBwcm9wIG9mIHRoZSBlZGl0YWJsZS5cclxuICovXG5cbnZhciBEZWNvcmF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXTtcbn0pO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgZGVjb3JhdGVgIHByb3Agb2YgdGhlIGVkaXRhYmxlLlxyXG4gKi9cblxudmFyIHVzZURlY29yYXRlID0gZnVuY3Rpb24gdXNlRGVjb3JhdGUoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KERlY29yYXRlQ29udGV4dCk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgU2VsZWN0ZWRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgdXNlU2VsZWN0ZWQgPSBmdW5jdGlvbiB1c2VTZWxlY3RlZCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoU2VsZWN0ZWRDb250ZXh0KTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcclxuICogQ2hpbGRyZW4uXHJcbiAqL1xuXG52YXIgdXNlQ2hpbGRyZW4gPSBmdW5jdGlvbiB1c2VDaGlsZHJlbihwcm9wcykge1xuICB2YXIgZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucyxcbiAgICAgIG5vZGUgPSBwcm9wcy5ub2RlLFxuICAgICAgcmVuZGVyRWxlbWVudCA9IHByb3BzLnJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJQbGFjZWhvbGRlciA9IHByb3BzLnJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgcmVuZGVyTGVhZiA9IHByb3BzLnJlbmRlckxlYWYsXG4gICAgICBzZWxlY3Rpb24gPSBwcm9wcy5zZWxlY3Rpb247XG4gIHZhciBkZWNvcmF0ZSA9IHVzZURlY29yYXRlKCk7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgaXNMZWFmQmxvY2sgPSBzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpICYmIHNsYXRlLkVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXRoLmNvbmNhdChpKTtcbiAgICB2YXIgbiA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBuKTtcbiAgICB2YXIgcmFuZ2UgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwKTtcbiAgICB2YXIgc2VsID0gc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgZHMgPSBkZWNvcmF0ZShbbiwgcF0pO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoZGVjb3JhdGlvbnMpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgZGVjID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBkID0gc2xhdGUuUmFuZ2UuaW50ZXJzZWN0aW9uKGRlYywgcmFuZ2UpO1xuXG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgZHMucHVzaChkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobikpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoU2VsZWN0ZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIGtleTogXCJwcm92aWRlci1cIi5jb25jYXQoa2V5LmlkKSxcbiAgICAgICAgdmFsdWU6ICEhc2VsXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KE1lbW9pemVkRWxlbWVudCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGVsZW1lbnQ6IG4sXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsXG4gICAgICB9KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICBpc0xhc3Q6IGlzTGVhZkJsb2NrICYmIGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHRleHQ6IG5cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBOT0RFX1RPX0lOREVYLnNldChuLCBpKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQobiwgbm9kZSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgUmVhZE9ubHlDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlUmVhZE9ubHkgPSBmdW5jdGlvbiB1c2VSZWFkT25seSgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUmVhZE9ubHlDb250ZXh0KTtcbn07XG5cbnZhciBTbGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKi9cblxudmFyIHVzZVNsYXRlID0gZnVuY3Rpb24gdXNlU2xhdGUoKSB7XG4gIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciBlZGl0b3IgPSBjb250ZXh0LmVkaXRvcjtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG52YXIgdXNlU2xhdGVXaXRoViA9IGZ1bmN0aW9uIHVzZVNsYXRlV2l0aFYoKSB7XG4gIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuZnVuY3Rpb24gdXNlVHJhY2tVc2VySW5wdXQoKSB7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVjZWl2ZWRVc2VySW5wdXQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB2YXIgYW5pbWF0aW9uRnJhbWVJZFJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgdmFyIG9uVXNlcklucHV0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCA9IHRydWU7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQpO1xuICAgIGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCA9IGZhbHNlO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICByZWNlaXZlZFVzZXJJbnB1dDogcmVjZWl2ZWRVc2VySW5wdXQsXG4gICAgb25Vc2VySW5wdXQ6IG9uVXNlcklucHV0XG4gIH07XG59XG5cbnZhciBUUklQTEVfQ0xJQ0sgPSAzO1xuXG4vKipcclxuICogSG90a2V5IG1hcHBpbmdzIGZvciBlYWNoIHBsYXRmb3JtLlxyXG4gKi9cblxudmFyIEhPVEtFWVMgPSB7XG4gIGJvbGQ6ICdtb2QrYicsXG4gIGNvbXBvc2U6IFsnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3VwJywgJ2JhY2tzcGFjZScsICdlbnRlciddLFxuICBtb3ZlQmFja3dhcmQ6ICdsZWZ0JyxcbiAgbW92ZUZvcndhcmQ6ICdyaWdodCcsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdjdHJsK2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdjdHJsK3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6ICdzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlRm9yd2FyZDogJ3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRCYWNrd2FyZDogJ3NoaWZ0K2xlZnQnLFxuICBleHRlbmRGb3J3YXJkOiAnc2hpZnQrcmlnaHQnLFxuICBpdGFsaWM6ICdtb2QraScsXG4gIGluc2VydFNvZnRCcmVhazogJ3NoaWZ0K2VudGVyJyxcbiAgc3BsaXRCbG9jazogJ2VudGVyJyxcbiAgdW5kbzogJ21vZCt6J1xufTtcbnZhciBBUFBMRV9IT1RLRVlTID0ge1xuICBtb3ZlTGluZUJhY2t3YXJkOiAnb3B0K3VwJyxcbiAgbW92ZUxpbmVGb3J3YXJkOiAnb3B0K2Rvd24nLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnb3B0K2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdvcHQrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogWydjdHJsK2JhY2tzcGFjZScsICdjdHJsK2gnXSxcbiAgZGVsZXRlRm9yd2FyZDogWydjdHJsK2RlbGV0ZScsICdjdHJsK2QnXSxcbiAgZGVsZXRlTGluZUJhY2t3YXJkOiAnY21kK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVMaW5lRm9yd2FyZDogWydjbWQrc2hpZnQ/K2RlbGV0ZScsICdjdHJsK2snXSxcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnb3B0K3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ29wdCtzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kTGluZUJhY2t3YXJkOiAnb3B0K3NoaWZ0K3VwJyxcbiAgZXh0ZW5kTGluZUZvcndhcmQ6ICdvcHQrc2hpZnQrZG93bicsXG4gIHJlZG86ICdjbWQrc2hpZnQreicsXG4gIHRyYW5zcG9zZUNoYXJhY3RlcjogJ2N0cmwrdCdcbn07XG52YXIgV0lORE9XU19IT1RLRVlTID0ge1xuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdjdHJsK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ2N0cmwrc2hpZnQ/K2RlbGV0ZScsXG4gIHJlZG86IFsnY3RybCt5JywgJ2N0cmwrc2hpZnQreiddXG59O1xuLyoqXHJcbiAqIENyZWF0ZSBhIHBsYXRmb3JtLWF3YXJlIGhvdGtleSBjaGVja2VyLlxyXG4gKi9cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShrZXkpIHtcbiAgdmFyIGdlbmVyaWMgPSBIT1RLRVlTW2tleV07XG4gIHZhciBhcHBsZSA9IEFQUExFX0hPVEtFWVNba2V5XTtcbiAgdmFyIHdpbmRvd3MgPSBXSU5ET1dTX0hPVEtFWVNba2V5XTtcbiAgdmFyIGlzR2VuZXJpYyA9IGdlbmVyaWMgJiYgaXNIb3RrZXkuaXNIb3RrZXkoZ2VuZXJpYyk7XG4gIHZhciBpc0FwcGxlID0gYXBwbGUgJiYgaXNIb3RrZXkuaXNIb3RrZXkoYXBwbGUpO1xuICB2YXIgaXNXaW5kb3dzID0gd2luZG93cyAmJiBpc0hvdGtleS5pc0hvdGtleSh3aW5kb3dzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChpc0dlbmVyaWMgJiYgaXNHZW5lcmljKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKElTX0FQUExFICYmIGlzQXBwbGUgJiYgaXNBcHBsZShldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghSVNfQVBQTEUgJiYgaXNXaW5kb3dzICYmIGlzV2luZG93cyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG4vKipcclxuICogSG90a2V5cy5cclxuICovXG5cblxudmFyIEhvdGtleXMgPSB7XG4gIGlzQm9sZDogY3JlYXRlKCdib2xkJyksXG4gIGlzQ29tcG9zZTogY3JlYXRlKCdjb21wb3NlJyksXG4gIGlzTW92ZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVCYWNrd2FyZCcpLFxuICBpc01vdmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlQmFja3dhcmQnKSxcbiAgaXNEZWxldGVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlTGluZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUZvcndhcmQnKSxcbiAgaXNEZWxldGVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEJhY2t3YXJkJyksXG4gIGlzRGVsZXRlV29yZEZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRCYWNrd2FyZCcpLFxuICBpc0V4dGVuZEZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kRm9yd2FyZCcpLFxuICBpc0V4dGVuZExpbmVCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRMaW5lRm9yd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lRm9yd2FyZCcpLFxuICBpc0l0YWxpYzogY3JlYXRlKCdpdGFsaWMnKSxcbiAgaXNNb3ZlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVMaW5lQmFja3dhcmQnKSxcbiAgaXNNb3ZlTGluZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVGb3J3YXJkJyksXG4gIGlzTW92ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdtb3ZlV29yZEJhY2t3YXJkJyksXG4gIGlzTW92ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ21vdmVXb3JkRm9yd2FyZCcpLFxuICBpc1JlZG86IGNyZWF0ZSgncmVkbycpLFxuICBpc1NvZnRCcmVhazogY3JlYXRlKCdpbnNlcnRTb2Z0QnJlYWsnKSxcbiAgaXNTcGxpdEJsb2NrOiBjcmVhdGUoJ3NwbGl0QmxvY2snKSxcbiAgaXNUcmFuc3Bvc2VDaGFyYWN0ZXI6IGNyZWF0ZSgndHJhbnNwb3NlQ2hhcmFjdGVyJyksXG4gIGlzVW5kbzogY3JlYXRlKCd1bmRvJylcbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IHVud3JhcEV4cG9ydHMoY3JlYXRlQ2xhc3MpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgaW5oZXJpdHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfaW5oZXJpdHMgPSB1bndyYXBFeHBvcnRzKGluaGVyaXRzKTtcblxudmFyIF90eXBlb2ZfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKF90eXBlb2ZfMSk7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhc3NlcnRUaGlzSW5pdGlhbGl6ZWQpO1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBfdHlwZW9mID0gX3R5cGVvZl8xW1wiZGVmYXVsdFwiXTtcblxuXG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IHVud3JhcEV4cG9ydHMocG9zc2libGVDb25zdHJ1Y3RvclJldHVybik7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSB1bndyYXBFeHBvcnRzKGdldFByb3RvdHlwZU9mKTtcblxudmFyIGNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCkge1xuICB2YXIgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBidWZmZXJlZE11dGF0aW9ucyA9IFtdO1xuICB9O1xuXG4gIHZhciByZWdpc3Rlck11dGF0aW9ucyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIHZhciBfYnVmZmVyZWRNdXRhdGlvbnM7XG5cbiAgICBpZiAoIXJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tlZE11dGF0aW9ucyA9IG11dGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICByZXR1cm4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKTtcbiAgICB9KTtcblxuICAgIChfYnVmZmVyZWRNdXRhdGlvbnMgPSBidWZmZXJlZE11dGF0aW9ucykucHVzaC5hcHBseShfYnVmZmVyZWRNdXRhdGlvbnMsIF90b0NvbnN1bWFibGVBcnJheSh0cmFja2VkTXV0YXRpb25zKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzdG9yZURPTSgpIHtcbiAgICBpZiAoYnVmZmVyZWRNdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgYnVmZmVyZWRNdXRhdGlvbnMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlc3RvcmUgdGhlIERPTSBmb3IgY2hhcmFjdGVyRGF0YSBtdXRhdGlvbnNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgaW50ZXJydXB0cyB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBtdXRhdGlvbi50YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIG11dGF0aW9uLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIG11dGF0aW9uLnRhcmdldC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gQ2xlYXIgYnVmZmVyZWQgbXV0YXRpb25zIHRvIGVuc3VyZSB3ZSBkb24ndCB1bmRvIHRoZW0gdHdpY2VcblxuICAgICAgY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlZ2lzdGVyTXV0YXRpb25zOiByZWdpc3Rlck11dGF0aW9ucyxcbiAgICByZXN0b3JlRE9NOiByZXN0b3JlRE9NLFxuICAgIGNsZWFyOiBjbGVhclxuICB9O1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG52YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTsgLy8gV2UgaGF2ZSB0byB1c2UgYSBjbGFzcyBjb21wb25lbnQgaGVyZSBzaW5jZSB3ZSByZWx5IG9uIGBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZWAgd2hpY2ggaGFzIG5vIEZDIGVxdWl2YWxlbnRcbi8vIHRvIHJ1biBjb2RlIHN5bmNocm9ub3VzbHkgaW1tZWRpYXRlbHkgYmVmb3JlIHJlYWN0IGNvbW1pdHMgdGhlIGNvbXBvbmVudCB1cGRhdGUgdG8gdGhlIERPTS5cblxudmFyIFJlc3RvcmVET01Db21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlc3RvcmVET01Db21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVzdG9yZURPTUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVzdG9yZURPTUNvbXBvbmVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzdG9yZURPTUNvbXBvbmVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIF90aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgIF90aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXN0b3JlRE9NQ29tcG9uZW50LCBbe1xuICAgIGtleTogXCJvYnNlcnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ic2VydmUoKSB7XG4gICAgICB2YXIgX3RoaXMkbXV0YXRpb25PYnNlcnZlO1xuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZTtcblxuICAgICAgaWYgKCFub2RlLmN1cnJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICAgIH1cblxuICAgICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZSA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbk9ic2VydmUub2JzZXJ2ZShub2RlLmN1cnJlbnQsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHJlY2VpdmVkVXNlcklucHV0ID0gdGhpcy5wcm9wcy5yZWNlaXZlZFVzZXJJbnB1dDtcbiAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlcihlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KTtcbiAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMubWFuYWdlci5yZWdpc3Rlck11dGF0aW9ucyk7XG4gICAgICB0aGlzLm9ic2VydmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMkbXV0YXRpb25PYnNlcnZlMiwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMywgX3RoaXMkbWFuYWdlcjI7XG5cbiAgICAgIHZhciBwZW5kaW5nTXV0YXRpb25zID0gKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIudGFrZVJlY29yZHMoKTtcblxuICAgICAgaWYgKHBlbmRpbmdNdXRhdGlvbnMgIT09IG51bGwgJiYgcGVuZGluZ011dGF0aW9ucyAhPT0gdm9pZCAwICYmIHBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfdGhpcyRtYW5hZ2VyO1xuXG4gICAgICAgIChfdGhpcyRtYW5hZ2VyID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKHBlbmRpbmdNdXRhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlMyA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlMy5kaXNjb25uZWN0KCk7XG4gICAgICAoX3RoaXMkbWFuYWdlcjIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyMi5yZXN0b3JlRE9NKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyRtYW5hZ2VyMztcblxuICAgICAgKF90aGlzJG1hbmFnZXIzID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbWFuYWdlcjMuY2xlYXIoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmU0O1xuXG4gICAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlNC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzdG9yZURPTUNvbXBvbmVudDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVzdG9yZURPTUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG52YXIgUmVzdG9yZURPTSA9IElTX0FORFJPSUQgPyBSZXN0b3JlRE9NQ29tcG9uZW50IDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1wiYXV0b0ZvY3VzXCIsIFwiZGVjb3JhdGVcIiwgXCJvbkRPTUJlZm9yZUlucHV0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlbmRlckVsZW1lbnRcIiwgXCJyZW5kZXJMZWFmXCIsIFwicmVuZGVyUGxhY2Vob2xkZXJcIiwgXCJzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1wiLCBcInN0eWxlXCIsIFwiYXNcIiwgXCJkaXNhYmxlRGVmYXVsdFN0eWxlc1wiXSxcbiAgICBfZXhjbHVkZWQyID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBDaGlsZHJlbiA9IGZ1bmN0aW9uIENoaWxkcmVuKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uRnJhZ21lbnQsIG51bGwsIHVzZUNoaWxkcmVuKHByb3BzKSk7XG59O1xuLyoqXHJcbiAqIEVkaXRhYmxlLlxyXG4gKi9cblxuXG52YXIgRWRpdGFibGUgPSBmdW5jdGlvbiBFZGl0YWJsZShwcm9wcykge1xuICB2YXIgZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFBsYWNlaG9sZGVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpO1xuICB9LCBbXSk7XG5cbiAgdmFyIGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIF9wcm9wcyRkZWNvcmF0ZSA9IHByb3BzLmRlY29yYXRlLFxuICAgICAgZGVjb3JhdGUgPSBfcHJvcHMkZGVjb3JhdGUgPT09IHZvaWQgMCA/IGRlZmF1bHREZWNvcmF0ZSA6IF9wcm9wcyRkZWNvcmF0ZSxcbiAgICAgIHByb3BzT25ET01CZWZvcmVJbnB1dCA9IHByb3BzLm9uRE9NQmVmb3JlSW5wdXQsXG4gICAgICBwbGFjZWhvbGRlciA9IHByb3BzLnBsYWNlaG9sZGVyLFxuICAgICAgX3Byb3BzJHJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHksXG4gICAgICByZWFkT25seSA9IF9wcm9wcyRyZWFkT25seSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcmVhZE9ubHksXG4gICAgICByZW5kZXJFbGVtZW50ID0gcHJvcHMucmVuZGVyRWxlbWVudCxcbiAgICAgIHJlbmRlckxlYWYgPSBwcm9wcy5yZW5kZXJMZWFmLFxuICAgICAgX3Byb3BzJHJlbmRlclBsYWNlaG9sID0gcHJvcHMucmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICByZW5kZXJQbGFjZWhvbGRlciA9IF9wcm9wcyRyZW5kZXJQbGFjZWhvbCA9PT0gdm9pZCAwID8gZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyIDogX3Byb3BzJHJlbmRlclBsYWNlaG9sLFxuICAgICAgX3Byb3BzJHNjcm9sbFNlbGVjdGlvID0gcHJvcHMuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IF9wcm9wcyRzY3JvbGxTZWxlY3RpbyA9PT0gdm9pZCAwID8gZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3IDogX3Byb3BzJHNjcm9sbFNlbGVjdGlvLFxuICAgICAgX3Byb3BzJHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICB1c2VyU3R5bGUgPSBfcHJvcHMkc3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHN0eWxlLFxuICAgICAgX3Byb3BzJGFzID0gcHJvcHMuYXMsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkYXMgPT09IHZvaWQgMCA/ICdkaXYnIDogX3Byb3BzJGFzLFxuICAgICAgX3Byb3BzJGRpc2FibGVEZWZhdWx0ID0gcHJvcHMuZGlzYWJsZURlZmF1bHRTdHlsZXMsXG4gICAgICBkaXNhYmxlRGVmYXVsdFN0eWxlcyA9IF9wcm9wcyRkaXNhYmxlRGVmYXVsdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZURlZmF1bHQsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkMSk7XG5cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlKCk7IC8vIFJlcmVuZGVyIGVkaXRvciB3aGVuIGNvbXBvc2l0aW9uIHN0YXR1cyBjaGFuZ2VkXG5cbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgaXNDb21wb3NpbmcgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0SXNDb21wb3NpbmcgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBkZWZlcnJlZE9wZXJhdGlvbnMgPSBSZWFjdC51c2VSZWYoW10pO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoKSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIHBsYWNlaG9sZGVySGVpZ2h0ID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldFBsYWNlaG9sZGVySGVpZ2h0ID0gX3VzZVN0YXRlNFsxXTtcblxuICB2YXIgX3VzZVRyYWNrVXNlcklucHV0ID0gdXNlVHJhY2tVc2VySW5wdXQoKSxcbiAgICAgIG9uVXNlcklucHV0ID0gX3VzZVRyYWNrVXNlcklucHV0Lm9uVXNlcklucHV0LFxuICAgICAgcmVjZWl2ZWRVc2VySW5wdXQgPSBfdXNlVHJhY2tVc2VySW5wdXQucmVjZWl2ZWRVc2VySW5wdXQ7XG5cbiAgdmFyIF91c2VSZWR1Y2VyID0gUmVhY3QudXNlUmVkdWNlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzICsgMTtcbiAgfSwgMCksXG4gICAgICBfdXNlUmVkdWNlcjIgPSBfc2xpY2VkVG9BcnJheShfdXNlUmVkdWNlciwgMiksXG4gICAgICBmb3JjZVJlbmRlciA9IF91c2VSZWR1Y2VyMlsxXTtcblxuICBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLnNldChlZGl0b3IsIGZvcmNlUmVuZGVyKTsgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlIG9uIGVhY2ggcmVuZGVyLlxuXG4gIElTX1JFQURfT05MWS5zZXQoZWRpdG9yLCByZWFkT25seSk7IC8vIEtlZXAgdHJhY2sgb2Ygc29tZSBzdGF0ZSBmb3IgdGhlIGV2ZW50IGhhbmRsZXIgbG9naWMuXG5cbiAgdmFyIHN0YXRlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzRHJhZ2dpbmdJbnRlcm5hbGx5OiBmYWxzZSxcbiAgICAgIGlzVXBkYXRpbmdTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgbGF0ZXN0RWxlbWVudDogbnVsbCxcbiAgICAgIGhhc01hcmtQbGFjZWhvbGRlcjogZmFsc2VcbiAgICB9O1xuICB9LCBbXSk7IC8vIFRoZSBhdXRvRm9jdXMgVGV4dGFyZWFIVE1MQXR0cmlidXRlIGRvZXNuJ3QgZG8gYW55dGhpbmcgb24gYSBkaXYsIHNvIGl0XG4gIC8vIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQuXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVmLmN1cnJlbnQgJiYgYXV0b0ZvY3VzKSB7XG4gICAgICByZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2F1dG9Gb2N1c10pO1xuICAvKipcclxuICAgKiBUaGUgQW5kcm9pZElucHV0TWFuYWdlciBvYmplY3QgaGFzIGEgY3ljbGljYWwgZGVwZW5kZW5jeSBvbiBvbkRPTVNlbGVjdGlvbkNoYW5nZVxyXG4gICAqXHJcbiAgICogSXQgaXMgZGVmaW5lZCBhcyBhIHJlZmVyZW5jZSB0byBzaW1wbGlmeSBob29rIGRlcGVuZGVuY2llcyBhbmQgY2xhcmlmeSB0aGF0XHJcbiAgICogaXQgbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQuXHJcbiAgICovXG5cbiAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYgPSBSZWFjdC51c2VSZWYoKTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYHNlbGVjdGlvbmNoYW5nZWAgZXZlbnQgdG8gYmUgYWJsZSB0byB1cGRhdGUgYW55IHRpbWVcbiAgLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgb25TZWxlY3RgIGlzIGxlYWt5XG4gIC8vIGFuZCBub24tc3RhbmRhcmQgc28gaXQgZG9lc24ndCBmaXJlIHVudGlsIGFmdGVyIGEgc2VsZWN0aW9uIGhhcyBiZWVuXG4gIC8vIHJlbGVhc2VkLiBUaGlzIGNhdXNlcyBpc3N1ZXMgaW4gc2l0dWF0aW9ucyB3aGVyZSBhbm90aGVyIGNoYW5nZSBoYXBwZW5zXG4gIC8vIHdoaWxlIGEgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQuXG5cbiAgdmFyIG9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRocm90dGxlX19kZWZhdWx0WydkZWZhdWx0J10oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXIgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmICgoSVNfQU5EUk9JRCB8fCAhUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkgJiYgKCFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaXNGbHVzaGluZygpKSAmJiAhc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgSVNfRk9DVVNFRFtcImRlbGV0ZVwiXShlZGl0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gc2xhdGUuVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICAgIHZhciBhbmNob3JOb2RlU2VsZWN0YWJsZSA9IFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgYW5jaG9yTm9kZSkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCBhbmNob3JOb2RlKTtcbiAgICAgICAgdmFyIGZvY3VzTm9kZVNlbGVjdGFibGUgPSBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGZvY3VzTm9kZSkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCBmb2N1c05vZGUpO1xuXG4gICAgICAgIGlmIChhbmNob3JOb2RlU2VsZWN0YWJsZSAmJiBmb2N1c05vZGVTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpICYmICEoYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5oYXNQZW5kaW5nQ2hhbmdlcygpKSAmJiAhKGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaXNGbHVzaGluZygpKSkge1xuICAgICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGVzZWxlY3QgdGhlIGVkaXRvciBpZiB0aGUgZG9tIHNlbGVjdGlvbiBpcyBub3Qgc2VsZWN0YWJsZSBpbiByZWFkb25seSBtb2RlXG5cblxuICAgICAgICBpZiAocmVhZE9ubHkgJiYgKCFhbmNob3JOb2RlU2VsZWN0YWJsZSB8fCAhZm9jdXNOb2RlU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9LCBbZWRpdG9yLCByZWFkT25seSwgc3RhdGVdKTtcbiAgdmFyIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVib3VuY2VfX2RlZmF1bHRbJ2RlZmF1bHQnXShvbkRPTVNlbGVjdGlvbkNoYW5nZSwgMCk7XG4gIH0sIFtvbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQgPSB1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyKHtcbiAgICBub2RlOiByZWYsXG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2U6IG9uRE9NU2VsZWN0aW9uQ2hhbmdlLFxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2U6IHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclIsIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjI7XG5cbiAgICAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG4gICAgdmFyIHdpbmRvdztcblxuICAgIGlmIChyZWYuY3VycmVudCAmJiAod2luZG93ID0gZ2V0RGVmYXVsdFZpZXcocmVmLmN1cnJlbnQpKSkge1xuICAgICAgRURJVE9SX1RPX1dJTkRPVy5zZXQoZWRpdG9yLCB3aW5kb3cpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLmN1cnJlbnQsIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE5PREVfVE9fRUxFTUVOVFtcImRlbGV0ZVwiXShlZGl0b3IpO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIGluIHN5bmMuXG5cblxuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWRvbVNlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikgfHwgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUiA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX2FuZHJvaWRJbnB1dE1hbmFnZXJSICE9PSB2b2lkIDAgJiYgX2FuZHJvaWRJbnB1dE1hbmFnZXJSLmhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXREb21TZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXREb21TZWxlY3Rpb24oZm9yY2VDaGFuZ2UpIHtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb24gPSBkb21TZWxlY3Rpb24udHlwZSAhPT0gJ05vbmUnOyAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBwcm9wZXJseSB1bnNldCwgd2UncmUgZG9uZS5cblxuICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgIWhhc0RvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEdldCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGVcblxuXG4gICAgICB2YXIgZm9jdXNOb2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgIHZhciBhbmNob3JOb2RlOyAvLyBDT01QQVQ6IEluIGZpcmVmb3ggdGhlIG5vcm1hbCBzZWxldGlvbiB3YXkgZG9lcyBub3Qgd29ya1xuICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzU0ODYjaXNzdWUtMTgyMDcyMDIyMylcblxuICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIHZhciBsYXN0UmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCAtIDEpOyAvLyBSaWdodCB0byBsZWZ0XG5cbiAgICAgICAgaWYgKGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICBhbmNob3JOb2RlID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgfSAvLyB2ZXJpZnkgdGhhdCB0aGUgZG9tIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yXG5cblxuICAgICAgdmFyIGVkaXRvckVsZW1lbnQgPSBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IGZhbHNlO1xuXG4gICAgICBpZiAoZWRpdG9yRWxlbWVudC5jb250YWlucyhhbmNob3JOb2RlKSAmJiBlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSB0cnVlO1xuICAgICAgfSAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yIGFuZCB0aGUgZWRpdG9yIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGNvcnJlY3QsIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKGhhc0RvbVNlbGVjdGlvbiAmJiBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciAmJiBzZWxlY3Rpb24gJiYgIWZvcmNlQ2hhbmdlKSB7XG4gICAgICAgIHZhciBzbGF0ZVJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogdHJ1ZSxcbiAgICAgICAgICAvLyBkb21TZWxlY3Rpb24gaXMgbm90IG5lY2Vzc2FyaWx5IGEgdmFsaWQgU2xhdGUgcmFuZ2VcbiAgICAgICAgICAvLyAoZS5nLiB3aGVuIGNsaWNraW5nIG9uIGNvbnRlbnRFZGl0YWJsZTpmYWxzZSBlbGVtZW50KVxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNsYXRlUmFuZ2UgJiYgc2xhdGUuUmFuZ2UuZXF1YWxzKHNsYXRlUmFuZ2UsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgX2FuY2hvck5vZGUsIF9hbmNob3JOb2RlJHBhcmVudEVsZTtcblxuICAgICAgICAgIGlmICghc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBFbnN1cmUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlclxuXG5cbiAgICAgICAgICBpZiAoKF9hbmNob3JOb2RlID0gYW5jaG9yTm9kZSkgIT09IG51bGwgJiYgX2FuY2hvck5vZGUgIT09IHZvaWQgMCAmJiAoX2FuY2hvck5vZGUkcGFyZW50RWxlID0gX2FuY2hvck5vZGUucGFyZW50RWxlbWVudCkgIT09IG51bGwgJiYgX2FuY2hvck5vZGUkcGFyZW50RWxlICE9PSB2b2lkIDAgJiYgX2FuY2hvck5vZGUkcGFyZW50RWxlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gd2hlbiA8RWRpdGFibGUvPiBpcyBiZWluZyBjb250cm9sbGVkIHRocm91Z2ggZXh0ZXJuYWwgdmFsdWVcbiAgICAgIC8vIHRoZW4gaXRzIGNoaWxkcmVuIG1pZ2h0IGp1c3QgY2hhbmdlIC0gRE9NIHJlc3BvbmRzIHRvIGl0IG9uIGl0cyBvd25cbiAgICAgIC8vIGJ1dCBTbGF0ZSdzIHZhbHVlIGlzIG5vdCBiZWluZyB1cGRhdGVkIHRocm91Z2ggYW55IG9wZXJhdGlvblxuICAgICAgLy8gYW5kIHRodXMgaXQgZG9lc24ndCB0cmFuc2Zvcm0gc2VsZWN0aW9uIG9uIGl0cyBvd25cblxuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmICFSZWFjdEVkaXRvci5oYXNSYW5nZShlZGl0b3IsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dCBvZiBzeW5jLCBzbyB1cGRhdGUgaXQuXG5cblxuICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICB2YXIgbmV3RG9tUmFuZ2UgPSBzZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgIGlmIChuZXdEb21SYW5nZSkge1xuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiAhSVNfQU5EUk9JRCkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5jb2xsYXBzZVRvRW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2xhdGUuUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQsIG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIG5ld0RvbVJhbmdlLnN0YXJ0T2Zmc2V0LCBuZXdEb21SYW5nZS5lbmRDb250YWluZXIsIG5ld0RvbVJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhlZGl0b3IsIG5ld0RvbVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0RvbVJhbmdlO1xuICAgIH07IC8vIEluIGZpcmVmb3ggaWYgdGhlcmUgaXMgbW9yZSB0aGVuIDEgcmFuZ2UgYW5kIHdlIGNhbGwgc2V0RG9tU2VsZWN0aW9uIHdlIHJlbW92ZSB0aGUgYWJpbGl0eSB0byBzZWxlY3QgbW9yZSBjZWxscyBpbiBhIHRhYmxlXG5cblxuICAgIGlmIChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA8PSAxKSB7XG4gICAgICBzZXREb21TZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgZW5zdXJlU2VsZWN0aW9uID0gKChfYW5kcm9pZElucHV0TWFuYWdlclIyID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclIyLmlzRmx1c2hpbmcoKSkgPT09ICdhY3Rpb24nO1xuXG4gICAgaWYgKCFJU19BTkRST0lEIHx8ICFlbnN1cmVTZWxlY3Rpb24pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGltZW91dElkID0gbnVsbDtcbiAgICB2YXIgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnN1cmVEb21TZWxlY3Rpb24gPSBmdW5jdGlvbiBlbnN1cmVEb21TZWxlY3Rpb24oZm9yY2VDaGFuZ2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgICBzZXREb21TZWxlY3Rpb24oZm9yY2VDaGFuZ2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBJZ25vcmUsIGRvbSBhbmQgc3RhdGUgbWlnaHQgYmUgb3V0IG9mIHN5bmNcbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIENvbXBhdDogQW5kcm9pZCBJTUVzIHRyeSB0byBmb3JjZSB0aGVpciBzZWxlY3Rpb24gYnkgbWFudWFsbHkgcmUtYXBwbHlpbmcgaXQgZXZlbiBhZnRlciB3ZSBzZXQgaXQuXG4gICAgICAgIC8vIFRoaXMgZXNzZW50aWFsbHkgd291bGQgbWFrZSBzZXR0aW5nIHRoZSBzbGF0ZSBzZWxlY3Rpb24gZHVyaW5nIGFuIHVwZGF0ZSBtZWFuaW5nbGVzcywgc28gd2UgZm9yY2UgaXRcbiAgICAgICAgLy8gYWdhaW4gaGVyZS4gV2UgY2FuJ3Qgb25seSBkbyBpdCBpbiB0aGUgc2V0VGltZW91dCBhZnRlciB0aGUgYW5pbWF0aW9uIGZyYW1lIHNpbmNlIHRoYXQgd291bGQgY2F1c2UgYVxuICAgICAgICAvLyB2aXNpYmxlIGZsaWNrZXIuXG5cblxuICAgICAgICBlbnN1cmVEb21TZWxlY3Rpb24oKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gaW4gYW4gYW5pbWF0aW9uIGZyYW1lIHZpc3VhbGx5IGNvcnJlY3RseSBzZXRzIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCB1cGRhdGUgR0JvYXJkcyBzcGVsbGNoZWNrZXIgc3RhdGUuIFdlIGhhdmUgdG8gbWFudWFsbHkgdHJpZ2dlciBhIHNlbGVjdGlvbiBjaGFuZ2UgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIGZyYW1lIHRvIGVuc3VyZSBpdCBkaXNwbGF5cyB0aGUgY29ycmVjdCBzdGF0ZS5cbiAgICAgICAgICBlbnN1cmVEb21TZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZCk7XG5cbiAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7IC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBiZWZvcmVpbnB1dGAgZXZlbnQgdG8gZ2V0IHJlYWwgXCJMZXZlbCAyXCIgZXZlbnRzLiBUaGlzXG4gIC8vIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgYmVmb3JlaW5wdXRgIGlzIGZha2UgYW5kIG5ldmVyIHJlYWxseSBhdHRhY2hlc1xuICAvLyB0byB0aGUgcmVhbCBldmVudCBzYWRseS4gKDIwMTkvMTEvMDEpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEyMTFcblxuICB2YXIgb25ET01CZWZvcmVJbnB1dCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIG9uVXNlcklucHV0KCk7XG5cbiAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIHByb3BzT25ET01CZWZvcmVJbnB1dCkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG5cbiAgICAgIC8vIENPTVBBVDogQmVmb3JlSW5wdXQgZXZlbnRzIGFyZW4ndCBjYW5jZWxhYmxlIG9uIGFuZHJvaWQsIHNvIHdlIGhhdmUgdG8gaGFuZGxlIHRoZW0gZGlmZmVyZW50bHkgdXNpbmcgdGhlIGFuZHJvaWQgaW5wdXQgbWFuYWdlci5cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudC5oYW5kbGVET01CZWZvcmVJbnB1dChldmVudCk7XG4gICAgICB9IC8vIFNvbWUgSU1Fcy9DaHJvbWUgZXh0ZW5zaW9ucyBsaWtlIGUuZy4gR3JhbW1hcmx5IHNldCB0aGUgc2VsZWN0aW9uIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgICAgLy8gdHJpZ2dlcmluZyBhIGBiZWZvcmVpbnB1dGAgZXhwZWN0aW5nIHRoZSBjaGFuZ2UgdG8gYmUgYXBwbGllZCB0byB0aGUgaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyBzZXQgc2VsZWN0aW9uLlxuXG5cbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIHZhciB0eXBlID0gZXZlbnQuaW5wdXRUeXBlO1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXNDb21wb3NpdGlvbkNoYW5nZSA9IHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnIHx8IHR5cGUgPT09ICdkZWxldGVDb21wb3NpdGlvblRleHQnOyAvLyBDT01QQVQ6IHVzZSBjb21wb3NpdGlvbiBjaGFuZ2UgZXZlbnRzIGFzIGEgaGludCB0byB3aGVyZSB3ZSBzaG91bGQgaW5zZXJ0XG4gICAgICAvLyBjb21wb3NpdGlvbiB0ZXh0IGlmIHdlIGFyZW4ndCBjb21wb3NpbmcgdG8gd29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy81MDM4XG5cbiAgICAgIGlmIChpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX25hdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnICYmIHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmIC8vIE9ubHkgdXNlIG5hdGl2ZSBjaGFyYWN0ZXIgaW5zZXJ0aW9uIGZvciBzaW5nbGUgY2hhcmFjdGVycyBhLXogb3Igc3BhY2UgZm9yIG5vdy5cbiAgICAgIC8vIExvbmctcHJlc3MgZXZlbnRzIChob2xkIGEgKyBwcmVzcyA0ID0gw6QpIHRvIGNob29zZSBhIHNwZWNpYWwgY2hhcmFjdGVyIG90aGVyd2lzZVxuICAgICAgLy8gY2F1c2VzIGR1cGxpY2F0ZSBpbnNlcnRzLlxuICAgICAgZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmxlbmd0aCA9PT0gMSAmJiAvW2EteiBdL2kudGVzdChldmVudC5kYXRhKSAmJiAvLyBDaHJvbWUgaGFzIGlzc3VlcyBjb3JyZWN0bHkgZWRpdGluZyB0aGUgc3RhcnQgb2Ygbm9kZXM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNDk0MDVcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYW4gaW5saW5lIGVsZW1lbnQsIGUuZy4gYSBsaW5rLCBhbmQgeW91IHNlbGVjdFxuICAgICAgLy8gcmlnaHQgYWZ0ZXIgaXQgKHRoZSBzdGFydCBvZiB0aGUgbmV4dCBub2RlKS5cbiAgICAgIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIHZhciBfbm9kZSRwYXJlbnRFbGVtZW50LCBfd2luZG93JGdldENvbXB1dGVkU3Q7XG5cbiAgICAgICAgX25hdGl2ZSA9IHRydWU7IC8vIFNraXAgbmF0aXZlIGlmIHRoZXJlIGFyZSBtYXJrcywgYXNcbiAgICAgICAgLy8gYGluc2VydFRleHRgIHdpbGwgaW5zZXJ0IGEgbm9kZSwgbm90IGp1c3QgdGV4dC5cblxuICAgICAgICBpZiAoZWRpdG9yLm1hcmtzKSB7XG4gICAgICAgICAgX25hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IC8vIENocm9tZSBhbHNvIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIGVuZCBvZiBhbmNob3IgZWxlbWVudHM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNTkxMDBcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIGRvbid0IGFsbG93IG5hdGl2ZSBldmVudHMgdG8gaW5zZXJ0IHRleHQgYXQgdGhlIGVuZCBvZiBhbmNob3Igbm9kZXMuXG5cblxuICAgICAgICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcblxuICAgICAgICB2YXIgX1JlYWN0RWRpdG9yJHRvRE9NUG9pID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvciksXG4gICAgICAgICAgICBfUmVhY3RFZGl0b3IkdG9ET01Qb2kyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0RWRpdG9yJHRvRE9NUG9pLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfUmVhY3RFZGl0b3IkdG9ET01Qb2kyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX1JlYWN0RWRpdG9yJHRvRE9NUG9pMlsxXTtcblxuICAgICAgICB2YXIgYW5jaG9yTm9kZSA9IChfbm9kZSRwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfbm9kZSRwYXJlbnRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ2EnKTtcbiAgICAgICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuXG4gICAgICAgIGlmIChfbmF0aXZlICYmIGFuY2hvck5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgdmFyIF9sYXN0VGV4dCR0ZXh0Q29udGVudDtcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgdGV4dCBub2RlIGluc2lkZSB0aGUgYW5jaG9yLlxuICAgICAgICAgIHZhciBsYXN0VGV4dCA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGFuY2hvck5vZGUsIE5vZGVGaWx0ZXIuU0hPV19URVhUKS5sYXN0Q2hpbGQoKTtcblxuICAgICAgICAgIGlmIChsYXN0VGV4dCA9PT0gbm9kZSAmJiAoKF9sYXN0VGV4dCR0ZXh0Q29udGVudCA9IGxhc3RUZXh0LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfbGFzdFRleHQkdGV4dENvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sYXN0VGV4dCR0ZXh0Q29udGVudC5sZW5ndGgpID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIF9uYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2hyb21lIGhhcyBpc3N1ZXMgd2l0aCB0aGUgcHJlc2VuY2Ugb2YgdGFiIGNoYXJhY3RlcnMgaW5zaWRlIGVsZW1lbnRzIHdpdGggd2hpdGVTcGFjZSA9ICdwcmUnXG4gICAgICAgIC8vIGNhdXNpbmcgYWJub3JtYWwgaW5zZXJ0IGJlaGF2aW9yOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjE5MTM5XG5cblxuICAgICAgICBpZiAoX25hdGl2ZSAmJiBub2RlLnBhcmVudEVsZW1lbnQgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfd2luZG93JGdldENvbXB1dGVkU3QgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLnBhcmVudEVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfd2luZG93JGdldENvbXB1dGVkU3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdC53aGl0ZVNwYWNlKSA9PT0gJ3ByZScpIHtcbiAgICAgICAgICB2YXIgYmxvY2sgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobikgJiYgc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChibG9jayAmJiBzbGF0ZS5Ob2RlLnN0cmluZyhibG9ja1swXSkuaW5jbHVkZXMoJ1xcdCcpKSB7XG4gICAgICAgICAgICBfbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENPTVBBVDogRm9yIHRoZSBkZWxldGluZyBmb3J3YXJkL2JhY2t3YXJkIGlucHV0IHR5cGVzIHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgaXQgaXMgdGhlIHJhbmdlIHRoYXQgd2lsbCBiZSBkZWxldGVkLFxuICAgICAgLy8gYW5kIHRob3NlIGNvbW1hbmRzIGRldGVybWluZSB0aGF0IGZvciB0aGVtc2VsdmVzLlxuXG5cbiAgICAgIGlmICghdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZUJ5JykpIHtcbiAgICAgICAgdmFyIF9ldmVudCRnZXRUYXJnZXRSYW5nZSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpLFxuICAgICAgICAgICAgX2V2ZW50JGdldFRhcmdldFJhbmdlMiA9IF9zbGljZWRUb0FycmF5KF9ldmVudCRnZXRUYXJnZXRSYW5nZSwgMSksXG4gICAgICAgICAgICB0YXJnZXRSYW5nZSA9IF9ldmVudCRnZXRUYXJnZXRSYW5nZTJbMF07XG5cbiAgICAgICAgaWYgKHRhcmdldFJhbmdlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzbGF0ZS5SYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCByYW5nZSkpIHtcbiAgICAgICAgICAgIF9uYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SZWYgPSAhaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLkVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLnNldChlZGl0b3IsIHNlbGVjdGlvblJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENvbXBvc2l0aW9uIGNoYW5nZSB0eXBlcyBvY2N1ciB3aGlsZSBhIHVzZXIgaXMgY29tcG9zaW5nIHRleHQgYW5kIGNhbid0IGJlXG4gICAgICAvLyBjYW5jZWxsZWQuIExldCB0aGVtIHRocm91Z2ggYW5kIHdhaXQgZm9yIHRoZSBjb21wb3NpdGlvbiB0byBlbmQuXG5cblxuICAgICAgaWYgKGlzQ29tcG9zaXRpb25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9uYXRpdmUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgc2VsZWN0aW9uIGlzIGV4cGFuZGVkLCBldmVuIGlmIHRoZSBjb21tYW5kIHNlZW1zIGxpa2VcbiAgICAgIC8vIGEgZGVsZXRlIGZvcndhcmQvYmFja3dhcmQgY29tbWFuZCBpdCBzaG91bGQgZGVsZXRlIHRoZSBzZWxlY3Rpb24uXG5cblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikgJiYgdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdHlwZS5lbmRzV2l0aCgnQmFja3dhcmQnKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICAgIHNsYXRlLkVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDb21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q3V0JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNsYXRlLkVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVFbnRpcmVTb2Z0TGluZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNsYXRlLkVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVXb3JkRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAgICBzbGF0ZS5FZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgIC8vIENPTVBBVDogaW4gU2FmYXJpLCBgY29tcG9zaXRpb25lbmRgIGlzIGRpc3BhdGNoZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZm9yIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCIuIEJ1dCBpZiB3ZSB3YWl0IGZvciBpdFxuICAgICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgYWJvcnQgYmVjYXVzZSB3ZSdyZSBzdGlsbCBjb21wb3NpbmcgYW5kIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgLy8gd29uJ3QgYmUgdXBkYXRlZCBwcm9wZXJseS5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2lucHV0LWV2ZW50cy0yL1xuICAgICAgICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgIHNldElzQ29tcG9zaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHVzZSBhIHdlYWsgY29tcGFyaXNvbiBpbnN0ZWFkIG9mICdpbnN0YW5jZW9mJyB0byBhbGxvd1xuICAgICAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGFjY2VzcyBvZiBwYXN0ZSBldmVudHMgY29taW5nIGZyb20gZXh0ZXJuYWwgd2luZG93c1xuICAgICAgICAgICAgLy8gbGlrZSBjeXByZXNzIHdoZXJlIGN5LndpbmRvdyBkb2VzIG5vdCB3b3JrIHJlYWxpYmx5XG5cblxuICAgICAgICAgICAgaWYgKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY29uc3RydWN0b3IubmFtZSkgPT09ICdEYXRhVHJhbnNmZXInKSB7XG4gICAgICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgaW5zZXJ0VGV4dCBvcGVyYXRpb25zIHVzZSB0aGUgbmF0aXZlIGZ1bmN0aW9uYWxpdHksIGZvciBub3cuXG4gICAgICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGV4cGFuZCB0byBzaW5nbGUgY2hhcmFjdGVyIGRlbGV0ZXMsIGFzIHdlbGwuXG4gICAgICAgICAgICAgIGlmIChfbmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhdGUuRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbGF0ZS5FZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gLy8gUmVzdG9yZSB0aGUgYWN0dWFsIHVzZXIgc2VjdGlvbiBpZiBub3RoaW5nIG1hbnVhbGx5IHNldCBpdC5cblxuXG4gICAgICB2YXIgdG9SZXN0b3JlID0gKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19VU0VSX1NFTEVDID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1VTRVJfU0VMRUMudW5yZWYoKTtcbiAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTltcImRlbGV0ZVwiXShlZGl0b3IpO1xuXG4gICAgICBpZiAodG9SZXN0b3JlICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhc2xhdGUuUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHRvUmVzdG9yZSkpKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdG9SZXN0b3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlZGl0b3IsIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCBvblVzZXJJbnB1dCwgcHJvcHNPbkRPTUJlZm9yZUlucHV0LCByZWFkT25seSwgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICB2YXIgY2FsbGJhY2tSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgIEVESVRPUl9UT19FTEVNRU5UW1wiZGVsZXRlXCJdKGVkaXRvcik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlRbXCJkZWxldGVcIl0oZWRpdG9yKTtcblxuICAgICAgaWYgKHJlZi5jdXJyZW50ICYmIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICAgIHJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0Jywgb25ET01CZWZvcmVJbnB1dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0dGFjaCBhIG5hdGl2ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgYGJlZm9yZWlucHV0YCBldmVudHMsIGJlY2F1c2UgUmVhY3Qnc1xuICAgICAgLy8gYnVpbHQtaW4gYG9uQmVmb3JlSW5wdXRgIGlzIGFjdHVhbGx5IGEgbGVha3kgcG9seWZpbGwgdGhhdCBkb2Vzbid0IGV4cG9zZVxuICAgICAgLy8gcmVhbCBgYmVmb3JlaW5wdXRgIGV2ZW50cyBzYWRseS4uLiAoMjAxOS8xMS8wNClcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEyMTFcbiAgICAgIGlmIChIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgYGJlZm9yZWlucHV0YCBldmVudCBpc24ndCByZWNvZ25pemVkLlxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0Jywgb25ET01CZWZvcmVJbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICB9LCBbb25ET01TZWxlY3Rpb25DaGFuZ2UsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UsIGVkaXRvciwgb25ET01CZWZvcmVJbnB1dF0pOyAvLyBBdHRhY2ggYSBuYXRpdmUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIGBzZWxlY3Rpb25jaGFuZ2VgLCBiZWNhdXNlIFJlYWN0J3NcbiAgLy8gYnVpbHQtaW4gYG9uU2VsZWN0YCBoYW5kbGVyIGRvZXNuJ3QgZmlyZSBmb3IgYWxsIHNlbGVjdGlvbiBjaGFuZ2VzLiBJdCdzIGFcbiAgLy8gbGVha3kgcG9seWZpbGwgdGhhdCBvbmx5IGZpcmVzIG9uIGtleXByZXNzZXMgb3IgY2xpY2tzLiBJbnN0ZWFkLCB3ZSB3YW50IHRvXG4gIC8vIGZpcmUgZm9yIGFueSBjaGFuZ2UgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGVkaXRvci4gKDIwMTkvMTEvMDQpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNTc4NVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICB2YXIgZGVjb3JhdGlvbnMgPSBkZWNvcmF0ZShbZWRpdG9yLCBbXV0pO1xuICB2YXIgc2hvd1BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5mcm9tKHNsYXRlLk5vZGUudGV4dHMoZWRpdG9yKSkubGVuZ3RoID09PSAxICYmIHNsYXRlLk5vZGUuc3RyaW5nKGVkaXRvcikgPT09ICcnICYmICFpc0NvbXBvc2luZztcbiAgdmFyIHBsYWNlSG9sZGVyUmVzaXplSGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwbGFjZWhvbGRlckVsKSB7XG4gICAgaWYgKHBsYWNlaG9sZGVyRWwgJiYgc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgX3BsYWNlaG9sZGVyRWwkZ2V0Qm91O1xuXG4gICAgICBzZXRQbGFjZWhvbGRlckhlaWdodCgoX3BsYWNlaG9sZGVyRWwkZ2V0Qm91ID0gcGxhY2Vob2xkZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgPT09IG51bGwgfHwgX3BsYWNlaG9sZGVyRWwkZ2V0Qm91ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGxhY2Vob2xkZXJFbCRnZXRCb3UuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UGxhY2Vob2xkZXJIZWlnaHQodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFtzaG93UGxhY2Vob2xkZXJdKTtcblxuICBpZiAoc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgdmFyIF9kZWNvcmF0aW9ucyRwdXNoO1xuXG4gICAgdmFyIHN0YXJ0ID0gc2xhdGUuRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIGRlY29yYXRpb25zLnB1c2goKF9kZWNvcmF0aW9ucyRwdXNoID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZGVjb3JhdGlvbnMkcHVzaCwgUExBQ0VIT0xERVJfU1lNQk9MLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9kZWNvcmF0aW9ucyRwdXNoLCBcInBsYWNlaG9sZGVyXCIsIHBsYWNlaG9sZGVyKSwgX2RlZmluZVByb3BlcnR5KF9kZWNvcmF0aW9ucyRwdXNoLCBcIm9uUGxhY2Vob2xkZXJSZXNpemVcIiwgcGxhY2VIb2xkZXJSZXNpemVIYW5kbGVyKSwgX2RlZmluZVByb3BlcnR5KF9kZWNvcmF0aW9ucyRwdXNoLCBcImFuY2hvclwiLCBzdGFydCksIF9kZWZpbmVQcm9wZXJ0eShfZGVjb3JhdGlvbnMkcHVzaCwgXCJmb2N1c1wiLCBzdGFydCksIF9kZWNvcmF0aW9ucyRwdXNoKSk7XG4gIH1cblxuICB2YXIgbWFya3MgPSBlZGl0b3IubWFya3M7XG4gIHN0YXRlLmhhc01hcmtQbGFjZWhvbGRlciA9IGZhbHNlO1xuXG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIG1hcmtzKSB7XG4gICAgdmFyIGFuY2hvciA9IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yO1xuICAgIHZhciBsZWFmID0gc2xhdGUuTm9kZS5sZWFmKGVkaXRvciwgYW5jaG9yLnBhdGgpO1xuXG4gICAgbGVhZi50ZXh0O1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhsZWFmLCBfZXhjbHVkZWQyKTsgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAvLyBoZXJlIHdoaWNoIG9ubHkgY29tcGFyZXMgbWFya3MgYW55d2F5LlxuXG5cbiAgICBpZiAoIXNsYXRlLlRleHQuZXF1YWxzKGxlYWYsIG1hcmtzLCB7XG4gICAgICBsb29zZTogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgdmFyIHVuc2V0ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHJlc3QpLm1hcChmdW5jdGlvbiAobWFyaykge1xuICAgICAgICByZXR1cm4gW21hcmssIG51bGxdO1xuICAgICAgfSkpO1xuICAgICAgZGVjb3JhdGlvbnMucHVzaChfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMShfZGVmaW5lUHJvcGVydHkoe30sIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MLCB0cnVlKSwgdW5zZXQpLCBtYXJrcyksIHt9LCB7XG4gICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICBmb2N1czogYW5jaG9yXG4gICAgICB9KSk7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBFRElUT1JfVE9fTUFSS19QTEFDRUhPTERFUl9NQVJLUyBpbiBzZXRUaW1lb3V0IHVzZUVmZmVjdCB0byBlbnN1cmUgd2UgZG9uJ3Qgc2V0IGl0XG4gIC8vIGJlZm9yZSB3ZSByZWNlaXZlIHRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQuXG5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuXG4gICAgICAgIHZhciBfdGV4dCA9IHNsYXRlLk5vZGUubGVhZihlZGl0b3IsIF9hbmNob3IucGF0aCk7IC8vIFdoaWxlIG1hcmtzIGlzbid0IGEgJ2NvbXBsZXRlJyB0ZXh0LCB3ZSBjYW4gc3RpbGwgdXNlIGxvb3NlIFRleHQuZXF1YWxzXG4gICAgICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG5cblxuICAgICAgICBpZiAobWFya3MgJiYgIXNsYXRlLlRleHQuZXF1YWxzKF90ZXh0LCBtYXJrcywge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlZGl0b3IsIG1hcmtzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTW1wiZGVsZXRlXCJdKGVkaXRvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChSZWFkT25seUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVhZE9ubHlcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChEZWNvcmF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGVjb3JhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChSZXN0b3JlRE9NLCB7XG4gICAgbm9kZTogcmVmLFxuICAgIHJlY2VpdmVkVXNlcklucHV0OiByZWNlaXZlZFVzZXJJbnB1dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgcm9sZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiAndGV4dGJveCcsXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiByZWFkT25seSA/IHVuZGVmaW5lZCA6IHRydWVcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZSdkXG4gICAgLy8gaGF2ZSB0byB1c2UgaGFja3MgdG8gbWFrZSB0aGVzZSByZXBsYWNlbWVudC1iYXNlZCBmZWF0dXJlcyB3b3JrLlxuICAgIC8vIEZvciBTU1Igc2l0dWF0aW9ucyBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgaXMgZmFsc2UgYW5kIHJlc3VsdHMgaW4gcHJvcFxuICAgIC8vIG1pc21hdGNoIHdhcm5pbmcgYXBwIG1vdmVzIHRvIGJyb3dzZXIuIFBhc3MtdGhyb3VnaCBjb25zdW1lciBwcm9wcyB3aGVuXG4gICAgLy8gbm90IENBTl9VU0VfRE9NIChTU1IpIGFuZCBkZWZhdWx0IHRvIGZhbHN5IHZhbHVlXG4gICAgc3BlbGxDaGVjazogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuc3BlbGxDaGVjayA6IGZhbHNlLFxuICAgIGF1dG9Db3JyZWN0OiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ29ycmVjdCA6ICdmYWxzZScsXG4gICAgYXV0b0NhcGl0YWxpemU6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9DYXBpdGFsaXplIDogJ2ZhbHNlJyxcbiAgICBcImRhdGEtc2xhdGUtZWRpdG9yXCI6IHRydWUsXG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ2YWx1ZVwiLFxuICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRoaXNcbiAgICBjb250ZW50RWRpdGFibGU6ICFyZWFkT25seSxcbiAgICAvLyBpbiBzb21lIGNhc2VzLCBhIGRlY29yYXRpb24gbmVlZHMgYWNjZXNzIHRvIHRoZSByYW5nZSAvIHNlbGVjdGlvbiB0byBkZWNvcmF0ZSBhIHRleHQgbm9kZSxcbiAgICAvLyB0aGVuIHlvdSB3aWxsIHNlbGVjdCB0aGUgd2hvbGUgdGV4dCBub2RlIHdoZW4geW91IHNlbGVjdCBwYXJ0IHRoZSBvZiB0ZXh0XG4gICAgLy8gdGhpcyBtYWdpYyB6SW5kZXg9XCItMVwiIHdpbGwgZml4IGl0XG4gICAgemluZGV4OiAtMSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgcmVmOiBjYWxsYmFja1JlZixcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgZGlzYWJsZURlZmF1bHRTdHlsZXMgPyB7fSA6IF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAvLyBBbGxvdyBwb3NpdGlvbmluZyByZWxhdGl2ZSB0byB0aGUgZWRpdGFibGUgZWxlbWVudC5cbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgLy8gUHJlc2VydmUgYWRqYWNlbnQgd2hpdGVzcGFjZSBhbmQgbmV3IGxpbmVzLlxuICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgIC8vIEFsbG93IHdvcmRzIHRvIGJyZWFrIGlmIHRoZXkgYXJlIHRvbyBsb25nLlxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgIH0sIHBsYWNlaG9sZGVySGVpZ2h0ID8ge1xuICAgICAgbWluSGVpZ2h0OiBwbGFjZWhvbGRlckhlaWdodFxuICAgIH0gOiB7fSkpLCB1c2VyU3R5bGUpLFxuICAgIG9uQmVmb3JlSW5wdXQ6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAvLyBmYWxsIGJhY2sgdG8gUmVhY3QncyBsZWFreSBwb2x5ZmlsbCBpbnN0ZWFkIGp1c3QgZm9yIGl0LiBJdFxuICAgICAgLy8gb25seSB3b3JrcyBmb3IgdGhlIGBpbnNlcnRUZXh0YCBpbnB1dCB0eXBlLlxuICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgJiYgIXJlYWRPbmx5ICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkJlZm9yZUlucHV0KSAmJiBSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHZhciBfdGV4dDIgPSBldmVudC5kYXRhO1xuICAgICAgICAgIHNsYXRlLkVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgX3RleHQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQmVmb3JlSW5wdXQsIGVkaXRvciwgcmVhZE9ubHldKSxcbiAgICBvbklucHV0OiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbklucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50LmhhbmRsZUlucHV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmx1c2ggbmF0aXZlIG9wZXJhdGlvbnMsIGFzIG5hdGl2ZSBldmVudHMgd2lsbCBoYXZlIHByb3BvZ2F0ZWRcbiAgICAgIC8vIGFuZCB3ZSBjYW4gY29ycmVjdGx5IGNvbXBhcmUgRE9NIHRleHQgdmFsdWVzIGluIGNvbXBvbmVudHNcbiAgICAgIC8vIHRvIHN0b3AgcmVuZGVyaW5nLCBzbyB0aGF0IGJyb3dzZXIgZnVuY3Rpb25zIGxpa2UgYXV0b2NvcnJlY3RcbiAgICAgIC8vIGFuZCBzcGVsbGNoZWNrIHdvcmsgYXMgZXhwZWN0ZWQuXG5cblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICB9LCBbYXR0cmlidXRlcy5vbklucHV0XSksXG4gICAgb25CbHVyOiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChyZWFkT25seSB8fCBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSB8fCBpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkJsdXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgY3VycmVudCBgYWN0aXZlRWxlbWVudGAgaXMgc3RpbGwgdGhlIHByZXZpb3VzXG4gICAgICAvLyBvbmUsIHRoaXMgaXMgZHVlIHRvIHRoZSB3aW5kb3cgYmVpbmcgYmx1cnJlZCB3aGVuIHRoZSB0YWJcbiAgICAgIC8vIGl0c2VsZiBiZWNvbWVzIHVuZm9jdXNlZCwgc28gd2Ugd2FudCB0byBhYm9ydCBlYXJseSB0byBhbGxvdyB0b1xuICAgICAgLy8gZWRpdG9yIHRvIHN0YXkgZm9jdXNlZCB3aGVuIHRoZSB0YWIgYmVjb21lcyBmb2N1c2VkIGFnYWluLlxuXG5cbiAgICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG5cbiAgICAgIGlmIChzdGF0ZS5sYXRlc3RFbGVtZW50ID09PSByb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpOyAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgcmV0dXJuaW5nXG4gICAgICAvLyB0byB0aGUgZWRpdG9yIGZyb20gYW4gZW1iZWRkZWQgZWRpdGFibGUgZWxlbWVudCAoZWcuIGFuIDxpbnB1dD5cbiAgICAgIC8vIGVsZW1lbnQgaW5zaWRlIGEgdm9pZCBub2RlKS5cblxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyBmcm9tXG4gICAgICAvLyB0aGUgZWRpdG9yIHRvIGluc2lkZSBhIHZvaWQgbm9kZSdzIHNwYWNlciBlbGVtZW50LlxuXG5cbiAgICAgIGlmIChpc0RPTUVsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtc3BhY2VyJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgbW92aW5nIHRvIGFcbiAgICAgIC8vIG5vbi0gZWRpdGFibGUgc2VjdGlvbiBvZiBhbiBlbGVtZW50IHRoYXQgaXNuJ3QgYSB2b2lkIG5vZGUgKGVnLlxuICAgICAgLy8gYSBsaXN0IGl0ZW0gb2YgdGhlIGNoZWNrIGxpc3QgZXhhbXBsZSkuXG5cblxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiBpc0RPTU5vZGUocmVsYXRlZFRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ09NUEFUOiBTYWZhcmkgZG9lc24ndCBhbHdheXMgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZXZlbiBpZiB0aGUgY29udGVudC1cbiAgICAgIC8vIGVkaXRhYmxlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBmb2N1cy4gUmVmZXIgdG86XG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM1MzI0Ny9mb3JjZS1jb250ZW50ZWRpdGFibGUtZGl2LXRvLXN0b3AtYWNjZXB0aW5nLWlucHV0LWFmdGVyLWl0LWxvc2VzLWZvY3VzLXVuZGVyLXdlYlxuXG5cbiAgICAgIGlmIChJU19XRUJLSVQpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgSVNfRk9DVVNFRFtcImRlbGV0ZVwiXShlZGl0b3IpO1xuICAgIH0sIFtyZWFkT25seSwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiwgc3RhdGUubGF0ZXN0RWxlbWVudCwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQmx1cl0pLFxuICAgIG9uQ2xpY2s6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ2xpY2spICYmIGlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7IC8vIEF0IHRoaXMgdGltZSwgdGhlIFNsYXRlIGRvY3VtZW50IG1heSBiZSBhcmJpdHJhcmlseSBkaWZmZXJlbnQsXG4gICAgICAgIC8vIGJlY2F1c2Ugb25DbGljayBoYW5kbGVycyBjYW4gY2hhbmdlIHRoZSBkb2N1bWVudCBiZWZvcmUgd2UgZ2V0IGhlcmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhpcyBwYXRoIGFjdHVhbGx5IGV4aXN0cyxcbiAgICAgICAgLy8gYW5kIHRoYXQgaXQgc3RpbGwgcmVmZXJzIHRvIHRoZSBzYW1lIG5vZGUuXG5cbiAgICAgICAgaWYgKCFzbGF0ZS5FZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpIHx8IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcGF0aCkgIT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGV0YWlsID09PSBUUklQTEVfQ0xJQ0sgJiYgcGF0aC5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIHZhciBibG9ja1BhdGggPSBwYXRoO1xuXG4gICAgICAgICAgaWYgKCEoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBub2RlKSkpIHtcbiAgICAgICAgICAgIHZhciBfYmxvY2skO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KG4pICYmIHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJsb2NrUGF0aCA9IChfYmxvY2skID0gYmxvY2sgPT09IG51bGwgfHwgYmxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJsb2NrWzFdKSAhPT0gbnVsbCAmJiBfYmxvY2skICE9PSB2b2lkIDAgPyBfYmxvY2skIDogcGF0aC5zbGljZSgwLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhcnQgPSBzbGF0ZS5FZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICB2YXIgZW5kID0gc2xhdGUuRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgc3RhcnRWb2lkID0gc2xhdGUuRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3N0YXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW5kVm9pZCA9IHNsYXRlLkVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhcnRWb2lkICYmIGVuZFZvaWQgJiYgc2xhdGUuUGF0aC5lcXVhbHMoc3RhcnRWb2lkWzFdLCBlbmRWb2lkWzFdKSkge1xuICAgICAgICAgIHZhciBfcmFuZ2UgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBfc3RhcnQpO1xuXG4gICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2VkaXRvciwgYXR0cmlidXRlcy5vbkNsaWNrLCByZWFkT25seV0pLFxuICAgIG9uQ29tcG9zaXRpb25FbmQ6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclIzO1xuXG4gICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FuZHJvaWRJbnB1dE1hbmFnZXJSMy5oYW5kbGVDb21wb3NpdGlvbkVuZChldmVudCk7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJbiBDaHJvbWUsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGZvciBjb21wb3NpdGlvbnNcbiAgICAgICAgLy8gYXJlbid0IGNvcnJlY3QgYW5kIG5ldmVyIGZpcmUgdGhlIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCJcbiAgICAgICAgLy8gdHlwZSB0aGF0IHdlIG5lZWQuIFNvIGluc3RlYWQsIGluc2VydCB3aGVuZXZlciBhIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIGVuZHMgc2luY2UgaXQgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBjb21taXR0ZWQgdG8gdGhlIERPTS5cblxuXG4gICAgICAgIGlmICghSVNfV0VCS0lUICYmICFJU19GSVJFRk9YX0xFR0FDWSAmJiAhSVNfSU9TICYmICFJU19XRUNIQVRCUk9XU0VSICYmICFJU19VQ19NT0JJTEUgJiYgZXZlbnQuZGF0YSkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlck1hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLU1tcImRlbGV0ZVwiXShlZGl0b3IpOyAvLyBFbnN1cmUgd2UgaW5zZXJ0IHRleHQgd2l0aCB0aGUgbWFya3MgdGhlIHVzZXIgd2FzIGFjdHVhbGx5IHNlZWluZ1xuXG4gICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICAgICAgICAgIGVkaXRvci5tYXJrcyA9IHBsYWNlaG9sZGVyTWFya3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2xhdGUuRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICAgICAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1NbXCJkZWxldGVcIl0oZWRpdG9yKTtcblxuICAgICAgICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQsIGVkaXRvcl0pLFxuICAgIG9uQ29tcG9zaXRpb25VcGRhdGU6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlKSkge1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlLCBlZGl0b3JdKSxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclI0O1xuXG4gICAgICAgIChfYW5kcm9pZElucHV0TWFuYWdlclI0ID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclI0LmhhbmRsZUNvbXBvc2l0aW9uU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uU3RhcnQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNsYXRlLkVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmxpbmUgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobikgJiYgc2xhdGUuRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW5saW5lKSB7XG4gICAgICAgICAgICB2YXIgX2lubGluZSA9IF9zbGljZWRUb0FycmF5KGlubGluZSwgMiksXG4gICAgICAgICAgICAgICAgaW5saW5lUGF0aCA9IF9pbmxpbmVbMV07XG5cbiAgICAgICAgICAgIGlmIChzbGF0ZS5FZGl0b3IuaXNFbmQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLCBpbmxpbmVQYXRoKSkge1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzbGF0ZS5FZGl0b3IuYWZ0ZXIoZWRpdG9yLCBpbmxpbmVQYXRoKTtcbiAgICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBwb2ludCxcbiAgICAgICAgICAgICAgICBmb2N1czogcG9pbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0LCBlZGl0b3JdKSxcbiAgICBvbkNvcHk6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvcHkpICYmICFpc0RPTUV2ZW50VGFyZ2V0SW5wdXQoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjb3B5Jyk7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db3B5LCBlZGl0b3JdKSxcbiAgICBvbkN1dDogUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkN1dCkgJiYgIWlzRE9NRXZlbnRUYXJnZXRJbnB1dChldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2N1dCcpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2xhdGUuTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoc2xhdGUuRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbkN1dF0pLFxuICAgIG9uRHJhZ092ZXI6IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgc2xhdGUuRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uRHJhZ092ZXIsIGVkaXRvcl0pLFxuICAgIG9uRHJhZ1N0YXJ0OiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIHZhciB2b2lkTWF0Y2ggPSBzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBzbGF0ZS5FZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgc2xhdGUuRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTsgLy8gSWYgc3RhcnRpbmcgYSBkcmFnIG9uIGEgdm9pZCBub2RlLCBtYWtlIHN1cmUgaXQgaXMgc2VsZWN0ZWRcbiAgICAgICAgLy8gc28gdGhhdCBpdCBzaG93cyB1cCBpbiB0aGUgc2VsZWN0aW9uJ3MgZnJhZ21lbnQuXG5cbiAgICAgICAgaWYgKHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSB0cnVlO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5kYXRhVHJhbnNmZXIsICdkcmFnJyk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQsIHN0YXRlXSksXG4gICAgb25Ecm9wOiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Ecm9wKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkcmFnZ2VkIHJhbmdlIGJlZm9yZSB1cGRhdGluZyBzZWxlY3Rpb25cblxuICAgICAgICB2YXIgZHJhZ2dlZFJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbjsgLy8gRmluZCB0aGUgcmFuZ2Ugd2hlcmUgdGhlIGRyb3AgaGFwcGVuZWRcblxuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci5maW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSkge1xuICAgICAgICAgIGlmIChkcmFnZ2VkUmFuZ2UgJiYgIXNsYXRlLlJhbmdlLmVxdWFscyhkcmFnZ2VkUmFuZ2UsIHJhbmdlKSAmJiAhc2xhdGUuRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBkcmFnZ2VkUmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTsgLy8gV2hlbiBkcmFnZ2luZyBmcm9tIGFub3RoZXIgc291cmNlIGludG8gdGhlIGVkaXRvciwgaXQncyBwb3NzaWJsZVxuICAgICAgICAvLyB0aGF0IHRoZSBjdXJyZW50IGVkaXRvciBkb2VzIG5vdCBoYXZlIGZvY3VzLlxuXG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpIHtcbiAgICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gZmFsc2U7XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25Ecm9wLCBzdGF0ZV0pLFxuICAgIG9uRHJhZ0VuZDogUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ICYmIGF0dHJpYnV0ZXMub25EcmFnRW5kICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYXR0cmlidXRlcy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfSAvLyBXaGVuIGRyb3BwaW5nIG9uIGEgZGlmZmVyZW50IGRyb3BwYWJsZSBlbGVtZW50IHRoYW4gdGhlIGN1cnJlbnQgZWRpdG9yLFxuICAgICAgLy8gYG9uRHJvcGAgaXMgbm90IGNhbGxlZC4gU28gd2UgbmVlZCB0byBjbGVhbiB1cCBpbiBgb25EcmFnRW5kYCBpbnN0ZWFkLlxuICAgICAgLy8gTm90ZTogYG9uRHJhZ0VuZGAgaXMgb25seSBjYWxsZWQgd2hlbiBgb25Ecm9wYCBpcyBub3QgY2FsbGVkXG5cblxuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLCBhdHRyaWJ1dGVzLCBlZGl0b3JdKSxcbiAgICBvbkZvY3VzOiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkZvY3VzKSkge1xuICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50OyAvLyBDT01QQVQ6IElmIHRoZSBlZGl0b3IgaGFzIG5lc3RlZCBlZGl0YWJsZSBlbGVtZW50cywgdGhlIGZvY3VzXG4gICAgICAgIC8vIGNhbiBnbyB0byB0aGVtLiBJbiBGaXJlZm94LCB0aGlzIG11c3QgYmUgcHJldmVudGVkIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBpc3N1ZXMgd2l0aCBrZXlib2FyZCBuYXZpZ2F0aW9uLiAoMjAxNy8wMy8zMClcblxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBldmVudC50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgc3RhdGUsIGVkaXRvciwgYXR0cmlidXRlcy5vbkZvY3VzXSksXG4gICAgb25LZXlEb3duOiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclI1O1xuXG4gICAgICAgIChfYW5kcm9pZElucHV0TWFuYWdlclI1ID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclI1LmhhbmRsZUtleURvd24oZXZlbnQpO1xuICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDsgLy8gQ09NUEFUOiBUaGUgY29tcG9zaXRpb24gZW5kIGV2ZW50IGlzbid0IGZpcmVkIHJlbGlhYmx5IGluIGFsbCBicm93c2VycyxcbiAgICAgICAgLy8gc28gd2Ugc29tZXRpbWVzIG1pZ2h0IGVuZCB1cCBzdHVjayBpbiBhIGNvbXBvc2l0aW9uIHN0YXRlIGV2ZW4gdGhvdWdoIHdlXG4gICAgICAgIC8vIGFyZW4ndCBjb21wb3NpbmcgYW55IG1vcmUuXG5cbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgbmF0aXZlRXZlbnQuaXNDb21wb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25LZXlEb3duKSB8fCBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIHZhciBlbGVtZW50ID0gZWRpdG9yLmNoaWxkcmVuW3NlbGVjdGlvbiAhPT0gbnVsbCA/IHNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdIDogMF07XG4gICAgICAgIHZhciBpc1JUTCA9IGdldERpcmVjdGlvbl9fZGVmYXVsdFsnZGVmYXVsdCddKHNsYXRlLk5vZGUuc3RyaW5nKGVsZW1lbnQpKSA9PT0gJ3J0bCc7IC8vIENPTVBBVDogU2luY2Ugd2UgcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvblxuICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGV2ZW50cywgdGhlIGJyb3dzZXIgZG9lc24ndCB0aGluayB0aGVyZSdzIGV2ZXJcbiAgICAgICAgLy8gYW55IGhpc3Rvcnkgc3RhY2sgdG8gdW5kbyBvciByZWRvLCBzbyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG91cnNlbHZlcy4gKDIwMTkvMTEvMDYpXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNSZWRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG1heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNVbmRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIF9tYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIF9tYXliZUhpc3RvcnlFZGl0b3IudW5kbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX21heWJlSGlzdG9yeUVkaXRvci51bmRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBoYW5kbGUgdGhlIHNlbGVjdGlvbiB1cGRhdGVzXG4gICAgICAgIC8vIHByb3Blcmx5LiBJbiBDaHJvbWUsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgZXh0ZW5kZWQuXG4gICAgICAgIC8vIEFuZCBpbiBGaXJlZm94LCB0aGUgc2VsZWN0aW9uIGlzbid0IHByb3Blcmx5IGNvbGxhcHNlZC5cbiAgICAgICAgLy8gKDIwMTcvMTAvMTcpXG5cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cycsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNFeHRlbmRMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJZiBhIHZvaWQgbm9kZSBpcyBzZWxlY3RlZCwgb3IgYSB6ZXJvLXdpZHRoIHRleHQgbm9kZVxuICAgICAgICAvLyBhZGphY2VudCB0byBhbiBpbmxpbmUgaXMgc2VsZWN0ZWQsIHdlIG5lZWQgdG8gaGFuZGxlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgbWFudWFsbHkgYmVjYXVzZSBicm93c2VycyB3b24ndCBiZSBhYmxlIHRvIHNraXAgb3ZlclxuICAgICAgICAvLyB0aGUgdm9pZCBub2RlIHdpdGggdGhlIHplcm8td2lkdGggc3BhY2Ugbm90IGJlaW5nIGFuIGVtcHR5XG4gICAgICAgIC8vIHN0cmluZy5cblxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogIWlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6IGlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBndWVzc2luZyBhdCB0aGUgaW5wdXQgaW50ZW50aW9uIGZvciBob3RrZXlzLlxuICAgICAgICAvLyBDT01QQVQ6IEluIGlPUywgc29tZSBvZiB0aGVzZSBob3RrZXlzIGFyZSBoYW5kbGVkIGluIHRoZVxuXG5cbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgY29yZSBiZWhhdmlvciBmb3IgdGhlc2UsIGJ1dCB0aGV5IGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyBET00gaWYgd2UgZG9uJ3QgcHJldmVudCB0aGVtLCBzbyB3ZSBoYXZlIHRvLlxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzQm9sZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0l0YWxpYyhuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc1RyYW5zcG9zZUNoYXJhY3RlcihuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTb2Z0QnJlYWsobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzU3BsaXRCbG9jayhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzbGF0ZS5FZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNsYXRlLkVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNsYXRlLkVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUxpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2xhdGUuRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKElTX0NIUk9NRSB8fCBJU19XRUJLSVQpIHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogQ2hyb21lIGFuZCBTYWZhcmkgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGV2ZW50IGJ1dCBkbyBub3QgZmlyZVxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgd2hlbiBkZWxldGluZyBiYWNrd2FyZHMgaW4gYSBzZWxlY3RlZCB2b2lkIGlubGluZSBub2RlXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkgJiYgc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBzbGF0ZS5Ob2RlLnBhcmVudChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IucGF0aCk7XG5cbiAgICAgICAgICAgICAgaWYgKHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBzbGF0ZS5FZGl0b3IuaXNWb2lkKGVkaXRvciwgY3VycmVudE5vZGUpICYmIChzbGF0ZS5FZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBjdXJyZW50Tm9kZSkgfHwgc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBjdXJyZW50Tm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzbGF0ZS5FZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25LZXlEb3duXSksXG4gICAgb25QYXN0ZTogUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25QYXN0ZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGBvblBhc3RlYCBoZXJlIGluc3RlYWQuXG4gICAgICAgIC8vIENPTVBBVDogRmlyZWZveCwgQ2hyb21lIGFuZCBTYWZhcmkgZG9uJ3QgZW1pdCBgYmVmb3JlaW5wdXRgIGV2ZW50c1xuICAgICAgICAvLyB3aGVuIFwicGFzdGUgd2l0aG91dCBmb3JtYXR0aW5nXCIgaXMgdXNlZCwgc28gZmFsbGJhY2suICgyMDIwLzAyLzIwKVxuICAgICAgICAvLyBDT01QQVQ6IFNhZmFyaSBJbnB1dEV2ZW50cyBnZW5lcmF0ZWQgYnkgcGFzdGluZyB3b24ndCBpbmNsdWRlXG4gICAgICAgIC8vIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgaXRlbXMsIHNvIHVzZSB0aGVcbiAgICAgICAgLy8gQ2xpcGJvYXJkRXZlbnQgaGVyZS4gKDIwMjMvMDMvMTUpXG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8IGlzUGxhaW5UZXh0T25seVBhc3RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSB8fCBJU19XRUJLSVQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uUGFzdGVdKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChDaGlsZHJlbiwge1xuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlZGl0b3IsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb246IGVkaXRvci5zZWxlY3Rpb25cbiAgfSkpKSkpO1xufTtcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciBlbGVtZW50XHJcbiAqL1xuXG52YXIgRGVmYXVsdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gRGVmYXVsdFBsYWNlaG9sZGVyKF9yZWYpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIENPTVBBVDogQXJ0aWZpY2lhbGx5IGFkZCBhIGxpbmUtYnJlYWsgdG8gdGhlIGVuZCBvbiB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudFxuICAgIC8vIHRvIHByZXZlbnQgQW5kcm9pZCBJTUVzIHRvIHBpY2sgdXAgaXRzIGNvbnRlbnQgaW4gYXV0b2NvcnJlY3QgYW5kIHRvIGF1dG8tY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyXG4gICAgUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4sIElTX0FORFJPSUQgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpKVxuICApO1xufTtcbi8qKlxyXG4gKiBBIGRlZmF1bHQgbWVtb2l6ZWQgZGVjb3JhdGUgZnVuY3Rpb24uXHJcbiAqL1xuXG52YXIgZGVmYXVsdERlY29yYXRlID0gZnVuY3Rpb24gZGVmYXVsdERlY29yYXRlKCkge1xuICByZXR1cm4gW107XG59O1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBpbXBsZW1lbnQgdG8gc2Nyb2xsIGRvbSByYW5nZSBpbnRvIHZpZXcuXHJcbiAqL1xuXG52YXIgZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gZnVuY3Rpb24gZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3KGVkaXRvciwgZG9tUmFuZ2UpIHtcbiAgLy8gVGhpcyB3YXMgYWZmZWN0aW5nIHRoZSBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgYmxvY2tzIGFuZCBkcmFnZ2luZyBiZWhhdmlvcixcbiAgLy8gc28gZW5hYmxlZCBvbmx5IGlmIHRoZSBzZWxlY3Rpb24gaGFzIGJlZW4gY29sbGFwc2VkLlxuICBpZiAoZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgIHZhciBsZWFmRWwgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZChkb21SYW5nZSk7XG4gICAgc2Nyb2xsSW50b1ZpZXdfX2RlZmF1bHRbJ2RlZmF1bHQnXShsZWFmRWwsIHtcbiAgICAgIHNjcm9sbE1vZGU6ICdpZi1uZWVkZWQnXG4gICAgfSk7IC8vIEB0cy1leHBlY3QtZXJyb3IgYW4gdW5vcnRob2RveCBkZWxldGUgRDpcblxuICAgIGRlbGV0ZSBsZWFmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0O1xuICB9XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGFuIGV2ZW50IGlzIG92ZXJyaWRlZCBieSBhIGhhbmRsZXIuXHJcbiAqL1xuXG5cbnZhciBpc0V2ZW50SGFuZGxlZCA9IGZ1bmN0aW9uIGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuXG5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcblxuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cblxuICByZXR1cm4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGV2ZW50J3MgdGFyZ2V0IGlzIGFuIGlucHV0IGVsZW1lbnRcclxuICovXG5cbnZhciBpc0RPTUV2ZW50VGFyZ2V0SW5wdXQgPSBmdW5jdGlvbiBpc0RPTUV2ZW50VGFyZ2V0SW5wdXQoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRE9NTm9kZShldmVudC50YXJnZXQpICYmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxyXG4gKi9cblxudmFyIGlzRE9NRXZlbnRIYW5kbGVkID0gZnVuY3Rpb24gaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIGhhbmRsZXIpIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBjdXN0b20gZXZlbnQgaGFuZGxlciBtYXkgcmV0dXJuIGEgYm9vbGVhbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlIGV2ZW50XG4gIC8vIHNoYWxsIGJlIHRyZWF0ZWQgYXMgYmVpbmcgaGFuZGxlZCBvciBub3QuXG5cblxuICB2YXIgc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCA9IGhhbmRsZXIoZXZlbnQpO1xuXG4gIGlmIChzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZDtcbiAgfVxuXG4gIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgRm9jdXNlZENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGBmb2N1c2VkYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cblxudmFyIHVzZUZvY3VzZWQgPSBmdW5jdGlvbiB1c2VGb2N1c2VkKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChGb2N1c2VkQ29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yO1xufVxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIHNlbGVjdG9yIGNvbnRleHQgaW4gYSB3YXkgdG8gY29udHJvbCByZXJlbmRlcnNcclxuICovXG5cblxudmFyIFNsYXRlU2VsZWN0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuXG52YXIgcmVmRXF1YWxpdHkgPSBmdW5jdGlvbiByZWZFcXVhbGl0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcbi8qKlxyXG4gKiB1c2UgcmVkdXggc3R5bGUgc2VsZWN0b3JzIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgb24gZXZlcnkga2V5c3Ryb2tlLlxyXG4gKiBCZWFyIGluIG1pbmQgcmVyZW5kZXJpbmcgY2FuIG9ubHkgcHJldmVudGVkIGlmIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhIHZhbHVlIHR5cGUgb3IgZm9yIHJlZmVyZW5jZSB0eXBlcyAoZS5nLiBvYmplY3RzIGFuZCBhcnJheXMpIGFkZCBhIGN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvbi5cclxuICpcclxuICogRXhhbXBsZTpcclxuICogYGBgXHJcbiAqICBjb25zdCBpc1NlbGVjdGlvbkFjdGl2ZSA9IHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IEJvb2xlYW4oZWRpdG9yLnNlbGVjdGlvbikpO1xyXG4gKiBgYGBcclxuICovXG5cblxuZnVuY3Rpb24gdXNlU2xhdGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICB2YXIgZXF1YWxpdHlGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcmVmRXF1YWxpdHk7XG5cbiAgdmFyIF91c2VSZWR1Y2VyID0gUmVhY3QudXNlUmVkdWNlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzICsgMTtcbiAgfSwgMCksXG4gICAgICBfdXNlUmVkdWNlcjIgPSBfc2xpY2VkVG9BcnJheShfdXNlUmVkdWNlciwgMiksXG4gICAgICBmb3JjZVJlbmRlciA9IF91c2VSZWR1Y2VyMlsxXTtcblxuICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoU2xhdGVTZWxlY3RvckNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTZWxlY3RvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgdmFyIGdldFNsYXRlID0gY29udGV4dC5nZXRTbGF0ZSxcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIgPSBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXI7XG4gIHZhciBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciBsYXRlc3RTZWxlY3RvciA9IFJlYWN0LnVzZVJlZihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuICB2YXIgbGF0ZXN0U2VsZWN0ZWRTdGF0ZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHNlbGVjdGVkU3RhdGU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgfHwgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gc2VsZWN0b3IoZ2V0U2xhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ICYmIGlzRXJyb3IoZXJyKSkge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gXCJcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcblwiLmNvbmNhdChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2ssIFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBzZWxlY3RlZFN0YXRlO1xuICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudChnZXRTbGF0ZSgpKTtcblxuICAgICAgICBpZiAoZXF1YWxpdHlGbihuZXdTZWxlY3RlZFN0YXRlLCBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSBpZ25vcmUgYWxsIGVycm9ycyBoZXJlLCBzaW5jZSB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAgIC8vIHdpbGwgdGhyb3cgYWdhaW4sIGlmIG5laXRoZXIgcHJvcHMgbm9yIHN0b3JlIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZWRcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBmb3JjZVJlbmRlcigpO1xuICAgIH1cblxuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIoY2hlY2tGb3JVcGRhdGVzKTtcbiAgICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgLy8gZG9uJ3QgcmVyZW5kZXIgb24gZXF1YWxpdHlGbiBjaGFuZ2Ugc2luY2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGRlZmluZSBpdCBpbmxpbmVcbiAgW2FkZEV2ZW50TGlzdGVuZXIsIGdldFNsYXRlXSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBzZWxlY3RvciBjb250ZXh0IHdpdGggZWRpdG9yIHVwZGF0aW5nIG9uIGV2ZXJ5IGVkaXRvciBjaGFuZ2VcclxuICovXG5cbmZ1bmN0aW9uIHVzZVNlbGVjdG9yQ29udGV4dChlZGl0b3IpIHtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gUmVhY3QudXNlUmVmKFtdKS5jdXJyZW50O1xuICB2YXIgc2xhdGVSZWYgPSBSZWFjdC51c2VSZWYoe1xuICAgIGVkaXRvcjogZWRpdG9yXG4gIH0pLmN1cnJlbnQ7XG4gIHZhciBvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICBzbGF0ZVJlZi5lZGl0b3IgPSBlZGl0b3I7XG4gICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcihlZGl0b3IpO1xuICAgIH0pO1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHZhciBzZWxlY3RvckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2xhdGU6IGZ1bmN0aW9uIGdldFNsYXRlKCkge1xuICAgICAgICByZXR1cm4gc2xhdGVSZWYuZWRpdG9yO1xuICAgICAgfSxcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JDb250ZXh0OiBzZWxlY3RvckNvbnRleHQsXG4gICAgb25DaGFuZ2U6IG9uQ2hhbmdlXG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlZGl0b3JcIiwgXCJjaGlsZHJlblwiLCBcIm9uQ2hhbmdlXCIsIFwiaW5pdGlhbFZhbHVlXCJdO1xuLyoqXHJcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIHByb3ZpZGVyIHRvIGhhbmRsZSBgb25DaGFuZ2VgIGV2ZW50cywgYmVjYXVzZSB0aGUgZWRpdG9yXHJcbiAqIGlzIGEgbXV0YWJsZSBzaW5nbGV0b24gc28gaXQgd29uJ3QgZXZlciByZWdpc3RlciBhcyBcImNoYW5nZWRcIiBvdGhlcndpc2UuXHJcbiAqL1xuXG52YXIgU2xhdGUgPSBmdW5jdGlvbiBTbGF0ZShwcm9wcykge1xuICB2YXIgZWRpdG9yID0gcHJvcHMuZWRpdG9yLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBpbml0aWFsVmFsdWUgPSBwcm9wcy5pbml0aWFsVmFsdWUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHZhciB1bm1vdW50UmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzbGF0ZS5Ob2RlLmlzTm9kZUxpc3QoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBpbml0aWFsVmFsdWUgaXMgaW52YWxpZCEgRXhwZWN0ZWQgYSBsaXN0IG9mIGVsZW1lbnRzIGJ1dCBnb3Q6IFwiLmNvbmNhdChzbGF0ZS5TY3J1YmJlci5zdHJpbmdpZnkoaW5pdGlhbFZhbHVlKSkpO1xuICAgIH1cblxuICAgIGlmICghc2xhdGUuRWRpdG9yLmlzRWRpdG9yKGVkaXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gZWRpdG9yIGlzIGludmFsaWQhIFlvdSBwYXNzZWQ6IFwiLmNvbmNhdChzbGF0ZS5TY3J1YmJlci5zdHJpbmdpZnkoZWRpdG9yKSkpO1xuICAgIH1cblxuICAgIGVkaXRvci5jaGlsZHJlbiA9IGluaXRpYWxWYWx1ZTtcbiAgICBPYmplY3QuYXNzaWduKGVkaXRvciwgcmVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHY6IDAsXG4gICAgICBlZGl0b3I6IGVkaXRvclxuICAgIH07XG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBjb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfdXNlU2VsZWN0b3JDb250ZXh0ID0gdXNlU2VsZWN0b3JDb250ZXh0KGVkaXRvciksXG4gICAgICBzZWxlY3RvckNvbnRleHQgPSBfdXNlU2VsZWN0b3JDb250ZXh0LnNlbGVjdG9yQ29udGV4dCxcbiAgICAgIGhhbmRsZVNlbGVjdG9yQ2hhbmdlID0gX3VzZVNlbGVjdG9yQ29udGV4dC5vbkNoYW5nZTtcblxuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0KGZ1bmN0aW9uIChwcmV2Q29udGV4dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogcHJldkNvbnRleHQudiArIDEsXG4gICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGhhbmRsZVNlbGVjdG9yQ2hhbmdlKGVkaXRvcik7XG4gIH0sIFtlZGl0b3IsIGhhbmRsZVNlbGVjdG9yQ2hhbmdlLCBvbkNoYW5nZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgb25Db250ZXh0Q2hhbmdlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgRURJVE9SX1RPX09OX0NIQU5HRS5zZXQoZWRpdG9yLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB1bm1vdW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtlZGl0b3IsIG9uQ29udGV4dENoYW5nZV0pO1xuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIGlzRm9jdXNlZCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRJc0ZvY3VzZWQgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0SXNGb2N1c2VkKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgIHJldHVybiBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBpZiAoUkVBQ1RfTUFKT1JfVkVSU0lPTiA+PSAxNykge1xuICAgICAgLy8gSW4gUmVhY3QgPj0gMTcgb25Gb2N1cyBhbmQgb25CbHVyIGxpc3RlbiB0byB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuXG4gICAgICAvLyBUaGVyZWZvcmUgaW4gb3JkZXIgZm9yIDxFZGl0YWJsZSAvPidzIGhhbmRsZXJzIHRvIHJ1biBmaXJzdCwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKVxuICAgICAgLy8gdG8gcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlLCB3ZSBoYXZlIHRvIGxpc3RlbiB0byB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIHdpdGhvdXQgdXNlQ2FwdHVyZSBoZXJlLlxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZuKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZuKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZuLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGZuLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGZuLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFNsYXRlU2VsZWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHNlbGVjdG9yQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFNsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0LmVkaXRvclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KEZvY3VzZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlzRm9jdXNlZFxuICB9LCBjaGlsZHJlbikpKSk7XG59O1xuXG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICogQGRlcHJlY2F0ZWQgVXNlIHVzZVNsYXRlU3RhdGljIGluc3RlYWQuXHJcbiAqL1xuXG52YXIgdXNlRWRpdG9yID0gZnVuY3Rpb24gdXNlRWRpdG9yKCkge1xuICB2YXIgZWRpdG9yID0gUmVhY3QudXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcblxuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlRWRpdG9yYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBzbGF0ZSBzZWxlY3Rpb24uXHJcbiAqIE9ubHkgdHJpZ2dlcnMgYSByZXJlbmRlciB3aGVuIHRoZSBzZWxlY3Rpb24gYWN0dWFsbHkgY2hhbmdlc1xyXG4gKi9cblxudmFyIHVzZVNsYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gdXNlU2xhdGVTZWxlY3Rpb24oKSB7XG4gIHJldHVybiB1c2VTbGF0ZVNlbGVjdG9yKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnNlbGVjdGlvbjtcbiAgfSwgaXNTZWxlY3Rpb25FcXVhbCk7XG59O1xuXG52YXIgaXNTZWxlY3Rpb25FcXVhbCA9IGZ1bmN0aW9uIGlzU2VsZWN0aW9uRXF1YWwoYSwgYikge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiB0cnVlO1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNsYXRlLlJhbmdlLmVxdWFscyhhLCBiKTtcbn07XG5cbi8qKlxyXG4gKiBVdGlsaXRpZXMgZm9yIHNpbmdsZS1saW5lIGRlbGV0aW9uXHJcbiAqL1xuXG52YXIgZG9SZWN0c0ludGVyc2VjdCA9IGZ1bmN0aW9uIGRvUmVjdHNJbnRlcnNlY3QocmVjdCwgY29tcGFyZVJlY3QpIHtcbiAgdmFyIG1pZGRsZSA9IChjb21wYXJlUmVjdC50b3AgKyBjb21wYXJlUmVjdC5ib3R0b20pIC8gMjtcbiAgcmV0dXJuIHJlY3QudG9wIDw9IG1pZGRsZSAmJiByZWN0LmJvdHRvbSA+PSBtaWRkbGU7XG59O1xuXG52YXIgYXJlUmFuZ2VzU2FtZUxpbmUgPSBmdW5jdGlvbiBhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIHJhbmdlMSwgcmFuZ2UyKSB7XG4gIHZhciByZWN0MSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgcmVjdDIgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGRvUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG59O1xuLyoqXHJcbiAqIEEgaGVscGVyIHV0aWxpdHkgdGhhdCByZXR1cm5zIHRoZSBlbmQgcG9ydGlvbiBvZiBhIGBSYW5nZWBcclxuICogd2hpY2ggaXMgbG9jYXRlZCBvbiBhIHNpbmdsZSBsaW5lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yIFRoZSBlZGl0b3Igb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcGFyYW0ge1JhbmdlfSBwYXJlbnRSYW5nZSBUaGUgcGFyZW50IHJhbmdlIHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcmV0dXJucyB7UmFuZ2V9IEEgdmFsaWQgcG9ydGlvbiBvZiB0aGUgcGFyZW50UmFuZ2Ugd2hpY2ggaXMgb25lIGEgc2luZ2xlIGxpbmVcclxuICovXG5cblxudmFyIGZpbmRDdXJyZW50TGluZVJhbmdlID0gZnVuY3Rpb24gZmluZEN1cnJlbnRMaW5lUmFuZ2UoZWRpdG9yLCBwYXJlbnRSYW5nZSkge1xuICB2YXIgcGFyZW50UmFuZ2VCb3VuZGFyeSA9IHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHNsYXRlLlJhbmdlLmVuZChwYXJlbnRSYW5nZSkpO1xuICB2YXIgcG9zaXRpb25zID0gQXJyYXkuZnJvbShzbGF0ZS5FZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiBwYXJlbnRSYW5nZVxuICB9KSk7XG4gIHZhciBsZWZ0ID0gMDtcbiAgdmFyIHJpZ2h0ID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IocmlnaHQgLyAyKTtcblxuICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbGVmdF0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgIHJldHVybiBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbGVmdF0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG5cbiAgd2hpbGUgKG1pZGRsZSAhPT0gcG9zaXRpb25zLmxlbmd0aCAmJiBtaWRkbGUgIT09IGxlZnQpIHtcbiAgICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbWlkZGxlXSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgICByaWdodCA9IG1pZGRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IG1pZGRsZTtcbiAgICB9XG5cbiAgICBtaWRkbGUgPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gIH1cblxuICByZXR1cm4gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3JpZ2h0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogYHdpdGhSZWFjdGAgYWRkcyBSZWFjdCBhbmQgRE9NIHNwZWNpZmljIGJlaGF2aW9ycyB0byB0aGUgZWRpdG9yLlxyXG4gKlxyXG4gKiBJZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQsIHlvdSBtdXN0IGV4dGVuZCBTbGF0ZSdzIEN1c3RvbVR5cGVzIHRvIHVzZVxyXG4gKiB0aGlzIHBsdWdpbi5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZG9jcy5zbGF0ZWpzLm9yZy9jb25jZXB0cy8xMS10eXBlc2NyaXB0IHRvIGxlYXJuIGhvdy5cclxuICovXG5cbnZhciB3aXRoUmVhY3QgPSBmdW5jdGlvbiB3aXRoUmVhY3QoZWRpdG9yKSB7XG4gIHZhciBjbGlwYm9hcmRGb3JtYXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd4LXNsYXRlLWZyYWdtZW50JztcbiAgdmFyIGUgPSBlZGl0b3I7XG4gIHZhciBhcHBseSA9IGUuYXBwbHksXG4gICAgICBvbkNoYW5nZSA9IGUub25DaGFuZ2UsXG4gICAgICBkZWxldGVCYWNrd2FyZCA9IGUuZGVsZXRlQmFja3dhcmQsXG4gICAgICBhZGRNYXJrID0gZS5hZGRNYXJrLFxuICAgICAgcmVtb3ZlTWFyayA9IGUucmVtb3ZlTWFyazsgLy8gVGhlIFdlYWtNYXAgd2hpY2ggbWFwcyBhIGtleSB0byBhIHNwZWNpZmljIEhUTUxFbGVtZW50IG11c3QgYmUgc2NvcGVkIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UgdG9cbiAgLy8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGVkaXRvcnMgaW4gdGhlIERPTSB0aGF0IHNoYXJlIHRoZSBzYW1lIHZhbHVlLlxuXG4gIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5zZXQoZSwgbmV3IFdlYWtNYXAoKSk7XG5cbiAgZS5hZGRNYXJrID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GLCBfRURJVE9SX1RPX1BFTkRJTkdfREk7XG5cbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcblxuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1NbXCJkZWxldGVcIl0oZSk7XG4gICAgYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfTtcblxuICBlLnJlbW92ZU1hcmsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTW1wiZGVsZXRlXCJdKGUpO1xuICAgIHJlbW92ZU1hcmsoa2V5KTtcbiAgfTtcblxuICBlLmRlbGV0ZUJhY2t3YXJkID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICBpZiAodW5pdCAhPT0gJ2xpbmUnKSB7XG4gICAgICByZXR1cm4gZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gICAgfVxuXG4gICAgaWYgKGUuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGUuc2VsZWN0aW9uKSkge1xuICAgICAgdmFyIHBhcmVudEJsb2NrRW50cnkgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZSwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChuKSAmJiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXQ6IGUuc2VsZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmVudEJsb2NrRW50cnkpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRCbG9ja0VudHJ5ID0gX3NsaWNlZFRvQXJyYXkocGFyZW50QmxvY2tFbnRyeSwgMiksXG4gICAgICAgICAgICBwYXJlbnRCbG9ja1BhdGggPSBfcGFyZW50QmxvY2tFbnRyeVsxXTtcblxuICAgICAgICB2YXIgcGFyZW50RWxlbWVudFJhbmdlID0gc2xhdGUuRWRpdG9yLnJhbmdlKGUsIHBhcmVudEJsb2NrUGF0aCwgZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lUmFuZ2UgPSBmaW5kQ3VycmVudExpbmVSYW5nZShlLCBwYXJlbnRFbGVtZW50UmFuZ2UpO1xuXG4gICAgICAgIGlmICghc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudExpbmVSYW5nZSkpIHtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGUsIHtcbiAgICAgICAgICAgIGF0OiBjdXJyZW50TGluZVJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgYXR0ZW1wdHMgdG8gcmVzZXQgdGhlIE5PREVfVE9fS0VZIGVudHJ5IHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGFzIGFwcGx5KCkgY2hhbmdlcyB0aGUgb2JqZWN0IHJlZmVyZW5jZSBhbmQgaGVuY2UgaW52YWxpZGF0ZXMgdGhlIE5PREVfVE9fS0VZIGVudHJ5XG5cblxuICBlLmFwcGx5ID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdEaWZmcyAhPT0gbnVsbCAmJiBwZW5kaW5nRGlmZnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nRGlmZnMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBwZW5kaW5nRGlmZnMubWFwKGZ1bmN0aW9uICh0ZXh0RGlmZikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlLCB0cmFuc2Zvcm1lZCk7XG4gICAgfVxuXG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZSwgdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdTZWxlY3Rpb24sIG9wKSk7XG4gICAgfVxuXG4gICAgdmFyIHBlbmRpbmdBY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gIT09IG51bGwgJiYgcGVuZGluZ0FjdGlvbiAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb24uYXQpIHtcbiAgICAgIHZhciBhdCA9IHNsYXRlLlBvaW50LmlzUG9pbnQocGVuZGluZ0FjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nQWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nQWN0aW9uLmF0KSA/IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCkgOiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlLCBhdCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGVuZGluZ0FjdGlvbiksIHt9LCB7XG4gICAgICAgIGF0OiBhdFxuICAgICAgfSkgOiBudWxsKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIG9wLnBhdGgpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0VESVRPUl9UT19VU0VSX1NFTEVDO1xuXG4gICAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyBtYW51YWxseSBzZXQsIGRvbid0IHJlc3RvcmUgdGhlIHVzZXIgc2VsZWN0aW9uIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OW1wiZGVsZXRlXCJdKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TWF0Y2hlcyhlLCBzbGF0ZS5QYXRoLnBhcmVudChvcC5wYXRoKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IHNsYXRlLlBhdGgucHJldmlvdXMob3AucGF0aCk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIHByZXZQYXRoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IHNsYXRlLlBhdGguY29tbW9uKHNsYXRlLlBhdGgucGFyZW50KG9wLnBhdGgpLCBzbGF0ZS5QYXRoLnBhcmVudChvcC5uZXdQYXRoKSk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIGNvbW1vblBhdGgpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseShvcCk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9tYXRjaGVzID0gbWF0Y2hlczsgX2kgPCBfbWF0Y2hlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbWF0Y2hlcyRfaSA9IF9zbGljZWRUb0FycmF5KF9tYXRjaGVzW19pXSwgMiksXG4gICAgICAgICAgcGF0aCA9IF9tYXRjaGVzJF9pWzBdLFxuICAgICAgICAgIGtleSA9IF9tYXRjaGVzJF9pWzFdO1xuXG4gICAgICB2YXIgX0VkaXRvciRub2RlID0gc2xhdGUuRWRpdG9yLm5vZGUoZSwgcGF0aCksXG4gICAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF07XG5cbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBlLnNldEZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGUuc2VsZWN0aW9uO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gc2xhdGUuUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgIHZhciBzdGFydFZvaWQgPSBzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGUsIHtcbiAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgfSk7XG4gICAgdmFyIGVuZFZvaWQgPSBzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGUsIHtcbiAgICAgIGF0OiBlbmQucGF0aFxuICAgIH0pO1xuXG4gICAgaWYgKHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBzZWxlY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGEgQmFzZTY0LWVuY29kZWQgY29weSBvZiB0aGVcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG5cblxuICAgIHZhciBkb21SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBkb21SYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgdmFyIGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbMF07IC8vIE1ha2Ugc3VyZSBhdHRhY2ggaXMgbm9uLWVtcHR5LCBzaW5jZSBlbXB0eSBub2RlcyB3aWxsIG5vdCBnZXQgY29waWVkLlxuXG4gICAgY29udGVudHMuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgYXR0YWNoID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ09NUEFUOiBJZiB0aGUgZW5kIG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gbW92ZSB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIHJhbmdlIGZyb20gdGhlIHZvaWQgbm9kZSdzIHNwYWNlciBzcGFuLCB0byB0aGUgZW5kIG9mIHRoZSB2b2lkIG5vZGUnc1xuICAgIC8vIGNvbnRlbnQsIHNpbmNlIHRoZSBzcGFjZXIgaXMgYmVmb3JlIHZvaWQncyBjb250ZW50IGluIHRoZSBET00uXG5cbiAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgdmFyIF9lbmRWb2lkID0gX3NsaWNlZFRvQXJyYXkoZW5kVm9pZCwgMSksXG4gICAgICAgICAgdm9pZE5vZGUgPSBfZW5kVm9pZFswXTtcblxuICAgICAgdmFyIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9IC8vIENPTVBBVDogSWYgdGhlIHN0YXJ0IG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gYXR0YWNoIHRoZSBlbmNvZGVkXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBzcGFjZXIsIGJlY2F1c2VcbiAgICAvLyBhdHRhY2hpbmcgaXQgdG8gZW1wdHkgYDxkaXY+LzxzcGFuPmAgbm9kZXMgd2lsbCBlbmQgdXAgaGF2aW5nIGl0IGVyYXNlZCBieVxuICAgIC8vIG1vc3QgYnJvd3NlcnMuICgyMDE4LzA0LzI3KVxuXG5cbiAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1zcGFjZXJdJyk7XG4gICAgfSAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cblxuXG4gICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKS5mb3JFYWNoKGZ1bmN0aW9uICh6dykge1xuICAgICAgdmFyIGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICduJztcbiAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB9KTsgLy8gU2V0IGEgYGRhdGEtc2xhdGUtZnJhZ21lbnRgIGF0dHJpYnV0ZSBvbiBhIG5vbi1lbXB0eSBub2RlLCBzbyBpdCBzaG93cyB1cFxuICAgIC8vIGluIHRoZSBIVE1MLCBhbmQgY2FuIGJlIHVzZWQgZm9yIGludHJhLVNsYXRlIHBhc3RpbmcuIElmIGl0J3MgYSB0ZXh0XG4gICAgLy8gbm9kZSwgd3JhcCBpdCBpbiBhIGA8c3Bhbj5gIHNvIHdlIGhhdmUgc29tZXRoaW5nIHRvIHNldCBhbiBhdHRyaWJ1dGUgb24uXG5cbiAgICBpZiAoaXNET01UZXh0KGF0dGFjaCkpIHtcbiAgICAgIHZhciBzcGFuID0gYXR0YWNoLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyAvLyBDT01QQVQ6IEluIENocm9tZSBhbmQgU2FmYXJpLCBpZiB3ZSBkb24ndCBhZGQgdGhlIGB3aGl0ZS1zcGFjZWAgc3R5bGVcbiAgICAgIC8vIHRoZW4gbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIHdpbGwgYmUgaWdub3JlZC4gKDIwMTcvMDkvMjEpXG5cbiAgICAgIHNwYW4uc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUnO1xuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChhdHRhY2gpO1xuICAgICAgY29udGVudHMuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBhdHRhY2ggPSBzcGFuO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IGUuZ2V0RnJhZ21lbnQoKTtcbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZnJhZ21lbnQpO1xuICAgIHZhciBlbmNvZGVkID0gd2luZG93LmJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTtcbiAgICBkYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9cIi5jb25jYXQoY2xpcGJvYXJkRm9ybWF0S2V5KSwgZW5jb2RlZCk7IC8vIEFkZCB0aGUgY29udGVudCB0byBhIDxkaXY+IHNvIHRoYXQgd2UgY2FuIGdldCBpdHMgaW5uZXIgSFRNTC5cblxuICAgIHZhciBkaXYgPSBjb250ZW50cy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ3RydWUnKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGRpdi5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGdldFBsYWluVGV4dChkaXYpKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBlLmluc2VydERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghZS5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSkpIHtcbiAgICAgIGUuaW5zZXJ0VGV4dERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIGUuaW5zZXJ0RnJhZ21lbnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvKipcclxuICAgICAqIENoZWNraW5nIGNvcGllZCBmcmFnbWVudCBmcm9tIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgb3IgZGF0YS1zbGF0ZS1mcmFnbWVudFxyXG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG5cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIGUuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLmluc2VydFRleHREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdGV4dCA9IGRhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG4gICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxpbmVzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgbGluZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZSwge1xuICAgICAgICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUuaW5zZXJ0VGV4dChsaW5lKTtcbiAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGUub25DaGFuZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIENPTVBBVDogUmVhY3QgPCAxOCBkb2Vzbid0IGJhdGNoIGBzZXRTdGF0ZWAgaG9vayBjYWxscywgd2hpY2ggbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBjaGlsZHJlbiBhbmQgc2VsZWN0aW9uIGNhbiBnZXQgb3V0IG9mIHN5bmMgZm9yIG9uZSByZW5kZXJcbiAgICAvLyBwYXNzLiBTbyB3ZSBoYXZlIHRvIHVzZSB0aGlzIHVuc3RhYmxlIEFQSSB0byBlbnN1cmUgaXQgYmF0Y2hlcyB0aGVtLlxuICAgIC8vICgyMDE5LzEyLzAzKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyNTkjaXNzdWVjb21tZW50LTQzOTcwMjM2N1xuICAgIHZhciBtYXliZUJhdGNoVXBkYXRlcyA9IFJFQUNUX01BSk9SX1ZFUlNJT04gPCAxOCA/IFJlYWN0RE9NX19kZWZhdWx0WydkZWZhdWx0J10udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgbWF5YmVCYXRjaFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQ29udGV4dENoYW5nZSA9IEVESVRPUl9UT19PTl9DSEFOR0UuZ2V0KGUpO1xuXG4gICAgICBpZiAob25Db250ZXh0Q2hhbmdlKSB7XG4gICAgICAgIG9uQ29udGV4dENoYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZTtcbn07XG5cbnZhciBnZXRNYXRjaGVzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlcyhlLCBwYXRoKSB7XG4gIHZhciBtYXRjaGVzID0gW107XG5cbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzbGF0ZS5FZGl0b3IubGV2ZWxzKGUsIHtcbiAgICBhdDogcGF0aFxuICB9KSksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgbiA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICBwID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlLCBuKTtcbiAgICAgIG1hdGNoZXMucHVzaChbcCwga2V5XSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxuZXhwb3J0cy5EZWZhdWx0RWxlbWVudCA9IERlZmF1bHRFbGVtZW50O1xuZXhwb3J0cy5EZWZhdWx0TGVhZiA9IERlZmF1bHRMZWFmO1xuZXhwb3J0cy5EZWZhdWx0UGxhY2Vob2xkZXIgPSBEZWZhdWx0UGxhY2Vob2xkZXI7XG5leHBvcnRzLkVkaXRhYmxlID0gRWRpdGFibGU7XG5leHBvcnRzLlJlYWN0RWRpdG9yID0gUmVhY3RFZGl0b3I7XG5leHBvcnRzLlNsYXRlID0gU2xhdGU7XG5leHBvcnRzLnVzZUVkaXRvciA9IHVzZUVkaXRvcjtcbmV4cG9ydHMudXNlRm9jdXNlZCA9IHVzZUZvY3VzZWQ7XG5leHBvcnRzLnVzZVJlYWRPbmx5ID0gdXNlUmVhZE9ubHk7XG5leHBvcnRzLnVzZVNlbGVjdGVkID0gdXNlU2VsZWN0ZWQ7XG5leHBvcnRzLnVzZVNsYXRlID0gdXNlU2xhdGU7XG5leHBvcnRzLnVzZVNsYXRlU2VsZWN0aW9uID0gdXNlU2xhdGVTZWxlY3Rpb247XG5leHBvcnRzLnVzZVNsYXRlU2VsZWN0b3IgPSB1c2VTbGF0ZVNlbGVjdG9yO1xuZXhwb3J0cy51c2VTbGF0ZVN0YXRpYyA9IHVzZVNsYXRlU3RhdGljO1xuZXhwb3J0cy51c2VTbGF0ZVdpdGhWID0gdXNlU2xhdGVXaXRoVjtcbmV4cG9ydHMud2l0aFJlYWN0ID0gd2l0aFJlYWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.js ***!
  \**************************************************************************************/
/***/ ((module) => {

eval("function t(t){return\"object\"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return(!e||\"hidden\"!==t)&&\"visible\"!==t&&\"clip\"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var i=getComputedStyle(t,null);return e(i.overflowY,n)||e(i.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function i(t,e,n,i,r,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-i:l>e&&d<n||o<t&&d>n?l-e+r:0}module.exports=function(e,r){var o=window,l=r.scrollMode,d=r.block,f=r.inline,h=r.boundary,u=r.skipOverflowHiddenElements,s=\"function\"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError(\"Invalid target\");for(var c,a,g=document.scrollingElement||document.documentElement,m=[],p=e;t(p)&&s(p);){if((p=null==(a=(c=p).parentElement)?c.getRootNode().host||null:a)===g){m.push(p);break}null!=p&&p===document.body&&n(p)&&!n(document.documentElement)||null!=p&&n(p,u)&&m.push(p)}for(var w=o.visualViewport?o.visualViewport.width:innerWidth,v=o.visualViewport?o.visualViewport.height:innerHeight,W=window.scrollX||pageXOffset,H=window.scrollY||pageYOffset,b=e.getBoundingClientRect(),y=b.height,E=b.width,M=b.top,V=b.right,x=b.bottom,I=b.left,C=\"start\"===d||\"nearest\"===d?M:\"end\"===d?x:M+y/2,R=\"center\"===f?I+E/2:\"end\"===f?V:I,T=[],k=0;k<m.length;k++){var B=m[k],D=B.getBoundingClientRect(),O=D.height,X=D.width,Y=D.top,L=D.right,S=D.bottom,j=D.left;if(\"if-needed\"===l&&M>=0&&I>=0&&x<=v&&V<=w&&M>=Y&&x<=S&&I>=j&&V<=L)return T;var N=getComputedStyle(B),q=parseInt(N.borderLeftWidth,10),z=parseInt(N.borderTopWidth,10),A=parseInt(N.borderRightWidth,10),F=parseInt(N.borderBottomWidth,10),G=0,J=0,K=\"offsetWidth\"in B?B.offsetWidth-B.clientWidth-q-A:0,P=\"offsetHeight\"in B?B.offsetHeight-B.clientHeight-z-F:0,Q=\"offsetWidth\"in B?0===B.offsetWidth?0:X/B.offsetWidth:0,U=\"offsetHeight\"in B?0===B.offsetHeight?0:O/B.offsetHeight:0;if(g===B)G=\"start\"===d?C:\"end\"===d?C-v:\"nearest\"===d?i(H,H+v,v,z,F,H+C,H+C+y,y):C-v/2,J=\"start\"===f?R:\"center\"===f?R-w/2:\"end\"===f?R-w:i(W,W+w,w,q,A,W+R,W+R+E,E),G=Math.max(0,G+H),J=Math.max(0,J+W);else{G=\"start\"===d?C-Y-z:\"end\"===d?C-S+F+P:\"nearest\"===d?i(Y,S,O,z,F+P,C,C+y,y):C-(Y+O/2)+P/2,J=\"start\"===f?R-j-q:\"center\"===f?R-(j+X/2)+K/2:\"end\"===f?R-L+A+K:i(j,L,X,q,A+K,R,R+E,E);var Z=B.scrollLeft,$=B.scrollTop;C+=$-(G=Math.max(0,Math.min($+G/U,B.scrollHeight-O/U+P))),R+=Z-(J=Math.max(0,Math.min(Z+J/Q,B.scrollWidth-X/Q+K)))}T.push({el:B,top:G,left:J})}return T};\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsa0RBQWtELGdCQUFnQixvREFBb0QsZ0JBQWdCLCtEQUErRCwrQkFBK0IsdURBQXVELGtCQUFrQiw4REFBOEQsSUFBSSxnREFBZ0QsU0FBUyxhQUFhLElBQUksd0VBQXdFLElBQUksU0FBUyw0QkFBNEIsb0ZBQW9GLDZCQUE2QixrSUFBa0ksY0FBYywrQ0FBK0MsMkVBQTJFLFdBQVcsRUFBRSx1RUFBdUUsVUFBVSxNQUFNLDJGQUEyRixvV0FBb1csV0FBVyxLQUFLLGtHQUFrRyw0RUFBNEUsOFlBQThZLHNNQUFzTSxLQUFLLGlMQUFpTCxpQ0FBaUMsbUhBQW1ILFFBQVEsa0JBQWtCLEVBQUU7QUFDOWtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9ub2RlX21vZHVsZXMvY29tcHV0ZS1zY3JvbGwtaW50by12aWV3L2Rpc3QvaW5kZXguanM/YWJhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB0KHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT10JiYxPT09dC5ub2RlVHlwZX1mdW5jdGlvbiBlKHQsZSl7cmV0dXJuKCFlfHxcImhpZGRlblwiIT09dCkmJlwidmlzaWJsZVwiIT09dCYmXCJjbGlwXCIhPT10fWZ1bmN0aW9uIG4odCxuKXtpZih0LmNsaWVudEhlaWdodDx0LnNjcm9sbEhlaWdodHx8dC5jbGllbnRXaWR0aDx0LnNjcm9sbFdpZHRoKXt2YXIgaT1nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCk7cmV0dXJuIGUoaS5vdmVyZmxvd1ksbil8fGUoaS5vdmVyZmxvd1gsbil8fGZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe2lmKCF0Lm93bmVyRG9jdW1lbnR8fCF0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpcmV0dXJuIG51bGw7dHJ5e3JldHVybiB0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZnJhbWVFbGVtZW50fWNhdGNoKHQpe3JldHVybiBudWxsfX0odCk7cmV0dXJuISFlJiYoZS5jbGllbnRIZWlnaHQ8dC5zY3JvbGxIZWlnaHR8fGUuY2xpZW50V2lkdGg8dC5zY3JvbGxXaWR0aCl9KHQpfXJldHVybiExfWZ1bmN0aW9uIGkodCxlLG4saSxyLG8sbCxkKXtyZXR1cm4gbzx0JiZsPmV8fG8+dCYmbDxlPzA6bzw9dCYmZDw9bnx8bD49ZSYmZD49bj9vLXQtaTpsPmUmJmQ8bnx8bzx0JiZkPm4/bC1lK3I6MH1tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihlLHIpe3ZhciBvPXdpbmRvdyxsPXIuc2Nyb2xsTW9kZSxkPXIuYmxvY2ssZj1yLmlubGluZSxoPXIuYm91bmRhcnksdT1yLnNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzLHM9XCJmdW5jdGlvblwiPT10eXBlb2YgaD9oOmZ1bmN0aW9uKHQpe3JldHVybiB0IT09aH07aWYoIXQoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFyZ2V0XCIpO2Zvcih2YXIgYyxhLGc9ZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LG09W10scD1lO3QocCkmJnMocCk7KXtpZigocD1udWxsPT0oYT0oYz1wKS5wYXJlbnRFbGVtZW50KT9jLmdldFJvb3ROb2RlKCkuaG9zdHx8bnVsbDphKT09PWcpe20ucHVzaChwKTticmVha31udWxsIT1wJiZwPT09ZG9jdW1lbnQuYm9keSYmbihwKSYmIW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXx8bnVsbCE9cCYmbihwLHUpJiZtLnB1c2gocCl9Zm9yKHZhciB3PW8udmlzdWFsVmlld3BvcnQ/by52aXN1YWxWaWV3cG9ydC53aWR0aDppbm5lcldpZHRoLHY9by52aXN1YWxWaWV3cG9ydD9vLnZpc3VhbFZpZXdwb3J0LmhlaWdodDppbm5lckhlaWdodCxXPXdpbmRvdy5zY3JvbGxYfHxwYWdlWE9mZnNldCxIPXdpbmRvdy5zY3JvbGxZfHxwYWdlWU9mZnNldCxiPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkseT1iLmhlaWdodCxFPWIud2lkdGgsTT1iLnRvcCxWPWIucmlnaHQseD1iLmJvdHRvbSxJPWIubGVmdCxDPVwic3RhcnRcIj09PWR8fFwibmVhcmVzdFwiPT09ZD9NOlwiZW5kXCI9PT1kP3g6TSt5LzIsUj1cImNlbnRlclwiPT09Zj9JK0UvMjpcImVuZFwiPT09Zj9WOkksVD1bXSxrPTA7azxtLmxlbmd0aDtrKyspe3ZhciBCPW1ba10sRD1CLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLE89RC5oZWlnaHQsWD1ELndpZHRoLFk9RC50b3AsTD1ELnJpZ2h0LFM9RC5ib3R0b20saj1ELmxlZnQ7aWYoXCJpZi1uZWVkZWRcIj09PWwmJk0+PTAmJkk+PTAmJng8PXYmJlY8PXcmJk0+PVkmJng8PVMmJkk+PWomJlY8PUwpcmV0dXJuIFQ7dmFyIE49Z2V0Q29tcHV0ZWRTdHlsZShCKSxxPXBhcnNlSW50KE4uYm9yZGVyTGVmdFdpZHRoLDEwKSx6PXBhcnNlSW50KE4uYm9yZGVyVG9wV2lkdGgsMTApLEE9cGFyc2VJbnQoTi5ib3JkZXJSaWdodFdpZHRoLDEwKSxGPXBhcnNlSW50KE4uYm9yZGVyQm90dG9tV2lkdGgsMTApLEc9MCxKPTAsSz1cIm9mZnNldFdpZHRoXCJpbiBCP0Iub2Zmc2V0V2lkdGgtQi5jbGllbnRXaWR0aC1xLUE6MCxQPVwib2Zmc2V0SGVpZ2h0XCJpbiBCP0Iub2Zmc2V0SGVpZ2h0LUIuY2xpZW50SGVpZ2h0LXotRjowLFE9XCJvZmZzZXRXaWR0aFwiaW4gQj8wPT09Qi5vZmZzZXRXaWR0aD8wOlgvQi5vZmZzZXRXaWR0aDowLFU9XCJvZmZzZXRIZWlnaHRcImluIEI/MD09PUIub2Zmc2V0SGVpZ2h0PzA6Ty9CLm9mZnNldEhlaWdodDowO2lmKGc9PT1CKUc9XCJzdGFydFwiPT09ZD9DOlwiZW5kXCI9PT1kP0MtdjpcIm5lYXJlc3RcIj09PWQ/aShILEgrdix2LHosRixIK0MsSCtDK3kseSk6Qy12LzIsSj1cInN0YXJ0XCI9PT1mP1I6XCJjZW50ZXJcIj09PWY/Ui13LzI6XCJlbmRcIj09PWY/Ui13OmkoVyxXK3csdyxxLEEsVytSLFcrUitFLEUpLEc9TWF0aC5tYXgoMCxHK0gpLEo9TWF0aC5tYXgoMCxKK1cpO2Vsc2V7Rz1cInN0YXJ0XCI9PT1kP0MtWS16OlwiZW5kXCI9PT1kP0MtUytGK1A6XCJuZWFyZXN0XCI9PT1kP2koWSxTLE8seixGK1AsQyxDK3kseSk6Qy0oWStPLzIpK1AvMixKPVwic3RhcnRcIj09PWY/Ui1qLXE6XCJjZW50ZXJcIj09PWY/Ui0oaitYLzIpK0svMjpcImVuZFwiPT09Zj9SLUwrQStLOmkoaixMLFgscSxBK0ssUixSK0UsRSk7dmFyIFo9Qi5zY3JvbGxMZWZ0LCQ9Qi5zY3JvbGxUb3A7Qys9JC0oRz1NYXRoLm1heCgwLE1hdGgubWluKCQrRy9VLEIuc2Nyb2xsSGVpZ2h0LU8vVStQKSkpLFIrPVotKEo9TWF0aC5tYXgoMCxNYXRoLm1pbihaK0ovUSxCLnNjcm9sbFdpZHRoLVgvUStLKSkpfVQucHVzaCh7ZWw6Qix0b3A6RyxsZWZ0Okp9KX1yZXR1cm4gVH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate-react/node_modules/scroll-into-view-if-needed/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/slate-react/node_modules/scroll-into-view-if-needed/index.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _computeScrollIntoView = _interopRequireDefault(__webpack_require__(/*! compute-scroll-into-view */ \"(ssr)/./node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n  var canSmoothScroll = ('scrollBehavior' in document.body.style);\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n      top = _ref.top,\n      left = _ref.left;\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n  if (isOptionsObject(options)) {\n    return options;\n  }\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\nfunction scrollIntoView(target, options) {\n  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(isTargetAttached ? (0, _computeScrollIntoView[\"default\"])(target, options) : []);\n  }\n  if (!isTargetAttached) {\n    return;\n  }\n  var computeOptions = getOptions(options);\n  return defaultBehavior((0, _computeScrollIntoView[\"default\"])(target, computeOptions), computeOptions.behavior);\n}\nvar _default = scrollIntoView;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3Qvbm9kZV9tb2R1bGVzL3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsb0RBQW9ELG1CQUFPLENBQUMsc0hBQTBCO0FBQ3RGLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9ub2RlX21vZHVsZXMvc2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWQvaW5kZXguanM/MjA2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIF9jb21wdXRlU2Nyb2xsSW50b1ZpZXcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjb21wdXRlLXNjcm9sbC1pbnRvLXZpZXdcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBpc09wdGlvbnNPYmplY3Qob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA9PT0gT2JqZWN0KG9wdGlvbnMpICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCAhPT0gMDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRCZWhhdmlvcihhY3Rpb25zLCBiZWhhdmlvcikge1xuICBpZiAoYmVoYXZpb3IgPT09IHZvaWQgMCkge1xuICAgIGJlaGF2aW9yID0gJ2F1dG8nO1xuICB9XG4gIHZhciBjYW5TbW9vdGhTY3JvbGwgPSAoJ3Njcm9sbEJlaGF2aW9yJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlKTtcbiAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGVsID0gX3JlZi5lbCxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdDtcbiAgICBpZiAoZWwuc2Nyb2xsICYmIGNhblNtb290aFNjcm9sbCkge1xuICAgICAgZWwuc2Nyb2xsKHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIGJlaGF2aW9yOiBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIGVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrOiAnZW5kJyxcbiAgICAgIGlubGluZTogJ25lYXJlc3QnXG4gICAgfTtcbiAgfVxuICBpZiAoaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBibG9jazogJ3N0YXJ0JyxcbiAgICBpbmxpbmU6ICduZWFyZXN0J1xuICB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBpc1RhcmdldEF0dGFjaGVkID0gdGFyZ2V0LmlzQ29ubmVjdGVkIHx8IHRhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0YXJnZXQpO1xuICBpZiAoaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpICYmIHR5cGVvZiBvcHRpb25zLmJlaGF2aW9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmVoYXZpb3IoaXNUYXJnZXRBdHRhY2hlZCA/ICgwLCBfY29tcHV0ZVNjcm9sbEludG9WaWV3W1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBvcHRpb25zKSA6IFtdKTtcbiAgfVxuICBpZiAoIWlzVGFyZ2V0QXR0YWNoZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbXB1dGVPcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgcmV0dXJuIGRlZmF1bHRCZWhhdmlvcigoMCwgX2NvbXB1dGVTY3JvbGxJbnRvVmlld1tcImRlZmF1bHRcIl0pKHRhcmdldCwgY29tcHV0ZU9wdGlvbnMpLCBjb21wdXRlT3B0aW9ucy5iZWhhdmlvcik7XG59XG52YXIgX2RlZmF1bHQgPSBzY3JvbGxJbnRvVmlldztcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-react/node_modules/scroll-into-view-if-needed/index.js\n");

/***/ })

};
;