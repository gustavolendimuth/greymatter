"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mendoza";
exports.ids = ["vendor-chunks/mendoza"];
exports.modules = {

/***/ "(ssr)/./node_modules/mendoza/dist/index.cjs":
/*!*********************************************!*\
  !*** ./node_modules/mendoza/dist/index.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst OPS = [\"Value\", \"Copy\", \"Blank\", \"ReturnIntoArray\", \"ReturnIntoObject\", \"ReturnIntoObjectSameKey\", \"PushField\", \"PushElement\", \"PushParent\", \"Pop\", \"PushFieldCopy\", \"PushFieldBlank\", \"PushElementCopy\", \"PushElementBlank\", \"ReturnIntoObjectPop\", \"ReturnIntoObjectSameKeyPop\", \"ReturnIntoArrayPop\", \"ObjectSetFieldValue\", \"ObjectCopyField\", \"ObjectDeleteField\", \"ArrayAppendValue\", \"ArrayAppendSlice\", \"StringAppendString\", \"StringAppendSlice\"];\nclass Patcher {\n  constructor(model, root, patch) {\n    __publicField$1(this, \"model\");\n    __publicField$1(this, \"root\");\n    __publicField$1(this, \"patch\");\n    __publicField$1(this, \"i\");\n    __publicField$1(this, \"inputStack\");\n    __publicField$1(this, \"outputStack\");\n    this.model = model;\n    this.root = root;\n    this.patch = patch;\n    this.i = 0;\n    this.inputStack = [];\n    this.outputStack = [];\n  }\n  read() {\n    return this.patch[this.i++];\n  }\n  process() {\n    this.inputStack.push({\n      value: this.root\n    });\n    this.outputStack.push({\n      value: this.root\n    });\n    for (; this.i < this.patch.length;) {\n      let opcode = this.read();\n      let op = OPS[opcode];\n      if (!op) throw new Error(\"Unknown opcode: \".concat(opcode));\n      let processor = \"process\".concat(op);\n      this[processor].apply(this);\n    }\n    let entry = this.outputStack.pop();\n    return this.finalizeOutput(entry);\n  }\n  inputEntry() {\n    return this.inputStack[this.inputStack.length - 1];\n  }\n  inputKey(entry, idx) {\n    if (!entry.keys) {\n      entry.keys = this.model.objectGetKeys(entry.value).sort();\n    }\n    return entry.keys[idx];\n  }\n  outputEntry() {\n    return this.outputStack[this.outputStack.length - 1];\n  }\n  outputArray() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyArray(entry.value);\n    }\n    return entry.writeValue;\n  }\n  outputObject() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyObject(entry.value);\n    }\n    return entry.writeValue;\n  }\n  outputString() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyString(entry.value);\n    }\n    return entry.writeValue;\n  }\n  finalizeOutput(entry) {\n    if (entry.writeValue) {\n      return this.model.finalize(entry.writeValue);\n    } else {\n      return entry.value;\n    }\n  }\n  // Processors:\n  processValue() {\n    let value = this.model.wrap(this.read());\n    this.outputStack.push({\n      value\n    });\n  }\n  processCopy() {\n    let input = this.inputEntry();\n    this.outputStack.push({\n      value: input.value\n    });\n  }\n  processBlank() {\n    this.outputStack.push({\n      value: null\n    });\n  }\n  processReturnIntoArray() {\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    let arr = this.outputArray();\n    this.model.arrayAppendValue(arr, result);\n  }\n  processReturnIntoObject() {\n    let key = this.read();\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    result = this.model.markChanged(result);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, key, result);\n  }\n  processReturnIntoObjectSameKey() {\n    let input = this.inputEntry();\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, input.key, result);\n  }\n  processPushField() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let key = this.inputKey(entry, idx);\n    let value = this.model.objectGetField(entry.value, key);\n    this.inputStack.push({\n      value,\n      key\n    });\n  }\n  processPushElement() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let value = this.model.arrayGetElement(entry.value, idx);\n    this.inputStack.push({\n      value\n    });\n  }\n  processPop() {\n    this.inputStack.pop();\n  }\n  processPushFieldCopy() {\n    this.processPushField();\n    this.processCopy();\n  }\n  processPushFieldBlank() {\n    this.processPushField();\n    this.processBlank();\n  }\n  processPushElementCopy() {\n    this.processPushElement();\n    this.processCopy();\n  }\n  processPushElementBlank() {\n    this.processPushElement();\n    this.processBlank();\n  }\n  processReturnIntoObjectPop() {\n    this.processReturnIntoObject();\n    this.processPop();\n  }\n  processReturnIntoObjectSameKeyPop() {\n    this.processReturnIntoObjectSameKey();\n    this.processPop();\n  }\n  processReturnIntoArrayPop() {\n    this.processReturnIntoArray();\n    this.processPop();\n  }\n  processObjectSetFieldValue() {\n    this.processValue();\n    this.processReturnIntoObject();\n  }\n  processObjectCopyField() {\n    this.processPushField();\n    this.processCopy();\n    this.processReturnIntoObjectSameKey();\n    this.processPop();\n  }\n  processObjectDeleteField() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let key = this.inputKey(entry, idx);\n    let obj = this.outputObject();\n    this.model.objectDeleteField(obj, key);\n  }\n  processArrayAppendValue() {\n    let value = this.model.wrap(this.read());\n    let arr = this.outputArray();\n    this.model.arrayAppendValue(arr, value);\n  }\n  processArrayAppendSlice() {\n    let left = this.read();\n    let right = this.read();\n    let str = this.outputArray();\n    let val = this.inputEntry().value;\n    this.model.arrayAppendSlice(str, val, left, right);\n  }\n  processStringAppendString() {\n    let value = this.model.wrap(this.read());\n    let str = this.outputString();\n    this.model.stringAppendValue(str, value);\n  }\n  processStringAppendSlice() {\n    let left = this.read();\n    let right = this.read();\n    let str = this.outputString();\n    let val = this.inputEntry().value;\n    this.model.stringAppendSlice(str, val, left, right);\n  }\n}\nfunction utf8charSize(code) {\n  if (code >> 16) {\n    return 4;\n  } else if (code >> 11) {\n    return 3;\n  } else if (code >> 7) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\nfunction utf8stringSize(str) {\n  let b = 0;\n  for (let i = 0; i < str.length; i++) {\n    let code = str.codePointAt(i);\n    let size = utf8charSize(code);\n    if (size == 4) i++;\n    b += size;\n  }\n  return b;\n}\nfunction utf8resolveIndex(str, idx) {\n  let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let byteCount = start;\n  let ucsIdx = 0;\n  for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n    let code = str.codePointAt(ucsIdx);\n    let size = utf8charSize(code);\n    if (size === 4) ucsIdx++;\n    byteCount += size;\n  }\n  return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n  let len = Math.min(str.length, str2.length);\n  let b = 0;\n  for (let i = 0; i < len;) {\n    let aPoint = str.codePointAt(i);\n    let bPoint = str2.codePointAt(i);\n    if (aPoint !== bPoint) return b;\n    let size = utf8charSize(aPoint);\n    b += size;\n    i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nfunction commonSuffix(str, str2) {\n  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let len = Math.min(str.length, str2.length) - prefix;\n  let b = 0;\n  for (let i = 0; i < len;) {\n    let aPoint = str.codePointAt(str.length - 1 - i);\n    let bPoint = str2.codePointAt(str2.length - 1 - i);\n    if (aPoint !== bPoint) return b;\n    let size = utf8charSize(aPoint);\n    b += size;\n    i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass IncrementalModel {\n  constructor(meta) {\n    __publicField(this, \"meta\");\n    this.meta = meta;\n  }\n  wrap(data) {\n    return this.wrapWithMeta(data, this.meta, this.meta);\n  }\n  wrapWithMeta(data, startMeta) {\n    let endMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.meta;\n    return {\n      data,\n      startMeta,\n      endMeta\n    };\n  }\n  asObject(value) {\n    if (!value.content) {\n      let fields = {};\n      for (let [key, val] of Object.entries(value.data)) {\n        fields[key] = this.wrapWithMeta(val, value.startMeta);\n      }\n      value.content = {\n        type: \"object\",\n        fields\n      };\n    }\n    return value.content;\n  }\n  asArray(value) {\n    if (!value.content) {\n      let elements = value.data.map(item => this.wrapWithMeta(item, value.startMeta));\n      let metas = elements.map(() => this.meta);\n      value.content = {\n        type: \"array\",\n        elements,\n        metas\n      };\n    }\n    return value.content;\n  }\n  asString(value) {\n    if (!value.content) {\n      let str = value.data;\n      let part = {\n        value: str,\n        utf8size: utf8stringSize(str),\n        uses: [],\n        startMeta: value.startMeta,\n        endMeta: value.endMeta\n      };\n      value.content = this.stringFromParts([part]);\n    }\n    return value.content;\n  }\n  stringFromParts(parts) {\n    let str = {\n      type: \"string\",\n      parts\n    };\n    for (let part of parts) {\n      part.uses.push(str);\n    }\n    return str;\n  }\n  objectGetKeys(value) {\n    if (value.content) {\n      return Object.keys(value.content.fields);\n    } else {\n      return Object.keys(value.data);\n    }\n  }\n  objectGetField(value, key) {\n    let obj = this.asObject(value);\n    return obj.fields[key];\n  }\n  arrayGetElement(value, idx) {\n    let arr = this.asArray(value);\n    return arr.elements[idx];\n  }\n  finalize(content) {\n    this.updateEndMeta(content);\n    return {\n      content,\n      startMeta: this.meta,\n      endMeta: this.meta\n    };\n  }\n  markChanged(value) {\n    return this.wrap(unwrap(value));\n  }\n  updateEndMeta(content) {\n    if (content.type == \"string\") {\n      for (let part of content.parts) {\n        part.endMeta = this.meta;\n      }\n    } else {\n      if (content.type === \"array\") {\n        for (let val of content.elements) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content);\n          }\n          val.endMeta = this.meta;\n        }\n      } else {\n        for (let val of Object.values(content.fields)) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content);\n          }\n          val.endMeta = this.meta;\n        }\n      }\n    }\n  }\n  copyString(value) {\n    if (value) {\n      let other = this.asString(value);\n      return this.stringFromParts(other.parts.slice());\n    } else {\n      return {\n        type: \"string\",\n        parts: []\n      };\n    }\n  }\n  copyObject(value) {\n    let obj = {\n      type: \"object\",\n      fields: {}\n    };\n    if (value) {\n      let other = this.asObject(value);\n      Object.assign(obj.fields, other.fields);\n    }\n    return obj;\n  }\n  copyArray(value) {\n    let arr = value ? this.asArray(value) : null;\n    let elements = arr ? arr.elements : [];\n    let metas = arr ? arr.metas : [];\n    return {\n      type: \"array\",\n      elements,\n      metas\n    };\n  }\n  objectSetField(target, key, value) {\n    target.fields[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.fields[key];\n  }\n  arrayAppendValue(target, value) {\n    target.elements.push(value);\n    target.metas.push(this.meta);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    let arr = this.asArray(source);\n    let samePosition = arr.elements.length === left;\n    target.elements.push(...arr.elements.slice(left, right));\n    if (samePosition) {\n      target.metas.push(...arr.metas.slice(left, right));\n    } else {\n      for (let i = left; i < right; i++) {\n        target.metas.push(this.meta);\n      }\n    }\n  }\n  stringAppendValue(target, value) {\n    let str = this.asString(value);\n    for (let part of str.parts) {\n      this.stringAppendPart(target, part);\n    }\n  }\n  stringAppendPart(target, part) {\n    target.parts.push(part);\n    part.uses.push(target);\n  }\n  resolveStringPart(str, from, len) {\n    if (len === 0) return from;\n    for (let i = from; i < str.parts.length; i++) {\n      let part = str.parts[i];\n      if (len === part.utf8size) {\n        return i + 1;\n      }\n      if (len < part.utf8size) {\n        this.splitString(part, len);\n        return i + 1;\n      }\n      len -= part.utf8size;\n    }\n    throw new Error(\"splitting string out of bounds\");\n  }\n  splitString(part, idx) {\n    let leftValue;\n    let rightValue;\n    let leftSize = idx;\n    let rightSize = part.utf8size - leftSize;\n    if (part.utf8size !== part.value.length) {\n      let byteCount = 0;\n      for (idx = 0; byteCount < leftSize; idx++) {\n        let code = part.value.codePointAt(idx);\n        let size = utf8charSize(code);\n        if (size === 4) idx++;\n        byteCount += size;\n      }\n    }\n    leftValue = part.value.slice(0, idx);\n    rightValue = part.value.slice(idx);\n    let newPart = {\n      value: rightValue,\n      utf8size: rightSize,\n      uses: part.uses.slice(),\n      startMeta: part.startMeta,\n      endMeta: part.endMeta\n    };\n    part.value = leftValue;\n    part.utf8size = leftSize;\n    for (let use of part.uses) {\n      let ndx = use.parts.indexOf(part);\n      if (ndx === -1) throw new Error(\"bug: mismatch between string parts and use.\");\n      use.parts.splice(ndx + 1, 0, newPart);\n    }\n  }\n  stringAppendSlice(target, source, left, right) {\n    let str = this.asString(source);\n    let firstPart = this.resolveStringPart(str, 0, left);\n    let lastPart = this.resolveStringPart(str, firstPart, right - left);\n    for (let i = firstPart; i < lastPart; i++) {\n      let part = str.parts[i];\n      this.stringAppendPart(target, part);\n    }\n  }\n}\nfunction wrap(data, meta) {\n  return {\n    data,\n    startMeta: meta,\n    endMeta: meta\n  };\n}\nfunction unwrap(value) {\n  if (typeof value.data !== \"undefined\") return value.data;\n  let result;\n  let content = value.content;\n  switch (content.type) {\n    case \"string\":\n      result = content.parts.map(part => part.value).join(\"\");\n      break;\n    case \"array\":\n      result = content.elements.map(val => unwrap(val));\n      break;\n    case \"object\":\n      {\n        result = {};\n        for (let [key, val] of Object.entries(content.fields)) {\n          result[key] = unwrap(val);\n        }\n      }\n  }\n  value.data = result;\n  return result;\n}\nfunction getType(value) {\n  if (value.content) return value.content.type;\n  if (Array.isArray(value.data)) return \"array\";\n  if (value.data === null) return \"null\";\n  return typeof value.data;\n}\nfunction rebaseValue(left, right) {\n  let leftType = getType(left);\n  let rightType = getType(right);\n  if (leftType !== rightType) return right;\n  let leftModel = new IncrementalModel(left.endMeta);\n  let rightModel = new IncrementalModel(right.endMeta);\n  switch (leftType) {\n    case \"object\":\n      {\n        let leftObj = leftModel.asObject(left);\n        let rightObj = rightModel.asObject(right);\n        let identicalFieldCount = 0;\n        let leftFieldCount = Object.keys(leftObj.fields).length;\n        let rightFieldCount = Object.keys(rightObj.fields).length;\n        for (let [key, rightVal] of Object.entries(rightObj.fields)) {\n          let leftVal = leftObj.fields[key];\n          if (leftVal) {\n            rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n            if (rightObj.fields[key] === leftVal) {\n              identicalFieldCount++;\n            }\n          }\n        }\n        let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n        return isIdentical ? left : right;\n      }\n    case \"array\":\n      {\n        let leftArr = leftModel.asArray(left);\n        let rightArr = rightModel.asArray(right);\n        if (leftArr.elements.length !== rightArr.elements.length) {\n          break;\n        }\n        let numRebased = 0;\n        for (let i = 0; i < rightArr.elements.length; i++) {\n          rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n          if (rightArr.elements[i] !== leftArr.elements[i]) {\n            numRebased++;\n          }\n        }\n        return numRebased === 0 ? left : right;\n      }\n    case \"null\":\n    case \"boolean\":\n    case \"number\":\n      {\n        if (unwrap(left) === unwrap(right)) return left;\n        break;\n      }\n    case \"string\":\n      {\n        let leftRaw = unwrap(left);\n        let rightRaw = unwrap(right);\n        if (leftRaw === rightRaw) return left;\n        let result = rightModel.copyString(null);\n        let prefix = commonPrefix(leftRaw, rightRaw);\n        let suffix = commonSuffix(leftRaw, rightRaw, prefix);\n        let rightLen = utf8stringSize(rightRaw);\n        let leftLen = utf8stringSize(leftRaw);\n        if (0 < prefix) {\n          rightModel.stringAppendSlice(result, left, 0, prefix);\n        }\n        if (prefix < rightLen - suffix) {\n          rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n        }\n        if (leftLen - suffix < leftLen) {\n          rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n        }\n        let value = rightModel.finalize(result);\n        if (unwrap(value) !== rightRaw) throw new Error(\"incorrect string rebase\");\n        return value;\n      }\n  }\n  return right;\n}\nfunction applyPatch$1(left, patch, startMeta) {\n  let model = new IncrementalModel(startMeta);\n  let patcher = new Patcher(model, left, patch);\n  return patcher.process();\n}\nvar incrementalPatcher = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  applyPatch: applyPatch$1,\n  getType: getType,\n  rebaseValue: rebaseValue,\n  unwrap: unwrap,\n  wrap: wrap\n});\nclass SimpleModel {\n  wrap(data) {\n    return data;\n  }\n  finalize(b) {\n    if (Array.isArray(b)) {\n      return b;\n    } else {\n      return b.data;\n    }\n  }\n  markChanged(value) {\n    return value;\n  }\n  objectGetKeys(value) {\n    return Object.keys(value);\n  }\n  objectGetField(value, key) {\n    return value[key];\n  }\n  arrayGetElement(value, idx) {\n    return value[idx];\n  }\n  copyObject(value) {\n    let res = {\n      type: \"object\",\n      data: {}\n    };\n    if (value !== null) {\n      for (let [key, val] of Object.entries(value)) {\n        res.data[key] = val;\n      }\n    }\n    return res;\n  }\n  copyArray(value) {\n    if (value === null) return [];\n    return value.slice();\n  }\n  copyString(value) {\n    return {\n      type: \"string\",\n      data: value === null ? \"\" : value\n    };\n  }\n  objectSetField(target, key, value) {\n    target.data[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.data[key];\n  }\n  arrayAppendValue(target, value) {\n    target.push(value);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    target.push(...source.slice(left, right));\n  }\n  stringAppendSlice(target, source, left, right) {\n    const sourceString = source;\n    const leftPos = utf8resolveIndex(sourceString, left);\n    const rightPos = utf8resolveIndex(sourceString, right, leftPos);\n    target.data += sourceString.slice(leftPos, rightPos);\n  }\n  stringAppendValue(target, value) {\n    target.data += value;\n  }\n}\nfunction applyPatch(left, patch) {\n  let root = left;\n  let patcher = new Patcher(new SimpleModel(), root, patch);\n  return patcher.process();\n}\nexports.applyPatch = applyPatch;\nexports.incremental = incrementalPatcher;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2Rpc3QvaW5kZXguY2pzPzQzZjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgT1BTID0gW1wiVmFsdWVcIiwgXCJDb3B5XCIsIFwiQmxhbmtcIiwgXCJSZXR1cm5JbnRvQXJyYXlcIiwgXCJSZXR1cm5JbnRvT2JqZWN0XCIsIFwiUmV0dXJuSW50b09iamVjdFNhbWVLZXlcIiwgXCJQdXNoRmllbGRcIiwgXCJQdXNoRWxlbWVudFwiLCBcIlB1c2hQYXJlbnRcIiwgXCJQb3BcIiwgXCJQdXNoRmllbGRDb3B5XCIsIFwiUHVzaEZpZWxkQmxhbmtcIiwgXCJQdXNoRWxlbWVudENvcHlcIiwgXCJQdXNoRWxlbWVudEJsYW5rXCIsIFwiUmV0dXJuSW50b09iamVjdFBvcFwiLCBcIlJldHVybkludG9PYmplY3RTYW1lS2V5UG9wXCIsIFwiUmV0dXJuSW50b0FycmF5UG9wXCIsIFwiT2JqZWN0U2V0RmllbGRWYWx1ZVwiLCBcIk9iamVjdENvcHlGaWVsZFwiLCBcIk9iamVjdERlbGV0ZUZpZWxkXCIsIFwiQXJyYXlBcHBlbmRWYWx1ZVwiLCBcIkFycmF5QXBwZW5kU2xpY2VcIiwgXCJTdHJpbmdBcHBlbmRTdHJpbmdcIiwgXCJTdHJpbmdBcHBlbmRTbGljZVwiXTtcbmNsYXNzIFBhdGNoZXIge1xuICBjb25zdHJ1Y3Rvcihtb2RlbCwgcm9vdCwgcGF0Y2gpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtb2RlbFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJyb290XCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInBhdGNoXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaW5wdXRTdGFja1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJvdXRwdXRTdGFja1wiKTtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnBhdGNoID0gcGF0Y2g7XG4gICAgdGhpcy5pID0gMDtcbiAgICB0aGlzLmlucHV0U3RhY2sgPSBbXTtcbiAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XG4gIH1cbiAgcmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XG4gIH1cbiAgcHJvY2VzcygpIHtcbiAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZTogdGhpcy5yb290XG4gICAgfSk7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlOiB0aGlzLnJvb3RcbiAgICB9KTtcbiAgICBmb3IgKDsgdGhpcy5pIDwgdGhpcy5wYXRjaC5sZW5ndGg7KSB7XG4gICAgICBsZXQgb3Bjb2RlID0gdGhpcy5yZWFkKCk7XG4gICAgICBsZXQgb3AgPSBPUFNbb3Bjb2RlXTtcbiAgICAgIGlmICghb3ApIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3Bjb2RlOiBcIi5jb25jYXQob3Bjb2RlKSk7XG4gICAgICBsZXQgcHJvY2Vzc29yID0gXCJwcm9jZXNzXCIuY29uY2F0KG9wKTtcbiAgICAgIHRoaXNbcHJvY2Vzc29yXS5hcHBseSh0aGlzKTtcbiAgICB9XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gIH1cbiAgaW5wdXRFbnRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFN0YWNrW3RoaXMuaW5wdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBpbnB1dEtleShlbnRyeSwgaWR4KSB7XG4gICAgaWYgKCFlbnRyeS5rZXlzKSB7XG4gICAgICBlbnRyeS5rZXlzID0gdGhpcy5tb2RlbC5vYmplY3RHZXRLZXlzKGVudHJ5LnZhbHVlKS5zb3J0KCk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5rZXlzW2lkeF07XG4gIH1cbiAgb3V0cHV0RW50cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RhY2tbdGhpcy5vdXRwdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBvdXRwdXRBcnJheSgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5QXJyYXkoZW50cnkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgfVxuICBvdXRwdXRPYmplY3QoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weU9iamVjdChlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICB9XG4gIG91dHB1dFN0cmluZygpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5U3RyaW5nKGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gIH1cbiAgZmluYWxpemVPdXRwdXQoZW50cnkpIHtcbiAgICBpZiAoZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gIH1cbiAgLy8gUHJvY2Vzc29yczpcbiAgcHJvY2Vzc1ZhbHVlKCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc0NvcHkoKSB7XG4gICAgbGV0IGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlOiBpbnB1dC52YWx1ZVxuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NCbGFuaygpIHtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b0FycmF5KCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIGxldCBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgcmVzdWx0KTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdCgpIHtcbiAgICBsZXQga2V5ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5tYXJrQ2hhbmdlZChyZXN1bHQpO1xuICAgIGxldCBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5KCkge1xuICAgIGxldCBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIGxldCBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBpbnB1dC5rZXksIHJlc3VsdCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZCgpIHtcbiAgICBsZXQgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgbGV0IGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC5vYmplY3RHZXRGaWVsZChlbnRyeS52YWx1ZSwga2V5KTtcbiAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGtleVxuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NQdXNoRWxlbWVudCgpIHtcbiAgICBsZXQgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC5hcnJheUdldEVsZW1lbnQoZW50cnkudmFsdWUsIGlkeCk7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzUG9wKCkge1xuICAgIHRoaXMuaW5wdXRTdGFjay5wb3AoKTtcbiAgfVxuICBwcm9jZXNzUHVzaEZpZWxkQ29weSgpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcbiAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZEJsYW5rKCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50Q29weSgpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xuICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgfVxuICBwcm9jZXNzUHVzaEVsZW1lbnRCbGFuaygpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xuICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3RQb3AoKSB7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCgpIHtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xuICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvQXJyYXlQb3AoKSB7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b0FycmF5KCk7XG4gICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdFNldEZpZWxkVmFsdWUoKSB7XG4gICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdENvcHlGaWVsZCgpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcbiAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIGxldCBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgIGxldCBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgIHRoaXMubW9kZWwub2JqZWN0RGVsZXRlRmllbGQob2JqLCBrZXkpO1xuICB9XG4gIHByb2Nlc3NBcnJheUFwcGVuZFZhbHVlKCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XG4gICAgbGV0IGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCB2YWx1ZSk7XG4gIH1cbiAgcHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UoKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgcmlnaHQgPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgIGxldCB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcbiAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nQXBwZW5kU3RyaW5nKCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XG4gICAgbGV0IHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRWYWx1ZShzdHIsIHZhbHVlKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UoKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgcmlnaHQgPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICBsZXQgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICB9XG59XG5mdW5jdGlvbiB1dGY4Y2hhclNpemUoY29kZSkge1xuICBpZiAoY29kZSA+PiAxNikge1xuICAgIHJldHVybiA0O1xuICB9IGVsc2UgaWYgKGNvZGUgPj4gMTEpIHtcbiAgICByZXR1cm4gMztcbiAgfSBlbHNlIGlmIChjb2RlID4+IDcpIHtcbiAgICByZXR1cm4gMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuZnVuY3Rpb24gdXRmOHN0cmluZ1NpemUoc3RyKSB7XG4gIGxldCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY29kZSA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICBpZiAoc2l6ZSA9PSA0KSBpKys7XG4gICAgYiArPSBzaXplO1xuICB9XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gdXRmOHJlc29sdmVJbmRleChzdHIsIGlkeCkge1xuICBsZXQgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGxldCBieXRlQ291bnQgPSBzdGFydDtcbiAgbGV0IHVjc0lkeCA9IDA7XG4gIGZvciAodWNzSWR4ID0gc3RhcnQ7IGJ5dGVDb3VudCA8IGlkeDsgdWNzSWR4KyspIHtcbiAgICBsZXQgY29kZSA9IHN0ci5jb2RlUG9pbnRBdCh1Y3NJZHgpO1xuICAgIGxldCBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgIGlmIChzaXplID09PSA0KSB1Y3NJZHgrKztcbiAgICBieXRlQ291bnQgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gdWNzSWR4O1xufVxuZnVuY3Rpb24gY29tbW9uUHJlZml4KHN0ciwgc3RyMikge1xuICBsZXQgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpO1xuICBsZXQgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgbGV0IGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoaSk7XG4gICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KSByZXR1cm4gYjtcbiAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgIGIgKz0gc2l6ZTtcbiAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIGNvbW1vblN1ZmZpeChzdHIsIHN0cjIpIHtcbiAgbGV0IHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgbGV0IGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSAtIHByZWZpeDtcbiAgbGV0IGIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHN0ci5sZW5ndGggLSAxIC0gaSk7XG4gICAgbGV0IGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoc3RyMi5sZW5ndGggLSAxIC0gaSk7XG4gICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KSByZXR1cm4gYjtcbiAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgIGIgKz0gc2l6ZTtcbiAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBJbmNyZW1lbnRhbE1vZGVsIHtcbiAgY29uc3RydWN0b3IobWV0YSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXRhXCIpO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgd3JhcChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFdpdGhNZXRhKGRhdGEsIHRoaXMubWV0YSwgdGhpcy5tZXRhKTtcbiAgfVxuICB3cmFwV2l0aE1ldGEoZGF0YSwgc3RhcnRNZXRhKSB7XG4gICAgbGV0IGVuZE1ldGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMubWV0YTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIHN0YXJ0TWV0YSxcbiAgICAgIGVuZE1ldGFcbiAgICB9O1xuICB9XG4gIGFzT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlLmRhdGEpKSB7XG4gICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xuICAgICAgfVxuICAgICAgdmFsdWUuY29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgZmllbGRzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgfVxuICBhc0FycmF5KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgZWxlbWVudHMgPSB2YWx1ZS5kYXRhLm1hcChpdGVtID0+IHRoaXMud3JhcFdpdGhNZXRhKGl0ZW0sIHZhbHVlLnN0YXJ0TWV0YSkpO1xuICAgICAgbGV0IG1ldGFzID0gZWxlbWVudHMubWFwKCgpID0+IHRoaXMubWV0YSk7XG4gICAgICB2YWx1ZS5jb250ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICBtZXRhc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gIH1cbiAgYXNTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIGxldCBzdHIgPSB2YWx1ZS5kYXRhO1xuICAgICAgbGV0IHBhcnQgPSB7XG4gICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgIHV0ZjhzaXplOiB1dGY4c3RyaW5nU2l6ZShzdHIpLFxuICAgICAgICB1c2VzOiBbXSxcbiAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXG4gICAgICAgIGVuZE1ldGE6IHZhbHVlLmVuZE1ldGFcbiAgICAgIH07XG4gICAgICB2YWx1ZS5jb250ZW50ID0gdGhpcy5zdHJpbmdGcm9tUGFydHMoW3BhcnRdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gIH1cbiAgc3RyaW5nRnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgbGV0IHN0ciA9IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBwYXJ0c1xuICAgIH07XG4gICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cykge1xuICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBvYmplY3RHZXRLZXlzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgb2JqZWN0R2V0RmllbGQodmFsdWUsIGtleSkge1xuICAgIGxldCBvYmogPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICByZXR1cm4gb2JqLmZpZWxkc1trZXldO1xuICB9XG4gIGFycmF5R2V0RWxlbWVudCh2YWx1ZSwgaWR4KSB7XG4gICAgbGV0IGFyciA9IHRoaXMuYXNBcnJheSh2YWx1ZSk7XG4gICAgcmV0dXJuIGFyci5lbGVtZW50c1tpZHhdO1xuICB9XG4gIGZpbmFsaXplKGNvbnRlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUVuZE1ldGEoY29udGVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBzdGFydE1ldGE6IHRoaXMubWV0YSxcbiAgICAgIGVuZE1ldGE6IHRoaXMubWV0YVxuICAgIH07XG4gIH1cbiAgbWFya0NoYW5nZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xuICB9XG4gIHVwZGF0ZUVuZE1ldGEoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9yIChsZXQgcGFydCBvZiBjb250ZW50LnBhcnRzKSB7XG4gICAgICAgIHBhcnQuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIGZvciAobGV0IHZhbCBvZiBjb250ZW50LmVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCB2YWwgb2YgT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcykpIHtcbiAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weVN0cmluZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgbGV0IG90aGVyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmdGcm9tUGFydHMob3RoZXIucGFydHMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHBhcnRzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29weU9iamVjdCh2YWx1ZSkge1xuICAgIGxldCBvYmogPSB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgZmllbGRzOiB7fVxuICAgIH07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBsZXQgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqLmZpZWxkcywgb3RoZXIuZmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb3B5QXJyYXkodmFsdWUpIHtcbiAgICBsZXQgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbDtcbiAgICBsZXQgZWxlbWVudHMgPSBhcnIgPyBhcnIuZWxlbWVudHMgOiBbXTtcbiAgICBsZXQgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtZXRhc1xuICAgIH07XG4gIH1cbiAgb2JqZWN0U2V0RmllbGQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmZpZWxkc1trZXldID0gdmFsdWU7XG4gIH1cbiAgb2JqZWN0RGVsZXRlRmllbGQodGFyZ2V0LCBrZXkpIHtcbiAgICBkZWxldGUgdGFyZ2V0LmZpZWxkc1trZXldO1xuICB9XG4gIGFycmF5QXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHRhcmdldC5lbGVtZW50cy5wdXNoKHZhbHVlKTtcbiAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICB9XG4gIGFycmF5QXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IGFyciA9IHRoaXMuYXNBcnJheShzb3VyY2UpO1xuICAgIGxldCBzYW1lUG9zaXRpb24gPSBhcnIuZWxlbWVudHMubGVuZ3RoID09PSBsZWZ0O1xuICAgIHRhcmdldC5lbGVtZW50cy5wdXNoKC4uLmFyci5lbGVtZW50cy5zbGljZShsZWZ0LCByaWdodCkpO1xuICAgIGlmIChzYW1lUG9zaXRpb24pIHtcbiAgICAgIHRhcmdldC5tZXRhcy5wdXNoKC4uLmFyci5tZXRhcy5zbGljZShsZWZ0LCByaWdodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RyaW5nQXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIGxldCBzdHIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHN0ci5wYXJ0cykge1xuICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgfVxuICB9XG4gIHN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KSB7XG4gICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCk7XG4gICAgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcbiAgfVxuICByZXNvbHZlU3RyaW5nUGFydChzdHIsIGZyb20sIGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHJldHVybiBmcm9tO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgc3RyLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHN0ci5wYXJ0c1tpXTtcbiAgICAgIGlmIChsZW4gPT09IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGxlbiA8IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgdGhpcy5zcGxpdFN0cmluZyhwYXJ0LCBsZW4pO1xuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICB9XG4gICAgICBsZW4gLT0gcGFydC51dGY4c2l6ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXR0aW5nIHN0cmluZyBvdXQgb2YgYm91bmRzXCIpO1xuICB9XG4gIHNwbGl0U3RyaW5nKHBhcnQsIGlkeCkge1xuICAgIGxldCBsZWZ0VmFsdWU7XG4gICAgbGV0IHJpZ2h0VmFsdWU7XG4gICAgbGV0IGxlZnRTaXplID0gaWR4O1xuICAgIGxldCByaWdodFNpemUgPSBwYXJ0LnV0ZjhzaXplIC0gbGVmdFNpemU7XG4gICAgaWYgKHBhcnQudXRmOHNpemUgIT09IHBhcnQudmFsdWUubGVuZ3RoKSB7XG4gICAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAgIGZvciAoaWR4ID0gMDsgYnl0ZUNvdW50IDwgbGVmdFNpemU7IGlkeCsrKSB7XG4gICAgICAgIGxldCBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgaWYgKHNpemUgPT09IDQpIGlkeCsrO1xuICAgICAgICBieXRlQ291bnQgKz0gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGVmdFZhbHVlID0gcGFydC52YWx1ZS5zbGljZSgwLCBpZHgpO1xuICAgIHJpZ2h0VmFsdWUgPSBwYXJ0LnZhbHVlLnNsaWNlKGlkeCk7XG4gICAgbGV0IG5ld1BhcnQgPSB7XG4gICAgICB2YWx1ZTogcmlnaHRWYWx1ZSxcbiAgICAgIHV0ZjhzaXplOiByaWdodFNpemUsXG4gICAgICB1c2VzOiBwYXJ0LnVzZXMuc2xpY2UoKSxcbiAgICAgIHN0YXJ0TWV0YTogcGFydC5zdGFydE1ldGEsXG4gICAgICBlbmRNZXRhOiBwYXJ0LmVuZE1ldGFcbiAgICB9O1xuICAgIHBhcnQudmFsdWUgPSBsZWZ0VmFsdWU7XG4gICAgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xuICAgIGZvciAobGV0IHVzZSBvZiBwYXJ0LnVzZXMpIHtcbiAgICAgIGxldCBuZHggPSB1c2UucGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgIGlmIChuZHggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuXCIpO1xuICAgICAgdXNlLnBhcnRzLnNwbGljZShuZHggKyAxLCAwLCBuZXdQYXJ0KTtcbiAgICB9XG4gIH1cbiAgc3RyaW5nQXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IHN0ciA9IHRoaXMuYXNTdHJpbmcoc291cmNlKTtcbiAgICBsZXQgZmlyc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIDAsIGxlZnQpO1xuICAgIGxldCBsYXN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCBmaXJzdFBhcnQsIHJpZ2h0IC0gbGVmdCk7XG4gICAgZm9yIChsZXQgaSA9IGZpcnN0UGFydDsgaSA8IGxhc3RQYXJ0OyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3cmFwKGRhdGEsIG1ldGEpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIHN0YXJ0TWV0YTogbWV0YSxcbiAgICBlbmRNZXRhOiBtZXRhXG4gIH07XG59XG5mdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWUuZGF0YTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGNvbnRlbnQgPSB2YWx1ZS5jb250ZW50O1xuICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKHBhcnQgPT4gcGFydC52YWx1ZSkuam9pbihcIlwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmVzdWx0ID0gY29udGVudC5lbGVtZW50cy5tYXAodmFsID0+IHVud3JhcCh2YWwpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoY29udGVudC5maWVsZHMpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB1bndyYXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIHZhbHVlLmRhdGEgPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZS5jb250ZW50KSByZXR1cm4gdmFsdWUuY29udGVudC50eXBlO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkgcmV0dXJuIFwiYXJyYXlcIjtcbiAgaWYgKHZhbHVlLmRhdGEgPT09IG51bGwpIHJldHVybiBcIm51bGxcIjtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5kYXRhO1xufVxuZnVuY3Rpb24gcmViYXNlVmFsdWUobGVmdCwgcmlnaHQpIHtcbiAgbGV0IGxlZnRUeXBlID0gZ2V0VHlwZShsZWZ0KTtcbiAgbGV0IHJpZ2h0VHlwZSA9IGdldFR5cGUocmlnaHQpO1xuICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkgcmV0dXJuIHJpZ2h0O1xuICBsZXQgbGVmdE1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwobGVmdC5lbmRNZXRhKTtcbiAgbGV0IHJpZ2h0TW9kZWwgPSBuZXcgSW5jcmVtZW50YWxNb2RlbChyaWdodC5lbmRNZXRhKTtcbiAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGxlZnRPYmogPSBsZWZ0TW9kZWwuYXNPYmplY3QobGVmdCk7XG4gICAgICAgIGxldCByaWdodE9iaiA9IHJpZ2h0TW9kZWwuYXNPYmplY3QocmlnaHQpO1xuICAgICAgICBsZXQgaWRlbnRpY2FsRmllbGRDb3VudCA9IDA7XG4gICAgICAgIGxldCBsZWZ0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKGxlZnRPYmouZmllbGRzKS5sZW5ndGg7XG4gICAgICAgIGxldCByaWdodEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhyaWdodE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgcmlnaHRWYWxdIG9mIE9iamVjdC5lbnRyaWVzKHJpZ2h0T2JqLmZpZWxkcykpIHtcbiAgICAgICAgICBsZXQgbGVmdFZhbCA9IGxlZnRPYmouZmllbGRzW2tleV07XG4gICAgICAgICAgaWYgKGxlZnRWYWwpIHtcbiAgICAgICAgICAgIHJpZ2h0T2JqLmZpZWxkc1trZXldID0gcmViYXNlVmFsdWUobGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0T2JqLmZpZWxkc1trZXldID09PSBsZWZ0VmFsKSB7XG4gICAgICAgICAgICAgIGlkZW50aWNhbEZpZWxkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzSWRlbnRpY2FsID0gbGVmdEZpZWxkQ291bnQgPT09IHJpZ2h0RmllbGRDb3VudCAmJiBsZWZ0RmllbGRDb3VudCA9PT0gaWRlbnRpY2FsRmllbGRDb3VudDtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpY2FsID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgfVxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAge1xuICAgICAgICBsZXQgbGVmdEFyciA9IGxlZnRNb2RlbC5hc0FycmF5KGxlZnQpO1xuICAgICAgICBsZXQgcmlnaHRBcnIgPSByaWdodE1vZGVsLmFzQXJyYXkocmlnaHQpO1xuICAgICAgICBpZiAobGVmdEFyci5lbGVtZW50cy5sZW5ndGggIT09IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1SZWJhc2VkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaWdodEFyci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJpZ2h0QXJyLmVsZW1lbnRzW2ldID0gcmViYXNlVmFsdWUobGVmdEFyci5lbGVtZW50c1tpXSwgcmlnaHRBcnIuZWxlbWVudHNbaV0pO1xuICAgICAgICAgIGlmIChyaWdodEFyci5lbGVtZW50c1tpXSAhPT0gbGVmdEFyci5lbGVtZW50c1tpXSkge1xuICAgICAgICAgICAgbnVtUmViYXNlZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtUmViYXNlZCA9PT0gMCA/IGxlZnQgOiByaWdodDtcbiAgICAgIH1cbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAge1xuICAgICAgICBpZiAodW53cmFwKGxlZnQpID09PSB1bndyYXAocmlnaHQpKSByZXR1cm4gbGVmdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAge1xuICAgICAgICBsZXQgbGVmdFJhdyA9IHVud3JhcChsZWZ0KTtcbiAgICAgICAgbGV0IHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcbiAgICAgICAgaWYgKGxlZnRSYXcgPT09IHJpZ2h0UmF3KSByZXR1cm4gbGVmdDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJpZ2h0TW9kZWwuY29weVN0cmluZyhudWxsKTtcbiAgICAgICAgbGV0IHByZWZpeCA9IGNvbW1vblByZWZpeChsZWZ0UmF3LCByaWdodFJhdyk7XG4gICAgICAgIGxldCBzdWZmaXggPSBjb21tb25TdWZmaXgobGVmdFJhdywgcmlnaHRSYXcsIHByZWZpeCk7XG4gICAgICAgIGxldCByaWdodExlbiA9IHV0ZjhzdHJpbmdTaXplKHJpZ2h0UmF3KTtcbiAgICAgICAgbGV0IGxlZnRMZW4gPSB1dGY4c3RyaW5nU2l6ZShsZWZ0UmF3KTtcbiAgICAgICAgaWYgKDAgPCBwcmVmaXgpIHtcbiAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXgpIHtcbiAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgcmlnaHQsIHByZWZpeCwgcmlnaHRMZW4gLSBzdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0TGVuIC0gc3VmZml4IDwgbGVmdExlbikge1xuICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCBsZWZ0LCBsZWZ0TGVuIC0gc3VmZml4LCBsZWZ0TGVuKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWUgPSByaWdodE1vZGVsLmZpbmFsaXplKHJlc3VsdCk7XG4gICAgICAgIGlmICh1bndyYXAodmFsdWUpICE9PSByaWdodFJhdykgdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IHN0cmluZyByZWJhc2VcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gcmlnaHQ7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoJDEobGVmdCwgcGF0Y2gsIHN0YXJ0TWV0YSkge1xuICBsZXQgbW9kZWwgPSBuZXcgSW5jcmVtZW50YWxNb2RlbChzdGFydE1ldGEpO1xuICBsZXQgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCk7XG4gIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbnZhciBpbmNyZW1lbnRhbFBhdGNoZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXBwbHlQYXRjaDogYXBwbHlQYXRjaCQxLFxuICBnZXRUeXBlOiBnZXRUeXBlLFxuICByZWJhc2VWYWx1ZTogcmViYXNlVmFsdWUsXG4gIHVud3JhcDogdW53cmFwLFxuICB3cmFwOiB3cmFwXG59KTtcbmNsYXNzIFNpbXBsZU1vZGVsIHtcbiAgd3JhcChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZmluYWxpemUoYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGIuZGF0YTtcbiAgICB9XG4gIH1cbiAgbWFya0NoYW5nZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgb2JqZWN0R2V0S2V5cyh2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIH1cbiAgb2JqZWN0R2V0RmllbGQodmFsdWUsIGtleSkge1xuICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICB9XG4gIGFycmF5R2V0RWxlbWVudCh2YWx1ZSwgaWR4KSB7XG4gICAgcmV0dXJuIHZhbHVlW2lkeF07XG4gIH1cbiAgY29weU9iamVjdCh2YWx1ZSkge1xuICAgIGxldCByZXMgPSB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgcmVzLmRhdGFba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjb3B5QXJyYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBbXTtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgfVxuICBjb3B5U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkYXRhOiB2YWx1ZSA9PT0gbnVsbCA/IFwiXCIgOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgb2JqZWN0U2V0RmllbGQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG4gIG9iamVjdERlbGV0ZUZpZWxkKHRhcmdldCwga2V5KSB7XG4gICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XG4gIH1cbiAgYXJyYXlBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdGFyZ2V0LnB1c2godmFsdWUpO1xuICB9XG4gIGFycmF5QXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgdGFyZ2V0LnB1c2goLi4uc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gIH1cbiAgc3RyaW5nQXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3Qgc291cmNlU3RyaW5nID0gc291cmNlO1xuICAgIGNvbnN0IGxlZnRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgbGVmdCk7XG4gICAgY29uc3QgcmlnaHRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgcmlnaHQsIGxlZnRQb3MpO1xuICAgIHRhcmdldC5kYXRhICs9IHNvdXJjZVN0cmluZy5zbGljZShsZWZ0UG9zLCByaWdodFBvcyk7XG4gIH1cbiAgc3RyaW5nQXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHRhcmdldC5kYXRhICs9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoKSB7XG4gIGxldCByb290ID0gbGVmdDtcbiAgbGV0IHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihuZXcgU2ltcGxlTW9kZWwoKSwgcm9vdCwgcGF0Y2gpO1xuICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XG59XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuZXhwb3J0cy5pbmNyZW1lbnRhbCA9IGluY3JlbWVudGFsUGF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mendoza/dist/index.cjs\n");

/***/ })

};
;