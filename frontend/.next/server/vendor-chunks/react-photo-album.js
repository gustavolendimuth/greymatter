/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-photo-album";
exports.ids = ["vendor-chunks/react-photo-album"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-photo-album/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-photo-album/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\"use client\";\n\"use strict\";\nObject.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: \"Module\" } });\nconst React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopNamespaceDefault(e) {\n  const n = Object.create(null, { [Symbol.toStringTag]: { value: \"Module\" } });\n  if (e) {\n    for (const k in e) {\n      if (k !== \"default\") {\n        const d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: () => e[k]\n        });\n      }\n    }\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\nconst React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);\nfunction ratio({ width, height }) {\n  return width / height;\n}\nfunction round(value, decimals = 0) {\n  const factor = 10 ** decimals;\n  return Math.round((value + Number.EPSILON) * factor) / factor;\n}\nfunction rankingFunctionComparator(rank) {\n  return (a, b) => rank(b) - rank(a);\n}\nclass MinHeap {\n  constructor(comparator) {\n    this.comparator = comparator;\n    this.heap = [];\n    this.n = 0;\n  }\n  greater(i, j) {\n    return this.comparator(this.heap[i], this.heap[j]) < 0;\n  }\n  swap(i, j) {\n    const temp = this.heap[i];\n    this.heap[i] = this.heap[j];\n    this.heap[j] = temp;\n  }\n  swim(i) {\n    let k = i;\n    let k2 = Math.floor(k / 2);\n    while (k > 1 && this.greater(k2, k)) {\n      this.swap(k2, k);\n      k = k2;\n      k2 = Math.floor(k / 2);\n    }\n  }\n  sink(i) {\n    let k = i;\n    let k2 = k * 2;\n    while (k2 <= this.n) {\n      if (k2 < this.n && this.greater(k2, k2 + 1))\n        k2 += 1;\n      if (!this.greater(k, k2))\n        break;\n      this.swap(k, k2);\n      k = k2;\n      k2 = k * 2;\n    }\n  }\n  push(element) {\n    this.n += 1;\n    this.heap[this.n] = element;\n    this.swim(this.n);\n  }\n  pop() {\n    if (this.n === 0)\n      return void 0;\n    this.swap(1, this.n);\n    this.n -= 1;\n    const max = this.heap.pop();\n    this.sink(1);\n    return max;\n  }\n  size() {\n    return this.n;\n  }\n}\nfunction buildPrecedentsMap(graph, startNode, endNode) {\n  const precedentsMap = /* @__PURE__ */ new Map();\n  const visited = /* @__PURE__ */ new Set();\n  const storedShortestPaths = /* @__PURE__ */ new Map();\n  storedShortestPaths.set(startNode, 0);\n  const queue = new MinHeap(rankingFunctionComparator((el) => el.weight));\n  queue.push({ id: startNode, weight: 0 });\n  while (queue.size() > 0) {\n    const { id, weight } = queue.pop();\n    if (!visited.has(id)) {\n      const neighboringNodes = graph(id);\n      visited.add(id);\n      neighboringNodes.forEach((neighborWeight, neighbor) => {\n        const newWeight = weight + neighborWeight;\n        const currentId = precedentsMap.get(neighbor);\n        const currentWeight = storedShortestPaths.get(neighbor);\n        if (currentWeight === void 0 || currentWeight > newWeight && (currentWeight / newWeight > 1.005 || currentId !== void 0 && currentId < id)) {\n          storedShortestPaths.set(neighbor, newWeight);\n          queue.push({ id: neighbor, weight: newWeight });\n          precedentsMap.set(neighbor, id);\n        }\n      });\n    }\n  }\n  return storedShortestPaths.has(endNode) ? precedentsMap : void 0;\n}\nfunction getPathFromPrecedentsMap(precedentsMap, endNode) {\n  const nodes = [];\n  for (let node = endNode; node !== void 0; node = precedentsMap.get(node)) {\n    nodes.push(node);\n  }\n  return nodes.reverse();\n}\nfunction findShortestPath(graph, startNode, endNode) {\n  const precedentsMap = buildPrecedentsMap(graph, startNode, endNode);\n  return precedentsMap ? getPathFromPrecedentsMap(precedentsMap, endNode) : void 0;\n}\nfunction findIdealNodeSearch({\n  photos,\n  targetRowHeight,\n  containerWidth\n}) {\n  const minRatio = photos.reduce((acc, photo) => Math.min(ratio(photo), acc), Number.MAX_VALUE);\n  return round(containerWidth / targetRowHeight / minRatio) + 2;\n}\nfunction getCommonHeight(row, containerWidth, spacing, padding) {\n  const rowWidth = containerWidth - (row.length - 1) * spacing - 2 * padding * row.length;\n  const totalAspectRatio = row.reduce((acc, photo) => acc + ratio(photo), 0);\n  return rowWidth / totalAspectRatio;\n}\nfunction cost(photos, i, j, width, targetRowHeight, spacing, padding) {\n  const row = photos.slice(i, j);\n  const commonHeight = getCommonHeight(row, width, spacing, padding);\n  return commonHeight > 0 ? (commonHeight - targetRowHeight) ** 2 * row.length : void 0;\n}\nfunction makeGetRowNeighbors({\n  photos,\n  layoutOptions,\n  targetRowHeight,\n  limitNodeSearch,\n  rowConstraints\n}) {\n  return (node) => {\n    var _a, _b;\n    const { containerWidth, spacing, padding } = layoutOptions;\n    const results = /* @__PURE__ */ new Map();\n    results.set(node, 0);\n    const startOffset = (_a = rowConstraints == null ? void 0 : rowConstraints.minPhotos) != null ? _a : 1;\n    const endOffset = Math.min(limitNodeSearch, (_b = rowConstraints == null ? void 0 : rowConstraints.maxPhotos) != null ? _b : Infinity);\n    for (let i = node + startOffset; i < photos.length + 1; i += 1) {\n      if (i - node > endOffset)\n        break;\n      const currentCost = cost(photos, node, i, containerWidth, targetRowHeight, spacing, padding);\n      if (currentCost === void 0)\n        break;\n      results.set(i, currentCost);\n    }\n    return results;\n  };\n}\nfunction computeRowsLayout({\n  photos,\n  layoutOptions\n}) {\n  const { spacing, padding, containerWidth, targetRowHeight, rowConstraints } = layoutOptions;\n  const limitNodeSearch = findIdealNodeSearch({ photos, containerWidth, targetRowHeight });\n  const getNeighbors = makeGetRowNeighbors({\n    photos,\n    layoutOptions,\n    targetRowHeight,\n    limitNodeSearch,\n    rowConstraints\n  });\n  const path = findShortestPath(getNeighbors, 0, photos.length);\n  if (path === void 0)\n    return void 0;\n  const layout = [];\n  for (let i = 1; i < path.length; i += 1) {\n    const row = photos.map((photo, index) => ({ photo, index })).slice(path[i - 1], path[i]);\n    const height = getCommonHeight(\n      row.map(({ photo }) => photo),\n      containerWidth,\n      spacing,\n      padding\n    );\n    layout.push(\n      row.map(({ photo, index }, photoIndex) => ({\n        photo,\n        layout: {\n          height,\n          width: height * ratio(photo),\n          index,\n          photoIndex,\n          photosCount: row.length\n        }\n      }))\n    );\n  }\n  return layout;\n}\nfunction clsx(...classes) {\n  return [...classes].filter((cls) => Boolean(cls)).join(\" \");\n}\nfunction calcWidth(base, { width, photosCount }, { spacing, padding, containerWidth }) {\n  const gaps = spacing * (photosCount - 1) + 2 * padding * photosCount;\n  return `calc((${base} - ${gaps}px) / ${round((containerWidth - gaps) / width, 5)})`;\n}\nfunction cssPhotoWidth(layout, layoutOptions) {\n  return layoutOptions.layout !== \"rows\" ? `calc(100% - ${2 * layoutOptions.padding}px)` : calcWidth(\"100%\", layout, layoutOptions);\n}\nfunction calculateSizesValue(size, layout, layoutOptions) {\n  var _a, _b;\n  return calcWidth((_b = (_a = size.match(/calc\\((.*)\\)/)) == null ? void 0 : _a[1]) != null ? _b : size, layout, layoutOptions);\n}\nfunction srcSetAndSizes(photo, layout, layoutOptions) {\n  let srcSet;\n  let sizes;\n  const images = photo.srcSet || photo.images;\n  if (images && images.length > 0) {\n    srcSet = images.concat(\n      !images.find(({ width }) => width === photo.width) ? [{ src: photo.src, width: photo.width, height: photo.height }] : []\n    ).sort((first, second) => first.width - second.width).map((image) => `${image.src} ${image.width}w`).join(\", \");\n  }\n  if (layoutOptions.sizes) {\n    sizes = (layoutOptions.sizes.sizes || []).map(({ viewport, size }) => `${viewport} ${calculateSizesValue(size, layout, layoutOptions)}`).concat(calculateSizesValue(layoutOptions.sizes.size, layout, layoutOptions)).join(\", \");\n  } else if (srcSet) {\n    sizes = `${Math.ceil(layout.width / layoutOptions.containerWidth * 100)}vw`;\n  }\n  return { srcSet, sizes };\n}\nfunction PhotoRenderer(props) {\n  var _a, _b;\n  const {\n    photo,\n    layout,\n    layoutOptions,\n    imageProps: { style, className, ...restImageProps } = {},\n    renderPhoto\n  } = props;\n  const { onClick } = layoutOptions;\n  const imageStyle = {\n    display: \"block\",\n    boxSizing: \"content-box\",\n    width: cssPhotoWidth(layout, layoutOptions),\n    height: \"auto\",\n    aspectRatio: `${photo.width} / ${photo.height}`,\n    ...layoutOptions.padding ? { padding: `${layoutOptions.padding}px` } : null,\n    ...(layoutOptions.layout === \"columns\" || layoutOptions.layout === \"masonry\") && layout.photoIndex < layout.photosCount - 1 ? { marginBottom: `${layoutOptions.spacing}px` } : null,\n    ...onClick ? { cursor: \"pointer\" } : null,\n    ...style\n  };\n  const handleClick = onClick ? (event) => {\n    onClick({ event, photo, index: layout.index });\n  } : void 0;\n  const imageProps = {\n    src: photo.src,\n    alt: (_a = photo.alt) != null ? _a : \"\",\n    title: photo.title,\n    onClick: handleClick,\n    style: imageStyle,\n    className: clsx(\"react-photo-album--photo\", className),\n    loading: \"lazy\",\n    decoding: \"async\",\n    ...srcSetAndSizes(photo, layout, layoutOptions),\n    ...restImageProps\n  };\n  const renderDefaultPhoto = (options) => {\n    const { src, alt, srcSet, sizes, style: unwrappedStyle, ...rest } = imageProps;\n    return React__namespace.createElement(\n      \"img\",\n      {\n        alt,\n        ...srcSet ? { srcSet, sizes } : null,\n        src,\n        style: (options == null ? void 0 : options.wrapped) ? { display: \"block\", width: \"100%\", height: \"100%\" } : unwrappedStyle,\n        ...rest\n      }\n    );\n  };\n  const wrapperStyle = (({ display, boxSizing, width, aspectRatio, padding, marginBottom, cursor }) => ({\n    display,\n    boxSizing,\n    width,\n    aspectRatio,\n    padding,\n    marginBottom,\n    cursor\n  }))(imageStyle);\n  return React__namespace.createElement(React__namespace.Fragment, null, (_b = renderPhoto == null ? void 0 : renderPhoto({\n    photo,\n    layout,\n    layoutOptions,\n    imageProps,\n    renderDefaultPhoto,\n    wrapperStyle\n  })) != null ? _b : renderDefaultPhoto());\n}\nfunction defaultRenderRowContainer({\n  rowContainerProps,\n  children\n}) {\n  return React__namespace.createElement(\"div\", { ...rowContainerProps }, children);\n}\nfunction RowContainerRenderer(props) {\n  const {\n    layoutOptions,\n    rowIndex,\n    rowsCount,\n    renderRowContainer,\n    rowContainerProps: { style, className, ...restRowContainerProps } = {},\n    children\n  } = props;\n  const rowContainerProps = {\n    className: clsx(\"react-photo-album--row\", className),\n    style: {\n      display: \"flex\",\n      flexDirection: \"row\",\n      flexWrap: \"nowrap\",\n      alignItems: \"flex-start\",\n      justifyContent: \"space-between\",\n      ...rowIndex < rowsCount - 1 ? { marginBottom: `${layoutOptions.spacing}px` } : null,\n      ...style\n    },\n    ...restRowContainerProps\n  };\n  return React__namespace.createElement(React__namespace.Fragment, null, (renderRowContainer != null ? renderRowContainer : defaultRenderRowContainer)({\n    layoutOptions,\n    rowIndex,\n    rowsCount,\n    rowContainerProps,\n    children\n  }));\n}\nfunction RowsLayout(props) {\n  const {\n    photos,\n    layoutOptions,\n    renderPhoto,\n    renderRowContainer,\n    componentsProps: { imageProps, rowContainerProps }\n  } = props;\n  const rowsLayout = computeRowsLayout({ photos, layoutOptions });\n  if (!rowsLayout)\n    return null;\n  return React__namespace.createElement(React__namespace.Fragment, null, rowsLayout.map((row, rowIndex) => React__namespace.createElement(\n    RowContainerRenderer,\n    {\n      key: `row-${rowIndex}`,\n      layoutOptions,\n      rowIndex,\n      rowsCount: rowsLayout.length,\n      renderRowContainer,\n      rowContainerProps\n    },\n    row.map(({ photo, layout }) => React__namespace.createElement(\n      PhotoRenderer,\n      {\n        key: photo.key || photo.src,\n        photo,\n        layout,\n        layoutOptions,\n        renderPhoto,\n        imageProps\n      }\n    ))\n  )));\n}\nfunction computeShortestPath(graph, pathLength, startNode, endNode) {\n  const matrix = /* @__PURE__ */ new Map();\n  const queue = /* @__PURE__ */ new Set();\n  queue.add(startNode);\n  for (let length = 0; length < pathLength; length += 1) {\n    const currentQueue = [...queue.keys()];\n    queue.clear();\n    currentQueue.forEach((node) => {\n      const accumulatedWeight = length > 0 ? matrix.get(node)[length].weight : 0;\n      graph(node).forEach(({ neighbor, weight }) => {\n        let paths = matrix.get(neighbor);\n        if (!paths) {\n          paths = [];\n          matrix.set(neighbor, paths);\n        }\n        const newWeight = accumulatedWeight + weight;\n        const nextPath = paths[length + 1];\n        if (!nextPath || nextPath.weight > newWeight && (nextPath.weight / newWeight > 1.0001 || node < nextPath.node)) {\n          paths[length + 1] = { node, weight: newWeight };\n        }\n        if (length < pathLength - 1 && neighbor !== endNode) {\n          queue.add(neighbor);\n        }\n      });\n    });\n  }\n  return matrix;\n}\nfunction reconstructShortestPath(matrix, pathLength, endNode) {\n  const path = [endNode];\n  for (let node = endNode, length = pathLength; length > 0; length -= 1) {\n    node = matrix.get(node)[length].node;\n    path.push(node);\n  }\n  return path.reverse();\n}\nfunction findShortestPathLengthN(graph, pathLength, startNode, endNode) {\n  return reconstructShortestPath(computeShortestPath(graph, pathLength, startNode, endNode), pathLength, endNode);\n}\nfunction makeGetColumnNeighbors({\n  photos,\n  spacing,\n  padding,\n  targetColumnWidth,\n  targetColumnHeight\n}) {\n  return (node) => {\n    const results = [];\n    const cutOffHeight = targetColumnHeight * 1.5;\n    let height = targetColumnWidth / ratio(photos[node]) + 2 * padding;\n    for (let i = node + 1; i < photos.length + 1; i += 1) {\n      results.push({ neighbor: i, weight: (targetColumnHeight - height) ** 2 });\n      if (height > cutOffHeight || i === photos.length) {\n        break;\n      }\n      height += targetColumnWidth / ratio(photos[i]) + spacing + 2 * padding;\n    }\n    return results;\n  };\n}\nfunction buildColumnsModel({\n  path,\n  photos,\n  containerWidth,\n  columnsGaps,\n  columnsRatios,\n  spacing,\n  padding\n}) {\n  const columnsModel = [];\n  const totalRatio = columnsRatios.reduce((total, columnRatio) => total + columnRatio, 0);\n  for (let i = 0; i < path.length - 1; i += 1) {\n    const column = photos.map((photo, index) => ({ photo, index })).slice(path[i], path[i + 1]);\n    const totalAdjustedGaps = columnsRatios.reduce(\n      (total, columnRatio, index) => total + (columnsGaps[i] - columnsGaps[index]) * columnRatio,\n      0\n    );\n    const columnWidth = (containerWidth - (path.length - 2) * spacing - 2 * (path.length - 1) * padding - totalAdjustedGaps) * columnsRatios[i] / totalRatio;\n    columnsModel.push(\n      column.map(({ photo, index }, photoIndex) => ({\n        photo,\n        layout: {\n          width: columnWidth,\n          height: columnWidth / ratio(photo),\n          index,\n          photoIndex,\n          photosCount: column.length\n        }\n      }))\n    );\n  }\n  return columnsModel;\n}\nfunction computeColumnsModel({\n  photos,\n  layoutOptions,\n  targetColumnWidth\n}) {\n  const { columns, spacing, padding, containerWidth } = layoutOptions;\n  const columnsGaps = [];\n  const columnsRatios = [];\n  if (photos.length <= columns) {\n    const averageRatio = photos.length > 0 ? photos.reduce((acc, photo) => acc + ratio(photo), 0) / photos.length : 1;\n    for (let i = 0; i < columns; i += 1) {\n      columnsGaps[i] = 2 * padding;\n      columnsRatios[i] = i < photos.length ? ratio(photos[i]) : averageRatio;\n    }\n    const columnsModel2 = buildColumnsModel({\n      path: Array.from({ length: columns + 1 }).map((_, index) => Math.min(index, photos.length)),\n      photos,\n      columnsRatios,\n      columnsGaps,\n      containerWidth,\n      spacing,\n      padding\n    });\n    return { columnsGaps, columnsRatios, columnsModel: columnsModel2 };\n  }\n  const targetColumnHeight = (photos.reduce((acc, photo) => acc + targetColumnWidth / ratio(photo), 0) + spacing * (photos.length - columns) + 2 * padding * photos.length) / columns;\n  const getNeighbors = makeGetColumnNeighbors({\n    photos,\n    targetColumnWidth,\n    targetColumnHeight,\n    spacing,\n    padding\n  });\n  const path = findShortestPathLengthN(getNeighbors, columns, 0, photos.length);\n  for (let i = 0; i < path.length - 1; i += 1) {\n    const column = photos.slice(path[i], path[i + 1]);\n    columnsGaps[i] = spacing * (column.length - 1) + 2 * padding * column.length;\n    columnsRatios[i] = 1 / column.reduce((acc, photo) => acc + 1 / ratio(photo), 0);\n  }\n  const columnsModel = buildColumnsModel({\n    path,\n    photos,\n    columnsRatios,\n    columnsGaps,\n    containerWidth,\n    spacing,\n    padding\n  });\n  return { columnsGaps, columnsRatios, columnsModel };\n}\nfunction computeLayout(props) {\n  const { photos, layoutOptions } = props;\n  const { columns, spacing, padding, containerWidth } = layoutOptions;\n  const targetColumnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n  const { columnsGaps, columnsRatios, columnsModel } = computeColumnsModel({\n    photos,\n    layoutOptions,\n    targetColumnWidth\n  });\n  if (columnsModel.findIndex(\n    (columnModel) => columnModel.findIndex(({ layout: { width, height } }) => width < 0 || height < 0) >= 0\n  ) >= 0) {\n    if (columns > 1) {\n      return computeLayout({ photos, layoutOptions: { ...layoutOptions, columns: columns - 1 } });\n    }\n    return void 0;\n  }\n  return { columnsModel, columnsGaps, columnsRatios };\n}\nfunction computeColumnsLayout({\n  photos,\n  layoutOptions\n}) {\n  return computeLayout({ photos, layoutOptions });\n}\nfunction defaultRenderColumnContainer({\n  columnContainerProps,\n  children\n}) {\n  return React__namespace.createElement(\"div\", { ...columnContainerProps }, children);\n}\nfunction cssColumnWidth(props) {\n  const { layoutOptions, columnIndex, columnsCount, columnsGaps, columnsRatios } = props;\n  const { layout, spacing, padding } = layoutOptions;\n  if (layout === \"masonry\" || !columnsGaps || !columnsRatios) {\n    return `calc((100% - ${spacing * (columnsCount - 1)}px) / ${columnsCount})`;\n  }\n  const totalRatio = columnsRatios.reduce((acc, ratio2) => acc + ratio2, 0);\n  const totalAdjustedGaps = columnsRatios.reduce(\n    (acc, ratio2, index) => acc + (columnsGaps[columnIndex] - columnsGaps[index]) * ratio2,\n    0\n  );\n  return `calc((100% - ${round(\n    (columnsCount - 1) * spacing + 2 * columnsCount * padding + totalAdjustedGaps,\n    3\n  )}px) * ${round(columnsRatios[columnIndex] / totalRatio, 5)} + ${2 * padding}px)`;\n}\nfunction ColumnContainerRenderer(props) {\n  const {\n    layoutOptions,\n    renderColumnContainer,\n    children,\n    columnContainerProps: { style, className, ...restColumnContainerProps } = {},\n    ...rest\n  } = props;\n  const columnContainerProps = {\n    className: clsx(\"react-photo-album--column\", className),\n    style: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      flexWrap: \"nowrap\",\n      alignItems: \"flex-start\",\n      width: cssColumnWidth(props),\n      justifyContent: layoutOptions.layout === \"columns\" ? \"space-between\" : \"flex-start\",\n      ...style\n    },\n    ...restColumnContainerProps\n  };\n  return React__namespace.createElement(React__namespace.Fragment, null, (renderColumnContainer != null ? renderColumnContainer : defaultRenderColumnContainer)({\n    layoutOptions,\n    columnContainerProps,\n    children,\n    ...rest\n  }));\n}\nfunction ColumnsLayout(props) {\n  const {\n    photos,\n    layoutOptions,\n    renderPhoto,\n    renderColumnContainer,\n    componentsProps: { imageProps, columnContainerProps }\n  } = props;\n  const columnsLayout = computeColumnsLayout({ photos, layoutOptions });\n  if (!columnsLayout)\n    return null;\n  const { columnsModel, columnsRatios, columnsGaps } = columnsLayout;\n  return React__namespace.createElement(React__namespace.Fragment, null, columnsModel.map((column, columnIndex) => React__namespace.createElement(\n    ColumnContainerRenderer,\n    {\n      key: `column-${columnIndex}`,\n      layoutOptions,\n      columnIndex,\n      columnsCount: columnsModel.length,\n      columnsGaps,\n      columnsRatios,\n      renderColumnContainer,\n      columnContainerProps\n    },\n    column.map(({ photo, layout }) => React__namespace.createElement(\n      PhotoRenderer,\n      {\n        key: photo.key || photo.src,\n        photo,\n        layout,\n        layoutOptions,\n        renderPhoto,\n        imageProps\n      }\n    ))\n  )));\n}\nfunction computeMasonryLayout(props) {\n  const { photos, layoutOptions } = props;\n  const { columns, spacing, padding, containerWidth } = layoutOptions;\n  const columnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n  if (columnWidth <= 0) {\n    return columns > 1 ? computeMasonryLayout({\n      ...props,\n      layoutOptions: { ...layoutOptions, columns: columns - 1 }\n    }) : void 0;\n  }\n  const columnsCurrentTopPositions = [];\n  for (let i = 0; i < columns; i += 1) {\n    columnsCurrentTopPositions[i] = 0;\n  }\n  const columnsModel = photos.reduce(\n    (model, photo, index) => {\n      const shortestColumn = columnsCurrentTopPositions.reduce(\n        (currentShortestColumn, item, i) => item < columnsCurrentTopPositions[currentShortestColumn] - 1 ? i : currentShortestColumn,\n        0\n      );\n      columnsCurrentTopPositions[shortestColumn] = columnsCurrentTopPositions[shortestColumn] + columnWidth / ratio(photo) + spacing + 2 * padding;\n      model[shortestColumn].push({ photo, index });\n      return model;\n    },\n    Array.from({ length: columns }).map(() => [])\n  );\n  return columnsModel.map(\n    (column) => column.map(({ photo, index }, photoIndex) => ({\n      photo,\n      layout: {\n        width: columnWidth,\n        height: columnWidth / ratio(photo),\n        index,\n        photoIndex,\n        photosCount: column.length\n      }\n    }))\n  );\n}\nfunction MasonryLayout(props) {\n  const {\n    photos,\n    layoutOptions,\n    renderPhoto,\n    renderColumnContainer,\n    componentsProps: { imageProps, columnContainerProps }\n  } = props;\n  const masonryLayout = computeMasonryLayout({ photos, layoutOptions });\n  if (!masonryLayout)\n    return null;\n  return React__namespace.createElement(React__namespace.Fragment, null, masonryLayout.map((column, columnIndex) => React__namespace.createElement(\n    ColumnContainerRenderer,\n    {\n      key: `masonry-column-${columnIndex}`,\n      layoutOptions,\n      columnsCount: masonryLayout.length,\n      columnIndex,\n      renderColumnContainer,\n      columnContainerProps\n    },\n    column.map(({ photo, layout }) => React__namespace.createElement(\n      PhotoRenderer,\n      {\n        key: photo.key || photo.src,\n        photo,\n        layout,\n        layoutOptions,\n        renderPhoto,\n        imageProps\n      }\n    ))\n  )));\n}\nfunction defaultRenderContainer({ containerProps, children, containerRef }) {\n  return React__namespace.createElement(\"div\", { ref: containerRef, ...containerProps }, children);\n}\nfunction ContainerRenderer(props) {\n  const {\n    layout,\n    renderContainer,\n    children,\n    containerRef,\n    containerProps: { style, className, ...restContainerProps } = {}\n  } = props;\n  const containerProps = {\n    className: clsx(\"react-photo-album\", `react-photo-album--${layout}`, className),\n    style: {\n      display: \"flex\",\n      flexWrap: \"nowrap\",\n      justifyContent: \"space-between\",\n      flexDirection: layout === \"rows\" ? \"column\" : \"row\",\n      ...style\n    },\n    ...restContainerProps\n  };\n  return React__namespace.createElement(React__namespace.Fragment, null, (renderContainer != null ? renderContainer : defaultRenderContainer)({\n    containerProps,\n    containerRef,\n    layout,\n    children\n  }));\n}\nfunction useArray(array) {\n  const ref = React__namespace.useRef(array);\n  if (!array || !ref.current || array.join() !== ref.current.join()) {\n    ref.current = array;\n  }\n  return ref.current;\n}\nfunction containerWidthReducer(state, { newContainerWidth, newScrollbarWidth }) {\n  const { containerWidth, scrollbarWidth } = state;\n  if (containerWidth !== void 0 && scrollbarWidth !== void 0 && newContainerWidth !== void 0 && newScrollbarWidth !== void 0 && newContainerWidth > containerWidth && newContainerWidth - containerWidth <= 20 && newScrollbarWidth < scrollbarWidth) {\n    return { containerWidth, scrollbarWidth: newScrollbarWidth };\n  }\n  return containerWidth !== newContainerWidth || scrollbarWidth !== newScrollbarWidth ? { containerWidth: newContainerWidth, scrollbarWidth: newScrollbarWidth } : state;\n}\nfunction resolveContainerWidth(el, breakpoints2) {\n  let width = el == null ? void 0 : el.clientWidth;\n  if (width !== void 0 && breakpoints2 && breakpoints2.length > 0) {\n    const sorted = [...breakpoints2.filter((x) => x > 0)].sort((a, b) => b - a);\n    sorted.push(Math.floor(sorted[sorted.length - 1] / 2));\n    const threshold = width;\n    width = sorted.find((breakpoint, index) => breakpoint <= threshold || index === sorted.length - 1);\n  }\n  return width;\n}\nfunction useContainerWidth(breakpoints2, defaultContainerWidth) {\n  const [{ containerWidth }, dispatch] = React__namespace.useReducer(containerWidthReducer, {\n    containerWidth: defaultContainerWidth\n  });\n  const ref = React__namespace.useRef(null);\n  const observerRef = React__namespace.useRef();\n  const containerRef = React__namespace.useCallback(\n    (node) => {\n      var _a;\n      (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n      observerRef.current = void 0;\n      ref.current = node;\n      const updateWidth = () => dispatch({\n        newContainerWidth: resolveContainerWidth(ref.current, breakpoints2),\n        newScrollbarWidth: window.innerWidth - document.documentElement.clientWidth\n      });\n      updateWidth();\n      if (node && typeof ResizeObserver !== \"undefined\") {\n        observerRef.current = new ResizeObserver(updateWidth);\n        observerRef.current.observe(node);\n      }\n    },\n    [breakpoints2]\n  );\n  return { containerRef, containerWidth };\n}\nconst breakpoints = Object.freeze([1200, 600, 300, 0]);\nfunction unwrap(value, arg) {\n  return typeof value === \"function\" ? value(arg) : value;\n}\nfunction unwrapParameter(value, containerWidth) {\n  return typeof value !== \"undefined\" ? unwrap(value, containerWidth) : void 0;\n}\nfunction selectResponsiveValue(values, containerWidth) {\n  const index = breakpoints.findIndex((breakpoint) => breakpoint <= containerWidth);\n  return unwrap(values[index >= 0 ? index : 0], containerWidth);\n}\nfunction resolveResponsiveParameter(parameter, containerWidth, values, minValue = 0) {\n  const value = unwrapParameter(parameter, containerWidth);\n  return Math.round(Math.max(value === void 0 ? selectResponsiveValue(values, containerWidth) : value, minValue));\n}\nfunction resolveLayoutOptions({\n  layout,\n  onClick,\n  containerWidth,\n  targetRowHeight,\n  rowConstraints,\n  columns,\n  spacing,\n  padding,\n  sizes\n}) {\n  return {\n    layout,\n    onClick,\n    containerWidth,\n    columns: resolveResponsiveParameter(columns, containerWidth, [5, 4, 3, 2], 1),\n    spacing: resolveResponsiveParameter(spacing, containerWidth, [20, 15, 10, 5]),\n    padding: resolveResponsiveParameter(padding, containerWidth, [0, 0, 0, 0, 0]),\n    targetRowHeight: resolveResponsiveParameter(targetRowHeight, containerWidth, [\n      (w) => w / 5,\n      (w) => w / 4,\n      (w) => w / 3,\n      (w) => w / 2\n    ]),\n    rowConstraints: unwrapParameter(rowConstraints, containerWidth),\n    sizes\n  };\n}\nfunction resolveComponentsProps(props, containerWidth, layoutOptions) {\n  const { photos, componentsProps: componentsPropsProp } = props;\n  const componentsProps = unwrap(componentsPropsProp, containerWidth) || {};\n  if (layoutOptions) {\n    const { layout, spacing, padding, rowConstraints } = layoutOptions;\n    if (layout === \"rows\") {\n      const { singleRowMaxHeight } = rowConstraints || {};\n      if (singleRowMaxHeight) {\n        const maxWidth = Math.floor(\n          photos.reduce(\n            (acc, { width, height }) => acc + width / height * singleRowMaxHeight - 2 * padding,\n            padding * photos.length * 2 + spacing * (photos.length - 1)\n          )\n        );\n        if (maxWidth > 0) {\n          componentsProps.containerProps = componentsProps.containerProps || {};\n          componentsProps.containerProps.style = { maxWidth, ...componentsProps.containerProps.style };\n        }\n      }\n    }\n  }\n  return componentsProps;\n}\nfunction renderLayout(props, componentsProps, layoutOptions) {\n  const { photos, layout, renderPhoto, renderRowContainer, renderColumnContainer } = props;\n  const commonLayoutProps = { photos, renderPhoto, componentsProps };\n  if (layout === \"rows\") {\n    return React__namespace.createElement(\n      RowsLayout,\n      {\n        layoutOptions,\n        renderRowContainer,\n        ...commonLayoutProps\n      }\n    );\n  }\n  if (layout === \"columns\") {\n    return React__namespace.createElement(\n      ColumnsLayout,\n      {\n        layoutOptions,\n        renderColumnContainer,\n        ...commonLayoutProps\n      }\n    );\n  }\n  return React__namespace.createElement(\n    MasonryLayout,\n    {\n      layoutOptions,\n      renderColumnContainer,\n      ...commonLayoutProps\n    }\n  );\n}\nfunction PhotoAlbum(props) {\n  const { photos, layout, renderContainer, defaultContainerWidth, breakpoints: breakpoints2 } = props;\n  const { containerRef, containerWidth } = useContainerWidth(useArray(breakpoints2), defaultContainerWidth);\n  if (!layout || ![\"rows\", \"columns\", \"masonry\"].includes(layout) || !Array.isArray(photos))\n    return null;\n  const layoutOptions = containerWidth ? resolveLayoutOptions({ containerWidth, ...props }) : void 0;\n  const componentsProps = resolveComponentsProps(props, containerWidth, layoutOptions);\n  return React__namespace.createElement(\n    ContainerRenderer,\n    {\n      layout,\n      containerRef,\n      renderContainer,\n      containerProps: componentsProps.containerProps\n    },\n    layoutOptions && renderLayout(props, componentsProps, layoutOptions)\n  );\n}\nexports.PhotoAlbum = PhotoAlbum;\nexports[\"default\"] = PhotoAlbum;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGhvdG8tYWxidW0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsYUFBYSwwQkFBMEIsbUJBQW1CO0FBQzNHLGNBQWMsbUJBQU8sQ0FBQyx3R0FBTztBQUM3QjtBQUNBLGtDQUFrQyx3QkFBd0IsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNB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QUN6QztBQUNBO0FBQ0EsZ0VBQWdFLDBCQUEwQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyZXltYXR0ZXItdjIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGhvdG8tYWxidW0vZGlzdC9pbmRleC5qcz80ZTk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhleHBvcnRzLCB7IF9fZXNNb2R1bGU6IHsgdmFsdWU6IHRydWUgfSwgW1N5bWJvbC50b1N0cmluZ1RhZ106IHsgdmFsdWU6IFwiTW9kdWxlXCIgfSB9KTtcbmNvbnN0IFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgY29uc3QgbiA9IE9iamVjdC5jcmVhdGUobnVsbCwgeyBbU3ltYm9sLnRvU3RyaW5nVGFnXTogeyB2YWx1ZTogXCJNb2R1bGVcIiB9IH0pO1xuICBpZiAoZSkge1xuICAgIGZvciAoY29uc3QgayBpbiBlKSB7XG4gICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgY29uc3QgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IGVba11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuY29uc3QgUmVhY3RfX25hbWVzcGFjZSA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoUmVhY3QpO1xuZnVuY3Rpb24gcmF0aW8oeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgcmV0dXJuIHdpZHRoIC8gaGVpZ2h0O1xufVxuZnVuY3Rpb24gcm91bmQodmFsdWUsIGRlY2ltYWxzID0gMCkge1xuICBjb25zdCBmYWN0b3IgPSAxMCAqKiBkZWNpbWFscztcbiAgcmV0dXJuIE1hdGgucm91bmQoKHZhbHVlICsgTnVtYmVyLkVQU0lMT04pICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cbmZ1bmN0aW9uIHJhbmtpbmdGdW5jdGlvbkNvbXBhcmF0b3IocmFuaykge1xuICByZXR1cm4gKGEsIGIpID0+IHJhbmsoYikgLSByYW5rKGEpO1xufVxuY2xhc3MgTWluSGVhcCB7XG4gIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcbiAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgIHRoaXMubiA9IDA7XG4gIH1cbiAgZ3JlYXRlcihpLCBqKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyYXRvcih0aGlzLmhlYXBbaV0sIHRoaXMuaGVhcFtqXSkgPCAwO1xuICB9XG4gIHN3YXAoaSwgaikge1xuICAgIGNvbnN0IHRlbXAgPSB0aGlzLmhlYXBbaV07XG4gICAgdGhpcy5oZWFwW2ldID0gdGhpcy5oZWFwW2pdO1xuICAgIHRoaXMuaGVhcFtqXSA9IHRlbXA7XG4gIH1cbiAgc3dpbShpKSB7XG4gICAgbGV0IGsgPSBpO1xuICAgIGxldCBrMiA9IE1hdGguZmxvb3IoayAvIDIpO1xuICAgIHdoaWxlIChrID4gMSAmJiB0aGlzLmdyZWF0ZXIoazIsIGspKSB7XG4gICAgICB0aGlzLnN3YXAoazIsIGspO1xuICAgICAgayA9IGsyO1xuICAgICAgazIgPSBNYXRoLmZsb29yKGsgLyAyKTtcbiAgICB9XG4gIH1cbiAgc2luayhpKSB7XG4gICAgbGV0IGsgPSBpO1xuICAgIGxldCBrMiA9IGsgKiAyO1xuICAgIHdoaWxlIChrMiA8PSB0aGlzLm4pIHtcbiAgICAgIGlmIChrMiA8IHRoaXMubiAmJiB0aGlzLmdyZWF0ZXIoazIsIGsyICsgMSkpXG4gICAgICAgIGsyICs9IDE7XG4gICAgICBpZiAoIXRoaXMuZ3JlYXRlcihrLCBrMikpXG4gICAgICAgIGJyZWFrO1xuICAgICAgdGhpcy5zd2FwKGssIGsyKTtcbiAgICAgIGsgPSBrMjtcbiAgICAgIGsyID0gayAqIDI7XG4gICAgfVxuICB9XG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMubiArPSAxO1xuICAgIHRoaXMuaGVhcFt0aGlzLm5dID0gZWxlbWVudDtcbiAgICB0aGlzLnN3aW0odGhpcy5uKTtcbiAgfVxuICBwb3AoKSB7XG4gICAgaWYgKHRoaXMubiA9PT0gMClcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy5zd2FwKDEsIHRoaXMubik7XG4gICAgdGhpcy5uIC09IDE7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5oZWFwLnBvcCgpO1xuICAgIHRoaXMuc2luaygxKTtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubjtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRQcmVjZWRlbnRzTWFwKGdyYXBoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3QgcHJlY2VkZW50c01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzdG9yZWRTaG9ydGVzdFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmVkU2hvcnRlc3RQYXRocy5zZXQoc3RhcnROb2RlLCAwKTtcbiAgY29uc3QgcXVldWUgPSBuZXcgTWluSGVhcChyYW5raW5nRnVuY3Rpb25Db21wYXJhdG9yKChlbCkgPT4gZWwud2VpZ2h0KSk7XG4gIHF1ZXVlLnB1c2goeyBpZDogc3RhcnROb2RlLCB3ZWlnaHQ6IDAgfSk7XG4gIHdoaWxlIChxdWV1ZS5zaXplKCkgPiAwKSB7XG4gICAgY29uc3QgeyBpZCwgd2VpZ2h0IH0gPSBxdWV1ZS5wb3AoKTtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKGlkKSkge1xuICAgICAgY29uc3QgbmVpZ2hib3JpbmdOb2RlcyA9IGdyYXBoKGlkKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGlkKTtcbiAgICAgIG5laWdoYm9yaW5nTm9kZXMuZm9yRWFjaCgobmVpZ2hib3JXZWlnaHQsIG5laWdoYm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1dlaWdodCA9IHdlaWdodCArIG5laWdoYm9yV2VpZ2h0O1xuICAgICAgICBjb25zdCBjdXJyZW50SWQgPSBwcmVjZWRlbnRzTWFwLmdldChuZWlnaGJvcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSBzdG9yZWRTaG9ydGVzdFBhdGhzLmdldChuZWlnaGJvcik7XG4gICAgICAgIGlmIChjdXJyZW50V2VpZ2h0ID09PSB2b2lkIDAgfHwgY3VycmVudFdlaWdodCA+IG5ld1dlaWdodCAmJiAoY3VycmVudFdlaWdodCAvIG5ld1dlaWdodCA+IDEuMDA1IHx8IGN1cnJlbnRJZCAhPT0gdm9pZCAwICYmIGN1cnJlbnRJZCA8IGlkKSkge1xuICAgICAgICAgIHN0b3JlZFNob3J0ZXN0UGF0aHMuc2V0KG5laWdoYm9yLCBuZXdXZWlnaHQpO1xuICAgICAgICAgIHF1ZXVlLnB1c2goeyBpZDogbmVpZ2hib3IsIHdlaWdodDogbmV3V2VpZ2h0IH0pO1xuICAgICAgICAgIHByZWNlZGVudHNNYXAuc2V0KG5laWdoYm9yLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RvcmVkU2hvcnRlc3RQYXRocy5oYXMoZW5kTm9kZSkgPyBwcmVjZWRlbnRzTWFwIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEZyb21QcmVjZWRlbnRzTWFwKHByZWNlZGVudHNNYXAsIGVuZE5vZGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChsZXQgbm9kZSA9IGVuZE5vZGU7IG5vZGUgIT09IHZvaWQgMDsgbm9kZSA9IHByZWNlZGVudHNNYXAuZ2V0KG5vZGUpKSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXMucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZmluZFNob3J0ZXN0UGF0aChncmFwaCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHByZWNlZGVudHNNYXAgPSBidWlsZFByZWNlZGVudHNNYXAoZ3JhcGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG4gIHJldHVybiBwcmVjZWRlbnRzTWFwID8gZ2V0UGF0aEZyb21QcmVjZWRlbnRzTWFwKHByZWNlZGVudHNNYXAsIGVuZE5vZGUpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZmluZElkZWFsTm9kZVNlYXJjaCh7XG4gIHBob3RvcyxcbiAgdGFyZ2V0Um93SGVpZ2h0LFxuICBjb250YWluZXJXaWR0aFxufSkge1xuICBjb25zdCBtaW5SYXRpbyA9IHBob3Rvcy5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IE1hdGgubWluKHJhdGlvKHBob3RvKSwgYWNjKSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gIHJldHVybiByb3VuZChjb250YWluZXJXaWR0aCAvIHRhcmdldFJvd0hlaWdodCAvIG1pblJhdGlvKSArIDI7XG59XG5mdW5jdGlvbiBnZXRDb21tb25IZWlnaHQocm93LCBjb250YWluZXJXaWR0aCwgc3BhY2luZywgcGFkZGluZykge1xuICBjb25zdCByb3dXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gKHJvdy5sZW5ndGggLSAxKSAqIHNwYWNpbmcgLSAyICogcGFkZGluZyAqIHJvdy5sZW5ndGg7XG4gIGNvbnN0IHRvdGFsQXNwZWN0UmF0aW8gPSByb3cucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyByYXRpbyhwaG90byksIDApO1xuICByZXR1cm4gcm93V2lkdGggLyB0b3RhbEFzcGVjdFJhdGlvO1xufVxuZnVuY3Rpb24gY29zdChwaG90b3MsIGksIGosIHdpZHRoLCB0YXJnZXRSb3dIZWlnaHQsIHNwYWNpbmcsIHBhZGRpbmcpIHtcbiAgY29uc3Qgcm93ID0gcGhvdG9zLnNsaWNlKGksIGopO1xuICBjb25zdCBjb21tb25IZWlnaHQgPSBnZXRDb21tb25IZWlnaHQocm93LCB3aWR0aCwgc3BhY2luZywgcGFkZGluZyk7XG4gIHJldHVybiBjb21tb25IZWlnaHQgPiAwID8gKGNvbW1vbkhlaWdodCAtIHRhcmdldFJvd0hlaWdodCkgKiogMiAqIHJvdy5sZW5ndGggOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBtYWtlR2V0Um93TmVpZ2hib3JzKHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zLFxuICB0YXJnZXRSb3dIZWlnaHQsXG4gIGxpbWl0Tm9kZVNlYXJjaCxcbiAgcm93Q29uc3RyYWludHNcbn0pIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGNvbnRhaW5lcldpZHRoLCBzcGFjaW5nLCBwYWRkaW5nIH0gPSBsYXlvdXRPcHRpb25zO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJlc3VsdHMuc2V0KG5vZGUsIDApO1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gKF9hID0gcm93Q29uc3RyYWludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHJvd0NvbnN0cmFpbnRzLm1pblBob3RvcykgIT0gbnVsbCA/IF9hIDogMTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihsaW1pdE5vZGVTZWFyY2gsIChfYiA9IHJvd0NvbnN0cmFpbnRzID09IG51bGwgPyB2b2lkIDAgOiByb3dDb25zdHJhaW50cy5tYXhQaG90b3MpICE9IG51bGwgPyBfYiA6IEluZmluaXR5KTtcbiAgICBmb3IgKGxldCBpID0gbm9kZSArIHN0YXJ0T2Zmc2V0OyBpIDwgcGhvdG9zLmxlbmd0aCArIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgLSBub2RlID4gZW5kT2Zmc2V0KVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IGN1cnJlbnRDb3N0ID0gY29zdChwaG90b3MsIG5vZGUsIGksIGNvbnRhaW5lcldpZHRoLCB0YXJnZXRSb3dIZWlnaHQsIHNwYWNpbmcsIHBhZGRpbmcpO1xuICAgICAgaWYgKGN1cnJlbnRDb3N0ID09PSB2b2lkIDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgcmVzdWx0cy5zZXQoaSwgY3VycmVudENvc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSb3dzTGF5b3V0KHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zXG59KSB7XG4gIGNvbnN0IHsgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGgsIHRhcmdldFJvd0hlaWdodCwgcm93Q29uc3RyYWludHMgfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGxpbWl0Tm9kZVNlYXJjaCA9IGZpbmRJZGVhbE5vZGVTZWFyY2goeyBwaG90b3MsIGNvbnRhaW5lcldpZHRoLCB0YXJnZXRSb3dIZWlnaHQgfSk7XG4gIGNvbnN0IGdldE5laWdoYm9ycyA9IG1ha2VHZXRSb3dOZWlnaGJvcnMoe1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHRhcmdldFJvd0hlaWdodCxcbiAgICBsaW1pdE5vZGVTZWFyY2gsXG4gICAgcm93Q29uc3RyYWludHNcbiAgfSk7XG4gIGNvbnN0IHBhdGggPSBmaW5kU2hvcnRlc3RQYXRoKGdldE5laWdoYm9ycywgMCwgcGhvdG9zLmxlbmd0aCk7XG4gIGlmIChwYXRoID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgbGF5b3V0ID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHJvdyA9IHBob3Rvcy5tYXAoKHBob3RvLCBpbmRleCkgPT4gKHsgcGhvdG8sIGluZGV4IH0pKS5zbGljZShwYXRoW2kgLSAxXSwgcGF0aFtpXSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gZ2V0Q29tbW9uSGVpZ2h0KFxuICAgICAgcm93Lm1hcCgoeyBwaG90byB9KSA9PiBwaG90byksXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIHNwYWNpbmcsXG4gICAgICBwYWRkaW5nXG4gICAgKTtcbiAgICBsYXlvdXQucHVzaChcbiAgICAgIHJvdy5tYXAoKHsgcGhvdG8sIGluZGV4IH0sIHBob3RvSW5kZXgpID0+ICh7XG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IGhlaWdodCAqIHJhdGlvKHBob3RvKSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwaG90b0luZGV4LFxuICAgICAgICAgIHBob3Rvc0NvdW50OiByb3cubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGxheW91dDtcbn1cbmZ1bmN0aW9uIGNsc3goLi4uY2xhc3Nlcykge1xuICByZXR1cm4gWy4uLmNsYXNzZXNdLmZpbHRlcigoY2xzKSA9PiBCb29sZWFuKGNscykpLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gY2FsY1dpZHRoKGJhc2UsIHsgd2lkdGgsIHBob3Rvc0NvdW50IH0sIHsgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSkge1xuICBjb25zdCBnYXBzID0gc3BhY2luZyAqIChwaG90b3NDb3VudCAtIDEpICsgMiAqIHBhZGRpbmcgKiBwaG90b3NDb3VudDtcbiAgcmV0dXJuIGBjYWxjKCgke2Jhc2V9IC0gJHtnYXBzfXB4KSAvICR7cm91bmQoKGNvbnRhaW5lcldpZHRoIC0gZ2FwcykgLyB3aWR0aCwgNSl9KWA7XG59XG5mdW5jdGlvbiBjc3NQaG90b1dpZHRoKGxheW91dCwgbGF5b3V0T3B0aW9ucykge1xuICByZXR1cm4gbGF5b3V0T3B0aW9ucy5sYXlvdXQgIT09IFwicm93c1wiID8gYGNhbGMoMTAwJSAtICR7MiAqIGxheW91dE9wdGlvbnMucGFkZGluZ31weClgIDogY2FsY1dpZHRoKFwiMTAwJVwiLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZXNWYWx1ZShzaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIGNhbGNXaWR0aCgoX2IgPSAoX2EgPSBzaXplLm1hdGNoKC9jYWxjXFwoKC4qKVxcKS8pKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMV0pICE9IG51bGwgPyBfYiA6IHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcmNTZXRBbmRTaXplcyhwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSB7XG4gIGxldCBzcmNTZXQ7XG4gIGxldCBzaXplcztcbiAgY29uc3QgaW1hZ2VzID0gcGhvdG8uc3JjU2V0IHx8IHBob3RvLmltYWdlcztcbiAgaWYgKGltYWdlcyAmJiBpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgIHNyY1NldCA9IGltYWdlcy5jb25jYXQoXG4gICAgICAhaW1hZ2VzLmZpbmQoKHsgd2lkdGggfSkgPT4gd2lkdGggPT09IHBob3RvLndpZHRoKSA/IFt7IHNyYzogcGhvdG8uc3JjLCB3aWR0aDogcGhvdG8ud2lkdGgsIGhlaWdodDogcGhvdG8uaGVpZ2h0IH1dIDogW11cbiAgICApLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IGZpcnN0LndpZHRoIC0gc2Vjb25kLndpZHRoKS5tYXAoKGltYWdlKSA9PiBgJHtpbWFnZS5zcmN9ICR7aW1hZ2Uud2lkdGh9d2ApLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBpZiAobGF5b3V0T3B0aW9ucy5zaXplcykge1xuICAgIHNpemVzID0gKGxheW91dE9wdGlvbnMuc2l6ZXMuc2l6ZXMgfHwgW10pLm1hcCgoeyB2aWV3cG9ydCwgc2l6ZSB9KSA9PiBgJHt2aWV3cG9ydH0gJHtjYWxjdWxhdGVTaXplc1ZhbHVlKHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucyl9YCkuY29uY2F0KGNhbGN1bGF0ZVNpemVzVmFsdWUobGF5b3V0T3B0aW9ucy5zaXplcy5zaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpKS5qb2luKFwiLCBcIik7XG4gIH0gZWxzZSBpZiAoc3JjU2V0KSB7XG4gICAgc2l6ZXMgPSBgJHtNYXRoLmNlaWwobGF5b3V0LndpZHRoIC8gbGF5b3V0T3B0aW9ucy5jb250YWluZXJXaWR0aCAqIDEwMCl9dndgO1xuICB9XG4gIHJldHVybiB7IHNyY1NldCwgc2l6ZXMgfTtcbn1cbmZ1bmN0aW9uIFBob3RvUmVuZGVyZXIocHJvcHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3Qge1xuICAgIHBob3RvLFxuICAgIGxheW91dCxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIGltYWdlUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdEltYWdlUHJvcHMgfSA9IHt9LFxuICAgIHJlbmRlclBob3RvXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgeyBvbkNsaWNrIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBpbWFnZVN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIixcbiAgICB3aWR0aDogY3NzUGhvdG9XaWR0aChsYXlvdXQsIGxheW91dE9wdGlvbnMpLFxuICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgYXNwZWN0UmF0aW86IGAke3Bob3RvLndpZHRofSAvICR7cGhvdG8uaGVpZ2h0fWAsXG4gICAgLi4ubGF5b3V0T3B0aW9ucy5wYWRkaW5nID8geyBwYWRkaW5nOiBgJHtsYXlvdXRPcHRpb25zLnBhZGRpbmd9cHhgIH0gOiBudWxsLFxuICAgIC4uLihsYXlvdXRPcHRpb25zLmxheW91dCA9PT0gXCJjb2x1bW5zXCIgfHwgbGF5b3V0T3B0aW9ucy5sYXlvdXQgPT09IFwibWFzb25yeVwiKSAmJiBsYXlvdXQucGhvdG9JbmRleCA8IGxheW91dC5waG90b3NDb3VudCAtIDEgPyB7IG1hcmdpbkJvdHRvbTogYCR7bGF5b3V0T3B0aW9ucy5zcGFjaW5nfXB4YCB9IDogbnVsbCxcbiAgICAuLi5vbkNsaWNrID8geyBjdXJzb3I6IFwicG9pbnRlclwiIH0gOiBudWxsLFxuICAgIC4uLnN0eWxlXG4gIH07XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gb25DbGljayA/IChldmVudCkgPT4ge1xuICAgIG9uQ2xpY2soeyBldmVudCwgcGhvdG8sIGluZGV4OiBsYXlvdXQuaW5kZXggfSk7XG4gIH0gOiB2b2lkIDA7XG4gIGNvbnN0IGltYWdlUHJvcHMgPSB7XG4gICAgc3JjOiBwaG90by5zcmMsXG4gICAgYWx0OiAoX2EgPSBwaG90by5hbHQpICE9IG51bGwgPyBfYSA6IFwiXCIsXG4gICAgdGl0bGU6IHBob3RvLnRpdGxlLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgIHN0eWxlOiBpbWFnZVN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1waG90b1wiLCBjbGFzc05hbWUpLFxuICAgIGxvYWRpbmc6IFwibGF6eVwiLFxuICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgLi4uc3JjU2V0QW5kU2l6ZXMocGhvdG8sIGxheW91dCwgbGF5b3V0T3B0aW9ucyksXG4gICAgLi4ucmVzdEltYWdlUHJvcHNcbiAgfTtcbiAgY29uc3QgcmVuZGVyRGVmYXVsdFBob3RvID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IHNyYywgYWx0LCBzcmNTZXQsIHNpemVzLCBzdHlsZTogdW53cmFwcGVkU3R5bGUsIC4uLnJlc3QgfSA9IGltYWdlUHJvcHM7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiaW1nXCIsXG4gICAgICB7XG4gICAgICAgIGFsdCxcbiAgICAgICAgLi4uc3JjU2V0ID8geyBzcmNTZXQsIHNpemVzIH0gOiBudWxsLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy53cmFwcGVkKSA/IHsgZGlzcGxheTogXCJibG9ja1wiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSA6IHVud3JhcHBlZFN0eWxlLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgY29uc3Qgd3JhcHBlclN0eWxlID0gKCh7IGRpc3BsYXksIGJveFNpemluZywgd2lkdGgsIGFzcGVjdFJhdGlvLCBwYWRkaW5nLCBtYXJnaW5Cb3R0b20sIGN1cnNvciB9KSA9PiAoe1xuICAgIGRpc3BsYXksXG4gICAgYm94U2l6aW5nLFxuICAgIHdpZHRoLFxuICAgIGFzcGVjdFJhdGlvLFxuICAgIHBhZGRpbmcsXG4gICAgbWFyZ2luQm90dG9tLFxuICAgIGN1cnNvclxuICB9KSkoaW1hZ2VTdHlsZSk7XG4gIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgKF9iID0gcmVuZGVyUGhvdG8gPT0gbnVsbCA/IHZvaWQgMCA6IHJlbmRlclBob3RvKHtcbiAgICBwaG90byxcbiAgICBsYXlvdXQsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICBpbWFnZVByb3BzLFxuICAgIHJlbmRlckRlZmF1bHRQaG90byxcbiAgICB3cmFwcGVyU3R5bGVcbiAgfSkpICE9IG51bGwgPyBfYiA6IHJlbmRlckRlZmF1bHRQaG90bygpKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJSb3dDb250YWluZXIoe1xuICByb3dDb250YWluZXJQcm9wcyxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnJvd0NvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIFJvd0NvbnRhaW5lclJlbmRlcmVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJvd0luZGV4LFxuICAgIHJvd3NDb3VudCxcbiAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgcm93Q29udGFpbmVyUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdFJvd0NvbnRhaW5lclByb3BzIH0gPSB7fSxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJvd0NvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1yb3dcIiwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcInJvd1wiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICAgIC4uLnJvd0luZGV4IDwgcm93c0NvdW50IC0gMSA/IHsgbWFyZ2luQm90dG9tOiBgJHtsYXlvdXRPcHRpb25zLnNwYWNpbmd9cHhgIH0gOiBudWxsLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnJlc3RSb3dDb250YWluZXJQcm9wc1xuICB9O1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIChyZW5kZXJSb3dDb250YWluZXIgIT0gbnVsbCA/IHJlbmRlclJvd0NvbnRhaW5lciA6IGRlZmF1bHRSZW5kZXJSb3dDb250YWluZXIpKHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJvd0luZGV4LFxuICAgIHJvd3NDb3VudCxcbiAgICByb3dDb250YWluZXJQcm9wcyxcbiAgICBjaGlsZHJlblxuICB9KSk7XG59XG5mdW5jdGlvbiBSb3dzTGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByZW5kZXJQaG90byxcbiAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgY29tcG9uZW50c1Byb3BzOiB7IGltYWdlUHJvcHMsIHJvd0NvbnRhaW5lclByb3BzIH1cbiAgfSA9IHByb3BzO1xuICBjb25zdCByb3dzTGF5b3V0ID0gY29tcHV0ZVJvd3NMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSk7XG4gIGlmICghcm93c0xheW91dClcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCByb3dzTGF5b3V0Lm1hcCgocm93LCByb3dJbmRleCkgPT4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFxuICAgIFJvd0NvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYHJvdy0ke3Jvd0luZGV4fWAsXG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgcm93SW5kZXgsXG4gICAgICByb3dzQ291bnQ6IHJvd3NMYXlvdXQubGVuZ3RoLFxuICAgICAgcmVuZGVyUm93Q29udGFpbmVyLFxuICAgICAgcm93Q29udGFpbmVyUHJvcHNcbiAgICB9LFxuICAgIHJvdy5tYXAoKHsgcGhvdG8sIGxheW91dCB9KSA9PiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQaG90b1JlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBrZXk6IHBob3RvLmtleSB8fCBwaG90by5zcmMsXG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclBob3RvLFxuICAgICAgICBpbWFnZVByb3BzXG4gICAgICB9XG4gICAgKSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNob3J0ZXN0UGF0aChncmFwaCwgcGF0aExlbmd0aCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IG1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHF1ZXVlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcXVldWUuYWRkKHN0YXJ0Tm9kZSk7XG4gIGZvciAobGV0IGxlbmd0aCA9IDA7IGxlbmd0aCA8IHBhdGhMZW5ndGg7IGxlbmd0aCArPSAxKSB7XG4gICAgY29uc3QgY3VycmVudFF1ZXVlID0gWy4uLnF1ZXVlLmtleXMoKV07XG4gICAgcXVldWUuY2xlYXIoKTtcbiAgICBjdXJyZW50UXVldWUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgY29uc3QgYWNjdW11bGF0ZWRXZWlnaHQgPSBsZW5ndGggPiAwID8gbWF0cml4LmdldChub2RlKVtsZW5ndGhdLndlaWdodCA6IDA7XG4gICAgICBncmFwaChub2RlKS5mb3JFYWNoKCh7IG5laWdoYm9yLCB3ZWlnaHQgfSkgPT4ge1xuICAgICAgICBsZXQgcGF0aHMgPSBtYXRyaXguZ2V0KG5laWdoYm9yKTtcbiAgICAgICAgaWYgKCFwYXRocykge1xuICAgICAgICAgIHBhdGhzID0gW107XG4gICAgICAgICAgbWF0cml4LnNldChuZWlnaGJvciwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1dlaWdodCA9IGFjY3VtdWxhdGVkV2VpZ2h0ICsgd2VpZ2h0O1xuICAgICAgICBjb25zdCBuZXh0UGF0aCA9IHBhdGhzW2xlbmd0aCArIDFdO1xuICAgICAgICBpZiAoIW5leHRQYXRoIHx8IG5leHRQYXRoLndlaWdodCA+IG5ld1dlaWdodCAmJiAobmV4dFBhdGgud2VpZ2h0IC8gbmV3V2VpZ2h0ID4gMS4wMDAxIHx8IG5vZGUgPCBuZXh0UGF0aC5ub2RlKSkge1xuICAgICAgICAgIHBhdGhzW2xlbmd0aCArIDFdID0geyBub2RlLCB3ZWlnaHQ6IG5ld1dlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCBwYXRoTGVuZ3RoIC0gMSAmJiBuZWlnaGJvciAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgIHF1ZXVlLmFkZChuZWlnaGJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5mdW5jdGlvbiByZWNvbnN0cnVjdFNob3J0ZXN0UGF0aChtYXRyaXgsIHBhdGhMZW5ndGgsIGVuZE5vZGUpIHtcbiAgY29uc3QgcGF0aCA9IFtlbmROb2RlXTtcbiAgZm9yIChsZXQgbm9kZSA9IGVuZE5vZGUsIGxlbmd0aCA9IHBhdGhMZW5ndGg7IGxlbmd0aCA+IDA7IGxlbmd0aCAtPSAxKSB7XG4gICAgbm9kZSA9IG1hdHJpeC5nZXQobm9kZSlbbGVuZ3RoXS5ub2RlO1xuICAgIHBhdGgucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBmaW5kU2hvcnRlc3RQYXRoTGVuZ3RoTihncmFwaCwgcGF0aExlbmd0aCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiByZWNvbnN0cnVjdFNob3J0ZXN0UGF0aChjb21wdXRlU2hvcnRlc3RQYXRoKGdyYXBoLCBwYXRoTGVuZ3RoLCBzdGFydE5vZGUsIGVuZE5vZGUpLCBwYXRoTGVuZ3RoLCBlbmROb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VHZXRDb2x1bW5OZWlnaGJvcnMoe1xuICBwaG90b3MsXG4gIHNwYWNpbmcsXG4gIHBhZGRpbmcsXG4gIHRhcmdldENvbHVtbldpZHRoLFxuICB0YXJnZXRDb2x1bW5IZWlnaHRcbn0pIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IGN1dE9mZkhlaWdodCA9IHRhcmdldENvbHVtbkhlaWdodCAqIDEuNTtcbiAgICBsZXQgaGVpZ2h0ID0gdGFyZ2V0Q29sdW1uV2lkdGggLyByYXRpbyhwaG90b3Nbbm9kZV0pICsgMiAqIHBhZGRpbmc7XG4gICAgZm9yIChsZXQgaSA9IG5vZGUgKyAxOyBpIDwgcGhvdG9zLmxlbmd0aCArIDE7IGkgKz0gMSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgbmVpZ2hib3I6IGksIHdlaWdodDogKHRhcmdldENvbHVtbkhlaWdodCAtIGhlaWdodCkgKiogMiB9KTtcbiAgICAgIGlmIChoZWlnaHQgPiBjdXRPZmZIZWlnaHQgfHwgaSA9PT0gcGhvdG9zLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGhlaWdodCArPSB0YXJnZXRDb2x1bW5XaWR0aCAvIHJhdGlvKHBob3Rvc1tpXSkgKyBzcGFjaW5nICsgMiAqIHBhZGRpbmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRDb2x1bW5zTW9kZWwoe1xuICBwYXRoLFxuICBwaG90b3MsXG4gIGNvbnRhaW5lcldpZHRoLFxuICBjb2x1bW5zR2FwcyxcbiAgY29sdW1uc1JhdGlvcyxcbiAgc3BhY2luZyxcbiAgcGFkZGluZ1xufSkge1xuICBjb25zdCBjb2x1bW5zTW9kZWwgPSBbXTtcbiAgY29uc3QgdG90YWxSYXRpbyA9IGNvbHVtbnNSYXRpb3MucmVkdWNlKCh0b3RhbCwgY29sdW1uUmF0aW8pID0+IHRvdGFsICsgY29sdW1uUmF0aW8sIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgY29sdW1uID0gcGhvdG9zLm1hcCgocGhvdG8sIGluZGV4KSA9PiAoeyBwaG90bywgaW5kZXggfSkpLnNsaWNlKHBhdGhbaV0sIHBhdGhbaSArIDFdKTtcbiAgICBjb25zdCB0b3RhbEFkanVzdGVkR2FwcyA9IGNvbHVtbnNSYXRpb3MucmVkdWNlKFxuICAgICAgKHRvdGFsLCBjb2x1bW5SYXRpbywgaW5kZXgpID0+IHRvdGFsICsgKGNvbHVtbnNHYXBzW2ldIC0gY29sdW1uc0dhcHNbaW5kZXhdKSAqIGNvbHVtblJhdGlvLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgY29sdW1uV2lkdGggPSAoY29udGFpbmVyV2lkdGggLSAocGF0aC5sZW5ndGggLSAyKSAqIHNwYWNpbmcgLSAyICogKHBhdGgubGVuZ3RoIC0gMSkgKiBwYWRkaW5nIC0gdG90YWxBZGp1c3RlZEdhcHMpICogY29sdW1uc1JhdGlvc1tpXSAvIHRvdGFsUmF0aW87XG4gICAgY29sdW1uc01vZGVsLnB1c2goXG4gICAgICBjb2x1bW4ubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogY29sdW1uV2lkdGggLyByYXRpbyhwaG90byksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgICBwaG90b3NDb3VudDogY29sdW1uLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHJldHVybiBjb2x1bW5zTW9kZWw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29sdW1uc01vZGVsKHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zLFxuICB0YXJnZXRDb2x1bW5XaWR0aFxufSkge1xuICBjb25zdCB7IGNvbHVtbnMsIHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBjb2x1bW5zR2FwcyA9IFtdO1xuICBjb25zdCBjb2x1bW5zUmF0aW9zID0gW107XG4gIGlmIChwaG90b3MubGVuZ3RoIDw9IGNvbHVtbnMpIHtcbiAgICBjb25zdCBhdmVyYWdlUmF0aW8gPSBwaG90b3MubGVuZ3RoID4gMCA/IHBob3Rvcy5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IGFjYyArIHJhdGlvKHBob3RvKSwgMCkgLyBwaG90b3MubGVuZ3RoIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkgKz0gMSkge1xuICAgICAgY29sdW1uc0dhcHNbaV0gPSAyICogcGFkZGluZztcbiAgICAgIGNvbHVtbnNSYXRpb3NbaV0gPSBpIDwgcGhvdG9zLmxlbmd0aCA/IHJhdGlvKHBob3Rvc1tpXSkgOiBhdmVyYWdlUmF0aW87XG4gICAgfVxuICAgIGNvbnN0IGNvbHVtbnNNb2RlbDIgPSBidWlsZENvbHVtbnNNb2RlbCh7XG4gICAgICBwYXRoOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2x1bW5zICsgMSB9KS5tYXAoKF8sIGluZGV4KSA9PiBNYXRoLm1pbihpbmRleCwgcGhvdG9zLmxlbmd0aCkpLFxuICAgICAgcGhvdG9zLFxuICAgICAgY29sdW1uc1JhdGlvcyxcbiAgICAgIGNvbHVtbnNHYXBzLFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBzcGFjaW5nLFxuICAgICAgcGFkZGluZ1xuICAgIH0pO1xuICAgIHJldHVybiB7IGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zTW9kZWw6IGNvbHVtbnNNb2RlbDIgfTtcbiAgfVxuICBjb25zdCB0YXJnZXRDb2x1bW5IZWlnaHQgPSAocGhvdG9zLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgdGFyZ2V0Q29sdW1uV2lkdGggLyByYXRpbyhwaG90byksIDApICsgc3BhY2luZyAqIChwaG90b3MubGVuZ3RoIC0gY29sdW1ucykgKyAyICogcGFkZGluZyAqIHBob3Rvcy5sZW5ndGgpIC8gY29sdW1ucztcbiAgY29uc3QgZ2V0TmVpZ2hib3JzID0gbWFrZUdldENvbHVtbk5laWdoYm9ycyh7XG4gICAgcGhvdG9zLFxuICAgIHRhcmdldENvbHVtbldpZHRoLFxuICAgIHRhcmdldENvbHVtbkhlaWdodCxcbiAgICBzcGFjaW5nLFxuICAgIHBhZGRpbmdcbiAgfSk7XG4gIGNvbnN0IHBhdGggPSBmaW5kU2hvcnRlc3RQYXRoTGVuZ3RoTihnZXROZWlnaGJvcnMsIGNvbHVtbnMsIDAsIHBob3Rvcy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgY29sdW1uID0gcGhvdG9zLnNsaWNlKHBhdGhbaV0sIHBhdGhbaSArIDFdKTtcbiAgICBjb2x1bW5zR2Fwc1tpXSA9IHNwYWNpbmcgKiAoY29sdW1uLmxlbmd0aCAtIDEpICsgMiAqIHBhZGRpbmcgKiBjb2x1bW4ubGVuZ3RoO1xuICAgIGNvbHVtbnNSYXRpb3NbaV0gPSAxIC8gY29sdW1uLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgMSAvIHJhdGlvKHBob3RvKSwgMCk7XG4gIH1cbiAgY29uc3QgY29sdW1uc01vZGVsID0gYnVpbGRDb2x1bW5zTW9kZWwoe1xuICAgIHBhdGgsXG4gICAgcGhvdG9zLFxuICAgIGNvbHVtbnNSYXRpb3MsXG4gICAgY29sdW1uc0dhcHMsXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgc3BhY2luZyxcbiAgICBwYWRkaW5nXG4gIH0pO1xuICByZXR1cm4geyBjb2x1bW5zR2FwcywgY29sdW1uc1JhdGlvcywgY29sdW1uc01vZGVsIH07XG59XG5mdW5jdGlvbiBjb21wdXRlTGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0gPSBwcm9wcztcbiAgY29uc3QgeyBjb2x1bW5zLCBzcGFjaW5nLCBwYWRkaW5nLCBjb250YWluZXJXaWR0aCB9ID0gbGF5b3V0T3B0aW9ucztcbiAgY29uc3QgdGFyZ2V0Q29sdW1uV2lkdGggPSAoY29udGFpbmVyV2lkdGggLSBzcGFjaW5nICogKGNvbHVtbnMgLSAxKSAtIDIgKiBwYWRkaW5nICogY29sdW1ucykgLyBjb2x1bW5zO1xuICBjb25zdCB7IGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zTW9kZWwgfSA9IGNvbXB1dGVDb2x1bW5zTW9kZWwoe1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHRhcmdldENvbHVtbldpZHRoXG4gIH0pO1xuICBpZiAoY29sdW1uc01vZGVsLmZpbmRJbmRleChcbiAgICAoY29sdW1uTW9kZWwpID0+IGNvbHVtbk1vZGVsLmZpbmRJbmRleCgoeyBsYXlvdXQ6IHsgd2lkdGgsIGhlaWdodCB9IH0pID0+IHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSA+PSAwXG4gICkgPj0gMCkge1xuICAgIGlmIChjb2x1bW5zID4gMSkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnM6IHsgLi4ubGF5b3V0T3B0aW9ucywgY29sdW1uczogY29sdW1ucyAtIDEgfSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBjb2x1bW5zTW9kZWwsIGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQ29sdW1uc0xheW91dCh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9uc1xufSkge1xuICByZXR1cm4gY29tcHV0ZUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDb2x1bW5Db250YWluZXIoe1xuICBjb2x1bW5Db250YWluZXJQcm9wcyxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLmNvbHVtbkNvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGNzc0NvbHVtbldpZHRoKHByb3BzKSB7XG4gIGNvbnN0IHsgbGF5b3V0T3B0aW9ucywgY29sdW1uSW5kZXgsIGNvbHVtbnNDb3VudCwgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MgfSA9IHByb3BzO1xuICBjb25zdCB7IGxheW91dCwgc3BhY2luZywgcGFkZGluZyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgaWYgKGxheW91dCA9PT0gXCJtYXNvbnJ5XCIgfHwgIWNvbHVtbnNHYXBzIHx8ICFjb2x1bW5zUmF0aW9zKSB7XG4gICAgcmV0dXJuIGBjYWxjKCgxMDAlIC0gJHtzcGFjaW5nICogKGNvbHVtbnNDb3VudCAtIDEpfXB4KSAvICR7Y29sdW1uc0NvdW50fSlgO1xuICB9XG4gIGNvbnN0IHRvdGFsUmF0aW8gPSBjb2x1bW5zUmF0aW9zLnJlZHVjZSgoYWNjLCByYXRpbzIpID0+IGFjYyArIHJhdGlvMiwgMCk7XG4gIGNvbnN0IHRvdGFsQWRqdXN0ZWRHYXBzID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoXG4gICAgKGFjYywgcmF0aW8yLCBpbmRleCkgPT4gYWNjICsgKGNvbHVtbnNHYXBzW2NvbHVtbkluZGV4XSAtIGNvbHVtbnNHYXBzW2luZGV4XSkgKiByYXRpbzIsXG4gICAgMFxuICApO1xuICByZXR1cm4gYGNhbGMoKDEwMCUgLSAke3JvdW5kKFxuICAgIChjb2x1bW5zQ291bnQgLSAxKSAqIHNwYWNpbmcgKyAyICogY29sdW1uc0NvdW50ICogcGFkZGluZyArIHRvdGFsQWRqdXN0ZWRHYXBzLFxuICAgIDNcbiAgKX1weCkgKiAke3JvdW5kKGNvbHVtbnNSYXRpb3NbY29sdW1uSW5kZXhdIC8gdG90YWxSYXRpbywgNSl9ICsgJHsyICogcGFkZGluZ31weClgO1xufVxuZnVuY3Rpb24gQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbHVtbkNvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RDb2x1bW5Db250YWluZXJQcm9wcyB9ID0ge30sXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHVtbkNvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1jb2x1bW5cIiwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIHdpZHRoOiBjc3NDb2x1bW5XaWR0aChwcm9wcyksXG4gICAgICBqdXN0aWZ5Q29udGVudDogbGF5b3V0T3B0aW9ucy5sYXlvdXQgPT09IFwiY29sdW1uc1wiID8gXCJzcGFjZS1iZXR3ZWVuXCIgOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5yZXN0Q29sdW1uQ29udGFpbmVyUHJvcHNcbiAgfTtcbiAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCAocmVuZGVyQ29sdW1uQ29udGFpbmVyICE9IG51bGwgPyByZW5kZXJDb2x1bW5Db250YWluZXIgOiBkZWZhdWx0UmVuZGVyQ29sdW1uQ29udGFpbmVyKSh7XG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICBjb2x1bW5Db250YWluZXJQcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICAuLi5yZXN0XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIENvbHVtbnNMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgY29sdW1uQ29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHVtbnNMYXlvdXQgPSBjb21wdXRlQ29sdW1uc0xheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFjb2x1bW5zTGF5b3V0KVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB7IGNvbHVtbnNNb2RlbCwgY29sdW1uc1JhdGlvcywgY29sdW1uc0dhcHMgfSA9IGNvbHVtbnNMYXlvdXQ7XG4gIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgY29sdW1uc01vZGVsLm1hcCgoY29sdW1uLCBjb2x1bW5JbmRleCkgPT4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFxuICAgIENvbHVtbkNvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYGNvbHVtbi0ke2NvbHVtbkluZGV4fWAsXG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICBjb2x1bW5zQ291bnQ6IGNvbHVtbnNNb2RlbC5sZW5ndGgsXG4gICAgICBjb2x1bW5zR2FwcyxcbiAgICAgIGNvbHVtbnNSYXRpb3MsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICBjb2x1bW5Db250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgY29sdW1uLm1hcCgoeyBwaG90bywgbGF5b3V0IH0pID0+IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcbiAgICAgIFBob3RvUmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGtleTogcGhvdG8ua2V5IHx8IHBob3RvLnNyYyxcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUGhvdG8sXG4gICAgICAgIGltYWdlUHJvcHNcbiAgICAgIH1cbiAgICApKVxuICApKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTWFzb25yeUxheW91dChwcm9wcykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgY29sdW1ucywgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGNvbHVtbldpZHRoID0gKGNvbnRhaW5lcldpZHRoIC0gc3BhY2luZyAqIChjb2x1bW5zIC0gMSkgLSAyICogcGFkZGluZyAqIGNvbHVtbnMpIC8gY29sdW1ucztcbiAgaWYgKGNvbHVtbldpZHRoIDw9IDApIHtcbiAgICByZXR1cm4gY29sdW1ucyA+IDEgPyBjb21wdXRlTWFzb25yeUxheW91dCh7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGxheW91dE9wdGlvbnM6IHsgLi4ubGF5b3V0T3B0aW9ucywgY29sdW1uczogY29sdW1ucyAtIDEgfVxuICAgIH0pIDogdm9pZCAwO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSArPSAxKSB7XG4gICAgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbaV0gPSAwO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNNb2RlbCA9IHBob3Rvcy5yZWR1Y2UoXG4gICAgKG1vZGVsLCBwaG90bywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0ZXN0Q29sdW1uID0gY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnMucmVkdWNlKFxuICAgICAgICAoY3VycmVudFNob3J0ZXN0Q29sdW1uLCBpdGVtLCBpKSA9PiBpdGVtIDwgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbY3VycmVudFNob3J0ZXN0Q29sdW1uXSAtIDEgPyBpIDogY3VycmVudFNob3J0ZXN0Q29sdW1uLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbc2hvcnRlc3RDb2x1bW5dID0gY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbc2hvcnRlc3RDb2x1bW5dICsgY29sdW1uV2lkdGggLyByYXRpbyhwaG90bykgKyBzcGFjaW5nICsgMiAqIHBhZGRpbmc7XG4gICAgICBtb2RlbFtzaG9ydGVzdENvbHVtbl0ucHVzaCh7IHBob3RvLCBpbmRleCB9KTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHVtbnMgfSkubWFwKCgpID0+IFtdKVxuICApO1xuICByZXR1cm4gY29sdW1uc01vZGVsLm1hcChcbiAgICAoY29sdW1uKSA9PiBjb2x1bW4ubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgcGhvdG8sXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgcGhvdG9zQ291bnQ6IGNvbHVtbi5sZW5ndGhcbiAgICAgIH1cbiAgICB9KSlcbiAgKTtcbn1cbmZ1bmN0aW9uIE1hc29ucnlMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgY29sdW1uQ29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG1hc29ucnlMYXlvdXQgPSBjb21wdXRlTWFzb25yeUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFtYXNvbnJ5TGF5b3V0KVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIG1hc29ucnlMYXlvdXQubWFwKChjb2x1bW4sIGNvbHVtbkluZGV4KSA9PiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAga2V5OiBgbWFzb25yeS1jb2x1bW4tJHtjb2x1bW5JbmRleH1gLFxuICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgIGNvbHVtbnNDb3VudDogbWFzb25yeUxheW91dC5sZW5ndGgsXG4gICAgICBjb2x1bW5JbmRleCxcbiAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgIGNvbHVtbkNvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICBjb2x1bW4ubWFwKCh7IHBob3RvLCBsYXlvdXQgfSkgPT4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFxuICAgICAgUGhvdG9SZW5kZXJlcixcbiAgICAgIHtcbiAgICAgICAga2V5OiBwaG90by5rZXkgfHwgcGhvdG8uc3JjLFxuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJQaG90byxcbiAgICAgICAgaW1hZ2VQcm9wc1xuICAgICAgfVxuICAgICkpXG4gICkpKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDb250YWluZXIoeyBjb250YWluZXJQcm9wcywgY2hpbGRyZW4sIGNvbnRhaW5lclJlZiB9KSB7XG4gIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lclJlZiwgLi4uY29udGFpbmVyUHJvcHMgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gQ29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dCxcbiAgICByZW5kZXJDb250YWluZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGFpbmVyUmVmLFxuICAgIGNvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RDb250YWluZXJQcm9wcyB9ID0ge31cbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb250YWluZXJQcm9wcyA9IHtcbiAgICBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1waG90by1hbGJ1bVwiLCBgcmVhY3QtcGhvdG8tYWxidW0tLSR7bGF5b3V0fWAsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBsYXlvdXQgPT09IFwicm93c1wiID8gXCJjb2x1bW5cIiA6IFwicm93XCIsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucmVzdENvbnRhaW5lclByb3BzXG4gIH07XG4gIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgKHJlbmRlckNvbnRhaW5lciAhPSBudWxsID8gcmVuZGVyQ29udGFpbmVyIDogZGVmYXVsdFJlbmRlckNvbnRhaW5lcikoe1xuICAgIGNvbnRhaW5lclByb3BzLFxuICAgIGNvbnRhaW5lclJlZixcbiAgICBsYXlvdXQsXG4gICAgY2hpbGRyZW5cbiAgfSkpO1xufVxuZnVuY3Rpb24gdXNlQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoYXJyYXkpO1xuICBpZiAoIWFycmF5IHx8ICFyZWYuY3VycmVudCB8fCBhcnJheS5qb2luKCkgIT09IHJlZi5jdXJyZW50LmpvaW4oKSkge1xuICAgIHJlZi5jdXJyZW50ID0gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gY29udGFpbmVyV2lkdGhSZWR1Y2VyKHN0YXRlLCB7IG5ld0NvbnRhaW5lcldpZHRoLCBuZXdTY3JvbGxiYXJXaWR0aCB9KSB7XG4gIGNvbnN0IHsgY29udGFpbmVyV2lkdGgsIHNjcm9sbGJhcldpZHRoIH0gPSBzdGF0ZTtcbiAgaWYgKGNvbnRhaW5lcldpZHRoICE9PSB2b2lkIDAgJiYgc2Nyb2xsYmFyV2lkdGggIT09IHZvaWQgMCAmJiBuZXdDb250YWluZXJXaWR0aCAhPT0gdm9pZCAwICYmIG5ld1Njcm9sbGJhcldpZHRoICE9PSB2b2lkIDAgJiYgbmV3Q29udGFpbmVyV2lkdGggPiBjb250YWluZXJXaWR0aCAmJiBuZXdDb250YWluZXJXaWR0aCAtIGNvbnRhaW5lcldpZHRoIDw9IDIwICYmIG5ld1Njcm9sbGJhcldpZHRoIDwgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICByZXR1cm4geyBjb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGg6IG5ld1Njcm9sbGJhcldpZHRoIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcldpZHRoICE9PSBuZXdDb250YWluZXJXaWR0aCB8fCBzY3JvbGxiYXJXaWR0aCAhPT0gbmV3U2Nyb2xsYmFyV2lkdGggPyB7IGNvbnRhaW5lcldpZHRoOiBuZXdDb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGg6IG5ld1Njcm9sbGJhcldpZHRoIH0gOiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb250YWluZXJXaWR0aChlbCwgYnJlYWtwb2ludHMyKSB7XG4gIGxldCB3aWR0aCA9IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5jbGllbnRXaWR0aDtcbiAgaWYgKHdpZHRoICE9PSB2b2lkIDAgJiYgYnJlYWtwb2ludHMyICYmIGJyZWFrcG9pbnRzMi5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmJyZWFrcG9pbnRzMi5maWx0ZXIoKHgpID0+IHggPiAwKV0uc29ydCgoYSwgYikgPT4gYiAtIGEpO1xuICAgIHNvcnRlZC5wdXNoKE1hdGguZmxvb3Ioc29ydGVkW3NvcnRlZC5sZW5ndGggLSAxXSAvIDIpKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB3aWR0aDtcbiAgICB3aWR0aCA9IHNvcnRlZC5maW5kKChicmVha3BvaW50LCBpbmRleCkgPT4gYnJlYWtwb2ludCA8PSB0aHJlc2hvbGQgfHwgaW5kZXggPT09IHNvcnRlZC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiB1c2VDb250YWluZXJXaWR0aChicmVha3BvaW50czIsIGRlZmF1bHRDb250YWluZXJXaWR0aCkge1xuICBjb25zdCBbeyBjb250YWluZXJXaWR0aCB9LCBkaXNwYXRjaF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZHVjZXIoY29udGFpbmVyV2lkdGhSZWR1Y2VyLCB7XG4gICAgY29udGFpbmVyV2lkdGg6IGRlZmF1bHRDb250YWluZXJXaWR0aFxuICB9KTtcbiAgY29uc3QgcmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9ic2VydmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhcbiAgICAobm9kZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gb2JzZXJ2ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBjb25zdCB1cGRhdGVXaWR0aCA9ICgpID0+IGRpc3BhdGNoKHtcbiAgICAgICAgbmV3Q29udGFpbmVyV2lkdGg6IHJlc29sdmVDb250YWluZXJXaWR0aChyZWYuY3VycmVudCwgYnJlYWtwb2ludHMyKSxcbiAgICAgICAgbmV3U2Nyb2xsYmFyV2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZVdpZHRoKCk7XG4gICAgICBpZiAobm9kZSAmJiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlcih1cGRhdGVXaWR0aCk7XG4gICAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQub2JzZXJ2ZShub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFticmVha3BvaW50czJdXG4gICk7XG4gIHJldHVybiB7IGNvbnRhaW5lclJlZiwgY29udGFpbmVyV2lkdGggfTtcbn1cbmNvbnN0IGJyZWFrcG9pbnRzID0gT2JqZWN0LmZyZWV6ZShbMTIwMCwgNjAwLCAzMDAsIDBdKTtcbmZ1bmN0aW9uIHVud3JhcCh2YWx1ZSwgYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlKGFyZykgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcFBhcmFtZXRlcih2YWx1ZSwgY29udGFpbmVyV2lkdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHVud3JhcCh2YWx1ZSwgY29udGFpbmVyV2lkdGgpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gc2VsZWN0UmVzcG9uc2l2ZVZhbHVlKHZhbHVlcywgY29udGFpbmVyV2lkdGgpIHtcbiAgY29uc3QgaW5kZXggPSBicmVha3BvaW50cy5maW5kSW5kZXgoKGJyZWFrcG9pbnQpID0+IGJyZWFrcG9pbnQgPD0gY29udGFpbmVyV2lkdGgpO1xuICByZXR1cm4gdW53cmFwKHZhbHVlc1tpbmRleCA+PSAwID8gaW5kZXggOiAwXSwgY29udGFpbmVyV2lkdGgpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIocGFyYW1ldGVyLCBjb250YWluZXJXaWR0aCwgdmFsdWVzLCBtaW5WYWx1ZSA9IDApIHtcbiAgY29uc3QgdmFsdWUgPSB1bndyYXBQYXJhbWV0ZXIocGFyYW1ldGVyLCBjb250YWluZXJXaWR0aCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWF4KHZhbHVlID09PSB2b2lkIDAgPyBzZWxlY3RSZXNwb25zaXZlVmFsdWUodmFsdWVzLCBjb250YWluZXJXaWR0aCkgOiB2YWx1ZSwgbWluVmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXlvdXRPcHRpb25zKHtcbiAgbGF5b3V0LFxuICBvbkNsaWNrLFxuICBjb250YWluZXJXaWR0aCxcbiAgdGFyZ2V0Um93SGVpZ2h0LFxuICByb3dDb25zdHJhaW50cyxcbiAgY29sdW1ucyxcbiAgc3BhY2luZyxcbiAgcGFkZGluZyxcbiAgc2l6ZXNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQsXG4gICAgb25DbGljayxcbiAgICBjb250YWluZXJXaWR0aCxcbiAgICBjb2x1bW5zOiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihjb2x1bW5zLCBjb250YWluZXJXaWR0aCwgWzUsIDQsIDMsIDJdLCAxKSxcbiAgICBzcGFjaW5nOiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihzcGFjaW5nLCBjb250YWluZXJXaWR0aCwgWzIwLCAxNSwgMTAsIDVdKSxcbiAgICBwYWRkaW5nOiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihwYWRkaW5nLCBjb250YWluZXJXaWR0aCwgWzAsIDAsIDAsIDAsIDBdKSxcbiAgICB0YXJnZXRSb3dIZWlnaHQ6IHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKHRhcmdldFJvd0hlaWdodCwgY29udGFpbmVyV2lkdGgsIFtcbiAgICAgICh3KSA9PiB3IC8gNSxcbiAgICAgICh3KSA9PiB3IC8gNCxcbiAgICAgICh3KSA9PiB3IC8gMyxcbiAgICAgICh3KSA9PiB3IC8gMlxuICAgIF0pLFxuICAgIHJvd0NvbnN0cmFpbnRzOiB1bndyYXBQYXJhbWV0ZXIocm93Q29uc3RyYWludHMsIGNvbnRhaW5lcldpZHRoKSxcbiAgICBzaXplc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHNQcm9wcyhwcm9wcywgY29udGFpbmVyV2lkdGgsIGxheW91dE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGNvbXBvbmVudHNQcm9wczogY29tcG9uZW50c1Byb3BzUHJvcCB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbXBvbmVudHNQcm9wcyA9IHVud3JhcChjb21wb25lbnRzUHJvcHNQcm9wLCBjb250YWluZXJXaWR0aCkgfHwge307XG4gIGlmIChsYXlvdXRPcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXlvdXQsIHNwYWNpbmcsIHBhZGRpbmcsIHJvd0NvbnN0cmFpbnRzIH0gPSBsYXlvdXRPcHRpb25zO1xuICAgIGlmIChsYXlvdXQgPT09IFwicm93c1wiKSB7XG4gICAgICBjb25zdCB7IHNpbmdsZVJvd01heEhlaWdodCB9ID0gcm93Q29uc3RyYWludHMgfHwge307XG4gICAgICBpZiAoc2luZ2xlUm93TWF4SGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBwaG90b3MucmVkdWNlKFxuICAgICAgICAgICAgKGFjYywgeyB3aWR0aCwgaGVpZ2h0IH0pID0+IGFjYyArIHdpZHRoIC8gaGVpZ2h0ICogc2luZ2xlUm93TWF4SGVpZ2h0IC0gMiAqIHBhZGRpbmcsXG4gICAgICAgICAgICBwYWRkaW5nICogcGhvdG9zLmxlbmd0aCAqIDIgKyBzcGFjaW5nICogKHBob3Rvcy5sZW5ndGggLSAxKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1heFdpZHRoID4gMCkge1xuICAgICAgICAgIGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wcyA9IGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wcyB8fCB7fTtcbiAgICAgICAgICBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMuc3R5bGUgPSB7IG1heFdpZHRoLCAuLi5jb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMuc3R5bGUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1Byb3BzO1xufVxuZnVuY3Rpb24gcmVuZGVyTGF5b3V0KHByb3BzLCBjb21wb25lbnRzUHJvcHMsIGxheW91dE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dCwgcmVuZGVyUGhvdG8sIHJlbmRlclJvd0NvbnRhaW5lciwgcmVuZGVyQ29sdW1uQ29udGFpbmVyIH0gPSBwcm9wcztcbiAgY29uc3QgY29tbW9uTGF5b3V0UHJvcHMgPSB7IHBob3RvcywgcmVuZGVyUGhvdG8sIGNvbXBvbmVudHNQcm9wcyB9O1xuICBpZiAobGF5b3V0ID09PSBcInJvd3NcIikge1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSb3dzTGF5b3V0LFxuICAgICAge1xuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAobGF5b3V0ID09PSBcImNvbHVtbnNcIikge1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb2x1bW5zTGF5b3V0LFxuICAgICAge1xuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFxuICAgIE1hc29ucnlMYXlvdXQsXG4gICAge1xuICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUGhvdG9BbGJ1bShwcm9wcykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0LCByZW5kZXJDb250YWluZXIsIGRlZmF1bHRDb250YWluZXJXaWR0aCwgYnJlYWtwb2ludHM6IGJyZWFrcG9pbnRzMiB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgY29udGFpbmVyUmVmLCBjb250YWluZXJXaWR0aCB9ID0gdXNlQ29udGFpbmVyV2lkdGgodXNlQXJyYXkoYnJlYWtwb2ludHMyKSwgZGVmYXVsdENvbnRhaW5lcldpZHRoKTtcbiAgaWYgKCFsYXlvdXQgfHwgIVtcInJvd3NcIiwgXCJjb2x1bW5zXCIsIFwibWFzb25yeVwiXS5pbmNsdWRlcyhsYXlvdXQpIHx8ICFBcnJheS5pc0FycmF5KHBob3RvcykpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxheW91dE9wdGlvbnMgPSBjb250YWluZXJXaWR0aCA/IHJlc29sdmVMYXlvdXRPcHRpb25zKHsgY29udGFpbmVyV2lkdGgsIC4uLnByb3BzIH0pIDogdm9pZCAwO1xuICBjb25zdCBjb21wb25lbnRzUHJvcHMgPSByZXNvbHZlQ29tcG9uZW50c1Byb3BzKHByb3BzLCBjb250YWluZXJXaWR0aCwgbGF5b3V0T3B0aW9ucyk7XG4gIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAgbGF5b3V0LFxuICAgICAgY29udGFpbmVyUmVmLFxuICAgICAgcmVuZGVyQ29udGFpbmVyLFxuICAgICAgY29udGFpbmVyUHJvcHM6IGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgbGF5b3V0T3B0aW9ucyAmJiByZW5kZXJMYXlvdXQocHJvcHMsIGNvbXBvbmVudHNQcm9wcywgbGF5b3V0T3B0aW9ucylcbiAgKTtcbn1cbmV4cG9ydHMuUGhvdG9BbGJ1bSA9IFBob3RvQWxidW07XG5leHBvcnRzLmRlZmF1bHQgPSBQaG90b0FsYnVtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-photo-album/dist/index.js\n");

/***/ })

};
;