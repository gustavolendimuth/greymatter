/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shuding";
exports.ids = ["vendor-chunks/@shuding"];
exports.modules = {

/***/ "(ssr)/./node_modules/@shuding/opentype.js/dist/opentype.js":
/*!************************************************************!*\
  !*** ./node_modules/@shuding/opentype.js/dist/opentype.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * https://opentype.js.org v1.3.5 | (c) Frederik De Bleser and other contributors | MIT License | Uses fflate by 101arrowz and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n(function (global, factory) {\n    true ? factory(exports) :\n   0;\n}(this, (function (exports) { 'use strict';\n\n   // DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n\n   // aliases for shorter compressed code (most minifers don't do this)\n   var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n   // fixed length extra bits\n   var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n   // fixed distance extra bits\n   // see fleb note\n   var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n   // code length index map\n   var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n   // get base, reverse index map from extra bits\n   var freb = function (eb, start) {\n       var b = new u16(31);\n       for (var i = 0; i < 31; ++i) {\n           b[i] = start += 1 << eb[i - 1];\n       }\n       // numbers here are at max 18 bits\n       var r = new u32(b[30]);\n       for (var i = 1; i < 30; ++i) {\n           for (var j = b[i]; j < b[i + 1]; ++j) {\n               r[j] = ((j - b[i]) << 5) | i;\n           }\n       }\n       return [b, r];\n   };\n   var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n   // we can ignore the fact that the other numbers are wrong; they never happen anyway\n   fl[28] = 258, revfl[258] = 28;\n   var _b = freb(fdeb, 0), fd = _b[0];\n   // map of value to reverse (assuming 16 bits)\n   var rev = new u16(32768);\n   for (var i = 0; i < 32768; ++i) {\n       // reverse table algorithm from SO\n       var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n       x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n       x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n       rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n   }\n   // create huffman tree from u8 \"map\": index -> code length for code index\n   // mb (max bits) must be at most 15\n   // TODO: optimize/split up?\n   var hMap = (function (cd, mb, r) {\n       var s = cd.length;\n       // index\n       var i = 0;\n       // u16 \"map\": index -> # of codes with bit length = index\n       var l = new u16(mb);\n       // length of cd must be 288 (total # of codes)\n       for (; i < s; ++i) {\n           if (cd[i])\n               { ++l[cd[i] - 1]; }\n       }\n       // u16 \"map\": index -> minimum code for bit length = index\n       var le = new u16(mb);\n       for (i = 0; i < mb; ++i) {\n           le[i] = (le[i - 1] + l[i - 1]) << 1;\n       }\n       var co;\n       if (r) {\n           // u16 \"map\": index -> number of actual bits, symbol for code\n           co = new u16(1 << mb);\n           // bits to remove for reverser\n           var rvb = 15 - mb;\n           for (i = 0; i < s; ++i) {\n               // ignore 0 lengths\n               if (cd[i]) {\n                   // num encoding both symbol and bits read\n                   var sv = (i << 4) | cd[i];\n                   // free bits\n                   var r_1 = mb - cd[i];\n                   // start value\n                   var v = le[cd[i] - 1]++ << r_1;\n                   // m is end value\n                   for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                       // every 16 bit value starting with the code yields the same result\n                       co[rev[v] >>> rvb] = sv;\n                   }\n               }\n           }\n       }\n       else {\n           co = new u16(s);\n           for (i = 0; i < s; ++i) {\n               if (cd[i]) {\n                   co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n               }\n           }\n       }\n       return co;\n   });\n   // fixed length tree\n   var flt = new u8(288);\n   for (var i = 0; i < 144; ++i)\n       { flt[i] = 8; }\n   for (var i = 144; i < 256; ++i)\n       { flt[i] = 9; }\n   for (var i = 256; i < 280; ++i)\n       { flt[i] = 7; }\n   for (var i = 280; i < 288; ++i)\n       { flt[i] = 8; }\n   // fixed distance tree\n   var fdt = new u8(32);\n   for (var i = 0; i < 32; ++i)\n       { fdt[i] = 5; }\n   // fixed length map\n   var flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n   // fixed distance map\n   var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n   // find max of array\n   var max = function (a) {\n       var m = a[0];\n       for (var i = 1; i < a.length; ++i) {\n           if (a[i] > m)\n               { m = a[i]; }\n       }\n       return m;\n   };\n   // read d, starting at bit p and mask with m\n   var bits = function (d, p, m) {\n       var o = (p / 8) | 0;\n       return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n   };\n   // read d, starting at bit p continuing for at least 16 bits\n   var bits16 = function (d, p) {\n       var o = (p / 8) | 0;\n       return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n   };\n   // get end of byte\n   var shft = function (p) { return ((p + 7) / 8) | 0; };\n   // typed array slice - allows garbage collector to free original reference,\n   // while being more compatible than .slice\n   var slc = function (v, s, e) {\n       if (s == null || s < 0)\n           { s = 0; }\n       if (e == null || e > v.length)\n           { e = v.length; }\n       // can't use .constructor in case user-supplied\n       var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n       n.set(v.subarray(s, e));\n       return n;\n   };\n   // error codes\n   var ec = [\n       'unexpected EOF',\n       'invalid block type',\n       'invalid length/literal',\n       'invalid distance',\n       'stream finished',\n       'no stream handler',\n       ,\n       'no callback',\n       'invalid UTF-8 data',\n       'extra field too long',\n       'date not in range 1980-2099',\n       'filename too long',\n       'stream finishing',\n       'invalid zip data'\n       // determined by unknown compression method\n   ];\n   var err = function (ind, msg, nt) {\n       var e = new Error(msg || ec[ind]);\n       e.code = ind;\n       if (Error.captureStackTrace)\n           { Error.captureStackTrace(e, err); }\n       if (!nt)\n           { throw e; }\n       return e;\n   };\n   // expands raw DEFLATE data\n   var inflt = function (dat, buf, st) {\n       // source length\n       var sl = dat.length;\n       if (!sl || (st && st.f && !st.l))\n           { return buf || new u8(0); }\n       // have to estimate size\n       var noBuf = !buf || st;\n       // no state\n       var noSt = !st || st.i;\n       if (!st)\n           { st = {}; }\n       // Assumes roughly 33% compression ratio average\n       if (!buf)\n           { buf = new u8(sl * 3); }\n       // ensure buffer can fit at least l elements\n       var cbuf = function (l) {\n           var bl = buf.length;\n           // need to increase size to fit\n           if (l > bl) {\n               // Double or set to necessary, whichever is greater\n               var nbuf = new u8(Math.max(bl * 2, l));\n               nbuf.set(buf);\n               buf = nbuf;\n           }\n       };\n       //  last chunk         bitpos           bytes\n       var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n       // total bits\n       var tbts = sl * 8;\n       do {\n           if (!lm) {\n               // BFINAL - this is only 1 when last chunk is next\n               final = bits(dat, pos, 1);\n               // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n               var type = bits(dat, pos + 1, 3);\n               pos += 3;\n               if (!type) {\n                   // go to end of byte boundary\n                   var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                   if (t > sl) {\n                       if (noSt)\n                           { err(0); }\n                       break;\n                   }\n                   // ensure size\n                   if (noBuf)\n                       { cbuf(bt + l); }\n                   // Copy over uncompressed data\n                   buf.set(dat.subarray(s, t), bt);\n                   // Get new bitpos, update byte count\n                   st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                   continue;\n               }\n               else if (type == 1)\n                   { lm = flrm, dm = fdrm, lbt = 9, dbt = 5; }\n               else if (type == 2) {\n                   //  literal                            lengths\n                   var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                   var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                   pos += 14;\n                   // length+distance tree\n                   var ldt = new u8(tl);\n                   // code length tree\n                   var clt = new u8(19);\n                   for (var i = 0; i < hcLen; ++i) {\n                       // use index map to get real code\n                       clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                   }\n                   pos += hcLen * 3;\n                   // code lengths bits\n                   var clb = max(clt), clbmsk = (1 << clb) - 1;\n                   // code lengths map\n                   var clm = hMap(clt, clb, 1);\n                   for (var i = 0; i < tl;) {\n                       var r = clm[bits(dat, pos, clbmsk)];\n                       // bits read\n                       pos += r & 15;\n                       // symbol\n                       var s = r >>> 4;\n                       // code length to copy\n                       if (s < 16) {\n                           ldt[i++] = s;\n                       }\n                       else {\n                           //  copy   count\n                           var c = 0, n = 0;\n                           if (s == 16)\n                               { n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1]; }\n                           else if (s == 17)\n                               { n = 3 + bits(dat, pos, 7), pos += 3; }\n                           else if (s == 18)\n                               { n = 11 + bits(dat, pos, 127), pos += 7; }\n                           while (n--)\n                               { ldt[i++] = c; }\n                       }\n                   }\n                   //    length tree                 distance tree\n                   var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                   // max length bits\n                   lbt = max(lt);\n                   // max dist bits\n                   dbt = max(dt);\n                   lm = hMap(lt, lbt, 1);\n                   dm = hMap(dt, dbt, 1);\n               }\n               else\n                   { err(1); }\n               if (pos > tbts) {\n                   if (noSt)\n                       { err(0); }\n                   break;\n               }\n           }\n           // Make sure the buffer can hold this + the largest possible addition\n           // Maximum chunk size (practically, theoretically infinite) is 2^17;\n           if (noBuf)\n               { cbuf(bt + 131072); }\n           var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n           var lpos = pos;\n           for (;; lpos = pos) {\n               // bits read, code\n               var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n               pos += c & 15;\n               if (pos > tbts) {\n                   if (noSt)\n                       { err(0); }\n                   break;\n               }\n               if (!c)\n                   { err(2); }\n               if (sym < 256)\n                   { buf[bt++] = sym; }\n               else if (sym == 256) {\n                   lpos = pos, lm = null;\n                   break;\n               }\n               else {\n                   var add = sym - 254;\n                   // no extra bits needed if less\n                   if (sym > 264) {\n                       // index\n                       var i = sym - 257, b = fleb[i];\n                       add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                       pos += b;\n                   }\n                   // dist\n                   var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                   if (!d)\n                       { err(3); }\n                   pos += d & 15;\n                   var dt = fd[dsym];\n                   if (dsym > 3) {\n                       var b = fdeb[dsym];\n                       dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                   }\n                   if (pos > tbts) {\n                       if (noSt)\n                           { err(0); }\n                       break;\n                   }\n                   if (noBuf)\n                       { cbuf(bt + 131072); }\n                   var end = bt + add;\n                   for (; bt < end; bt += 4) {\n                       buf[bt] = buf[bt - dt];\n                       buf[bt + 1] = buf[bt + 1 - dt];\n                       buf[bt + 2] = buf[bt + 2 - dt];\n                       buf[bt + 3] = buf[bt + 3 - dt];\n                   }\n                   bt = end;\n               }\n           }\n           st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n           if (lm)\n               { final = 1, st.m = lbt, st.d = dm, st.n = dbt; }\n       } while (!final);\n       return bt == buf.length ? buf : slc(buf, 0, bt);\n   };\n   // empty\n   var et = /*#__PURE__*/ new u8(0);\n   /**\n    * Expands DEFLATE data with no wrapper\n    * @param data The data to decompress\n    * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n    * @returns The decompressed version of the data\n    */\n   function inflateSync(data, out) {\n       return inflt(data, out);\n   }\n   // text decoder\n   var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n   // text decoder stream\n   var tds = 0;\n   try {\n       td.decode(et, { stream: true });\n       tds = 1;\n   }\n   catch (e) { }\n\n   // Geometric objects\n\n   // import BoundingBox from './bbox';\n\n   /**\n    * A bÃ©zier path containing a set of path commands similar to a SVG path.\n    * Paths can be drawn on a context using `draw`.\n    * @exports opentype.Path\n    * @class\n    * @constructor\n    */\n   function Path() {\n       this.commands = [];\n       this.fill = 'black';\n       this.stroke = null;\n       this.strokeWidth = 1;\n   }\n\n   /**\n    * @param  {number} x\n    * @param  {number} y\n    */\n   Path.prototype.moveTo = function (x, y) {\n       this.commands.push({\n           type: 'M',\n           x: x,\n           y: y,\n       });\n   };\n\n   /**\n    * @param  {number} x\n    * @param  {number} y\n    */\n   Path.prototype.lineTo = function (x, y) {\n       this.commands.push({\n           type: 'L',\n           x: x,\n           y: y,\n       });\n   };\n\n   /**\n    * Draws cubic curve\n    * @function\n    * curveTo\n    * @memberof opentype.Path.prototype\n    * @param  {number} x1 - x of control 1\n    * @param  {number} y1 - y of control 1\n    * @param  {number} x2 - x of control 2\n    * @param  {number} y2 - y of control 2\n    * @param  {number} x - x of path point\n    * @param  {number} y - y of path point\n    */\n\n   /**\n    * Draws cubic curve\n    * @function\n    * bezierCurveTo\n    * @memberof opentype.Path.prototype\n    * @param  {number} x1 - x of control 1\n    * @param  {number} y1 - y of control 1\n    * @param  {number} x2 - x of control 2\n    * @param  {number} y2 - y of control 2\n    * @param  {number} x - x of path point\n    * @param  {number} y - y of path point\n    * @see curveTo\n    */\n   Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (\n       x1,\n       y1,\n       x2,\n       y2,\n       x,\n       y\n   ) {\n       this.commands.push({\n           type: 'C',\n           x1: x1,\n           y1: y1,\n           x2: x2,\n           y2: y2,\n           x: x,\n           y: y,\n       });\n   };\n\n   /**\n    * Draws quadratic curve\n    * @function\n    * quadraticCurveTo\n    * @memberof opentype.Path.prototype\n    * @param  {number} x1 - x of control\n    * @param  {number} y1 - y of control\n    * @param  {number} x - x of path point\n    * @param  {number} y - y of path point\n    */\n\n   /**\n    * Draws quadratic curve\n    * @function\n    * quadTo\n    * @memberof opentype.Path.prototype\n    * @param  {number} x1 - x of control\n    * @param  {number} y1 - y of control\n    * @param  {number} x - x of path point\n    * @param  {number} y - y of path point\n    */\n   Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (\n       x1,\n       y1,\n       x,\n       y\n   ) {\n       this.commands.push({\n           type: 'Q',\n           x1: x1,\n           y1: y1,\n           x: x,\n           y: y,\n       });\n   };\n\n   /**\n    * Closes the path\n    * @function closePath\n    * @memberof opentype.Path.prototype\n    */\n\n   /**\n    * Close the path\n    * @function close\n    * @memberof opentype.Path.prototype\n    */\n   Path.prototype.close = Path.prototype.closePath = function () {\n       this.commands.push({\n           type: 'Z',\n       });\n   };\n\n   /**\n    * Add the given path or list of commands to the commands of this path.\n    * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n    */\n   Path.prototype.extend = function (pathOrCommands) {\n       if (pathOrCommands.commands) {\n           pathOrCommands = pathOrCommands.commands;\n       }\n       // else if (pathOrCommands instanceof BoundingBox) {\n       //     const box = pathOrCommands;\n       //     this.moveTo(box.x1, box.y1);\n       //     this.lineTo(box.x2, box.y1);\n       //     this.lineTo(box.x2, box.y2);\n       //     this.lineTo(box.x1, box.y2);\n       //     this.close();\n       //     return;\n       // }\n\n       Array.prototype.push.apply(this.commands, pathOrCommands);\n   };\n\n   /**\n    * Convert the Path to a string of path data instructions\n    * See http://www.w3.org/TR/SVG/paths.html#PathData\n    * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n    * @return {string}\n    */\n   Path.prototype.toPathData = function (decimalPlaces) {\n       decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n       function floatToString(v) {\n           if (Math.round(v) === v) {\n               return '' + Math.round(v);\n           } else {\n               return v.toFixed(decimalPlaces);\n           }\n       }\n\n       function packValues() {\n           var arguments$1 = arguments;\n\n           var s = '';\n           for (var i = 0; i < arguments.length; i += 1) {\n               var v = arguments$1[i];\n               if (v >= 0 && i > 0) {\n                   s += ' ';\n               }\n\n               s += floatToString(v);\n           }\n\n           return s;\n       }\n\n       var d = '';\n       for (var i = 0; i < this.commands.length; i += 1) {\n           var cmd = this.commands[i];\n           if (cmd.type === 'M') {\n               d += 'M' + packValues(cmd.x, cmd.y);\n           } else if (cmd.type === 'L') {\n               d += 'L' + packValues(cmd.x, cmd.y);\n           } else if (cmd.type === 'C') {\n               d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n           } else if (cmd.type === 'Q') {\n               d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n           } else if (cmd.type === 'Z') {\n               d += 'Z';\n           }\n       }\n\n       return d;\n   };\n\n   // Glyph encoding\n\n   var cffStandardStrings = [\n       '.notdef',\n       'space',\n       'exclam',\n       'quotedbl',\n       'numbersign',\n       'dollar',\n       'percent',\n       'ampersand',\n       'quoteright',\n       'parenleft',\n       'parenright',\n       'asterisk',\n       'plus',\n       'comma',\n       'hyphen',\n       'period',\n       'slash',\n       'zero',\n       'one',\n       'two',\n       'three',\n       'four',\n       'five',\n       'six',\n       'seven',\n       'eight',\n       'nine',\n       'colon',\n       'semicolon',\n       'less',\n       'equal',\n       'greater',\n       'question',\n       'at',\n       'A',\n       'B',\n       'C',\n       'D',\n       'E',\n       'F',\n       'G',\n       'H',\n       'I',\n       'J',\n       'K',\n       'L',\n       'M',\n       'N',\n       'O',\n       'P',\n       'Q',\n       'R',\n       'S',\n       'T',\n       'U',\n       'V',\n       'W',\n       'X',\n       'Y',\n       'Z',\n       'bracketleft',\n       'backslash',\n       'bracketright',\n       'asciicircum',\n       'underscore',\n       'quoteleft',\n       'a',\n       'b',\n       'c',\n       'd',\n       'e',\n       'f',\n       'g',\n       'h',\n       'i',\n       'j',\n       'k',\n       'l',\n       'm',\n       'n',\n       'o',\n       'p',\n       'q',\n       'r',\n       's',\n       't',\n       'u',\n       'v',\n       'w',\n       'x',\n       'y',\n       'z',\n       'braceleft',\n       'bar',\n       'braceright',\n       'asciitilde',\n       'exclamdown',\n       'cent',\n       'sterling',\n       'fraction',\n       'yen',\n       'florin',\n       'section',\n       'currency',\n       'quotesingle',\n       'quotedblleft',\n       'guillemotleft',\n       'guilsinglleft',\n       'guilsinglright',\n       'fi',\n       'fl',\n       'endash',\n       'dagger',\n       'daggerdbl',\n       'periodcentered',\n       'paragraph',\n       'bullet',\n       'quotesinglbase',\n       'quotedblbase',\n       'quotedblright',\n       'guillemotright',\n       'ellipsis',\n       'perthousand',\n       'questiondown',\n       'grave',\n       'acute',\n       'circumflex',\n       'tilde',\n       'macron',\n       'breve',\n       'dotaccent',\n       'dieresis',\n       'ring',\n       'cedilla',\n       'hungarumlaut',\n       'ogonek',\n       'caron',\n       'emdash',\n       'AE',\n       'ordfeminine',\n       'Lslash',\n       'Oslash',\n       'OE',\n       'ordmasculine',\n       'ae',\n       'dotlessi',\n       'lslash',\n       'oslash',\n       'oe',\n       'germandbls',\n       'onesuperior',\n       'logicalnot',\n       'mu',\n       'trademark',\n       'Eth',\n       'onehalf',\n       'plusminus',\n       'Thorn',\n       'onequarter',\n       'divide',\n       'brokenbar',\n       'degree',\n       'thorn',\n       'threequarters',\n       'twosuperior',\n       'registered',\n       'minus',\n       'eth',\n       'multiply',\n       'threesuperior',\n       'copyright',\n       'Aacute',\n       'Acircumflex',\n       'Adieresis',\n       'Agrave',\n       'Aring',\n       'Atilde',\n       'Ccedilla',\n       'Eacute',\n       'Ecircumflex',\n       'Edieresis',\n       'Egrave',\n       'Iacute',\n       'Icircumflex',\n       'Idieresis',\n       'Igrave',\n       'Ntilde',\n       'Oacute',\n       'Ocircumflex',\n       'Odieresis',\n       'Ograve',\n       'Otilde',\n       'Scaron',\n       'Uacute',\n       'Ucircumflex',\n       'Udieresis',\n       'Ugrave',\n       'Yacute',\n       'Ydieresis',\n       'Zcaron',\n       'aacute',\n       'acircumflex',\n       'adieresis',\n       'agrave',\n       'aring',\n       'atilde',\n       'ccedilla',\n       'eacute',\n       'ecircumflex',\n       'edieresis',\n       'egrave',\n       'iacute',\n       'icircumflex',\n       'idieresis',\n       'igrave',\n       'ntilde',\n       'oacute',\n       'ocircumflex',\n       'odieresis',\n       'ograve',\n       'otilde',\n       'scaron',\n       'uacute',\n       'ucircumflex',\n       'udieresis',\n       'ugrave',\n       'yacute',\n       'ydieresis',\n       'zcaron',\n       'exclamsmall',\n       'Hungarumlautsmall',\n       'dollaroldstyle',\n       'dollarsuperior',\n       'ampersandsmall',\n       'Acutesmall',\n       'parenleftsuperior',\n       'parenrightsuperior',\n       '266 ff',\n       'onedotenleader',\n       'zerooldstyle',\n       'oneoldstyle',\n       'twooldstyle',\n       'threeoldstyle',\n       'fouroldstyle',\n       'fiveoldstyle',\n       'sixoldstyle',\n       'sevenoldstyle',\n       'eightoldstyle',\n       'nineoldstyle',\n       'commasuperior',\n       'threequartersemdash',\n       'periodsuperior',\n       'questionsmall',\n       'asuperior',\n       'bsuperior',\n       'centsuperior',\n       'dsuperior',\n       'esuperior',\n       'isuperior',\n       'lsuperior',\n       'msuperior',\n       'nsuperior',\n       'osuperior',\n       'rsuperior',\n       'ssuperior',\n       'tsuperior',\n       'ff',\n       'ffi',\n       'ffl',\n       'parenleftinferior',\n       'parenrightinferior',\n       'Circumflexsmall',\n       'hyphensuperior',\n       'Gravesmall',\n       'Asmall',\n       'Bsmall',\n       'Csmall',\n       'Dsmall',\n       'Esmall',\n       'Fsmall',\n       'Gsmall',\n       'Hsmall',\n       'Ismall',\n       'Jsmall',\n       'Ksmall',\n       'Lsmall',\n       'Msmall',\n       'Nsmall',\n       'Osmall',\n       'Psmall',\n       'Qsmall',\n       'Rsmall',\n       'Ssmall',\n       'Tsmall',\n       'Usmall',\n       'Vsmall',\n       'Wsmall',\n       'Xsmall',\n       'Ysmall',\n       'Zsmall',\n       'colonmonetary',\n       'onefitted',\n       'rupiah',\n       'Tildesmall',\n       'exclamdownsmall',\n       'centoldstyle',\n       'Lslashsmall',\n       'Scaronsmall',\n       'Zcaronsmall',\n       'Dieresissmall',\n       'Brevesmall',\n       'Caronsmall',\n       'Dotaccentsmall',\n       'Macronsmall',\n       'figuredash',\n       'hypheninferior',\n       'Ogoneksmall',\n       'Ringsmall',\n       'Cedillasmall',\n       'questiondownsmall',\n       'oneeighth',\n       'threeeighths',\n       'fiveeighths',\n       'seveneighths',\n       'onethird',\n       'twothirds',\n       'zerosuperior',\n       'foursuperior',\n       'fivesuperior',\n       'sixsuperior',\n       'sevensuperior',\n       'eightsuperior',\n       'ninesuperior',\n       'zeroinferior',\n       'oneinferior',\n       'twoinferior',\n       'threeinferior',\n       'fourinferior',\n       'fiveinferior',\n       'sixinferior',\n       'seveninferior',\n       'eightinferior',\n       'nineinferior',\n       'centinferior',\n       'dollarinferior',\n       'periodinferior',\n       'commainferior',\n       'Agravesmall',\n       'Aacutesmall',\n       'Acircumflexsmall',\n       'Atildesmall',\n       'Adieresissmall',\n       'Aringsmall',\n       'AEsmall',\n       'Ccedillasmall',\n       'Egravesmall',\n       'Eacutesmall',\n       'Ecircumflexsmall',\n       'Edieresissmall',\n       'Igravesmall',\n       'Iacutesmall',\n       'Icircumflexsmall',\n       'Idieresissmall',\n       'Ethsmall',\n       'Ntildesmall',\n       'Ogravesmall',\n       'Oacutesmall',\n       'Ocircumflexsmall',\n       'Otildesmall',\n       'Odieresissmall',\n       'OEsmall',\n       'Oslashsmall',\n       'Ugravesmall',\n       'Uacutesmall',\n       'Ucircumflexsmall',\n       'Udieresissmall',\n       'Yacutesmall',\n       'Thornsmall',\n       'Ydieresissmall',\n       '001.000',\n       '001.001',\n       '001.002',\n       '001.003',\n       'Black',\n       'Bold',\n       'Book',\n       'Light',\n       'Medium',\n       'Regular',\n       'Roman',\n       'Semibold' ];\n\n   var cffStandardEncoding = [\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       'space',\n       'exclam',\n       'quotedbl',\n       'numbersign',\n       'dollar',\n       'percent',\n       'ampersand',\n       'quoteright',\n       'parenleft',\n       'parenright',\n       'asterisk',\n       'plus',\n       'comma',\n       'hyphen',\n       'period',\n       'slash',\n       'zero',\n       'one',\n       'two',\n       'three',\n       'four',\n       'five',\n       'six',\n       'seven',\n       'eight',\n       'nine',\n       'colon',\n       'semicolon',\n       'less',\n       'equal',\n       'greater',\n       'question',\n       'at',\n       'A',\n       'B',\n       'C',\n       'D',\n       'E',\n       'F',\n       'G',\n       'H',\n       'I',\n       'J',\n       'K',\n       'L',\n       'M',\n       'N',\n       'O',\n       'P',\n       'Q',\n       'R',\n       'S',\n       'T',\n       'U',\n       'V',\n       'W',\n       'X',\n       'Y',\n       'Z',\n       'bracketleft',\n       'backslash',\n       'bracketright',\n       'asciicircum',\n       'underscore',\n       'quoteleft',\n       'a',\n       'b',\n       'c',\n       'd',\n       'e',\n       'f',\n       'g',\n       'h',\n       'i',\n       'j',\n       'k',\n       'l',\n       'm',\n       'n',\n       'o',\n       'p',\n       'q',\n       'r',\n       's',\n       't',\n       'u',\n       'v',\n       'w',\n       'x',\n       'y',\n       'z',\n       'braceleft',\n       'bar',\n       'braceright',\n       'asciitilde',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       'exclamdown',\n       'cent',\n       'sterling',\n       'fraction',\n       'yen',\n       'florin',\n       'section',\n       'currency',\n       'quotesingle',\n       'quotedblleft',\n       'guillemotleft',\n       'guilsinglleft',\n       'guilsinglright',\n       'fi',\n       'fl',\n       '',\n       'endash',\n       'dagger',\n       'daggerdbl',\n       'periodcentered',\n       '',\n       'paragraph',\n       'bullet',\n       'quotesinglbase',\n       'quotedblbase',\n       'quotedblright',\n       'guillemotright',\n       'ellipsis',\n       'perthousand',\n       '',\n       'questiondown',\n       '',\n       'grave',\n       'acute',\n       'circumflex',\n       'tilde',\n       'macron',\n       'breve',\n       'dotaccent',\n       'dieresis',\n       '',\n       'ring',\n       'cedilla',\n       '',\n       'hungarumlaut',\n       'ogonek',\n       'caron',\n       'emdash',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       'AE',\n       '',\n       'ordfeminine',\n       '',\n       '',\n       '',\n       '',\n       'Lslash',\n       'Oslash',\n       'OE',\n       'ordmasculine',\n       '',\n       '',\n       '',\n       '',\n       '',\n       'ae',\n       '',\n       '',\n       '',\n       'dotlessi',\n       '',\n       '',\n       'lslash',\n       'oslash',\n       'oe',\n       'germandbls' ];\n\n   var cffExpertEncoding = [\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       'space',\n       'exclamsmall',\n       'Hungarumlautsmall',\n       '',\n       'dollaroldstyle',\n       'dollarsuperior',\n       'ampersandsmall',\n       'Acutesmall',\n       'parenleftsuperior',\n       'parenrightsuperior',\n       'twodotenleader',\n       'onedotenleader',\n       'comma',\n       'hyphen',\n       'period',\n       'fraction',\n       'zerooldstyle',\n       'oneoldstyle',\n       'twooldstyle',\n       'threeoldstyle',\n       'fouroldstyle',\n       'fiveoldstyle',\n       'sixoldstyle',\n       'sevenoldstyle',\n       'eightoldstyle',\n       'nineoldstyle',\n       'colon',\n       'semicolon',\n       'commasuperior',\n       'threequartersemdash',\n       'periodsuperior',\n       'questionsmall',\n       '',\n       'asuperior',\n       'bsuperior',\n       'centsuperior',\n       'dsuperior',\n       'esuperior',\n       '',\n       '',\n       'isuperior',\n       '',\n       '',\n       'lsuperior',\n       'msuperior',\n       'nsuperior',\n       'osuperior',\n       '',\n       '',\n       'rsuperior',\n       'ssuperior',\n       'tsuperior',\n       '',\n       'ff',\n       'fi',\n       'fl',\n       'ffi',\n       'ffl',\n       'parenleftinferior',\n       '',\n       'parenrightinferior',\n       'Circumflexsmall',\n       'hyphensuperior',\n       'Gravesmall',\n       'Asmall',\n       'Bsmall',\n       'Csmall',\n       'Dsmall',\n       'Esmall',\n       'Fsmall',\n       'Gsmall',\n       'Hsmall',\n       'Ismall',\n       'Jsmall',\n       'Ksmall',\n       'Lsmall',\n       'Msmall',\n       'Nsmall',\n       'Osmall',\n       'Psmall',\n       'Qsmall',\n       'Rsmall',\n       'Ssmall',\n       'Tsmall',\n       'Usmall',\n       'Vsmall',\n       'Wsmall',\n       'Xsmall',\n       'Ysmall',\n       'Zsmall',\n       'colonmonetary',\n       'onefitted',\n       'rupiah',\n       'Tildesmall',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       '',\n       'exclamdownsmall',\n       'centoldstyle',\n       'Lslashsmall',\n       '',\n       '',\n       'Scaronsmall',\n       'Zcaronsmall',\n       'Dieresissmall',\n       'Brevesmall',\n       'Caronsmall',\n       '',\n       'Dotaccentsmall',\n       '',\n       '',\n       'Macronsmall',\n       '',\n       '',\n       'figuredash',\n       'hypheninferior',\n       '',\n       '',\n       'Ogoneksmall',\n       'Ringsmall',\n       'Cedillasmall',\n       '',\n       '',\n       '',\n       'onequarter',\n       'onehalf',\n       'threequarters',\n       'questiondownsmall',\n       'oneeighth',\n       'threeeighths',\n       'fiveeighths',\n       'seveneighths',\n       'onethird',\n       'twothirds',\n       '',\n       '',\n       'zerosuperior',\n       'onesuperior',\n       'twosuperior',\n       'threesuperior',\n       'foursuperior',\n       'fivesuperior',\n       'sixsuperior',\n       'sevensuperior',\n       'eightsuperior',\n       'ninesuperior',\n       'zeroinferior',\n       'oneinferior',\n       'twoinferior',\n       'threeinferior',\n       'fourinferior',\n       'fiveinferior',\n       'sixinferior',\n       'seveninferior',\n       'eightinferior',\n       'nineinferior',\n       'centinferior',\n       'dollarinferior',\n       'periodinferior',\n       'commainferior',\n       'Agravesmall',\n       'Aacutesmall',\n       'Acircumflexsmall',\n       'Atildesmall',\n       'Adieresissmall',\n       'Aringsmall',\n       'AEsmall',\n       'Ccedillasmall',\n       'Egravesmall',\n       'Eacutesmall',\n       'Ecircumflexsmall',\n       'Edieresissmall',\n       'Igravesmall',\n       'Iacutesmall',\n       'Icircumflexsmall',\n       'Idieresissmall',\n       'Ethsmall',\n       'Ntildesmall',\n       'Ogravesmall',\n       'Oacutesmall',\n       'Ocircumflexsmall',\n       'Otildesmall',\n       'Odieresissmall',\n       'OEsmall',\n       'Oslashsmall',\n       'Ugravesmall',\n       'Uacutesmall',\n       'Ucircumflexsmall',\n       'Udieresissmall',\n       'Yacutesmall',\n       'Thornsmall',\n       'Ydieresissmall' ];\n\n   /**\n    * This is the encoding used for fonts created from scratch.\n    * It loops through all glyphs and finds the appropriate unicode value.\n    * Since it's linear time, other encodings will be faster.\n    * @exports opentype.DefaultEncoding\n    * @class\n    * @constructor\n    * @param {opentype.Font}\n    */\n   function DefaultEncoding(font) {\n       this.font = font;\n   }\n\n   DefaultEncoding.prototype.charToGlyphIndex = function (c) {\n       var code = c.codePointAt(0);\n       var glyphs = this.font.glyphs;\n       if (glyphs) {\n           for (var i = 0; i < glyphs.length; i += 1) {\n               var glyph = glyphs.get(i);\n               for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                   if (glyph.unicodes[j] === code) {\n                       return i;\n                   }\n               }\n           }\n       }\n       return null;\n   };\n\n   /**\n    * @exports opentype.CmapEncoding\n    * @class\n    * @constructor\n    * @param {Object} cmap - a object with the cmap encoded data\n    */\n   function CmapEncoding(cmap) {\n       this.cmap = cmap;\n   }\n\n   /**\n    * @param  {string} c - the character\n    * @return {number} The glyph index.\n    */\n   CmapEncoding.prototype.charToGlyphIndex = function (c) {\n       return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n   };\n\n   /**\n    * @exports opentype.CffEncoding\n    * @class\n    * @constructor\n    * @param {string} encoding - The encoding\n    * @param {Array} charset - The character set.\n    */\n   function CffEncoding(encoding, charset) {\n       this.encoding = encoding;\n       this.charset = charset;\n   }\n\n   /**\n    * @param  {string} s - The character\n    * @return {number} The index.\n    */\n   CffEncoding.prototype.charToGlyphIndex = function (s) {\n       var code = s.codePointAt(0);\n       var charName = this.encoding[code];\n       return this.charset.indexOf(charName);\n   };\n\n   function addGlyphNamesAll(font) {\n       var glyph;\n       var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n       var charCodes = Object.keys(glyphIndexMap);\n\n       for (var i = 0; i < charCodes.length; i += 1) {\n           var c = charCodes[i];\n           var glyphIndex = glyphIndexMap[c];\n           glyph = font.glyphs.get(glyphIndex);\n           glyph.addUnicode(parseInt(c));\n       }\n   }\n\n   function addGlyphNamesToUnicodeMap(font) {\n       font._IndexToUnicodeMap = {};\n\n       var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n       var charCodes = Object.keys(glyphIndexMap);\n\n       for (var i = 0; i < charCodes.length; i += 1) {\n           var c = charCodes[i];\n           var glyphIndex = glyphIndexMap[c];\n           if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n               font._IndexToUnicodeMap[glyphIndex] = {\n                   unicodes: [parseInt(c)],\n               };\n           } else {\n               font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n           }\n       }\n   }\n\n   /**\n    * @alias opentype.addGlyphNames\n    * @param {opentype.Font}\n    * @param {Object}\n    */\n   function addGlyphNames(font, opt) {\n       if (opt.lowMemory) {\n           addGlyphNamesToUnicodeMap(font);\n       } else {\n           addGlyphNamesAll(font);\n       }\n   }\n\n   // Run-time checking of preconditions.\n\n   function fail(message) {\n       throw new Error(message);\n   }\n\n   // Precondition function that checks if the given predicate is true.\n   // If not, it will throw an error.\n   function argument(predicate, message) {\n       if (!predicate) {\n           fail(message);\n       }\n   }\n   var check = { fail: fail, argument: argument, assert: argument };\n\n   // The Glyph object\n   // import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\n   function getPathDefinition(glyph, path) {\n       var _path = path || new Path();\n       return {\n           configurable: true,\n\n           get: function () {\n               if (typeof _path === 'function') {\n                   _path = _path();\n               }\n\n               return _path;\n           },\n\n           set: function (p) {\n               _path = p;\n           },\n       };\n   }\n   /**\n    * @typedef GlyphOptions\n    * @type Object\n    * @property {string} [name] - The glyph name\n    * @property {number} [unicode]\n    * @property {Array} [unicodes]\n    * @property {number} [xMin]\n    * @property {number} [yMin]\n    * @property {number} [xMax]\n    * @property {number} [yMax]\n    * @property {number} [advanceWidth]\n    */\n\n   // A Glyph is an individual mark that often corresponds to a character.\n   // Some glyphs, such as ligatures, are a combination of many characters.\n   // Glyphs are the basic building blocks of a font.\n   //\n   // The `Glyph` class contains utility methods for drawing the path and its points.\n   /**\n    * @exports opentype.Glyph\n    * @class\n    * @param {GlyphOptions}\n    * @constructor\n    */\n   function Glyph(options) {\n       // By putting all the code on a prototype function (which is only declared once)\n       // we reduce the memory requirements for larger fonts by some 2%\n       this.bindConstructorValues(options);\n   }\n\n   /**\n    * @param  {GlyphOptions}\n    */\n   Glyph.prototype.bindConstructorValues = function (options) {\n       this.index = options.index || 0;\n\n       // These three values cannot be deferred for memory optimization:\n       this.name = options.name || null;\n       this.unicode = options.unicode || undefined;\n       this.unicodes =\n           options.unicodes || options.unicode !== undefined\n               ? [options.unicode]\n               : [];\n\n       // But by binding these values only when necessary, we reduce can\n       // the memory requirements by almost 3% for larger fonts.\n       if ('xMin' in options) {\n           this.xMin = options.xMin;\n       }\n\n       if ('yMin' in options) {\n           this.yMin = options.yMin;\n       }\n\n       if ('xMax' in options) {\n           this.xMax = options.xMax;\n       }\n\n       if ('yMax' in options) {\n           this.yMax = options.yMax;\n       }\n\n       if ('advanceWidth' in options) {\n           this.advanceWidth = options.advanceWidth;\n       }\n\n       // The path for a glyph is the most memory intensive, and is bound as a value\n       // with a getter/setter to ensure we actually do path parsing only once the\n       // path is actually needed by anything.\n       Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n   };\n\n   /**\n    * @param {number}\n    */\n   Glyph.prototype.addUnicode = function (unicode) {\n       if (this.unicodes.length === 0) {\n           this.unicode = unicode;\n       }\n\n       this.unicodes.push(unicode);\n   };\n\n   // /**\n   //  * Calculate the minimum bounding box for this glyph.\n   //  * @return {opentype.BoundingBox}\n   //  */\n   // Glyph.prototype.getBoundingBox = function() {\n   //     return this.path.getBoundingBox();\n   // };\n\n   /**\n    * Convert the glyph to a Path we can draw on a drawing context.\n    * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n    * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n    * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n    * @param  {Object=} options - xScale, yScale to stretch the glyph.\n    * @param  {opentype.Font} if hinting is to be used, the font\n    * @return {opentype.Path}\n    */\n   Glyph.prototype.getPath = function (x, y, fontSize, options, font) {\n       x = x !== undefined ? x : 0;\n       y = y !== undefined ? y : 0;\n       fontSize = fontSize !== undefined ? fontSize : 72;\n       var commands;\n       var hPoints;\n       if (!options) { options = {}; }\n       var xScale = options.xScale;\n       var yScale = options.yScale;\n\n       if (options.hinting && font && font.hinting) {\n           // in case of hinting, the hinting engine takes care\n           // of scaling the points (not the path) before hinting.\n           hPoints = this.path && font.hinting.exec(this, fontSize);\n           // in case the hinting engine failed hPoints is undefined\n           // and thus reverts to plain rending\n       }\n\n       if (hPoints) {\n           // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n           commands = font.hinting.getCommands(hPoints);\n           x = Math.round(x);\n           y = Math.round(y);\n           // TODO in case of hinting xyScaling is not yet supported\n           xScale = yScale = 1;\n       } else {\n           commands = this.path.commands;\n           var scale = (1 / (this.path.unitsPerEm || 1000)) * fontSize;\n           if (xScale === undefined) { xScale = scale; }\n           if (yScale === undefined) { yScale = scale; }\n       }\n\n       var p = new Path();\n       for (var i = 0; i < commands.length; i += 1) {\n           var cmd = commands[i];\n           if (cmd.type === 'M') {\n               p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n           } else if (cmd.type === 'L') {\n               p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n           } else if (cmd.type === 'Q') {\n               p.quadraticCurveTo(\n                   x + cmd.x1 * xScale,\n                   y + -cmd.y1 * yScale,\n                   x + cmd.x * xScale,\n                   y + -cmd.y * yScale\n               );\n           } else if (cmd.type === 'C') {\n               p.curveTo(\n                   x + cmd.x1 * xScale,\n                   y + -cmd.y1 * yScale,\n                   x + cmd.x2 * xScale,\n                   y + -cmd.y2 * yScale,\n                   x + cmd.x * xScale,\n                   y + -cmd.y * yScale\n               );\n           } else if (cmd.type === 'Z') {\n               p.closePath();\n           }\n       }\n\n       return p;\n   };\n\n   /**\n    * Split the glyph into contours.\n    * This function is here for backwards compatibility, and to\n    * provide raw access to the TrueType glyph outlines.\n    * @return {Array}\n    */\n   Glyph.prototype.getContours = function () {\n       if (this.points === undefined) {\n           return [];\n       }\n\n       var contours = [];\n       var currentContour = [];\n       for (var i = 0; i < this.points.length; i += 1) {\n           var pt = this.points[i];\n           currentContour.push(pt);\n           if (pt.lastPointOfContour) {\n               contours.push(currentContour);\n               currentContour = [];\n           }\n       }\n\n       check.argument(\n           currentContour.length === 0,\n           'There are still points left in the current contour.'\n       );\n       return contours;\n   };\n\n   /**\n    * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n    * @return {Object}\n    */\n   Glyph.prototype.getMetrics = function () {\n       var commands = this.path.commands;\n       var xCoords = [];\n       var yCoords = [];\n       for (var i = 0; i < commands.length; i += 1) {\n           var cmd = commands[i];\n           if (cmd.type !== 'Z') {\n               xCoords.push(cmd.x);\n               yCoords.push(cmd.y);\n           }\n\n           if (cmd.type === 'Q' || cmd.type === 'C') {\n               xCoords.push(cmd.x1);\n               yCoords.push(cmd.y1);\n           }\n\n           if (cmd.type === 'C') {\n               xCoords.push(cmd.x2);\n               yCoords.push(cmd.y2);\n           }\n       }\n\n       var metrics = {\n           xMin: Math.min.apply(null, xCoords),\n           yMin: Math.min.apply(null, yCoords),\n           xMax: Math.max.apply(null, xCoords),\n           yMax: Math.max.apply(null, yCoords),\n           leftSideBearing: this.leftSideBearing,\n       };\n\n       if (!isFinite(metrics.xMin)) {\n           metrics.xMin = 0;\n       }\n\n       if (!isFinite(metrics.xMax)) {\n           metrics.xMax = this.advanceWidth;\n       }\n\n       if (!isFinite(metrics.yMin)) {\n           metrics.yMin = 0;\n       }\n\n       if (!isFinite(metrics.yMax)) {\n           metrics.yMax = 0;\n       }\n\n       metrics.rightSideBearing =\n           this.advanceWidth -\n           metrics.leftSideBearing -\n           (metrics.xMax - metrics.xMin);\n       return metrics;\n   };\n\n   // The GlyphSet object\n\n   // Define a property on the glyph that depends on the path being loaded.\n   function defineDependentProperty(glyph, externalName, internalName) {\n       Object.defineProperty(glyph, externalName, {\n           get: function () {\n               // Request the path property to make sure the path is loaded.\n               glyph.path; // jshint ignore:line\n               return glyph[internalName];\n           },\n           set: function (newValue) {\n               glyph[internalName] = newValue;\n           },\n           enumerable: true,\n           configurable: true,\n       });\n   }\n\n   /**\n    * A GlyphSet represents all glyphs available in the font, but modelled using\n    * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n    * necessary, to keep the memory footprint down.\n    * @exports opentype.GlyphSet\n    * @class\n    * @param {opentype.Font}\n    * @param {Array}\n    */\n   function GlyphSet(font, glyphs) {\n       this.font = font;\n       this.glyphs = {};\n       if (Array.isArray(glyphs)) {\n           for (var i = 0; i < glyphs.length; i++) {\n               var glyph = glyphs[i];\n               glyph.path.unitsPerEm = font.unitsPerEm;\n               this.glyphs[i] = glyph;\n           }\n       }\n\n       this.length = (glyphs && glyphs.length) || 0;\n   }\n\n   /**\n    * @param  {number} index\n    * @return {opentype.Glyph}\n    */\n   GlyphSet.prototype.get = function (index) {\n       // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n       if (this.glyphs[index] === undefined) {\n           this.font._push(index);\n           if (typeof this.glyphs[index] === 'function') {\n               this.glyphs[index] = this.glyphs[index]();\n           }\n\n           var glyph = this.glyphs[index];\n           var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n           if (unicodeObj) {\n               for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                   { glyph.addUnicode(unicodeObj.unicodes[j]); }\n           }\n\n           this.glyphs[index].advanceWidth =\n               this.font._hmtxTableData[index].advanceWidth;\n           this.glyphs[index].leftSideBearing =\n               this.font._hmtxTableData[index].leftSideBearing;\n       } else {\n           if (typeof this.glyphs[index] === 'function') {\n               this.glyphs[index] = this.glyphs[index]();\n           }\n       }\n\n       return this.glyphs[index];\n   };\n\n   /**\n    * @param  {number} index\n    * @param  {Object}\n    */\n   GlyphSet.prototype.push = function (index, loader) {\n       this.glyphs[index] = loader;\n       this.length++;\n   };\n\n   /**\n    * @alias opentype.glyphLoader\n    * @param  {opentype.Font} font\n    * @param  {number} index\n    * @return {opentype.Glyph}\n    */\n   function glyphLoader(font, index) {\n       return new Glyph({ index: index, font: font });\n   }\n\n   /**\n    * Generate a stub glyph that can be filled with all metadata *except*\n    * the \"points\" and \"path\" properties, which must be loaded only once\n    * the glyph's path is actually requested for text shaping.\n    * @alias opentype.ttfGlyphLoader\n    * @param  {opentype.Font} font\n    * @param  {number} index\n    * @param  {Function} parseGlyph\n    * @param  {Object} data\n    * @param  {number} position\n    * @param  {Function} buildPath\n    * @return {opentype.Glyph}\n    */\n   function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n       return function () {\n           var glyph = new Glyph({ index: index, font: font });\n\n           glyph.path = function () {\n               parseGlyph(glyph, data, position);\n               var path = buildPath(font.glyphs, glyph);\n               path.unitsPerEm = font.unitsPerEm;\n               return path;\n           };\n\n           defineDependentProperty(glyph, 'xMin', '_xMin');\n           defineDependentProperty(glyph, 'xMax', '_xMax');\n           defineDependentProperty(glyph, 'yMin', '_yMin');\n           defineDependentProperty(glyph, 'yMax', '_yMax');\n\n           return glyph;\n       };\n   }\n   /**\n    * @alias opentype.cffGlyphLoader\n    * @param  {opentype.Font} font\n    * @param  {number} index\n    * @param  {Function} parseCFFCharstring\n    * @param  {string} charstring\n    * @return {opentype.Glyph}\n    */\n   function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n       return function () {\n           var glyph = new Glyph({ index: index, font: font });\n\n           glyph.path = function () {\n               var path = parseCFFCharstring(font, glyph, charstring);\n               path.unitsPerEm = font.unitsPerEm;\n               return path;\n           };\n\n           return glyph;\n       };\n   }\n\n   var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n   // The Layout object is the prototype of Substitution objects, and provides\n\n   function searchTag(arr, tag) {\n       /* jshint bitwise: false */\n       var imin = 0;\n       var imax = arr.length - 1;\n       while (imin <= imax) {\n           var imid = (imin + imax) >>> 1;\n           var val = arr[imid].tag;\n           if (val === tag) {\n               return imid;\n           } else if (val < tag) {\n               imin = imid + 1;\n           } else {\n               imax = imid - 1;\n           }\n       }\n       // Not found: return -1-insertion point\n       return -imin - 1;\n   }\n\n   function binSearch(arr, value) {\n       /* jshint bitwise: false */\n       var imin = 0;\n       var imax = arr.length - 1;\n       while (imin <= imax) {\n           var imid = (imin + imax) >>> 1;\n           var val = arr[imid];\n           if (val === value) {\n               return imid;\n           } else if (val < value) {\n               imin = imid + 1;\n           } else {\n               imax = imid - 1;\n           }\n       }\n       // Not found: return -1-insertion point\n       return -imin - 1;\n   }\n\n   // binary search in a list of ranges (coverage, class definition)\n   function searchRange(ranges, value) {\n       // jshint bitwise: false\n       var range;\n       var imin = 0;\n       var imax = ranges.length - 1;\n       while (imin <= imax) {\n           var imid = (imin + imax) >>> 1;\n           range = ranges[imid];\n           var start = range.start;\n           if (start === value) {\n               return range;\n           } else if (start < value) {\n               imin = imid + 1;\n           } else {\n               imax = imid - 1;\n           }\n       }\n       if (imin > 0) {\n           range = ranges[imin - 1];\n           if (value > range.end) { return 0; }\n           return range;\n       }\n   }\n\n   /**\n    * @exports opentype.Layout\n    * @class\n    */\n   function Layout(font, tableName) {\n       this.font = font;\n       this.tableName = tableName;\n   }\n\n   Layout.prototype = {\n       /**\n        * Binary search an object by \"tag\" property\n        * @instance\n        * @function searchTag\n        * @memberof opentype.Layout\n        * @param  {Array} arr\n        * @param  {string} tag\n        * @return {number}\n        */\n       searchTag: searchTag,\n\n       /**\n        * Binary search in a list of numbers\n        * @instance\n        * @function binSearch\n        * @memberof opentype.Layout\n        * @param  {Array} arr\n        * @param  {number} value\n        * @return {number}\n        */\n       binSearch: binSearch,\n\n       /**\n        * Get or create the Layout table (GSUB, GPOS etc).\n        * @param  {boolean} create - Whether to create a new one.\n        * @return {Object} The GSUB or GPOS table.\n        */\n       getTable: function (create) {\n           var layout = this.font.tables[this.tableName];\n           if (!layout && create) {\n               layout = this.font.tables[this.tableName] =\n                   this.createDefaultTable();\n           }\n           return layout;\n       },\n\n       /**\n        * Returns the best bet for a script name.\n        * Returns 'DFLT' if it exists.\n        * If not, returns 'latn' if it exists.\n        * If neither exist, returns undefined.\n        */\n       getDefaultScriptName: function () {\n           var layout = this.getTable();\n           if (!layout) {\n               return;\n           }\n           var hasLatn = false;\n           for (var i = 0; i < layout.scripts.length; i++) {\n               var name = layout.scripts[i].tag;\n               if (name === 'DFLT') { return name; }\n               if (name === 'latn') { hasLatn = true; }\n           }\n           if (hasLatn) { return 'latn'; }\n       },\n\n       /**\n        * Returns all LangSysRecords in the given script.\n        * @instance\n        * @param {string} [script='DFLT']\n        * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n        * @return {Object} An object with tag and script properties.\n        */\n       getScriptTable: function (script, create) {\n           var layout = this.getTable(create);\n           if (layout) {\n               script = script || 'DFLT';\n               var scripts = layout.scripts;\n               var pos = searchTag(layout.scripts, script);\n               if (pos >= 0) {\n                   return scripts[pos].script;\n               } else if (create) {\n                   var scr = {\n                       tag: script,\n                       script: {\n                           defaultLangSys: {\n                               reserved: 0,\n                               reqFeatureIndex: 0xffff,\n                               featureIndexes: [],\n                           },\n                           langSysRecords: [],\n                       },\n                   };\n                   scripts.splice(-1 - pos, 0, scr);\n                   return scr.script;\n               }\n           }\n       },\n\n       /**\n        * Returns a language system table\n        * @instance\n        * @param {string} [script='DFLT']\n        * @param {string} [language='dlft']\n        * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n        * @return {Object}\n        */\n       getLangSysTable: function (script, language, create) {\n           var scriptTable = this.getScriptTable(script, create);\n           if (scriptTable) {\n               if (!language || language === 'dflt' || language === 'DFLT') {\n                   return scriptTable.defaultLangSys;\n               }\n               var pos = searchTag(scriptTable.langSysRecords, language);\n               if (pos >= 0) {\n                   return scriptTable.langSysRecords[pos].langSys;\n               } else if (create) {\n                   var langSysRecord = {\n                       tag: language,\n                       langSys: {\n                           reserved: 0,\n                           reqFeatureIndex: 0xffff,\n                           featureIndexes: [],\n                       },\n                   };\n                   scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                   return langSysRecord.langSys;\n               }\n           }\n       },\n\n       /**\n        * Get a specific feature table.\n        * @instance\n        * @param {string} [script='DFLT']\n        * @param {string} [language='dlft']\n        * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n        * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n        * @return {Object}\n        */\n       getFeatureTable: function (script, language, feature, create) {\n           var langSysTable = this.getLangSysTable(script, language, create);\n           if (langSysTable) {\n               var featureRecord;\n               var featIndexes = langSysTable.featureIndexes;\n               var allFeatures = this.font.tables[this.tableName].features;\n               // The FeatureIndex array of indices is in arbitrary order,\n               // even if allFeatures is sorted alphabetically by feature tag.\n               for (var i = 0; i < featIndexes.length; i++) {\n                   featureRecord = allFeatures[featIndexes[i]];\n                   if (featureRecord.tag === feature) {\n                       return featureRecord.feature;\n                   }\n               }\n               if (create) {\n                   var index = allFeatures.length;\n                   // Automatic ordering of features would require to shift feature indexes in the script list.\n                   check.assert(\n                       index === 0 || feature >= allFeatures[index - 1].tag,\n                       'Features must be added in alphabetical order.'\n                   );\n                   featureRecord = {\n                       tag: feature,\n                       feature: { params: 0, lookupListIndexes: [] },\n                   };\n                   allFeatures.push(featureRecord);\n                   featIndexes.push(index);\n                   return featureRecord.feature;\n               }\n           }\n       },\n\n       /**\n        * Get the lookup tables of a given type for a script/language/feature.\n        * @instance\n        * @param {string} [script='DFLT']\n        * @param {string} [language='dlft']\n        * @param {string} feature - 4-letter feature code\n        * @param {number} lookupType - 1 to 9\n        * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n        * @return {Object[]}\n        */\n       getLookupTables: function (script, language, feature, lookupType, create) {\n           var featureTable = this.getFeatureTable(\n               script,\n               language,\n               feature,\n               create\n           );\n           var tables = [];\n           if (featureTable) {\n               var lookupTable;\n               var lookupListIndexes = featureTable.lookupListIndexes;\n               var allLookups = this.font.tables[this.tableName].lookups;\n               // lookupListIndexes are in no particular order, so use naive search.\n               for (var i = 0; i < lookupListIndexes.length; i++) {\n                   lookupTable = allLookups[lookupListIndexes[i]];\n                   if (lookupTable.lookupType === lookupType) {\n                       tables.push(lookupTable);\n                   }\n               }\n               if (tables.length === 0 && create) {\n                   lookupTable = {\n                       lookupType: lookupType,\n                       lookupFlag: 0,\n                       subtables: [],\n                       markFilteringSet: undefined,\n                   };\n                   var index = allLookups.length;\n                   allLookups.push(lookupTable);\n                   lookupListIndexes.push(index);\n                   return [lookupTable];\n               }\n           }\n           return tables;\n       },\n\n       /**\n        * Find a glyph in a class definition table\n        * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n        * @param {object} classDefTable - an OpenType Layout class definition table\n        * @param {number} glyphIndex - the index of the glyph to find\n        * @returns {number} -1 if not found\n        */\n       getGlyphClass: function (classDefTable, glyphIndex) {\n           switch (classDefTable.format) {\n               case 1:\n                   if (\n                       classDefTable.startGlyph <= glyphIndex &&\n                       glyphIndex <\n                           classDefTable.startGlyph + classDefTable.classes.length\n                   ) {\n                       return classDefTable.classes[\n                           glyphIndex - classDefTable.startGlyph\n                       ];\n                   }\n                   return 0;\n               case 2:\n                   var range = searchRange(classDefTable.ranges, glyphIndex);\n                   return range ? range.classId : 0;\n           }\n       },\n\n       /**\n        * Find a glyph in a coverage table\n        * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n        * @param {object} coverageTable - an OpenType Layout coverage table\n        * @param {number} glyphIndex - the index of the glyph to find\n        * @returns {number} -1 if not found\n        */\n       getCoverageIndex: function (coverageTable, glyphIndex) {\n           switch (coverageTable.format) {\n               case 1:\n                   var index = binSearch(coverageTable.glyphs, glyphIndex);\n                   return index >= 0 ? index : -1;\n               case 2:\n                   var range = searchRange(coverageTable.ranges, glyphIndex);\n                   return range ? range.index + glyphIndex - range.start : -1;\n           }\n       },\n\n       /**\n        * Returns the list of glyph indexes of a coverage table.\n        * Format 1: the list is stored raw\n        * Format 2: compact list as range records.\n        * @instance\n        * @param  {Object} coverageTable\n        * @return {Array}\n        */\n       expandCoverage: function (coverageTable) {\n           if (coverageTable.format === 1) {\n               return coverageTable.glyphs;\n           } else {\n               var glyphs = [];\n               var ranges = coverageTable.ranges;\n               for (var i = 0; i < ranges.length; i++) {\n                   var range = ranges[i];\n                   var start = range.start;\n                   var end = range.end;\n                   for (var j = start; j <= end; j++) {\n                       glyphs.push(j);\n                   }\n               }\n               return glyphs;\n           }\n       },\n   };\n\n   // The Position object provides utility methods to manipulate\n\n   /**\n    * @exports opentype.Position\n    * @class\n    * @extends opentype.Layout\n    * @param {opentype.Font}\n    * @constructor\n    */\n   function Position(font) {\n       Layout.call(this, font, 'gpos');\n   }\n\n   Position.prototype = Layout.prototype;\n\n   /**\n    * Init some data for faster and easier access later.\n    */\n   Position.prototype.init = function() {\n       var script = this.getDefaultScriptName();\n       this.defaultKerningTables = this.getKerningTables(script);\n   };\n\n   /**\n    * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n    *\n    * @param {integer} leftIndex - left glyph index\n    * @param {integer} rightIndex - right glyph index\n    * @returns {integer}\n    */\n   Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n       for (var i = 0; i < kerningLookups.length; i++) {\n           var subtables = kerningLookups[i].subtables;\n           for (var j = 0; j < subtables.length; j++) {\n               var subtable = subtables[j];\n               var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n               if (covIndex < 0) { continue; }\n               switch (subtable.posFormat) {\n                   case 1:\n                       // Search Pair Adjustment Positioning Format 1\n                       var pairSet = subtable.pairSets[covIndex];\n                       for (var k = 0; k < pairSet.length; k++) {\n                           var pair = pairSet[k];\n                           if (pair.secondGlyph === rightIndex) {\n                               return pair.value1 && pair.value1.xAdvance || 0;\n                           }\n                       }\n                       break;      // left glyph found, not right glyph - try next subtable\n                   case 2:\n                       // Search Pair Adjustment Positioning Format 2\n                       var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                       var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                       var pair$1 = subtable.classRecords[class1][class2];\n                       return pair$1.value1 && pair$1.value1.xAdvance || 0;\n               }\n           }\n       }\n       return 0;\n   };\n\n   /**\n    * List all kerning lookup tables.\n    *\n    * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n    * @param {string} [language='dflt']\n    * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n    */\n   Position.prototype.getKerningTables = function(script, language) {\n       if (this.font.tables.gpos) {\n           return this.getLookupTables(script, language, 'kern', 2);\n       }\n   };\n\n   // The Substitution object provides utility methods to manipulate\n\n   /**\n    * @exports opentype.Substitution\n    * @class\n    * @extends opentype.Layout\n    * @param {opentype.Font}\n    * @constructor\n    */\n   function Substitution(font) {\n       Layout.call(this, font, 'gsub');\n   }\n\n   // Check if 2 arrays of primitives are equal.\n   function arraysEqual(ar1, ar2) {\n       var n = ar1.length;\n       if (n !== ar2.length) {\n           return false;\n       }\n       for (var i = 0; i < n; i++) {\n           if (ar1[i] !== ar2[i]) {\n               return false;\n           }\n       }\n       return true;\n   }\n\n   // Find the first subtable of a lookup table in a particular format.\n   function getSubstFormat(lookupTable, format, defaultSubtable) {\n       var subtables = lookupTable.subtables;\n       for (var i = 0; i < subtables.length; i++) {\n           var subtable = subtables[i];\n           if (subtable.substFormat === format) {\n               return subtable;\n           }\n       }\n       if (defaultSubtable) {\n           subtables.push(defaultSubtable);\n           return defaultSubtable;\n       }\n       return undefined;\n   }\n\n   Substitution.prototype = Layout.prototype;\n\n   /**\n    * Create a default GSUB table.\n    * @return {Object} gsub - The GSUB table.\n    */\n   Substitution.prototype.createDefaultTable = function () {\n       // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n       return {\n           version: 1,\n           scripts: [\n               {\n                   tag: 'DFLT',\n                   script: {\n                       defaultLangSys: {\n                           reserved: 0,\n                           reqFeatureIndex: 0xffff,\n                           featureIndexes: [],\n                       },\n                       langSysRecords: [],\n                   },\n               } ],\n           features: [],\n           lookups: [],\n       };\n   };\n\n   /**\n    * List all single substitutions (lookup type 1) for a given script, language, and feature.\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n    * @return {Array} substitutions - The list of substitutions.\n    */\n   Substitution.prototype.getSingle = function (feature, script, language) {\n       var substitutions = [];\n       var lookupTables = this.getLookupTables(script, language, feature, 1);\n       for (var idx = 0; idx < lookupTables.length; idx++) {\n           var subtables = lookupTables[idx].subtables;\n           for (var i = 0; i < subtables.length; i++) {\n               var subtable = subtables[i];\n               var glyphs = this.expandCoverage(subtable.coverage);\n               var j = (void 0);\n               if (subtable.substFormat === 1) {\n                   var delta = subtable.deltaGlyphId;\n                   for (j = 0; j < glyphs.length; j++) {\n                       var glyph = glyphs[j];\n                       substitutions.push({ sub: glyph, by: glyph + delta });\n                   }\n               } else {\n                   var substitute = subtable.substitute;\n                   for (j = 0; j < glyphs.length; j++) {\n                       substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                   }\n               }\n           }\n       }\n       return substitutions;\n   };\n\n   /**\n    * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n    * @return {Array} substitutions - The list of substitutions.\n    */\n   Substitution.prototype.getMultiple = function (feature, script, language) {\n       var substitutions = [];\n       var lookupTables = this.getLookupTables(script, language, feature, 2);\n       for (var idx = 0; idx < lookupTables.length; idx++) {\n           var subtables = lookupTables[idx].subtables;\n           for (var i = 0; i < subtables.length; i++) {\n               var subtable = subtables[i];\n               var glyphs = this.expandCoverage(subtable.coverage);\n               var j = (void 0);\n\n               for (j = 0; j < glyphs.length; j++) {\n                   var glyph = glyphs[j];\n                   var replacements = subtable.sequences[j];\n                   substitutions.push({ sub: glyph, by: replacements });\n               }\n           }\n       }\n       return substitutions;\n   };\n\n   /**\n    * List all alternates (lookup type 3) for a given script, language, and feature.\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n    * @return {Array} alternates - The list of alternates\n    */\n   Substitution.prototype.getAlternates = function (feature, script, language) {\n       var alternates = [];\n       var lookupTables = this.getLookupTables(script, language, feature, 3);\n       for (var idx = 0; idx < lookupTables.length; idx++) {\n           var subtables = lookupTables[idx].subtables;\n           for (var i = 0; i < subtables.length; i++) {\n               var subtable = subtables[i];\n               var glyphs = this.expandCoverage(subtable.coverage);\n               var alternateSets = subtable.alternateSets;\n               for (var j = 0; j < glyphs.length; j++) {\n                   alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n               }\n           }\n       }\n       return alternates;\n   };\n\n   /**\n    * List all ligatures (lookup type 4) for a given script, language, and feature.\n    * The result is an array of ligature objects like { sub: [ids], by: id }\n    * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    * @return {Array} ligatures - The list of ligatures.\n    */\n   Substitution.prototype.getLigatures = function (feature, script, language) {\n       var ligatures = [];\n       var lookupTables = this.getLookupTables(script, language, feature, 4);\n       for (var idx = 0; idx < lookupTables.length; idx++) {\n           var subtables = lookupTables[idx].subtables;\n           for (var i = 0; i < subtables.length; i++) {\n               var subtable = subtables[i];\n               var glyphs = this.expandCoverage(subtable.coverage);\n               var ligatureSets = subtable.ligatureSets;\n               for (var j = 0; j < glyphs.length; j++) {\n                   var startGlyph = glyphs[j];\n                   var ligSet = ligatureSets[j];\n                   for (var k = 0; k < ligSet.length; k++) {\n                       var lig = ligSet[k];\n                       ligatures.push({\n                           sub: [startGlyph].concat(lig.components),\n                           by: lig.ligGlyph,\n                       });\n                   }\n               }\n           }\n       }\n       return ligatures;\n   };\n\n   /**\n    * Add or modify a single substitution (lookup type 1)\n    * Format 2, more flexible, is always used.\n    * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n    * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    */\n   Substitution.prototype.addSingle = function (\n       feature,\n       substitution,\n       script,\n       language\n   ) {\n       var lookupTable = this.getLookupTables(\n           script,\n           language,\n           feature,\n           1,\n           true\n       )[0];\n       var subtable = getSubstFormat(lookupTable, 2, {\n           // lookup type 1 subtable, format 2, coverage format 1\n           substFormat: 2,\n           coverage: { format: 1, glyphs: [] },\n           substitute: [],\n       });\n       check.assert(\n           subtable.coverage.format === 1,\n           'Single: unable to modify coverage table format ' +\n               subtable.coverage.format\n       );\n       var coverageGlyph = substitution.sub;\n       var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n       if (pos < 0) {\n           pos = -1 - pos;\n           subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n           subtable.substitute.splice(pos, 0, 0);\n       }\n       subtable.substitute[pos] = substitution.by;\n   };\n\n   /**\n    * Add or modify a multiple substitution (lookup type 2)\n    * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n    * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    */\n   Substitution.prototype.addMultiple = function (\n       feature,\n       substitution,\n       script,\n       language\n   ) {\n       check.assert(\n           substitution.by instanceof Array && substitution.by.length > 1,\n           'Multiple: \"by\" must be an array of two or more ids'\n       );\n       var lookupTable = this.getLookupTables(\n           script,\n           language,\n           feature,\n           2,\n           true\n       )[0];\n       var subtable = getSubstFormat(lookupTable, 1, {\n           // lookup type 2 subtable, format 1, coverage format 1\n           substFormat: 1,\n           coverage: { format: 1, glyphs: [] },\n           sequences: [],\n       });\n       check.assert(\n           subtable.coverage.format === 1,\n           'Multiple: unable to modify coverage table format ' +\n               subtable.coverage.format\n       );\n       var coverageGlyph = substitution.sub;\n       var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n       if (pos < 0) {\n           pos = -1 - pos;\n           subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n           subtable.sequences.splice(pos, 0, 0);\n       }\n       subtable.sequences[pos] = substitution.by;\n   };\n\n   /**\n    * Add or modify an alternate substitution (lookup type 3)\n    * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n    * @param {Object} substitution - { sub: id, by: [ids] }\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    */\n   Substitution.prototype.addAlternate = function (\n       feature,\n       substitution,\n       script,\n       language\n   ) {\n       var lookupTable = this.getLookupTables(\n           script,\n           language,\n           feature,\n           3,\n           true\n       )[0];\n       var subtable = getSubstFormat(lookupTable, 1, {\n           // lookup type 3 subtable, format 1, coverage format 1\n           substFormat: 1,\n           coverage: { format: 1, glyphs: [] },\n           alternateSets: [],\n       });\n       check.assert(\n           subtable.coverage.format === 1,\n           'Alternate: unable to modify coverage table format ' +\n               subtable.coverage.format\n       );\n       var coverageGlyph = substitution.sub;\n       var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n       if (pos < 0) {\n           pos = -1 - pos;\n           subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n           subtable.alternateSets.splice(pos, 0, 0);\n       }\n       subtable.alternateSets[pos] = substitution.by;\n   };\n\n   /**\n    * Add a ligature (lookup type 4)\n    * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n    * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n    * @param {Object} ligature - { sub: [ids], by: id }\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    */\n   Substitution.prototype.addLigature = function (\n       feature,\n       ligature,\n       script,\n       language\n   ) {\n       var lookupTable = this.getLookupTables(\n           script,\n           language,\n           feature,\n           4,\n           true\n       )[0];\n       var subtable = lookupTable.subtables[0];\n       if (!subtable) {\n           subtable = {\n               // lookup type 4 subtable, format 1, coverage format 1\n               substFormat: 1,\n               coverage: { format: 1, glyphs: [] },\n               ligatureSets: [],\n           };\n           lookupTable.subtables[0] = subtable;\n       }\n       check.assert(\n           subtable.coverage.format === 1,\n           'Ligature: unable to modify coverage table format ' +\n               subtable.coverage.format\n       );\n       var coverageGlyph = ligature.sub[0];\n       var ligComponents = ligature.sub.slice(1);\n       var ligatureTable = {\n           ligGlyph: ligature.by,\n           components: ligComponents,\n       };\n       var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n       if (pos >= 0) {\n           // ligatureSet already exists\n           var ligatureSet = subtable.ligatureSets[pos];\n           for (var i = 0; i < ligatureSet.length; i++) {\n               // If ligature already exists, return.\n               if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                   return;\n               }\n           }\n           // ligature does not exist: add it.\n           ligatureSet.push(ligatureTable);\n       } else {\n           // Create a new ligatureSet and add coverage for the first glyph.\n           pos = -1 - pos;\n           subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n           subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n       }\n   };\n\n   /**\n    * List all feature data for a given script and language.\n    * @param {string} feature - 4-letter feature name\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    * @return {Array} substitutions - The list of substitutions.\n    */\n   Substitution.prototype.getFeature = function (feature, script, language) {\n       if (/ss\\d\\d/.test(feature)) {\n           // ss01 - ss20\n           return this.getSingle(feature, script, language);\n       }\n       switch (feature) {\n           case 'aalt':\n           case 'salt':\n               return this.getSingle(feature, script, language).concat(\n                   this.getAlternates(feature, script, language)\n               );\n           case 'dlig':\n           case 'liga':\n           case 'rlig':\n               return this.getLigatures(feature, script, language);\n           case 'ccmp':\n               return this.getMultiple(feature, script, language).concat(\n                   this.getLigatures(feature, script, language)\n               );\n           case 'stch':\n               return this.getMultiple(feature, script, language);\n       }\n       return undefined;\n   };\n\n   /**\n    * Add a substitution to a feature for a given script and language.\n    * @param {string} feature - 4-letter feature name\n    * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n    * @param {string} [script='DFLT']\n    * @param {string} [language='dflt']\n    */\n   Substitution.prototype.add = function (feature, sub, script, language) {\n       if (/ss\\d\\d/.test(feature)) {\n           // ss01 - ss20\n           return this.addSingle(feature, sub, script, language);\n       }\n       switch (feature) {\n           case 'aalt':\n           case 'salt':\n               if (typeof sub.by === 'number') {\n                   return this.addSingle(feature, sub, script, language);\n               }\n               return this.addAlternate(feature, sub, script, language);\n           case 'dlig':\n           case 'liga':\n           case 'rlig':\n               return this.addLigature(feature, sub, script, language);\n           case 'ccmp':\n               if (sub.by instanceof Array) {\n                   return this.addMultiple(feature, sub, script, language);\n               }\n               return this.addLigature(feature, sub, script, language);\n       }\n       return undefined;\n   };\n\n   function checkArgument(expression, message) {\n       if (!expression) {\n           throw message;\n       }\n   }\n\n   // Parsing utility functions\n\n   // Retrieve an unsigned byte from the DataView.\n   function getByte(dataView, offset) {\n       return dataView.getUint8(offset);\n   }\n\n   // Retrieve an unsigned 16-bit short from the DataView.\n   // The value is stored in big endian.\n   function getUShort(dataView, offset) {\n       return dataView.getUint16(offset, false);\n   }\n\n   // Retrieve a signed 16-bit short from the DataView.\n   // The value is stored in big endian.\n   function getShort(dataView, offset) {\n       return dataView.getInt16(offset, false);\n   }\n\n   // Retrieve an unsigned 32-bit long from the DataView.\n   // The value is stored in big endian.\n   function getULong(dataView, offset) {\n       return dataView.getUint32(offset, false);\n   }\n\n   // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n   // The value is stored in big endian.\n   function getFixed(dataView, offset) {\n       var decimal = dataView.getInt16(offset, false);\n       var fraction = dataView.getUint16(offset + 2, false);\n       return decimal + fraction / 65535;\n   }\n\n   // Retrieve a 4-character tag from the DataView.\n   // Tags are used to identify tables.\n   function getTag(dataView, offset) {\n       var tag = '';\n       for (var i = offset; i < offset + 4; i += 1) {\n           tag += String.fromCharCode(dataView.getInt8(i));\n       }\n\n       return tag;\n   }\n\n   // Retrieve an offset from the DataView.\n   // Offsets are 1 to 4 bytes in length, depending on the offSize argument.\n   function getOffset(dataView, offset, offSize) {\n       var v = 0;\n       for (var i = 0; i < offSize; i += 1) {\n           v <<= 8;\n           v += dataView.getUint8(offset + i);\n       }\n\n       return v;\n   }\n\n   // Retrieve a number of bytes from start offset to the end offset from the DataView.\n   function getBytes(dataView, startOffset, endOffset) {\n       var bytes = [];\n       for (var i = startOffset; i < endOffset; i += 1) {\n           bytes.push(dataView.getUint8(i));\n       }\n\n       return bytes;\n   }\n\n   // Convert the list of bytes to a string.\n   function bytesToString(bytes) {\n       var s = '';\n       for (var i = 0; i < bytes.length; i += 1) {\n           s += String.fromCharCode(bytes[i]);\n       }\n\n       return s;\n   }\n\n   var typeOffsets = {\n       byte: 1,\n       uShort: 2,\n       short: 2,\n       uLong: 4,\n       fixed: 4,\n       longDateTime: 8,\n       tag: 4\n   };\n\n   // A stateful parser that changes the offset whenever a value is retrieved.\n   // The data is a DataView.\n   function Parser(data, offset) {\n       this.data = data;\n       this.offset = offset;\n       this.relativeOffset = 0;\n   }\n\n   Parser.prototype.parseByte = function() {\n       var v = this.data.getUint8(this.offset + this.relativeOffset);\n       this.relativeOffset += 1;\n       return v;\n   };\n\n   Parser.prototype.parseChar = function() {\n       var v = this.data.getInt8(this.offset + this.relativeOffset);\n       this.relativeOffset += 1;\n       return v;\n   };\n\n   Parser.prototype.parseCard8 = Parser.prototype.parseByte;\n\n   Parser.prototype.parseUShort = function() {\n       var v = this.data.getUint16(this.offset + this.relativeOffset);\n       this.relativeOffset += 2;\n       return v;\n   };\n\n   Parser.prototype.parseCard16 = Parser.prototype.parseUShort;\n   Parser.prototype.parseSID = Parser.prototype.parseUShort;\n   Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\n   Parser.prototype.parseShort = function() {\n       var v = this.data.getInt16(this.offset + this.relativeOffset);\n       this.relativeOffset += 2;\n       return v;\n   };\n\n   Parser.prototype.parseF2Dot14 = function() {\n       var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n       this.relativeOffset += 2;\n       return v;\n   };\n\n   Parser.prototype.parseULong = function() {\n       var v = getULong(this.data, this.offset + this.relativeOffset);\n       this.relativeOffset += 4;\n       return v;\n   };\n\n   Parser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\n   Parser.prototype.parseFixed = function() {\n       var v = getFixed(this.data, this.offset + this.relativeOffset);\n       this.relativeOffset += 4;\n       return v;\n   };\n\n   Parser.prototype.parseString = function(length) {\n       var dataView = this.data;\n       var offset = this.offset + this.relativeOffset;\n       var string = '';\n       this.relativeOffset += length;\n       for (var i = 0; i < length; i++) {\n           string += String.fromCharCode(dataView.getUint8(offset + i));\n       }\n\n       return string;\n   };\n\n   Parser.prototype.parseTag = function() {\n       return this.parseString(4);\n   };\n\n   // LONGDATETIME is a 64-bit integer.\n   // JavaScript and unix timestamps traditionally use 32 bits, so we\n   // only take the last 32 bits.\n   // + Since until 2038 those bits will be filled by zeros we can ignore them.\n   Parser.prototype.parseLongDateTime = function() {\n       var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n       // Subtract seconds between 01/01/1904 and 01/01/1970\n       // to convert Apple Mac timestamp to Standard Unix timestamp\n       v -= 2082844800;\n       this.relativeOffset += 8;\n       return v;\n   };\n\n   Parser.prototype.parseVersion = function(minorBase) {\n       var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n       // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n       // Default returns the correct number if minor = 0xN000 where N is 0-9\n       // Set minorBase to 1 for tables that use minor = N where N is 0-9\n       var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n       this.relativeOffset += 4;\n       if (minorBase === undefined) { minorBase = 0x1000; }\n       return major + minor / minorBase / 10;\n   };\n\n   Parser.prototype.skip = function(type, amount) {\n       if (amount === undefined) {\n           amount = 1;\n       }\n\n       this.relativeOffset += typeOffsets[type] * amount;\n   };\n\n   ///// Parsing lists and records ///////////////////////////////\n\n   // Parse a list of 32 bit unsigned integers.\n   Parser.prototype.parseULongList = function(count) {\n       if (count === undefined) { count = this.parseULong(); }\n       var offsets = new Array(count);\n       var dataView = this.data;\n       var offset = this.offset + this.relativeOffset;\n       for (var i = 0; i < count; i++) {\n           offsets[i] = dataView.getUint32(offset);\n           offset += 4;\n       }\n\n       this.relativeOffset += count * 4;\n       return offsets;\n   };\n\n   // Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n   // or provided as an argument.\n   Parser.prototype.parseOffset16List =\n   Parser.prototype.parseUShortList = function(count) {\n       if (count === undefined) { count = this.parseUShort(); }\n       var offsets = new Array(count);\n       var dataView = this.data;\n       var offset = this.offset + this.relativeOffset;\n       for (var i = 0; i < count; i++) {\n           offsets[i] = dataView.getUint16(offset);\n           offset += 2;\n       }\n\n       this.relativeOffset += count * 2;\n       return offsets;\n   };\n\n   // Parses a list of 16 bit signed integers.\n   Parser.prototype.parseShortList = function(count) {\n       var list = new Array(count);\n       var dataView = this.data;\n       var offset = this.offset + this.relativeOffset;\n       for (var i = 0; i < count; i++) {\n           list[i] = dataView.getInt16(offset);\n           offset += 2;\n       }\n\n       this.relativeOffset += count * 2;\n       return list;\n   };\n\n   // Parses a list of bytes.\n   Parser.prototype.parseByteList = function(count) {\n       var list = new Array(count);\n       var dataView = this.data;\n       var offset = this.offset + this.relativeOffset;\n       for (var i = 0; i < count; i++) {\n           list[i] = dataView.getUint8(offset++);\n       }\n\n       this.relativeOffset += count;\n       return list;\n   };\n\n   /**\n    * Parse a list of items.\n    * Record count is optional, if omitted it is read from the stream.\n    * itemCallback is one of the Parser methods.\n    */\n   Parser.prototype.parseList = function(count, itemCallback) {\n       if (!itemCallback) {\n           itemCallback = count;\n           count = this.parseUShort();\n       }\n       var list = new Array(count);\n       for (var i = 0; i < count; i++) {\n           list[i] = itemCallback.call(this);\n       }\n       return list;\n   };\n\n   Parser.prototype.parseList32 = function(count, itemCallback) {\n       if (!itemCallback) {\n           itemCallback = count;\n           count = this.parseULong();\n       }\n       var list = new Array(count);\n       for (var i = 0; i < count; i++) {\n           list[i] = itemCallback.call(this);\n       }\n       return list;\n   };\n\n   /**\n    * Parse a list of records.\n    * Record count is optional, if omitted it is read from the stream.\n    * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n    */\n   Parser.prototype.parseRecordList = function(count, recordDescription) {\n       // If the count argument is absent, read it in the stream.\n       if (!recordDescription) {\n           recordDescription = count;\n           count = this.parseUShort();\n       }\n       var records = new Array(count);\n       var fields = Object.keys(recordDescription);\n       for (var i = 0; i < count; i++) {\n           var rec = {};\n           for (var j = 0; j < fields.length; j++) {\n               var fieldName = fields[j];\n               var fieldType = recordDescription[fieldName];\n               rec[fieldName] = fieldType.call(this);\n           }\n           records[i] = rec;\n       }\n       return records;\n   };\n\n   Parser.prototype.parseRecordList32 = function(count, recordDescription) {\n       // If the count argument is absent, read it in the stream.\n       if (!recordDescription) {\n           recordDescription = count;\n           count = this.parseULong();\n       }\n       var records = new Array(count);\n       var fields = Object.keys(recordDescription);\n       for (var i = 0; i < count; i++) {\n           var rec = {};\n           for (var j = 0; j < fields.length; j++) {\n               var fieldName = fields[j];\n               var fieldType = recordDescription[fieldName];\n               rec[fieldName] = fieldType.call(this);\n           }\n           records[i] = rec;\n       }\n       return records;\n   };\n\n   // Parse a data structure into an object\n   // Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n   Parser.prototype.parseStruct = function(description) {\n       if (typeof description === 'function') {\n           return description.call(this);\n       } else {\n           var fields = Object.keys(description);\n           var struct = {};\n           for (var j = 0; j < fields.length; j++) {\n               var fieldName = fields[j];\n               var fieldType = description[fieldName];\n               struct[fieldName] = fieldType.call(this);\n           }\n           return struct;\n       }\n   };\n\n   /**\n    * Parse a GPOS valueRecord\n    * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n    * valueFormat is optional, if omitted it is read from the stream.\n    */\n   Parser.prototype.parseValueRecord = function(valueFormat) {\n       if (valueFormat === undefined) {\n           valueFormat = this.parseUShort();\n       }\n       if (valueFormat === 0) {\n           // valueFormat2 in kerning pairs is most often 0\n           // in this case return undefined instead of an empty object, to save space\n           return;\n       }\n       var valueRecord = {};\n\n       if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n       if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n       if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n       if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n       // Device table (non-variable font) / VariationIndex table (variable font) not supported\n       // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n       if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n       if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n       if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n       if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n       return valueRecord;\n   };\n\n   /**\n    * Parse a list of GPOS valueRecords\n    * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n    * valueFormat and valueCount are read from the stream.\n    */\n   Parser.prototype.parseValueRecordList = function() {\n       var valueFormat = this.parseUShort();\n       var valueCount = this.parseUShort();\n       var values = new Array(valueCount);\n       for (var i = 0; i < valueCount; i++) {\n           values[i] = this.parseValueRecord(valueFormat);\n       }\n       return values;\n   };\n\n   Parser.prototype.parsePointer = function(description) {\n       var structOffset = this.parseOffset16();\n       if (structOffset > 0) {\n           // NULL offset => return undefined\n           return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n       }\n       return undefined;\n   };\n\n   Parser.prototype.parsePointer32 = function(description) {\n       var structOffset = this.parseOffset32();\n       if (structOffset > 0) {\n           // NULL offset => return undefined\n           return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n       }\n       return undefined;\n   };\n\n   /**\n    * Parse a list of offsets to lists of 16-bit integers,\n    * or a list of offsets to lists of offsets to any kind of items.\n    * If itemCallback is not provided, a list of list of UShort is assumed.\n    * If provided, itemCallback is called on each item and must parse the item.\n    * See examples in tables/gsub.js\n    */\n   Parser.prototype.parseListOfLists = function(itemCallback) {\n       var offsets = this.parseOffset16List();\n       var count = offsets.length;\n       var relativeOffset = this.relativeOffset;\n       var list = new Array(count);\n       for (var i = 0; i < count; i++) {\n           var start = offsets[i];\n           if (start === 0) {\n               // NULL offset\n               // Add i as owned property to list. Convenient with assert.\n               list[i] = undefined;\n               continue;\n           }\n           this.relativeOffset = start;\n           if (itemCallback) {\n               var subOffsets = this.parseOffset16List();\n               var subList = new Array(subOffsets.length);\n               for (var j = 0; j < subOffsets.length; j++) {\n                   this.relativeOffset = start + subOffsets[j];\n                   subList[j] = itemCallback.call(this);\n               }\n               list[i] = subList;\n           } else {\n               list[i] = this.parseUShortList();\n           }\n       }\n       this.relativeOffset = relativeOffset;\n       return list;\n   };\n\n   ///// Complex tables parsing //////////////////////////////////\n\n   // Parse a coverage table in a GSUB, GPOS or GDEF table.\n   // https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n   // parser.offset must point to the start of the table containing the coverage.\n   Parser.prototype.parseCoverage = function() {\n       var startOffset = this.offset + this.relativeOffset;\n       var format = this.parseUShort();\n       var count = this.parseUShort();\n       if (format === 1) {\n           return {\n               format: 1,\n               glyphs: this.parseUShortList(count)\n           };\n       } else if (format === 2) {\n           var ranges = new Array(count);\n           for (var i = 0; i < count; i++) {\n               ranges[i] = {\n                   start: this.parseUShort(),\n                   end: this.parseUShort(),\n                   index: this.parseUShort()\n               };\n           }\n           return {\n               format: 2,\n               ranges: ranges\n           };\n       }\n       throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n   };\n\n   // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n   // https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n   Parser.prototype.parseClassDef = function() {\n       var startOffset = this.offset + this.relativeOffset;\n       var format = this.parseUShort();\n       if (format === 1) {\n           return {\n               format: 1,\n               startGlyph: this.parseUShort(),\n               classes: this.parseUShortList()\n           };\n       } else if (format === 2) {\n           return {\n               format: 2,\n               ranges: this.parseRecordList({\n                   start: Parser.uShort,\n                   end: Parser.uShort,\n                   classId: Parser.uShort\n               })\n           };\n       }\n       throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n   };\n\n   ///// Static methods ///////////////////////////////////\n   // These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\n   Parser.list = function(count, itemCallback) {\n       return function() {\n           return this.parseList(count, itemCallback);\n       };\n   };\n\n   Parser.list32 = function(count, itemCallback) {\n       return function() {\n           return this.parseList32(count, itemCallback);\n       };\n   };\n\n   Parser.recordList = function(count, recordDescription) {\n       return function() {\n           return this.parseRecordList(count, recordDescription);\n       };\n   };\n\n   Parser.recordList32 = function(count, recordDescription) {\n       return function() {\n           return this.parseRecordList32(count, recordDescription);\n       };\n   };\n\n   Parser.pointer = function(description) {\n       return function() {\n           return this.parsePointer(description);\n       };\n   };\n\n   Parser.pointer32 = function(description) {\n       return function() {\n           return this.parsePointer32(description);\n       };\n   };\n\n   Parser.tag = Parser.prototype.parseTag;\n   Parser.byte = Parser.prototype.parseByte;\n   Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\n   Parser.uShortList = Parser.prototype.parseUShortList;\n   Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;\n   Parser.uLongList = Parser.prototype.parseULongList;\n   Parser.struct = Parser.prototype.parseStruct;\n   Parser.coverage = Parser.prototype.parseCoverage;\n   Parser.classDef = Parser.prototype.parseClassDef;\n\n   ///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n   // https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\n   var langSysTable = {\n       reserved: Parser.uShort,\n       reqFeatureIndex: Parser.uShort,\n       featureIndexes: Parser.uShortList\n   };\n\n   Parser.prototype.parseScriptList = function() {\n       return this.parsePointer(Parser.recordList({\n           tag: Parser.tag,\n           script: Parser.pointer({\n               defaultLangSys: Parser.pointer(langSysTable),\n               langSysRecords: Parser.recordList({\n                   tag: Parser.tag,\n                   langSys: Parser.pointer(langSysTable)\n               })\n           })\n       })) || [];\n   };\n\n   Parser.prototype.parseFeatureList = function() {\n       return this.parsePointer(Parser.recordList({\n           tag: Parser.tag,\n           feature: Parser.pointer({\n               featureParams: Parser.offset16,\n               lookupListIndexes: Parser.uShortList\n           })\n       })) || [];\n   };\n\n   Parser.prototype.parseLookupList = function(lookupTableParsers) {\n       return this.parsePointer(Parser.list(Parser.pointer(function() {\n           var lookupType = this.parseUShort();\n           check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n           var lookupFlag = this.parseUShort();\n           var useMarkFilteringSet = lookupFlag & 0x10;\n           return {\n               lookupType: lookupType,\n               lookupFlag: lookupFlag,\n               subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n               markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n           };\n       }))) || [];\n   };\n\n   Parser.prototype.parseFeatureVariationsList = function() {\n       return this.parsePointer32(function() {\n           var majorVersion = this.parseUShort();\n           var minorVersion = this.parseUShort();\n           check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n           var featureVariations = this.parseRecordList32({\n               conditionSetOffset: Parser.offset32,\n               featureTableSubstitutionOffset: Parser.offset32\n           });\n           return featureVariations;\n       }) || [];\n   };\n\n   var parse = {\n       getByte: getByte,\n       getCard8: getByte,\n       getUShort: getUShort,\n       getCard16: getUShort,\n       getShort: getShort,\n       getULong: getULong,\n       getFixed: getFixed,\n       getTag: getTag,\n       getOffset: getOffset,\n       getBytes: getBytes,\n       bytesToString: bytesToString,\n       Parser: Parser,\n   };\n\n   // The `glyf` table describes the glyphs in TrueType outline format.\n\n   // Parse the coordinate data for a glyph.\n   function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n       var v;\n       if ((flag & shortVectorBitMask) > 0) {\n           // The coordinate is 1 byte long.\n           v = p.parseByte();\n           // The `same` bit is re-used for short values to signify the sign of the value.\n           if ((flag & sameBitMask) === 0) {\n               v = -v;\n           }\n\n           v = previousValue + v;\n       } else {\n           //  The coordinate is 2 bytes long.\n           // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n           if ((flag & sameBitMask) > 0) {\n               v = previousValue;\n           } else {\n               // Parse the coordinate as a signed 16-bit delta value.\n               v = previousValue + p.parseShort();\n           }\n       }\n\n       return v;\n   }\n\n   // Parse a TrueType glyph.\n   function parseGlyph(glyph, data, start) {\n       var p = new parse.Parser(data, start);\n       glyph.numberOfContours = p.parseShort();\n       glyph._xMin = p.parseShort();\n       glyph._yMin = p.parseShort();\n       glyph._xMax = p.parseShort();\n       glyph._yMax = p.parseShort();\n       var flags;\n       var flag;\n\n       if (glyph.numberOfContours > 0) {\n           // This glyph is not a composite.\n           var endPointIndices = glyph.endPointIndices = [];\n           for (var i = 0; i < glyph.numberOfContours; i += 1) {\n               endPointIndices.push(p.parseUShort());\n           }\n\n           glyph.instructionLength = p.parseUShort();\n           glyph.instructions = [];\n           for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n               glyph.instructions.push(p.parseByte());\n           }\n\n           var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n           flags = [];\n           for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n               flag = p.parseByte();\n               flags.push(flag);\n               // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n               if ((flag & 8) > 0) {\n                   var repeatCount = p.parseByte();\n                   for (var j = 0; j < repeatCount; j += 1) {\n                       flags.push(flag);\n                       i$2 += 1;\n                   }\n               }\n           }\n\n           check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n           if (endPointIndices.length > 0) {\n               var points = [];\n               var point;\n               // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n               if (numberOfCoordinates > 0) {\n                   for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                       flag = flags[i$3];\n                       point = {};\n                       point.onCurve = !!(flag & 1);\n                       point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                       points.push(point);\n                   }\n\n                   var px = 0;\n                   for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                       flag = flags[i$4];\n                       point = points[i$4];\n                       point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                       px = point.x;\n                   }\n\n                   var py = 0;\n                   for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                       flag = flags[i$5];\n                       point = points[i$5];\n                       point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                       py = point.y;\n                   }\n               }\n\n               glyph.points = points;\n           } else {\n               glyph.points = [];\n           }\n       } else if (glyph.numberOfContours === 0) {\n           glyph.points = [];\n       } else {\n           glyph.isComposite = true;\n           glyph.points = [];\n           glyph.components = [];\n           var moreComponents = true;\n           while (moreComponents) {\n               flags = p.parseUShort();\n               var component = {\n                   glyphIndex: p.parseUShort(),\n                   xScale: 1,\n                   scale01: 0,\n                   scale10: 0,\n                   yScale: 1,\n                   dx: 0,\n                   dy: 0\n               };\n               if ((flags & 1) > 0) {\n                   // The arguments are words\n                   if ((flags & 2) > 0) {\n                       // values are offset\n                       component.dx = p.parseShort();\n                       component.dy = p.parseShort();\n                   } else {\n                       // values are matched points\n                       component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                   }\n\n               } else {\n                   // The arguments are bytes\n                   if ((flags & 2) > 0) {\n                       // values are offset\n                       component.dx = p.parseChar();\n                       component.dy = p.parseChar();\n                   } else {\n                       // values are matched points\n                       component.matchedPoints = [p.parseByte(), p.parseByte()];\n                   }\n               }\n\n               if ((flags & 8) > 0) {\n                   // We have a scale\n                   component.xScale = component.yScale = p.parseF2Dot14();\n               } else if ((flags & 64) > 0) {\n                   // We have an X / Y scale\n                   component.xScale = p.parseF2Dot14();\n                   component.yScale = p.parseF2Dot14();\n               } else if ((flags & 128) > 0) {\n                   // We have a 2x2 transformation\n                   component.xScale = p.parseF2Dot14();\n                   component.scale01 = p.parseF2Dot14();\n                   component.scale10 = p.parseF2Dot14();\n                   component.yScale = p.parseF2Dot14();\n               }\n\n               glyph.components.push(component);\n               moreComponents = !!(flags & 32);\n           }\n           if (flags & 0x100) {\n               // We have instructions\n               glyph.instructionLength = p.parseUShort();\n               glyph.instructions = [];\n               for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                   glyph.instructions.push(p.parseByte());\n               }\n           }\n       }\n   }\n\n   // Transform an array of points and return a new array.\n   function transformPoints(points, transform) {\n       var newPoints = [];\n       for (var i = 0; i < points.length; i += 1) {\n           var pt = points[i];\n           var newPt = {\n               x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n               y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n               onCurve: pt.onCurve,\n               lastPointOfContour: pt.lastPointOfContour\n           };\n           newPoints.push(newPt);\n       }\n\n       return newPoints;\n   }\n\n   function getContours(points) {\n       var contours = [];\n       var currentContour = [];\n       for (var i = 0; i < points.length; i += 1) {\n           var pt = points[i];\n           currentContour.push(pt);\n           if (pt.lastPointOfContour) {\n               contours.push(currentContour);\n               currentContour = [];\n           }\n       }\n\n       check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n       return contours;\n   }\n\n   // Convert the TrueType glyph outline to a Path.\n   function getPath(points) {\n       var p = new Path();\n       if (!points) {\n           return p;\n       }\n\n       var contours = getContours(points);\n\n       for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n           var contour = contours[contourIndex];\n\n           var prev = null;\n           var curr = contour[contour.length - 1];\n           var next = contour[0];\n\n           if (curr.onCurve) {\n               p.moveTo(curr.x, curr.y);\n           } else {\n               if (next.onCurve) {\n                   p.moveTo(next.x, next.y);\n               } else {\n                   // If both first and last points are off-curve, start at their middle.\n                   var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                   p.moveTo(start.x, start.y);\n               }\n           }\n\n           for (var i = 0; i < contour.length; ++i) {\n               prev = curr;\n               curr = next;\n               next = contour[(i + 1) % contour.length];\n\n               if (curr.onCurve) {\n                   // This is a straight line.\n                   p.lineTo(curr.x, curr.y);\n               } else {\n                   var prev2 = prev;\n                   var next2 = next;\n\n                   if (!prev.onCurve) {\n                       prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                   }\n\n                   if (!next.onCurve) {\n                       next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                   }\n\n                   p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n               }\n           }\n\n           p.closePath();\n       }\n       return p;\n   }\n\n   function buildPath(glyphs, glyph) {\n       if (glyph.isComposite) {\n           for (var j = 0; j < glyph.components.length; j += 1) {\n               var component = glyph.components[j];\n               var componentGlyph = glyphs.get(component.glyphIndex);\n               // Force the ttfGlyphLoader to parse the glyph.\n               componentGlyph.getPath();\n               if (componentGlyph.points) {\n                   var transformedPoints = (void 0);\n                   if (component.matchedPoints === undefined) {\n                       // component positioned by offset\n                       transformedPoints = transformPoints(componentGlyph.points, component);\n                   } else {\n                       // component positioned by matched points\n                       if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                           (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                           throw Error('Matched points out of range in ' + glyph.name);\n                       }\n                       var firstPt = glyph.points[component.matchedPoints[0]];\n                       var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                       var transform = {\n                           xScale: component.xScale, scale01: component.scale01,\n                           scale10: component.scale10, yScale: component.yScale,\n                           dx: 0, dy: 0\n                       };\n                       secondPt = transformPoints([secondPt], transform)[0];\n                       transform.dx = firstPt.x - secondPt.x;\n                       transform.dy = firstPt.y - secondPt.y;\n                       transformedPoints = transformPoints(componentGlyph.points, transform);\n                   }\n                   glyph.points = glyph.points.concat(transformedPoints);\n               }\n           }\n       }\n\n       return getPath(glyph.points);\n   }\n\n   function parseGlyfTableAll(data, start, loca, font) {\n       var glyphs = new glyphset.GlyphSet(font);\n\n       // The last element of the loca table is invalid.\n       for (var i = 0; i < loca.length - 1; i += 1) {\n           var offset = loca[i];\n           var nextOffset = loca[i + 1];\n           if (offset !== nextOffset) {\n               glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n           } else {\n               glyphs.push(i, glyphset.glyphLoader(font, i));\n           }\n       }\n\n       return glyphs;\n   }\n\n   function parseGlyfTableOnLowMemory(data, start, loca, font) {\n       var glyphs = new glyphset.GlyphSet(font);\n\n       font._push = function(i) {\n           var offset = loca[i];\n           var nextOffset = loca[i + 1];\n           if (offset !== nextOffset) {\n               glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n           } else {\n               glyphs.push(i, glyphset.glyphLoader(font, i));\n           }\n       };\n\n       return glyphs;\n   }\n\n   // Parse all the glyphs according to the offsets from the `loca` table.\n   function parseGlyfTable(data, start, loca, font, opt) {\n       if (opt.lowMemory)\n           { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n       else\n           { return parseGlyfTableAll(data, start, loca, font); }\n   }\n\n   var glyf = { getPath: getPath, parse: parseGlyfTable};\n\n   /* A TrueType font hinting interpreter.\n   *\n   * (c) 2017 Axel Kittenberger\n   *\n   * This interpreter has been implemented according to this documentation:\n   * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n   *\n   * According to the documentation F24DOT6 values are used for pixels.\n   * That means calculation is 1/64 pixel accurate and uses integer operations.\n   * However, Javascript has floating point operations by default and only\n   * those are available. One could make a case to simulate the 1/64 accuracy\n   * exactly by truncating after every division operation\n   * (for example with << 0) to get pixel exactly results as other TrueType\n   * implementations. It may make sense since some fonts are pixel optimized\n   * by hand using DELTAP instructions. The current implementation doesn't\n   * and rather uses full floating point precision.\n   *\n   * xScale, yScale and rotation is currently ignored.\n   *\n   * A few non-trivial instructions are missing as I didn't encounter yet\n   * a font that used them to test a possible implementation.\n   *\n   * Some fonts seem to use undocumented features regarding the twilight zone.\n   * Only some of them are implemented as they were encountered.\n   *\n   * The exports.DEBUG statements are removed on the minified distribution file.\n   */\n\n   var instructionTable;\n   var exec;\n   var execGlyph;\n   var execComponent;\n\n   /*\n   * Creates a hinting object.\n   *\n   * There ought to be exactly one\n   * for each truetype font that is used for hinting.\n   */\n   function Hinting(font) {\n       // the font this hinting object is for\n       this.font = font;\n\n       this.getCommands = function (hPoints) {\n           return glyf.getPath(hPoints).commands;\n       };\n\n       // cached states\n       this._fpgmState  =\n       this._prepState  =\n           undefined;\n\n       // errorState\n       // 0 ... all okay\n       // 1 ... had an error in a glyf,\n       //       continue working but stop spamming\n       //       the console\n       // 2 ... error at prep, stop hinting at this ppem\n       // 3 ... error at fpeg, stop hinting for this font at all\n       this._errorState = 0;\n   }\n\n   /*\n   * Not rounding.\n   */\n   function roundOff(v) {\n       return v;\n   }\n\n   /*\n   * Rounding to grid.\n   */\n   function roundToGrid(v) {\n       //Rounding in TT is supposed to \"symmetrical around zero\"\n       return Math.sign(v) * Math.round(Math.abs(v));\n   }\n\n   /*\n   * Rounding to double grid.\n   */\n   function roundToDoubleGrid(v) {\n       return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n   }\n\n   /*\n   * Rounding to half grid.\n   */\n   function roundToHalfGrid(v) {\n       return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n   }\n\n   /*\n   * Rounding to up to grid.\n   */\n   function roundUpToGrid(v) {\n       return Math.sign(v) * Math.ceil(Math.abs(v));\n   }\n\n   /*\n   * Rounding to down to grid.\n   */\n   function roundDownToGrid(v) {\n       return Math.sign(v) * Math.floor(Math.abs(v));\n   }\n\n   /*\n   * Super rounding.\n   */\n   var roundSuper = function (v) {\n       var period = this.srPeriod;\n       var phase = this.srPhase;\n       var threshold = this.srThreshold;\n       var sign = 1;\n\n       if (v < 0) {\n           v = -v;\n           sign = -1;\n       }\n\n       v += threshold - phase;\n\n       v = Math.trunc(v / period) * period;\n\n       v += phase;\n\n       // according to http://xgridfit.sourceforge.net/round.html\n       if (v < 0) { return phase * sign; }\n\n       return v * sign;\n   };\n\n   /*\n   * Unit vector of x-axis.\n   */\n   var xUnitVector = {\n       x: 1,\n\n       y: 0,\n\n       axis: 'x',\n\n       // Gets the projected distance between two points.\n       // o1/o2 ... if true, respective original position is used.\n       distance: function (p1, p2, o1, o2) {\n           return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n       },\n\n       // Moves point p so the moved position has the same relative\n       // position to the moved positions of rp1 and rp2 than the\n       // original positions had.\n       //\n       // See APPENDIX on INTERPOLATE at the bottom of this file.\n       interpolate: function (p, rp1, rp2, pv) {\n           var do1;\n           var do2;\n           var doa1;\n           var doa2;\n           var dm1;\n           var dm2;\n           var dt;\n\n           if (!pv || pv === this) {\n               do1 = p.xo - rp1.xo;\n               do2 = p.xo - rp2.xo;\n               dm1 = rp1.x - rp1.xo;\n               dm2 = rp2.x - rp2.xo;\n               doa1 = Math.abs(do1);\n               doa2 = Math.abs(do2);\n               dt = doa1 + doa2;\n\n               if (dt === 0) {\n                   p.x = p.xo + (dm1 + dm2) / 2;\n                   return;\n               }\n\n               p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n               return;\n           }\n\n           do1 = pv.distance(p, rp1, true, true);\n           do2 = pv.distance(p, rp2, true, true);\n           dm1 = pv.distance(rp1, rp1, false, true);\n           dm2 = pv.distance(rp2, rp2, false, true);\n           doa1 = Math.abs(do1);\n           doa2 = Math.abs(do2);\n           dt = doa1 + doa2;\n\n           if (dt === 0) {\n               xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n               return;\n           }\n\n           xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n       },\n\n       // Slope of line normal to this\n       normalSlope: Number.NEGATIVE_INFINITY,\n\n       // Sets the point 'p' relative to point 'rp'\n       // by the distance 'd'.\n       //\n       // See APPENDIX on SETRELATIVE at the bottom of this file.\n       //\n       // p   ... point to set\n       // rp  ... reference point\n       // d   ... distance on projection vector\n       // pv  ... projection vector (undefined = this)\n       // org ... if true, uses the original position of rp as reference.\n       setRelative: function (p, rp, d, pv, org) {\n           if (!pv || pv === this) {\n               p.x = (org ? rp.xo : rp.x) + d;\n               return;\n           }\n\n           var rpx = org ? rp.xo : rp.x;\n           var rpy = org ? rp.yo : rp.y;\n           var rpdx = rpx + d * pv.x;\n           var rpdy = rpy + d * pv.y;\n\n           p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n       },\n\n       // Slope of vector line.\n       slope: 0,\n\n       // Touches the point p.\n       touch: function (p) {\n           p.xTouched = true;\n       },\n\n       // Tests if a point p is touched.\n       touched: function (p) {\n           return p.xTouched;\n       },\n\n       // Untouches the point p.\n       untouch: function (p) {\n           p.xTouched = false;\n       }\n   };\n\n   /*\n   * Unit vector of y-axis.\n   */\n   var yUnitVector = {\n       x: 0,\n\n       y: 1,\n\n       axis: 'y',\n\n       // Gets the projected distance between two points.\n       // o1/o2 ... if true, respective original position is used.\n       distance: function (p1, p2, o1, o2) {\n           return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n       },\n\n       // Moves point p so the moved position has the same relative\n       // position to the moved positions of rp1 and rp2 than the\n       // original positions had.\n       //\n       // See APPENDIX on INTERPOLATE at the bottom of this file.\n       interpolate: function (p, rp1, rp2, pv) {\n           var do1;\n           var do2;\n           var doa1;\n           var doa2;\n           var dm1;\n           var dm2;\n           var dt;\n\n           if (!pv || pv === this) {\n               do1 = p.yo - rp1.yo;\n               do2 = p.yo - rp2.yo;\n               dm1 = rp1.y - rp1.yo;\n               dm2 = rp2.y - rp2.yo;\n               doa1 = Math.abs(do1);\n               doa2 = Math.abs(do2);\n               dt = doa1 + doa2;\n\n               if (dt === 0) {\n                   p.y = p.yo + (dm1 + dm2) / 2;\n                   return;\n               }\n\n               p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n               return;\n           }\n\n           do1 = pv.distance(p, rp1, true, true);\n           do2 = pv.distance(p, rp2, true, true);\n           dm1 = pv.distance(rp1, rp1, false, true);\n           dm2 = pv.distance(rp2, rp2, false, true);\n           doa1 = Math.abs(do1);\n           doa2 = Math.abs(do2);\n           dt = doa1 + doa2;\n\n           if (dt === 0) {\n               yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n               return;\n           }\n\n           yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n       },\n\n       // Slope of line normal to this.\n       normalSlope: 0,\n\n       // Sets the point 'p' relative to point 'rp'\n       // by the distance 'd'\n       //\n       // See APPENDIX on SETRELATIVE at the bottom of this file.\n       //\n       // p   ... point to set\n       // rp  ... reference point\n       // d   ... distance on projection vector\n       // pv  ... projection vector (undefined = this)\n       // org ... if true, uses the original position of rp as reference.\n       setRelative: function (p, rp, d, pv, org) {\n           if (!pv || pv === this) {\n               p.y = (org ? rp.yo : rp.y) + d;\n               return;\n           }\n\n           var rpx = org ? rp.xo : rp.x;\n           var rpy = org ? rp.yo : rp.y;\n           var rpdx = rpx + d * pv.x;\n           var rpdy = rpy + d * pv.y;\n\n           p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n       },\n\n       // Slope of vector line.\n       slope: Number.POSITIVE_INFINITY,\n\n       // Touches the point p.\n       touch: function (p) {\n           p.yTouched = true;\n       },\n\n       // Tests if a point p is touched.\n       touched: function (p) {\n           return p.yTouched;\n       },\n\n       // Untouches the point p.\n       untouch: function (p) {\n           p.yTouched = false;\n       }\n   };\n\n   Object.freeze(xUnitVector);\n   Object.freeze(yUnitVector);\n\n   /*\n   * Creates a unit vector that is not x- or y-axis.\n   */\n   function UnitVector(x, y) {\n       this.x = x;\n       this.y = y;\n       this.axis = undefined;\n       this.slope = y / x;\n       this.normalSlope = -x / y;\n       Object.freeze(this);\n   }\n\n   /*\n   * Gets the projected distance between two points.\n   * o1/o2 ... if true, respective original position is used.\n   */\n   UnitVector.prototype.distance = function(p1, p2, o1, o2) {\n       return (\n           this.x * xUnitVector.distance(p1, p2, o1, o2) +\n           this.y * yUnitVector.distance(p1, p2, o1, o2)\n       );\n   };\n\n   /*\n   * Moves point p so the moved position has the same relative\n   * position to the moved positions of rp1 and rp2 than the\n   * original positions had.\n   *\n   * See APPENDIX on INTERPOLATE at the bottom of this file.\n   */\n   UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n       var dm1;\n       var dm2;\n       var do1;\n       var do2;\n       var doa1;\n       var doa2;\n       var dt;\n\n       do1 = pv.distance(p, rp1, true, true);\n       do2 = pv.distance(p, rp2, true, true);\n       dm1 = pv.distance(rp1, rp1, false, true);\n       dm2 = pv.distance(rp2, rp2, false, true);\n       doa1 = Math.abs(do1);\n       doa2 = Math.abs(do2);\n       dt = doa1 + doa2;\n\n       if (dt === 0) {\n           this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n           return;\n       }\n\n       this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n   };\n\n   /*\n   * Sets the point 'p' relative to point 'rp'\n   * by the distance 'd'\n   *\n   * See APPENDIX on SETRELATIVE at the bottom of this file.\n   *\n   * p   ...  point to set\n   * rp  ... reference point\n   * d   ... distance on projection vector\n   * pv  ... projection vector (undefined = this)\n   * org ... if true, uses the original position of rp as reference.\n   */\n   UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n       pv = pv || this;\n\n       var rpx = org ? rp.xo : rp.x;\n       var rpy = org ? rp.yo : rp.y;\n       var rpdx = rpx + d * pv.x;\n       var rpdy = rpy + d * pv.y;\n\n       var pvns = pv.normalSlope;\n       var fvs = this.slope;\n\n       var px = p.x;\n       var py = p.y;\n\n       p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n       p.y = fvs * (p.x - px) + py;\n   };\n\n   /*\n   * Touches the point p.\n   */\n   UnitVector.prototype.touch = function(p) {\n       p.xTouched = true;\n       p.yTouched = true;\n   };\n\n   /*\n   * Returns a unit vector with x/y coordinates.\n   */\n   function getUnitVector(x, y) {\n       var d = Math.sqrt(x * x + y * y);\n\n       x /= d;\n       y /= d;\n\n       if (x === 1 && y === 0) { return xUnitVector; }\n       else if (x === 0 && y === 1) { return yUnitVector; }\n       else { return new UnitVector(x, y); }\n   }\n\n   /*\n   * Creates a point in the hinting engine.\n   */\n   function HPoint(\n       x,\n       y,\n       lastPointOfContour,\n       onCurve\n   ) {\n       this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n       this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n       this.lastPointOfContour = lastPointOfContour;\n       this.onCurve = onCurve;\n       this.prevPointOnContour = undefined;\n       this.nextPointOnContour = undefined;\n       this.xTouched = false;\n       this.yTouched = false;\n\n       Object.preventExtensions(this);\n   }\n\n   /*\n   * Returns the next touched point on the contour.\n   *\n   * v  ... unit vector to test touch axis.\n   */\n   HPoint.prototype.nextTouched = function(v) {\n       var p = this.nextPointOnContour;\n\n       while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n       return p;\n   };\n\n   /*\n   * Returns the previous touched point on the contour\n   *\n   * v  ... unit vector to test touch axis.\n   */\n   HPoint.prototype.prevTouched = function(v) {\n       var p = this.prevPointOnContour;\n\n       while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n       return p;\n   };\n\n   /*\n   * The zero point.\n   */\n   var HPZero = Object.freeze(new HPoint(0, 0));\n\n   /*\n   * The default state of the interpreter.\n   *\n   * Note: Freezing the defaultState and then deriving from it\n   * makes the V8 Javascript engine going awkward,\n   * so this is avoided, albeit the defaultState shouldn't\n   * ever change.\n   */\n   var defaultState = {\n       cvCutIn: 17 / 16,    // control value cut in\n       deltaBase: 9,\n       deltaShift: 0.125,\n       loop: 1,             // loops some instructions\n       minDis: 1,           // minimum distance\n       autoFlip: true\n   };\n\n   /*\n   * The current state of the interpreter.\n   *\n   * env  ... 'fpgm' or 'prep' or 'glyf'\n   * prog ... the program\n   */\n   function State(env, prog) {\n       this.env = env;\n       this.stack = [];\n       this.prog = prog;\n\n       switch (env) {\n           case 'glyf' :\n               this.zp0 = this.zp1 = this.zp2 = 1;\n               this.rp0 = this.rp1 = this.rp2 = 0;\n               /* fall through */\n           case 'prep' :\n               this.fv = this.pv = this.dpv = xUnitVector;\n               this.round = roundToGrid;\n       }\n   }\n\n   /*\n   * Executes a glyph program.\n   *\n   * This does the hinting for each glyph.\n   *\n   * Returns an array of moved points.\n   *\n   * glyph: the glyph to hint\n   * ppem: the size the glyph is rendered for\n   */\n   Hinting.prototype.exec = function(glyph, ppem) {\n       if (typeof ppem !== 'number') {\n           throw new Error('Point size is not a number!');\n       }\n\n       // Received a fatal error, don't do any hinting anymore.\n       if (this._errorState > 2) { return; }\n\n       var font = this.font;\n       var prepState = this._prepState;\n\n       if (!prepState || prepState.ppem !== ppem) {\n           var fpgmState = this._fpgmState;\n\n           if (!fpgmState) {\n               // Executes the fpgm state.\n               // This is used by fonts to define functions.\n               State.prototype = defaultState;\n\n               fpgmState =\n               this._fpgmState =\n                   new State('fpgm', font.tables.fpgm);\n\n               fpgmState.funcs = [ ];\n               fpgmState.font = font;\n\n               if (exports.DEBUG) {\n                   console.log('---EXEC FPGM---');\n                   fpgmState.step = -1;\n               }\n\n               try {\n                   exec(fpgmState);\n               } catch (e) {\n                   console.log('Hinting error in FPGM:' + e);\n                   this._errorState = 3;\n                   return;\n               }\n           }\n\n           // Executes the prep program for this ppem setting.\n           // This is used by fonts to set cvt values\n           // depending on to be rendered font size.\n\n           State.prototype = fpgmState;\n           prepState =\n           this._prepState =\n               new State('prep', font.tables.prep);\n\n           prepState.ppem = ppem;\n\n           // Creates a copy of the cvt table\n           // and scales it to the current ppem setting.\n           var oCvt = font.tables.cvt;\n           if (oCvt) {\n               var cvt = prepState.cvt = new Array(oCvt.length);\n               var scale = ppem / font.unitsPerEm;\n               for (var c = 0; c < oCvt.length; c++) {\n                   cvt[c] = oCvt[c] * scale;\n               }\n           } else {\n               prepState.cvt = [];\n           }\n\n           if (exports.DEBUG) {\n               console.log('---EXEC PREP---');\n               prepState.step = -1;\n           }\n\n           try {\n               exec(prepState);\n           } catch (e) {\n               if (this._errorState < 2) {\n                   console.log('Hinting error in PREP:' + e);\n               }\n               this._errorState = 2;\n           }\n       }\n\n       if (this._errorState > 1) { return; }\n\n       try {\n           return execGlyph(glyph, prepState);\n       } catch (e) {\n           if (this._errorState < 1) {\n               console.log('Hinting error:' + e);\n               console.log('Note: further hinting errors are silenced');\n           }\n           this._errorState = 1;\n           return undefined;\n       }\n   };\n\n   /*\n   * Executes the hinting program for a glyph.\n   */\n   execGlyph = function(glyph, prepState) {\n       // original point positions\n       var xScale = prepState.ppem / prepState.font.unitsPerEm;\n       var yScale = xScale;\n       var components = glyph.components;\n       var contours;\n       var gZone;\n       var state;\n\n       State.prototype = prepState;\n       if (!components) {\n           state = new State('glyf', glyph.instructions);\n           if (exports.DEBUG) {\n               console.log('---EXEC GLYPH---');\n               state.step = -1;\n           }\n           execComponent(glyph, state, xScale, yScale);\n           gZone = state.gZone;\n       } else {\n           var font = prepState.font;\n           gZone = [];\n           contours = [];\n           for (var i = 0; i < components.length; i++) {\n               var c = components[i];\n               var cg = font.glyphs.get(c.glyphIndex);\n\n               state = new State('glyf', cg.instructions);\n\n               if (exports.DEBUG) {\n                   console.log('---EXEC COMP ' + i + '---');\n                   state.step = -1;\n               }\n\n               execComponent(cg, state, xScale, yScale);\n               // appends the computed points to the result array\n               // post processes the component points\n               var dx = Math.round(c.dx * xScale);\n               var dy = Math.round(c.dy * yScale);\n               var gz = state.gZone;\n               var cc = state.contours;\n               for (var pi = 0; pi < gz.length; pi++) {\n                   var p = gz[pi];\n                   p.xTouched = p.yTouched = false;\n                   p.xo = p.x = p.x + dx;\n                   p.yo = p.y = p.y + dy;\n               }\n\n               var gLen = gZone.length;\n               gZone.push.apply(gZone, gz);\n               for (var j = 0; j < cc.length; j++) {\n                   contours.push(cc[j] + gLen);\n               }\n           }\n\n           if (glyph.instructions && !state.inhibitGridFit) {\n               // the composite has instructions on its own\n               state = new State('glyf', glyph.instructions);\n\n               state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n               state.contours = contours;\n\n               // note: HPZero cannot be used here, since\n               //       the point might be modified\n               gZone.push(\n                   new HPoint(0, 0),\n                   new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n               );\n\n               if (exports.DEBUG) {\n                   console.log('---EXEC COMPOSITE---');\n                   state.step = -1;\n               }\n\n               exec(state);\n\n               gZone.length -= 2;\n           }\n       }\n\n       return gZone;\n   };\n\n   /*\n   * Executes the hinting program for a component of a multi-component glyph\n   * or of the glyph itself for a non-component glyph.\n   */\n   execComponent = function(glyph, state, xScale, yScale)\n   {\n       var points = glyph.points || [];\n       var pLen = points.length;\n       var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n       var contours = state.contours = [];\n\n       // Scales the original points and\n       // makes copies for the hinted points.\n       var cp; // current point\n       for (var i = 0; i < pLen; i++) {\n           cp = points[i];\n\n           gZone[i] = new HPoint(\n               cp.x * xScale,\n               cp.y * yScale,\n               cp.lastPointOfContour,\n               cp.onCurve\n           );\n       }\n\n       // Chain links the contours.\n       var sp; // start point\n       var np; // next point\n\n       for (var i$1 = 0; i$1 < pLen; i$1++) {\n           cp = gZone[i$1];\n\n           if (!sp) {\n               sp = cp;\n               contours.push(i$1);\n           }\n\n           if (cp.lastPointOfContour) {\n               cp.nextPointOnContour = sp;\n               sp.prevPointOnContour = cp;\n               sp = undefined;\n           } else {\n               np = gZone[i$1 + 1];\n               cp.nextPointOnContour = np;\n               np.prevPointOnContour = cp;\n           }\n       }\n\n       if (state.inhibitGridFit) { return; }\n\n       if (exports.DEBUG) {\n           console.log('PROCESSING GLYPH', state.stack);\n           for (var i$2 = 0; i$2 < pLen; i$2++) {\n               console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n           }\n       }\n\n       gZone.push(\n           new HPoint(0, 0),\n           new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n       );\n\n       exec(state);\n\n       // Removes the extra points.\n       gZone.length -= 2;\n\n       if (exports.DEBUG) {\n           console.log('FINISHED GLYPH', state.stack);\n           for (var i$3 = 0; i$3 < pLen; i$3++) {\n               console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n           }\n       }\n   };\n\n   /*\n   * Executes the program loaded in state.\n   */\n   exec = function(state) {\n       var prog = state.prog;\n\n       if (!prog) { return; }\n\n       var pLen = prog.length;\n       var ins;\n\n       for (state.ip = 0; state.ip < pLen; state.ip++) {\n           if (exports.DEBUG) { state.step++; }\n           ins = instructionTable[prog[state.ip]];\n\n           if (!ins) {\n               throw new Error(\n                   'unknown instruction: 0x' +\n                   Number(prog[state.ip]).toString(16)\n               );\n           }\n\n           ins(state);\n\n           // very extensive debugging for each step\n           /*\n           if (exports.DEBUG) {\n               var da;\n               if (state.gZone) {\n                   da = [];\n                   for (let i = 0; i < state.gZone.length; i++)\n                   {\n                       da.push(i + ' ' +\n                           state.gZone[i].x * 64 + ' ' +\n                           state.gZone[i].y * 64 + ' ' +\n                           (state.gZone[i].xTouched ? 'x' : '') +\n                           (state.gZone[i].yTouched ? 'y' : '')\n                       );\n                   }\n                   console.log('GZ', da);\n               }\n\n               if (state.tZone) {\n                   da = [];\n                   for (let i = 0; i < state.tZone.length; i++) {\n                       da.push(i + ' ' +\n                           state.tZone[i].x * 64 + ' ' +\n                           state.tZone[i].y * 64 + ' ' +\n                           (state.tZone[i].xTouched ? 'x' : '') +\n                           (state.tZone[i].yTouched ? 'y' : '')\n                       );\n                   }\n                   console.log('TZ', da);\n               }\n\n               if (state.stack.length > 10) {\n                   console.log(\n                       state.stack.length,\n                       '...', state.stack.slice(state.stack.length - 10)\n                   );\n               } else {\n                   console.log(state.stack.length, state.stack);\n               }\n           }\n           */\n       }\n   };\n\n   /*\n   * Initializes the twilight zone.\n   *\n   * This is only done if a SZPx instruction\n   * refers to the twilight zone.\n   */\n   function initTZone(state)\n   {\n       var tZone = state.tZone = new Array(state.gZone.length);\n\n       // no idea if this is actually correct...\n       for (var i = 0; i < tZone.length; i++)\n       {\n           tZone[i] = new HPoint(0, 0);\n       }\n   }\n\n   /*\n   * Skips the instruction pointer ahead over an IF/ELSE block.\n   * handleElse .. if true breaks on matching ELSE\n   */\n   function skip(state, handleElse)\n   {\n       var prog = state.prog;\n       var ip = state.ip;\n       var nesting = 1;\n       var ins;\n\n       do {\n           ins = prog[++ip];\n           if (ins === 0x58) // IF\n               { nesting++; }\n           else if (ins === 0x59) // EIF\n               { nesting--; }\n           else if (ins === 0x40) // NPUSHB\n               { ip += prog[ip + 1] + 1; }\n           else if (ins === 0x41) // NPUSHW\n               { ip += 2 * prog[ip + 1] + 1; }\n           else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n               { ip += ins - 0xB0 + 1; }\n           else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n               { ip += (ins - 0xB8 + 1) * 2; }\n           else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n               { break; }\n       } while (nesting > 0);\n\n       state.ip = ip;\n   }\n\n   /*----------------------------------------------------------*\n   *          And then a lot of instructions...                *\n   *----------------------------------------------------------*/\n\n   // SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n   // 0x00-0x01\n   function SVTCA(v, state) {\n       if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n       state.fv = state.pv = state.dpv = v;\n   }\n\n   // SPVTCA[a] Set Projection Vector to Coordinate Axis\n   // 0x02-0x03\n   function SPVTCA(v, state) {\n       if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n       state.pv = state.dpv = v;\n   }\n\n   // SFVTCA[a] Set Freedom Vector to Coordinate Axis\n   // 0x04-0x05\n   function SFVTCA(v, state) {\n       if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n       state.fv = v;\n   }\n\n   // SPVTL[a] Set Projection Vector To Line\n   // 0x06-0x07\n   function SPVTL(a, state) {\n       var stack = state.stack;\n       var p2i = stack.pop();\n       var p1i = stack.pop();\n       var p2 = state.z2[p2i];\n       var p1 = state.z1[p1i];\n\n       if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n       var dx;\n       var dy;\n\n       if (!a) {\n           dx = p1.x - p2.x;\n           dy = p1.y - p2.y;\n       } else {\n           dx = p2.y - p1.y;\n           dy = p1.x - p2.x;\n       }\n\n       state.pv = state.dpv = getUnitVector(dx, dy);\n   }\n\n   // SFVTL[a] Set Freedom Vector To Line\n   // 0x08-0x09\n   function SFVTL(a, state) {\n       var stack = state.stack;\n       var p2i = stack.pop();\n       var p1i = stack.pop();\n       var p2 = state.z2[p2i];\n       var p1 = state.z1[p1i];\n\n       if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n       var dx;\n       var dy;\n\n       if (!a) {\n           dx = p1.x - p2.x;\n           dy = p1.y - p2.y;\n       } else {\n           dx = p2.y - p1.y;\n           dy = p1.x - p2.x;\n       }\n\n       state.fv = getUnitVector(dx, dy);\n   }\n\n   // SPVFS[] Set Projection Vector From Stack\n   // 0x0A\n   function SPVFS(state) {\n       var stack = state.stack;\n       var y = stack.pop();\n       var x = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n       state.pv = state.dpv = getUnitVector(x, y);\n   }\n\n   // SFVFS[] Set Freedom Vector From Stack\n   // 0x0B\n   function SFVFS(state) {\n       var stack = state.stack;\n       var y = stack.pop();\n       var x = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n       state.fv = getUnitVector(x, y);\n   }\n\n   // GPV[] Get Projection Vector\n   // 0x0C\n   function GPV(state) {\n       var stack = state.stack;\n       var pv = state.pv;\n\n       if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n       stack.push(pv.x * 0x4000);\n       stack.push(pv.y * 0x4000);\n   }\n\n   // GFV[] Get Freedom Vector\n   // 0x0C\n   function GFV(state) {\n       var stack = state.stack;\n       var fv = state.fv;\n\n       if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n       stack.push(fv.x * 0x4000);\n       stack.push(fv.y * 0x4000);\n   }\n\n   // SFVTPV[] Set Freedom Vector To Projection Vector\n   // 0x0E\n   function SFVTPV(state) {\n       state.fv = state.pv;\n\n       if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n   }\n\n   // ISECT[] moves point p to the InterSECTion of two lines\n   // 0x0F\n   function ISECT(state)\n   {\n       var stack = state.stack;\n       var pa0i = stack.pop();\n       var pa1i = stack.pop();\n       var pb0i = stack.pop();\n       var pb1i = stack.pop();\n       var pi = stack.pop();\n       var z0 = state.z0;\n       var z1 = state.z1;\n       var pa0 = z0[pa0i];\n       var pa1 = z0[pa1i];\n       var pb0 = z1[pb0i];\n       var pb1 = z1[pb1i];\n       var p = state.z2[pi];\n\n       if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n       // math from\n       // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n       var x1 = pa0.x;\n       var y1 = pa0.y;\n       var x2 = pa1.x;\n       var y2 = pa1.y;\n       var x3 = pb0.x;\n       var y3 = pb0.y;\n       var x4 = pb1.x;\n       var y4 = pb1.y;\n\n       var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n       var f1 = x1 * y2 - y1 * x2;\n       var f2 = x3 * y4 - y3 * x4;\n\n       p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n       p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n   }\n\n   // SRP0[] Set Reference Point 0\n   // 0x10\n   function SRP0(state) {\n       state.rp0 = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n   }\n\n   // SRP1[] Set Reference Point 1\n   // 0x11\n   function SRP1(state) {\n       state.rp1 = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n   }\n\n   // SRP1[] Set Reference Point 2\n   // 0x12\n   function SRP2(state) {\n       state.rp2 = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n   }\n\n   // SZP0[] Set Zone Pointer 0\n   // 0x13\n   function SZP0(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n       state.zp0 = n;\n\n       switch (n) {\n           case 0:\n               if (!state.tZone) { initTZone(state); }\n               state.z0 = state.tZone;\n               break;\n           case 1 :\n               state.z0 = state.gZone;\n               break;\n           default :\n               throw new Error('Invalid zone pointer');\n       }\n   }\n\n   // SZP1[] Set Zone Pointer 1\n   // 0x14\n   function SZP1(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n       state.zp1 = n;\n\n       switch (n) {\n           case 0:\n               if (!state.tZone) { initTZone(state); }\n               state.z1 = state.tZone;\n               break;\n           case 1 :\n               state.z1 = state.gZone;\n               break;\n           default :\n               throw new Error('Invalid zone pointer');\n       }\n   }\n\n   // SZP2[] Set Zone Pointer 2\n   // 0x15\n   function SZP2(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n       state.zp2 = n;\n\n       switch (n) {\n           case 0:\n               if (!state.tZone) { initTZone(state); }\n               state.z2 = state.tZone;\n               break;\n           case 1 :\n               state.z2 = state.gZone;\n               break;\n           default :\n               throw new Error('Invalid zone pointer');\n       }\n   }\n\n   // SZPS[] Set Zone PointerS\n   // 0x16\n   function SZPS(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n       state.zp0 = state.zp1 = state.zp2 = n;\n\n       switch (n) {\n           case 0:\n               if (!state.tZone) { initTZone(state); }\n               state.z0 = state.z1 = state.z2 = state.tZone;\n               break;\n           case 1 :\n               state.z0 = state.z1 = state.z2 = state.gZone;\n               break;\n           default :\n               throw new Error('Invalid zone pointer');\n       }\n   }\n\n   // SLOOP[] Set LOOP variable\n   // 0x17\n   function SLOOP(state) {\n       state.loop = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n   }\n\n   // RTG[] Round To Grid\n   // 0x18\n   function RTG(state) {\n       if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n       state.round = roundToGrid;\n   }\n\n   // RTHG[] Round To Half Grid\n   // 0x19\n   function RTHG(state) {\n       if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n       state.round = roundToHalfGrid;\n   }\n\n   // SMD[] Set Minimum Distance\n   // 0x1A\n   function SMD(state) {\n       var d = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n       state.minDis = d / 0x40;\n   }\n\n   // ELSE[] ELSE clause\n   // 0x1B\n   function ELSE(state) {\n       // This instruction has been reached by executing a then branch\n       // so it just skips ahead until matching EIF.\n       //\n       // In case the IF was negative the IF[] instruction already\n       // skipped forward over the ELSE[]\n\n       if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n       skip(state, false);\n   }\n\n   // JMPR[] JuMP Relative\n   // 0x1C\n   function JMPR(state) {\n       var o = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n       // A jump by 1 would do nothing.\n       state.ip += o - 1;\n   }\n\n   // SCVTCI[] Set Control Value Table Cut-In\n   // 0x1D\n   function SCVTCI(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n       state.cvCutIn = n / 0x40;\n   }\n\n   // DUP[] DUPlicate top stack element\n   // 0x20\n   function DUP(state) {\n       var stack = state.stack;\n\n       if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n       stack.push(stack[stack.length - 1]);\n   }\n\n   // POP[] POP top stack element\n   // 0x21\n   function POP(state) {\n       if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n       state.stack.pop();\n   }\n\n   // CLEAR[] CLEAR the stack\n   // 0x22\n   function CLEAR(state) {\n       if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n       state.stack.length = 0;\n   }\n\n   // SWAP[] SWAP the top two elements on the stack\n   // 0x23\n   function SWAP(state) {\n       var stack = state.stack;\n\n       var a = stack.pop();\n       var b = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n       stack.push(a);\n       stack.push(b);\n   }\n\n   // DEPTH[] DEPTH of the stack\n   // 0x24\n   function DEPTH(state) {\n       var stack = state.stack;\n\n       if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n       stack.push(stack.length);\n   }\n\n   // LOOPCALL[] LOOPCALL function\n   // 0x2A\n   function LOOPCALL(state) {\n       var stack = state.stack;\n       var fn = stack.pop();\n       var c = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n       // saves callers program\n       var cip = state.ip;\n       var cprog = state.prog;\n\n       state.prog = state.funcs[fn];\n\n       // executes the function\n       for (var i = 0; i < c; i++) {\n           exec(state);\n\n           if (exports.DEBUG) { console.log(\n               ++state.step,\n               i + 1 < c ? 'next loopcall' : 'done loopcall',\n               i\n           ); }\n       }\n\n       // restores the callers program\n       state.ip = cip;\n       state.prog = cprog;\n   }\n\n   // CALL[] CALL function\n   // 0x2B\n   function CALL(state) {\n       var fn = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n       // saves callers program\n       var cip = state.ip;\n       var cprog = state.prog;\n\n       state.prog = state.funcs[fn];\n\n       // executes the function\n       exec(state);\n\n       // restores the callers program\n       state.ip = cip;\n       state.prog = cprog;\n\n       if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n   }\n\n   // CINDEX[] Copy the INDEXed element to the top of the stack\n   // 0x25\n   function CINDEX(state) {\n       var stack = state.stack;\n       var k = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n       // In case of k == 1, it copies the last element after popping\n       // thus stack.length - k.\n       stack.push(stack[stack.length - k]);\n   }\n\n   // MINDEX[] Move the INDEXed element to the top of the stack\n   // 0x26\n   function MINDEX(state) {\n       var stack = state.stack;\n       var k = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n       stack.push(stack.splice(stack.length - k, 1)[0]);\n   }\n\n   // FDEF[] Function DEFinition\n   // 0x2C\n   function FDEF(state) {\n       if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n       var stack = state.stack;\n       var prog = state.prog;\n       var ip = state.ip;\n\n       var fn = stack.pop();\n       var ipBegin = ip;\n\n       if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n       while (prog[++ip] !== 0x2D){ }\n\n       state.ip = ip;\n       state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n   }\n\n   // MDAP[a] Move Direct Absolute Point\n   // 0x2E-0x2F\n   function MDAP(round, state) {\n       var pi = state.stack.pop();\n       var p = state.z0[pi];\n       var fv = state.fv;\n       var pv = state.pv;\n\n       if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n       var d = pv.distance(p, HPZero);\n\n       if (round) { d = state.round(d); }\n\n       fv.setRelative(p, HPZero, d, pv);\n       fv.touch(p);\n\n       state.rp0 = state.rp1 = pi;\n   }\n\n   // IUP[a] Interpolate Untouched Points through the outline\n   // 0x30\n   function IUP(v, state) {\n       var z2 = state.z2;\n       var pLen = z2.length - 2;\n       var cp;\n       var pp;\n       var np;\n\n       if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n       for (var i = 0; i < pLen; i++) {\n           cp = z2[i]; // current point\n\n           // if this point has been touched go on\n           if (v.touched(cp)) { continue; }\n\n           pp = cp.prevTouched(v);\n\n           // no point on the contour has been touched?\n           if (pp === cp) { continue; }\n\n           np = cp.nextTouched(v);\n\n           if (pp === np) {\n               // only one point on the contour has been touched\n               // so simply moves the point like that\n\n               v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n           }\n\n           v.interpolate(cp, pp, np, v);\n       }\n   }\n\n   // SHP[] SHift Point using reference point\n   // 0x32-0x33\n   function SHP(a, state) {\n       var stack = state.stack;\n       var rpi = a ? state.rp1 : state.rp2;\n       var rp = (a ? state.z0 : state.z1)[rpi];\n       var fv = state.fv;\n       var pv = state.pv;\n       var loop = state.loop;\n       var z2 = state.z2;\n\n       while (loop--)\n       {\n           var pi = stack.pop();\n           var p = z2[pi];\n\n           var d = pv.distance(rp, rp, false, true);\n           fv.setRelative(p, p, d, pv);\n           fv.touch(p);\n\n           if (exports.DEBUG) {\n               console.log(\n                   state.step,\n                   (state.loop > 1 ?\n                      'loop ' + (state.loop - loop) + ': ' :\n                      ''\n                   ) +\n                   'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n               );\n           }\n       }\n\n       state.loop = 1;\n   }\n\n   // SHC[] SHift Contour using reference point\n   // 0x36-0x37\n   function SHC(a, state) {\n       var stack = state.stack;\n       var rpi = a ? state.rp1 : state.rp2;\n       var rp = (a ? state.z0 : state.z1)[rpi];\n       var fv = state.fv;\n       var pv = state.pv;\n       var ci = stack.pop();\n       var sp = state.z2[state.contours[ci]];\n       var p = sp;\n\n       if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n       var d = pv.distance(rp, rp, false, true);\n\n       do {\n           if (p !== rp) { fv.setRelative(p, p, d, pv); }\n           p = p.nextPointOnContour;\n       } while (p !== sp);\n   }\n\n   // SHZ[] SHift Zone using reference point\n   // 0x36-0x37\n   function SHZ(a, state) {\n       var stack = state.stack;\n       var rpi = a ? state.rp1 : state.rp2;\n       var rp = (a ? state.z0 : state.z1)[rpi];\n       var fv = state.fv;\n       var pv = state.pv;\n\n       var e = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n       var z;\n       switch (e) {\n           case 0 : z = state.tZone; break;\n           case 1 : z = state.gZone; break;\n           default : throw new Error('Invalid zone');\n       }\n\n       var p;\n       var d = pv.distance(rp, rp, false, true);\n       var pLen = z.length - 2;\n       for (var i = 0; i < pLen; i++)\n       {\n           p = z[i];\n           fv.setRelative(p, p, d, pv);\n           //if (p !== rp) fv.setRelative(p, p, d, pv);\n       }\n   }\n\n   // SHPIX[] SHift point by a PIXel amount\n   // 0x38\n   function SHPIX(state) {\n       var stack = state.stack;\n       var loop = state.loop;\n       var fv = state.fv;\n       var d = stack.pop() / 0x40;\n       var z2 = state.z2;\n\n       while (loop--) {\n           var pi = stack.pop();\n           var p = z2[pi];\n\n           if (exports.DEBUG) {\n               console.log(\n                   state.step,\n                   (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                   'SHPIX[]', pi, d\n               );\n           }\n\n           fv.setRelative(p, p, d);\n           fv.touch(p);\n       }\n\n       state.loop = 1;\n   }\n\n   // IP[] Interpolate Point\n   // 0x39\n   function IP(state) {\n       var stack = state.stack;\n       var rp1i = state.rp1;\n       var rp2i = state.rp2;\n       var loop = state.loop;\n       var rp1 = state.z0[rp1i];\n       var rp2 = state.z1[rp2i];\n       var fv = state.fv;\n       var pv = state.dpv;\n       var z2 = state.z2;\n\n       while (loop--) {\n           var pi = stack.pop();\n           var p = z2[pi];\n\n           if (exports.DEBUG) {\n               console.log(\n                   state.step,\n                   (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                   'IP[]', pi, rp1i, '<->', rp2i\n               );\n           }\n\n           fv.interpolate(p, rp1, rp2, pv);\n\n           fv.touch(p);\n       }\n\n       state.loop = 1;\n   }\n\n   // MSIRP[a] Move Stack Indirect Relative Point\n   // 0x3A-0x3B\n   function MSIRP(a, state) {\n       var stack = state.stack;\n       var d = stack.pop() / 64;\n       var pi = stack.pop();\n       var p = state.z1[pi];\n       var rp0 = state.z0[state.rp0];\n       var fv = state.fv;\n       var pv = state.pv;\n\n       fv.setRelative(p, rp0, d, pv);\n       fv.touch(p);\n\n       if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n       state.rp1 = state.rp0;\n       state.rp2 = pi;\n       if (a) { state.rp0 = pi; }\n   }\n\n   // ALIGNRP[] Align to reference point.\n   // 0x3C\n   function ALIGNRP(state) {\n       var stack = state.stack;\n       var rp0i = state.rp0;\n       var rp0 = state.z0[rp0i];\n       var loop = state.loop;\n       var fv = state.fv;\n       var pv = state.pv;\n       var z1 = state.z1;\n\n       while (loop--) {\n           var pi = stack.pop();\n           var p = z1[pi];\n\n           if (exports.DEBUG) {\n               console.log(\n                   state.step,\n                   (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                   'ALIGNRP[]', pi\n               );\n           }\n\n           fv.setRelative(p, rp0, 0, pv);\n           fv.touch(p);\n       }\n\n       state.loop = 1;\n   }\n\n   // RTG[] Round To Double Grid\n   // 0x3D\n   function RTDG(state) {\n       if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n       state.round = roundToDoubleGrid;\n   }\n\n   // MIAP[a] Move Indirect Absolute Point\n   // 0x3E-0x3F\n   function MIAP(round, state) {\n       var stack = state.stack;\n       var n = stack.pop();\n       var pi = stack.pop();\n       var p = state.z0[pi];\n       var fv = state.fv;\n       var pv = state.pv;\n       var cv = state.cvt[n];\n\n       if (exports.DEBUG) {\n           console.log(\n               state.step,\n               'MIAP[' + round + ']',\n               n, '(', cv, ')', pi\n           );\n       }\n\n       var d = pv.distance(p, HPZero);\n\n       if (round) {\n           if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n           d = state.round(d);\n       }\n\n       fv.setRelative(p, HPZero, d, pv);\n\n       if (state.zp0 === 0) {\n           p.xo = p.x;\n           p.yo = p.y;\n       }\n\n       fv.touch(p);\n\n       state.rp0 = state.rp1 = pi;\n   }\n\n   // NPUSB[] PUSH N Bytes\n   // 0x40\n   function NPUSHB(state) {\n       var prog = state.prog;\n       var ip = state.ip;\n       var stack = state.stack;\n\n       var n = prog[++ip];\n\n       if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n       for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n       state.ip = ip;\n   }\n\n   // NPUSHW[] PUSH N Words\n   // 0x41\n   function NPUSHW(state) {\n       var ip = state.ip;\n       var prog = state.prog;\n       var stack = state.stack;\n       var n = prog[++ip];\n\n       if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n       for (var i = 0; i < n; i++) {\n           var w = (prog[++ip] << 8) | prog[++ip];\n           if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n           stack.push(w);\n       }\n\n       state.ip = ip;\n   }\n\n   // WS[] Write Store\n   // 0x42\n   function WS(state) {\n       var stack = state.stack;\n       var store = state.store;\n\n       if (!store) { store = state.store = []; }\n\n       var v = stack.pop();\n       var l = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n       store[l] = v;\n   }\n\n   // RS[] Read Store\n   // 0x43\n   function RS(state) {\n       var stack = state.stack;\n       var store = state.store;\n\n       var l = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n       var v = (store && store[l]) || 0;\n\n       stack.push(v);\n   }\n\n   // WCVTP[] Write Control Value Table in Pixel units\n   // 0x44\n   function WCVTP(state) {\n       var stack = state.stack;\n\n       var v = stack.pop();\n       var l = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n       state.cvt[l] = v / 0x40;\n   }\n\n   // RCVT[] Read Control Value Table entry\n   // 0x45\n   function RCVT(state) {\n       var stack = state.stack;\n       var cvte = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n       stack.push(state.cvt[cvte] * 0x40);\n   }\n\n   // GC[] Get Coordinate projected onto the projection vector\n   // 0x46-0x47\n   function GC(a, state) {\n       var stack = state.stack;\n       var pi = stack.pop();\n       var p = state.z2[pi];\n\n       if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n       stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n   }\n\n   // MD[a] Measure Distance\n   // 0x49-0x4A\n   function MD(a, state) {\n       var stack = state.stack;\n       var pi2 = stack.pop();\n       var pi1 = stack.pop();\n       var p2 = state.z1[pi2];\n       var p1 = state.z0[pi1];\n       var d = state.dpv.distance(p1, p2, a, a);\n\n       if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n       state.stack.push(Math.round(d * 64));\n   }\n\n   // MPPEM[] Measure Pixels Per EM\n   // 0x4B\n   function MPPEM(state) {\n       if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n       state.stack.push(state.ppem);\n   }\n\n   // FLIPON[] set the auto FLIP Boolean to ON\n   // 0x4D\n   function FLIPON(state) {\n       if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n       state.autoFlip = true;\n   }\n\n   // LT[] Less Than\n   // 0x50\n   function LT(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n       stack.push(e1 < e2 ? 1 : 0);\n   }\n\n   // LTEQ[] Less Than or EQual\n   // 0x53\n   function LTEQ(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n       stack.push(e1 <= e2 ? 1 : 0);\n   }\n\n   // GTEQ[] Greater Than\n   // 0x52\n   function GT(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n       stack.push(e1 > e2 ? 1 : 0);\n   }\n\n   // GTEQ[] Greater Than or EQual\n   // 0x53\n   function GTEQ(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n       stack.push(e1 >= e2 ? 1 : 0);\n   }\n\n   // EQ[] EQual\n   // 0x54\n   function EQ(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n       stack.push(e2 === e1 ? 1 : 0);\n   }\n\n   // NEQ[] Not EQual\n   // 0x55\n   function NEQ(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n       stack.push(e2 !== e1 ? 1 : 0);\n   }\n\n   // ODD[] ODD\n   // 0x56\n   function ODD(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n       stack.push(Math.trunc(n) % 2 ? 1 : 0);\n   }\n\n   // EVEN[] EVEN\n   // 0x57\n   function EVEN(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n       stack.push(Math.trunc(n) % 2 ? 0 : 1);\n   }\n\n   // IF[] IF test\n   // 0x58\n   function IF(state) {\n       var test = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n       // if test is true it just continues\n       // if not the ip is skipped until matching ELSE or EIF\n       if (!test) {\n           skip(state, true);\n\n           if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n       }\n   }\n\n   // EIF[] End IF\n   // 0x59\n   function EIF(state) {\n       // this can be reached normally when\n       // executing an else branch.\n       // -> just ignore it\n\n       if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n   }\n\n   // AND[] logical AND\n   // 0x5A\n   function AND(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n       stack.push(e2 && e1 ? 1 : 0);\n   }\n\n   // OR[] logical OR\n   // 0x5B\n   function OR(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n       stack.push(e2 || e1 ? 1 : 0);\n   }\n\n   // NOT[] logical NOT\n   // 0x5C\n   function NOT(state) {\n       var stack = state.stack;\n       var e = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n       stack.push(e ? 0 : 1);\n   }\n\n   // DELTAP1[] DELTA exception P1\n   // DELTAP2[] DELTA exception P2\n   // DELTAP3[] DELTA exception P3\n   // 0x5D, 0x71, 0x72\n   function DELTAP123(b, state) {\n       var stack = state.stack;\n       var n = stack.pop();\n       var fv = state.fv;\n       var pv = state.pv;\n       var ppem = state.ppem;\n       var base = state.deltaBase + (b - 1) * 16;\n       var ds = state.deltaShift;\n       var z0 = state.z0;\n\n       if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n       for (var i = 0; i < n; i++) {\n           var pi = stack.pop();\n           var arg = stack.pop();\n           var appem = base + ((arg & 0xF0) >> 4);\n           if (appem !== ppem) { continue; }\n\n           var mag = (arg & 0x0F) - 8;\n           if (mag >= 0) { mag++; }\n           if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n           var p = z0[pi];\n           fv.setRelative(p, p, mag * ds, pv);\n       }\n   }\n\n   // SDB[] Set Delta Base in the graphics state\n   // 0x5E\n   function SDB(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n       state.deltaBase = n;\n   }\n\n   // SDS[] Set Delta Shift in the graphics state\n   // 0x5F\n   function SDS(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n       state.deltaShift = Math.pow(0.5, n);\n   }\n\n   // ADD[] ADD\n   // 0x60\n   function ADD(state) {\n       var stack = state.stack;\n       var n2 = stack.pop();\n       var n1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n       stack.push(n1 + n2);\n   }\n\n   // SUB[] SUB\n   // 0x61\n   function SUB(state) {\n       var stack = state.stack;\n       var n2 = stack.pop();\n       var n1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n       stack.push(n1 - n2);\n   }\n\n   // DIV[] DIV\n   // 0x62\n   function DIV(state) {\n       var stack = state.stack;\n       var n2 = stack.pop();\n       var n1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n       stack.push(n1 * 64 / n2);\n   }\n\n   // MUL[] MUL\n   // 0x63\n   function MUL(state) {\n       var stack = state.stack;\n       var n2 = stack.pop();\n       var n1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n       stack.push(n1 * n2 / 64);\n   }\n\n   // ABS[] ABSolute value\n   // 0x64\n   function ABS(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n       stack.push(Math.abs(n));\n   }\n\n   // NEG[] NEGate\n   // 0x65\n   function NEG(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n       stack.push(-n);\n   }\n\n   // FLOOR[] FLOOR\n   // 0x66\n   function FLOOR(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n       stack.push(Math.floor(n / 0x40) * 0x40);\n   }\n\n   // CEILING[] CEILING\n   // 0x67\n   function CEILING(state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n       stack.push(Math.ceil(n / 0x40) * 0x40);\n   }\n\n   // ROUND[ab] ROUND value\n   // 0x68-0x6B\n   function ROUND(dt, state) {\n       var stack = state.stack;\n       var n = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n       stack.push(state.round(n / 0x40) * 0x40);\n   }\n\n   // WCVTF[] Write Control Value Table in Funits\n   // 0x70\n   function WCVTF(state) {\n       var stack = state.stack;\n       var v = stack.pop();\n       var l = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n       state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n   }\n\n   // DELTAC1[] DELTA exception C1\n   // DELTAC2[] DELTA exception C2\n   // DELTAC3[] DELTA exception C3\n   // 0x73, 0x74, 0x75\n   function DELTAC123(b, state) {\n       var stack = state.stack;\n       var n = stack.pop();\n       var ppem = state.ppem;\n       var base = state.deltaBase + (b - 1) * 16;\n       var ds = state.deltaShift;\n\n       if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n       for (var i = 0; i < n; i++) {\n           var c = stack.pop();\n           var arg = stack.pop();\n           var appem = base + ((arg & 0xF0) >> 4);\n           if (appem !== ppem) { continue; }\n\n           var mag = (arg & 0x0F) - 8;\n           if (mag >= 0) { mag++; }\n\n           var delta = mag * ds;\n\n           if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n           state.cvt[c] += delta;\n       }\n   }\n\n   // SROUND[] Super ROUND\n   // 0x76\n   function SROUND(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n       state.round = roundSuper;\n\n       var period;\n\n       switch (n & 0xC0) {\n           case 0x00:\n               period = 0.5;\n               break;\n           case 0x40:\n               period = 1;\n               break;\n           case 0x80:\n               period = 2;\n               break;\n           default:\n               throw new Error('invalid SROUND value');\n       }\n\n       state.srPeriod = period;\n\n       switch (n & 0x30) {\n           case 0x00:\n               state.srPhase = 0;\n               break;\n           case 0x10:\n               state.srPhase = 0.25 * period;\n               break;\n           case 0x20:\n               state.srPhase = 0.5  * period;\n               break;\n           case 0x30:\n               state.srPhase = 0.75 * period;\n               break;\n           default: throw new Error('invalid SROUND value');\n       }\n\n       n &= 0x0F;\n\n       if (n === 0) { state.srThreshold = 0; }\n       else { state.srThreshold = (n / 8 - 0.5) * period; }\n   }\n\n   // S45ROUND[] Super ROUND 45 degrees\n   // 0x77\n   function S45ROUND(state) {\n       var n = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n       state.round = roundSuper;\n\n       var period;\n\n       switch (n & 0xC0) {\n           case 0x00:\n               period = Math.sqrt(2) / 2;\n               break;\n           case 0x40:\n               period = Math.sqrt(2);\n               break;\n           case 0x80:\n               period = 2 * Math.sqrt(2);\n               break;\n           default:\n               throw new Error('invalid S45ROUND value');\n       }\n\n       state.srPeriod = period;\n\n       switch (n & 0x30) {\n           case 0x00:\n               state.srPhase = 0;\n               break;\n           case 0x10:\n               state.srPhase = 0.25 * period;\n               break;\n           case 0x20:\n               state.srPhase = 0.5  * period;\n               break;\n           case 0x30:\n               state.srPhase = 0.75 * period;\n               break;\n           default:\n               throw new Error('invalid S45ROUND value');\n       }\n\n       n &= 0x0F;\n\n       if (n === 0) { state.srThreshold = 0; }\n       else { state.srThreshold = (n / 8 - 0.5) * period; }\n   }\n\n   // ROFF[] Round Off\n   // 0x7A\n   function ROFF(state) {\n       if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n       state.round = roundOff;\n   }\n\n   // RUTG[] Round Up To Grid\n   // 0x7C\n   function RUTG(state) {\n       if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n       state.round = roundUpToGrid;\n   }\n\n   // RDTG[] Round Down To Grid\n   // 0x7D\n   function RDTG(state) {\n       if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n       state.round = roundDownToGrid;\n   }\n\n   // SCANCTRL[] SCAN conversion ConTRoL\n   // 0x85\n   function SCANCTRL(state) {\n       var n = state.stack.pop();\n\n       // ignored by opentype.js\n\n       if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n   }\n\n   // SDPVTL[a] Set Dual Projection Vector To Line\n   // 0x86-0x87\n   function SDPVTL(a, state) {\n       var stack = state.stack;\n       var p2i = stack.pop();\n       var p1i = stack.pop();\n       var p2 = state.z2[p2i];\n       var p1 = state.z1[p1i];\n\n       if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n       var dx;\n       var dy;\n\n       if (!a) {\n           dx = p1.x - p2.x;\n           dy = p1.y - p2.y;\n       } else {\n           dx = p2.y - p1.y;\n           dy = p1.x - p2.x;\n       }\n\n       state.dpv = getUnitVector(dx, dy);\n   }\n\n   // GETINFO[] GET INFOrmation\n   // 0x88\n   function GETINFO(state) {\n       var stack = state.stack;\n       var sel = stack.pop();\n       var r = 0;\n\n       if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n       // v35 as in no subpixel hinting\n       if (sel & 0x01) { r = 35; }\n\n       // TODO rotation and stretch currently not supported\n       // and thus those GETINFO are always 0.\n\n       // opentype.js is always gray scaling\n       if (sel & 0x20) { r |= 0x1000; }\n\n       stack.push(r);\n   }\n\n   // ROLL[] ROLL the top three stack elements\n   // 0x8A\n   function ROLL(state) {\n       var stack = state.stack;\n       var a = stack.pop();\n       var b = stack.pop();\n       var c = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n       stack.push(b);\n       stack.push(a);\n       stack.push(c);\n   }\n\n   // MAX[] MAXimum of top two stack elements\n   // 0x8B\n   function MAX(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n       stack.push(Math.max(e1, e2));\n   }\n\n   // MIN[] MINimum of top two stack elements\n   // 0x8C\n   function MIN(state) {\n       var stack = state.stack;\n       var e2 = stack.pop();\n       var e1 = stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n       stack.push(Math.min(e1, e2));\n   }\n\n   // SCANTYPE[] SCANTYPE\n   // 0x8D\n   function SCANTYPE(state) {\n       var n = state.stack.pop();\n       // ignored by opentype.js\n       if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n   }\n\n   // INSTCTRL[] INSTCTRL\n   // 0x8D\n   function INSTCTRL(state) {\n       var s = state.stack.pop();\n       var v = state.stack.pop();\n\n       if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n       switch (s) {\n           case 1 : state.inhibitGridFit = !!v; return;\n           case 2 : state.ignoreCvt = !!v; return;\n           default: throw new Error('invalid INSTCTRL[] selector');\n       }\n   }\n\n   // PUSHB[abc] PUSH Bytes\n   // 0xB0-0xB7\n   function PUSHB(n, state) {\n       var stack = state.stack;\n       var prog = state.prog;\n       var ip = state.ip;\n\n       if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n       for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n       state.ip = ip;\n   }\n\n   // PUSHW[abc] PUSH Words\n   // 0xB8-0xBF\n   function PUSHW(n, state) {\n       var ip = state.ip;\n       var prog = state.prog;\n       var stack = state.stack;\n\n       if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n       for (var i = 0; i < n; i++) {\n           var w = (prog[++ip] << 8) | prog[++ip];\n           if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n           stack.push(w);\n       }\n\n       state.ip = ip;\n   }\n\n   // MDRP[abcde] Move Direct Relative Point\n   // 0xD0-0xEF\n   // (if indirect is 0)\n   //\n   // and\n   //\n   // MIRP[abcde] Move Indirect Relative Point\n   // 0xE0-0xFF\n   // (if indirect is 1)\n\n   function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n       var stack = state.stack;\n       var cvte = indirect && stack.pop();\n       var pi = stack.pop();\n       var rp0i = state.rp0;\n       var rp = state.z0[rp0i];\n       var p = state.z1[pi];\n\n       var md = state.minDis;\n       var fv = state.fv;\n       var pv = state.dpv;\n       var od; // original distance\n       var d; // moving distance\n       var sign; // sign of distance\n       var cv;\n\n       d = od = pv.distance(p, rp, true, true);\n       sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n       // TODO consider autoFlip\n       d = Math.abs(d);\n\n       if (indirect) {\n           cv = state.cvt[cvte];\n\n           if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n       }\n\n       if (keepD && d < md) { d = md; }\n\n       if (ro) { d = state.round(d); }\n\n       fv.setRelative(p, rp, sign * d, pv);\n       fv.touch(p);\n\n       if (exports.DEBUG) {\n           console.log(\n               state.step,\n               (indirect ? 'MIRP[' : 'MDRP[') +\n               (setRp0 ? 'M' : 'm') +\n               (keepD ? '>' : '_') +\n               (ro ? 'R' : '_') +\n               (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n               ']',\n               indirect ?\n                   cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                   '',\n               pi,\n               '(d =', od, '->', sign * d, ')'\n           );\n       }\n\n       state.rp1 = state.rp0;\n       state.rp2 = pi;\n       if (setRp0) { state.rp0 = pi; }\n   }\n\n   /*\n   * The instruction table.\n   */\n   instructionTable = [\n       /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n       /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n       /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n       /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n       /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n       /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n       /* 0x06 */ SPVTL.bind(undefined, 0),\n       /* 0x07 */ SPVTL.bind(undefined, 1),\n       /* 0x08 */ SFVTL.bind(undefined, 0),\n       /* 0x09 */ SFVTL.bind(undefined, 1),\n       /* 0x0A */ SPVFS,\n       /* 0x0B */ SFVFS,\n       /* 0x0C */ GPV,\n       /* 0x0D */ GFV,\n       /* 0x0E */ SFVTPV,\n       /* 0x0F */ ISECT,\n       /* 0x10 */ SRP0,\n       /* 0x11 */ SRP1,\n       /* 0x12 */ SRP2,\n       /* 0x13 */ SZP0,\n       /* 0x14 */ SZP1,\n       /* 0x15 */ SZP2,\n       /* 0x16 */ SZPS,\n       /* 0x17 */ SLOOP,\n       /* 0x18 */ RTG,\n       /* 0x19 */ RTHG,\n       /* 0x1A */ SMD,\n       /* 0x1B */ ELSE,\n       /* 0x1C */ JMPR,\n       /* 0x1D */ SCVTCI,\n       /* 0x1E */ undefined,   // TODO SSWCI\n       /* 0x1F */ undefined,   // TODO SSW\n       /* 0x20 */ DUP,\n       /* 0x21 */ POP,\n       /* 0x22 */ CLEAR,\n       /* 0x23 */ SWAP,\n       /* 0x24 */ DEPTH,\n       /* 0x25 */ CINDEX,\n       /* 0x26 */ MINDEX,\n       /* 0x27 */ undefined,   // TODO ALIGNPTS\n       /* 0x28 */ undefined,\n       /* 0x29 */ undefined,   // TODO UTP\n       /* 0x2A */ LOOPCALL,\n       /* 0x2B */ CALL,\n       /* 0x2C */ FDEF,\n       /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n       /* 0x2E */ MDAP.bind(undefined, 0),\n       /* 0x2F */ MDAP.bind(undefined, 1),\n       /* 0x30 */ IUP.bind(undefined, yUnitVector),\n       /* 0x31 */ IUP.bind(undefined, xUnitVector),\n       /* 0x32 */ SHP.bind(undefined, 0),\n       /* 0x33 */ SHP.bind(undefined, 1),\n       /* 0x34 */ SHC.bind(undefined, 0),\n       /* 0x35 */ SHC.bind(undefined, 1),\n       /* 0x36 */ SHZ.bind(undefined, 0),\n       /* 0x37 */ SHZ.bind(undefined, 1),\n       /* 0x38 */ SHPIX,\n       /* 0x39 */ IP,\n       /* 0x3A */ MSIRP.bind(undefined, 0),\n       /* 0x3B */ MSIRP.bind(undefined, 1),\n       /* 0x3C */ ALIGNRP,\n       /* 0x3D */ RTDG,\n       /* 0x3E */ MIAP.bind(undefined, 0),\n       /* 0x3F */ MIAP.bind(undefined, 1),\n       /* 0x40 */ NPUSHB,\n       /* 0x41 */ NPUSHW,\n       /* 0x42 */ WS,\n       /* 0x43 */ RS,\n       /* 0x44 */ WCVTP,\n       /* 0x45 */ RCVT,\n       /* 0x46 */ GC.bind(undefined, 0),\n       /* 0x47 */ GC.bind(undefined, 1),\n       /* 0x48 */ undefined,   // TODO SCFS\n       /* 0x49 */ MD.bind(undefined, 0),\n       /* 0x4A */ MD.bind(undefined, 1),\n       /* 0x4B */ MPPEM,\n       /* 0x4C */ undefined,   // TODO MPS\n       /* 0x4D */ FLIPON,\n       /* 0x4E */ undefined,   // TODO FLIPOFF\n       /* 0x4F */ undefined,   // TODO DEBUG\n       /* 0x50 */ LT,\n       /* 0x51 */ LTEQ,\n       /* 0x52 */ GT,\n       /* 0x53 */ GTEQ,\n       /* 0x54 */ EQ,\n       /* 0x55 */ NEQ,\n       /* 0x56 */ ODD,\n       /* 0x57 */ EVEN,\n       /* 0x58 */ IF,\n       /* 0x59 */ EIF,\n       /* 0x5A */ AND,\n       /* 0x5B */ OR,\n       /* 0x5C */ NOT,\n       /* 0x5D */ DELTAP123.bind(undefined, 1),\n       /* 0x5E */ SDB,\n       /* 0x5F */ SDS,\n       /* 0x60 */ ADD,\n       /* 0x61 */ SUB,\n       /* 0x62 */ DIV,\n       /* 0x63 */ MUL,\n       /* 0x64 */ ABS,\n       /* 0x65 */ NEG,\n       /* 0x66 */ FLOOR,\n       /* 0x67 */ CEILING,\n       /* 0x68 */ ROUND.bind(undefined, 0),\n       /* 0x69 */ ROUND.bind(undefined, 1),\n       /* 0x6A */ ROUND.bind(undefined, 2),\n       /* 0x6B */ ROUND.bind(undefined, 3),\n       /* 0x6C */ undefined,   // TODO NROUND[ab]\n       /* 0x6D */ undefined,   // TODO NROUND[ab]\n       /* 0x6E */ undefined,   // TODO NROUND[ab]\n       /* 0x6F */ undefined,   // TODO NROUND[ab]\n       /* 0x70 */ WCVTF,\n       /* 0x71 */ DELTAP123.bind(undefined, 2),\n       /* 0x72 */ DELTAP123.bind(undefined, 3),\n       /* 0x73 */ DELTAC123.bind(undefined, 1),\n       /* 0x74 */ DELTAC123.bind(undefined, 2),\n       /* 0x75 */ DELTAC123.bind(undefined, 3),\n       /* 0x76 */ SROUND,\n       /* 0x77 */ S45ROUND,\n       /* 0x78 */ undefined,   // TODO JROT[]\n       /* 0x79 */ undefined,   // TODO JROF[]\n       /* 0x7A */ ROFF,\n       /* 0x7B */ undefined,\n       /* 0x7C */ RUTG,\n       /* 0x7D */ RDTG,\n       /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n       /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n       /* 0x80 */ undefined,   // TODO FLIPPT\n       /* 0x81 */ undefined,   // TODO FLIPRGON\n       /* 0x82 */ undefined,   // TODO FLIPRGOFF\n       /* 0x83 */ undefined,\n       /* 0x84 */ undefined,\n       /* 0x85 */ SCANCTRL,\n       /* 0x86 */ SDPVTL.bind(undefined, 0),\n       /* 0x87 */ SDPVTL.bind(undefined, 1),\n       /* 0x88 */ GETINFO,\n       /* 0x89 */ undefined,   // TODO IDEF\n       /* 0x8A */ ROLL,\n       /* 0x8B */ MAX,\n       /* 0x8C */ MIN,\n       /* 0x8D */ SCANTYPE,\n       /* 0x8E */ INSTCTRL,\n       /* 0x8F */ undefined,\n       /* 0x90 */ undefined,\n       /* 0x91 */ undefined,\n       /* 0x92 */ undefined,\n       /* 0x93 */ undefined,\n       /* 0x94 */ undefined,\n       /* 0x95 */ undefined,\n       /* 0x96 */ undefined,\n       /* 0x97 */ undefined,\n       /* 0x98 */ undefined,\n       /* 0x99 */ undefined,\n       /* 0x9A */ undefined,\n       /* 0x9B */ undefined,\n       /* 0x9C */ undefined,\n       /* 0x9D */ undefined,\n       /* 0x9E */ undefined,\n       /* 0x9F */ undefined,\n       /* 0xA0 */ undefined,\n       /* 0xA1 */ undefined,\n       /* 0xA2 */ undefined,\n       /* 0xA3 */ undefined,\n       /* 0xA4 */ undefined,\n       /* 0xA5 */ undefined,\n       /* 0xA6 */ undefined,\n       /* 0xA7 */ undefined,\n       /* 0xA8 */ undefined,\n       /* 0xA9 */ undefined,\n       /* 0xAA */ undefined,\n       /* 0xAB */ undefined,\n       /* 0xAC */ undefined,\n       /* 0xAD */ undefined,\n       /* 0xAE */ undefined,\n       /* 0xAF */ undefined,\n       /* 0xB0 */ PUSHB.bind(undefined, 1),\n       /* 0xB1 */ PUSHB.bind(undefined, 2),\n       /* 0xB2 */ PUSHB.bind(undefined, 3),\n       /* 0xB3 */ PUSHB.bind(undefined, 4),\n       /* 0xB4 */ PUSHB.bind(undefined, 5),\n       /* 0xB5 */ PUSHB.bind(undefined, 6),\n       /* 0xB6 */ PUSHB.bind(undefined, 7),\n       /* 0xB7 */ PUSHB.bind(undefined, 8),\n       /* 0xB8 */ PUSHW.bind(undefined, 1),\n       /* 0xB9 */ PUSHW.bind(undefined, 2),\n       /* 0xBA */ PUSHW.bind(undefined, 3),\n       /* 0xBB */ PUSHW.bind(undefined, 4),\n       /* 0xBC */ PUSHW.bind(undefined, 5),\n       /* 0xBD */ PUSHW.bind(undefined, 6),\n       /* 0xBE */ PUSHW.bind(undefined, 7),\n       /* 0xBF */ PUSHW.bind(undefined, 8),\n       /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n       /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n       /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n       /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n       /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n       /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n       /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n       /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n       /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n       /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n       /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n       /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n       /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n       /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n       /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n       /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n       /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n       /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n       /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n       /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n       /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n       /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n       /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n       /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n       /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n       /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n       /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n       /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n       /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n       /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n       /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n       /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n       /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n       /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n       /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n       /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n       /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n       /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n       /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n       /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n       /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n       /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n       /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n       /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n       /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n       /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n       /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n       /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n       /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n       /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n       /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n       /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n       /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n       /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n       /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n       /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n       /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n       /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n       /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n       /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n       /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n       /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n       /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n       /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n   ];\n\n   /*****************************\n     Mathematical Considerations\n   ******************************\n\n   fv ... refers to freedom vector\n   pv ... refers to projection vector\n   rp ... refers to reference point\n   p  ... refers to to point being operated on\n   d  ... refers to distance\n\n   SETRELATIVE:\n   ============\n\n   case freedom vector == x-axis:\n   ------------------------------\n\n                           (pv)\n                        .-'\n                 rpd .-'\n                  .-*\n             d .-'90Â°'\n            .-'       '\n         .-'           '\n      *-'               ' b\n     rp                  '\n                          '\n                           '\n               p *----------*-------------- (fv)\n                             pm\n\n     rpdx = rpx + d * pv.x\n     rpdy = rpy + d * pv.y\n\n     equation of line b\n\n      y - rpdy = pvns * (x- rpdx)\n\n      y = p.y\n\n      x = rpdx + ( p.y - rpdy ) / pvns\n\n\n   case freedom vector == y-axis:\n   ------------------------------\n\n       * pm\n       |\\\n       | \\\n       |  \\\n       |   \\\n       |    \\\n       |     \\\n       |      \\\n       |       \\\n       |        \\\n       |         \\ b\n       |          \\\n       |           \\\n       |            \\    .-' (pv)\n       |         90Â° \\.-'\n       |           .-'* rpd\n       |        .-'\n       *     *-'  d\n       p     rp\n\n     rpdx = rpx + d * pv.x\n     rpdy = rpy + d * pv.y\n\n     equation of line b:\n              pvns ... normal slope to pv\n\n      y - rpdy = pvns * (x - rpdx)\n\n      x = p.x\n\n      y = rpdy +  pvns * (p.x - rpdx)\n\n\n\n   generic case:\n   -------------\n\n\n                                 .'(fv)\n                               .'\n                             .* pm\n                           .' !\n                         .'    .\n                       .'      !\n                     .'         . b\n                   .'           !\n                  *              .\n                 p               !\n                            90Â°   .    ... (pv)\n                              ...-*-'''\n                     ...---'''    rpd\n            ...---'''   d\n      *--'''\n     rp\n\n       rpdx = rpx + d * pv.x\n       rpdy = rpy + d * pv.y\n\n    equation of line b:\n       pvns... normal slope to pv\n\n       y - rpdy = pvns * (x - rpdx)\n\n    equation of freedom vector line:\n       fvs ... slope of freedom vector (=fy/fx)\n\n       y - py = fvs * (x - px)\n\n\n     on pm both equations are true for same x/y\n\n       y - rpdy = pvns * (x - rpdx)\n\n       y - py = fvs * (x - px)\n\n     form to y and set equal:\n\n       pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n     expand:\n\n       pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n     switch:\n\n       fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n     solve for x:\n\n       fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n             fvs * px - pvns * rpdx + rpdy - py\n       x =  -----------------------------------\n                    fvs - pvns\n\n     and:\n\n       y = fvs * (x - px) + py\n\n\n\n   INTERPOLATE:\n   ============\n\n   Examples of point interpolation.\n\n   The weight of the movement of the reference point gets bigger\n   the further the other reference point is away, thus the safest\n   option (that is avoiding 0/0 divisions) is to weight the\n   original distance of the other point by the sum of both distances.\n\n   If the sum of both distances is 0, then move the point by the\n   arithmetic average of the movement of both reference points.\n\n\n\n\n              (+6)\n       rp1o *---->*rp1\n            .     .                          (+12)\n            .     .                  rp2o *---------->* rp2\n            .     .                       .           .\n            .     .                       .           .\n            .    10          20           .           .\n            |.........|...................|           .\n                  .   .                               .\n                  .   . (+8)                          .\n                   po *------>*p                      .\n                  .           .                       .\n                  .    12     .          24           .\n                  |...........|.......................|\n                                     36\n\n\n   -------\n\n\n\n              (+10)\n       rp1o *-------->*rp1\n            .         .                      (-10)\n            .         .              rp2 *<---------* rpo2\n            .         .                   .         .\n            .         .                   .         .\n            .    10   .          30       .         .\n            |.........|.............................|\n                      .                   .\n                      . (+5)              .\n                   po *--->* p            .\n                      .    .              .\n                      .    .   20         .\n                      |....|..............|\n                        5        15\n\n\n   -------\n\n\n              (+10)\n       rp1o *-------->*rp1\n            .         .\n            .         .\n       rp2o *-------->*rp2\n\n\n                                  (+10)\n                             po *-------->* p\n\n   -------\n\n\n              (+10)\n       rp1o *-------->*rp1\n            .         .\n            .         .(+30)\n       rp2o *---------------------------->*rp2\n\n\n                                           (+25)\n                             po *----------------------->* p\n\n\n\n   vim: set ts=4 sw=4 expandtab:\n   *****/\n\n   /**\n    * Converts a string into a list of tokens.\n    */\n\n   /**\n    * Create a new token\n    * @param {string} char a single char\n    */\n   function Token(char) {\n       this.char = char;\n       this.state = {};\n       this.activeState = null;\n   }\n\n   /**\n    * Create a new context range\n    * @param {number} startIndex range start index\n    * @param {number} endOffset range end index offset\n    * @param {string} contextName owner context name\n    */\n   function ContextRange(startIndex, endOffset, contextName) {\n       this.contextName = contextName;\n       this.startIndex = startIndex;\n       this.endOffset = endOffset;\n   }\n\n   /**\n    * Check context start and end\n    * @param {string} contextName a unique context name\n    * @param {function} checkStart a predicate function the indicates a context's start\n    * @param {function} checkEnd a predicate function the indicates a context's end\n    */\n   function ContextChecker(contextName, checkStart, checkEnd) {\n       this.contextName = contextName;\n       this.openRange = null;\n       this.ranges = [];\n       this.checkStart = checkStart;\n       this.checkEnd = checkEnd;\n   }\n\n   /**\n    * @typedef ContextParams\n    * @type Object\n    * @property {array} context context items\n    * @property {number} currentIndex current item index\n    */\n\n   /**\n    * Create a context params\n    * @param {array} context a list of items\n    * @param {number} currentIndex current item index\n    */\n   function ContextParams(context, currentIndex) {\n       this.context = context;\n       this.index = currentIndex;\n       this.length = context.length;\n       this.current = context[currentIndex];\n       this.backtrack = context.slice(0, currentIndex);\n       this.lookahead = context.slice(currentIndex + 1);\n   }\n\n   /**\n    * Create an event instance\n    * @param {string} eventId event unique id\n    */\n   function Event(eventId) {\n       this.eventId = eventId;\n       this.subscribers = [];\n   }\n\n   /**\n    * Initialize a core events and auto subscribe required event handlers\n    * @param {any} events an object that enlists core events handlers\n    */\n   function initializeCoreEvents(events) {\n       var this$1 = this;\n\n       var coreEvents = [\n           'start', 'end', 'next', 'newToken', 'contextStart',\n           'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n           'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n       ];\n\n       coreEvents.forEach(function (eventId) {\n           Object.defineProperty(this$1.events, eventId, {\n               value: new Event(eventId)\n           });\n       });\n\n       if (!!events) {\n           coreEvents.forEach(function (eventId) {\n               var event = events[eventId];\n               if (typeof event === 'function') {\n                   this$1.events[eventId].subscribe(event);\n               }\n           });\n       }\n       var requiresContextUpdate = [\n           'insertToken', 'removeToken', 'removeRange',\n           'replaceToken', 'replaceRange', 'composeRUD'\n       ];\n       requiresContextUpdate.forEach(function (eventId) {\n           this$1.events[eventId].subscribe(\n               this$1.updateContextsRanges\n           );\n       });\n   }\n\n   /**\n    * Converts a string into a list of tokens\n    * @param {any} events tokenizer core events\n    */\n   function Tokenizer(events) {\n       this.tokens = [];\n       this.registeredContexts = {};\n       this.contextCheckers = [];\n       this.events = {};\n       this.registeredModifiers = [];\n\n       initializeCoreEvents.call(this, events);\n   }\n\n   /**\n    * Sets the state of a token, usually called by a state modifier.\n    * @param {string} key state item key\n    * @param {any} value state item value\n    */\n   Token.prototype.setState = function(key, value) {\n       this.state[key] = value;\n       this.activeState = { key: key, value: this.state[key] };\n       return this.activeState;\n   };\n\n   Token.prototype.getState = function (stateId) {\n       return this.state[stateId] || null;\n   };\n\n   /**\n    * Checks if an index exists in the tokens list.\n    * @param {number} index token index\n    */\n   Tokenizer.prototype.inboundIndex = function(index) {\n       return index >= 0 && index < this.tokens.length;\n   };\n\n   /**\n    * Compose and apply a list of operations (replace, update, delete)\n    * @param {array} RUDs replace, update and delete operations\n    * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n    */\n   Tokenizer.prototype.composeRUD = function (RUDs) {\n       var this$1 = this;\n\n       var silent = true;\n       var state = RUDs.map(function (RUD) { return (\n           this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n       ); });\n       var hasFAILObject = function (obj) { return (\n           typeof obj === 'object' &&\n           obj.hasOwnProperty('FAIL')\n       ); };\n       if (state.every(hasFAILObject)) {\n           return {\n               FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n               report: state.filter(hasFAILObject)\n           };\n       }\n       this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n   };\n\n   /**\n    * Replace a range of tokens with a list of tokens\n    * @param {number} startIndex range start index\n    * @param {number} offset range offset\n    * @param {token} tokens a list of tokens to replace\n    * @param {boolean} silent dispatch events and update context ranges\n    */\n   Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n       offset = offset !== null ? offset : this.tokens.length;\n       var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n       if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n           var replaced = this.tokens.splice.apply(\n               this.tokens, [startIndex, offset].concat(tokens)\n           );\n           if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n           return [replaced, tokens];\n       } else {\n           return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n       }\n   };\n\n   /**\n    * Replace a token with another token\n    * @param {number} index token index\n    * @param {token} token a token to replace\n    * @param {boolean} silent dispatch events and update context ranges\n    */\n   Tokenizer.prototype.replaceToken = function (index, token, silent) {\n       if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n           var replaced = this.tokens.splice(index, 1, token);\n           if (!silent) { this.dispatch('replaceToken', [index, token]); }\n           return [replaced[0], token];\n       } else {\n           return { FAIL: 'replaceToken: invalid token or index.' };\n       }\n   };\n\n   /**\n    * Removes a range of tokens\n    * @param {number} startIndex range start index\n    * @param {number} offset range offset\n    * @param {boolean} silent dispatch events and update context ranges\n    */\n   Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n       offset = !isNaN(offset) ? offset : this.tokens.length;\n       var tokens = this.tokens.splice(startIndex, offset);\n       if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n       return tokens;\n   };\n\n   /**\n    * Remove a token at a certain index\n    * @param {number} index token index\n    * @param {boolean} silent dispatch events and update context ranges\n    */\n   Tokenizer.prototype.removeToken = function(index, silent) {\n       if (!isNaN(index) && this.inboundIndex(index)) {\n           var token = this.tokens.splice(index, 1);\n           if (!silent) { this.dispatch('removeToken', [token, index]); }\n           return token;\n       } else {\n           return { FAIL: 'removeToken: invalid token index.' };\n       }\n   };\n\n   /**\n    * Insert a list of tokens at a certain index\n    * @param {array} tokens a list of tokens to insert\n    * @param {number} index insert the list of tokens at index\n    * @param {boolean} silent dispatch events and update context ranges\n    */\n   Tokenizer.prototype.insertToken = function (tokens, index, silent) {\n       var tokenType = tokens.every(\n           function (token) { return token instanceof Token; }\n       );\n       if (tokenType) {\n           this.tokens.splice.apply(\n               this.tokens, [index, 0].concat(tokens)\n           );\n           if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n           return tokens;\n       } else {\n           return { FAIL: 'insertToken: invalid token(s).' };\n       }\n   };\n\n   /**\n    * A state modifier that is called on 'newToken' event\n    * @param {string} modifierId state modifier id\n    * @param {function} condition a predicate function that returns true or false\n    * @param {function} modifier a function to update token state\n    */\n   Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n       this.events.newToken.subscribe(function(token, contextParams) {\n           var conditionParams = [token, contextParams];\n           var canApplyModifier = (\n               condition === null ||\n               condition.apply(this, conditionParams) === true\n           );\n           var modifierParams = [token, contextParams];\n           if (canApplyModifier) {\n               var newStateValue = modifier.apply(this, modifierParams);\n               token.setState(modifierId, newStateValue);\n           }\n       });\n       this.registeredModifiers.push(modifierId);\n   };\n\n   /**\n    * Subscribe a handler to an event\n    * @param {function} eventHandler an event handler function\n    */\n   Event.prototype.subscribe = function (eventHandler) {\n       if (typeof eventHandler === 'function') {\n           return ((this.subscribers.push(eventHandler)) - 1);\n       } else {\n           return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n       }\n   };\n\n   /**\n    * Unsubscribe an event handler\n    * @param {string} subsId subscription id\n    */\n   Event.prototype.unsubscribe = function (subsId) {\n       this.subscribers.splice(subsId, 1);\n   };\n\n   /**\n    * Sets context params current value index\n    * @param {number} index context params current value index\n    */\n   ContextParams.prototype.setCurrentIndex = function(index) {\n       this.index = index;\n       this.current = this.context[index];\n       this.backtrack = this.context.slice(0, index);\n       this.lookahead = this.context.slice(index + 1);\n   };\n\n   /**\n    * Get an item at an offset from the current value\n    * example (current value is 3):\n    *  1    2   [3]   4    5   |   items values\n    * -2   -1    0    1    2   |   offset values\n    * @param {number} offset an offset from current value index\n    */\n   ContextParams.prototype.get = function (offset) {\n       switch (true) {\n           case (offset === 0):\n               return this.current;\n           case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n               return this.backtrack.slice(offset)[0];\n           case (offset > 0 && offset <= this.lookahead.length):\n               return this.lookahead[offset - 1];\n           default:\n               return null;\n       }\n   };\n\n   /**\n    * Converts a context range into a string value\n    * @param {contextRange} range a context range\n    */\n   Tokenizer.prototype.rangeToText = function (range) {\n       if (range instanceof ContextRange) {\n           return (\n               this.getRangeTokens(range)\n                   .map(function (token) { return token.char; }).join('')\n           );\n       }\n   };\n\n   /**\n    * Converts all tokens into a string\n    */\n   Tokenizer.prototype.getText = function () {\n       return this.tokens.map(function (token) { return token.char; }).join('');\n   };\n\n   /**\n    * Get a context by name\n    * @param {string} contextName context name to get\n    */\n   Tokenizer.prototype.getContext = function (contextName) {\n       var context = this.registeredContexts[contextName];\n       return !!context ? context : null;\n   };\n\n   /**\n    * Subscribes a new event handler to an event\n    * @param {string} eventName event name to subscribe to\n    * @param {function} eventHandler a function to be invoked on event\n    */\n   Tokenizer.prototype.on = function(eventName, eventHandler) {\n       var event = this.events[eventName];\n       if (!!event) {\n           return event.subscribe(eventHandler);\n       } else {\n           return null;\n       }\n   };\n\n   /**\n    * Dispatches an event\n    * @param {string} eventName event name\n    * @param {any} args event handler arguments\n    */\n   Tokenizer.prototype.dispatch = function(eventName, args) {\n       var this$1 = this;\n\n       var event = this.events[eventName];\n       if (event instanceof Event) {\n           event.subscribers.forEach(function (subscriber) {\n               subscriber.apply(this$1, args || []);\n           });\n       }\n   };\n\n   /**\n    * Register a new context checker\n    * @param {string} contextName a unique context name\n    * @param {function} contextStartCheck a predicate function that returns true on context start\n    * @param {function} contextEndCheck  a predicate function that returns true on context end\n    * TODO: call tokenize on registration to update context ranges with the new context.\n    */\n   Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n       if (!!this.getContext(contextName)) { return {\n           FAIL:\n           (\"context name '\" + contextName + \"' is already registered.\")\n       }; }\n       if (typeof contextStartCheck !== 'function') { return {\n           FAIL:\n           \"missing context start check.\"\n       }; }\n       if (typeof contextEndCheck !== 'function') { return {\n           FAIL:\n           \"missing context end check.\"\n       }; }\n       var contextCheckers = new ContextChecker(\n           contextName, contextStartCheck, contextEndCheck\n       );\n       this.registeredContexts[contextName] = contextCheckers;\n       this.contextCheckers.push(contextCheckers);\n       return contextCheckers;\n   };\n\n   /**\n    * Gets a context range tokens\n    * @param {contextRange} range a context range\n    */\n   Tokenizer.prototype.getRangeTokens = function(range) {\n       var endIndex = range.startIndex + range.endOffset;\n       return [].concat(\n           this.tokens\n               .slice(range.startIndex, endIndex)\n       );\n   };\n\n   /**\n    * Gets the ranges of a context\n    * @param {string} contextName context name\n    */\n   Tokenizer.prototype.getContextRanges = function(contextName) {\n       var context = this.getContext(contextName);\n       if (!!context) {\n           return context.ranges;\n       } else {\n           return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n       }\n   };\n\n   /**\n    * Resets context ranges to run context update\n    */\n   Tokenizer.prototype.resetContextsRanges = function () {\n       var registeredContexts = this.registeredContexts;\n       for (var contextName in registeredContexts) {\n           if (registeredContexts.hasOwnProperty(contextName)) {\n               var context = registeredContexts[contextName];\n               context.ranges = [];\n           }\n       }\n   };\n\n   /**\n    * Updates context ranges\n    */\n   Tokenizer.prototype.updateContextsRanges = function () {\n       this.resetContextsRanges();\n       var chars = this.tokens.map(function (token) { return token.char; });\n       for (var i = 0; i < chars.length; i++) {\n           var contextParams = new ContextParams(chars, i);\n           this.runContextCheck(contextParams);\n       }\n       this.dispatch('updateContextsRanges', [this.registeredContexts]);\n   };\n\n   /**\n    * Sets the end offset of an open range\n    * @param {number} offset range end offset\n    * @param {string} contextName context name\n    */\n   Tokenizer.prototype.setEndOffset = function (offset, contextName) {\n       var startIndex = this.getContext(contextName).openRange.startIndex;\n       var range = new ContextRange(startIndex, offset, contextName);\n       var ranges = this.getContext(contextName).ranges;\n       range.rangeId = contextName + \".\" + (ranges.length);\n       ranges.push(range);\n       this.getContext(contextName).openRange = null;\n       return range;\n   };\n\n   /**\n    * Runs a context check on the current context\n    * @param {contextParams} contextParams current context params\n    */\n   Tokenizer.prototype.runContextCheck = function(contextParams) {\n       var this$1 = this;\n\n       var index = contextParams.index;\n       this.contextCheckers.forEach(function (contextChecker) {\n           var contextName = contextChecker.contextName;\n           var openRange = this$1.getContext(contextName).openRange;\n           if (!openRange && contextChecker.checkStart(contextParams)) {\n               openRange = new ContextRange(index, null, contextName);\n               this$1.getContext(contextName).openRange = openRange;\n               this$1.dispatch('contextStart', [contextName, index]);\n           }\n           if (!!openRange && contextChecker.checkEnd(contextParams)) {\n               var offset = (index - openRange.startIndex) + 1;\n               var range = this$1.setEndOffset(offset, contextName);\n               this$1.dispatch('contextEnd', [contextName, range]);\n           }\n       });\n   };\n\n   /**\n    * Converts a text into a list of tokens\n    * @param {string} text a text to tokenize\n    */\n   Tokenizer.prototype.tokenize = function (text) {\n       this.tokens = [];\n       this.resetContextsRanges();\n       var chars = Array.from(text);\n       this.dispatch('start');\n       for (var i = 0; i < chars.length; i++) {\n           var char = chars[i];\n           var contextParams = new ContextParams(chars, i);\n           this.dispatch('next', [contextParams]);\n           this.runContextCheck(contextParams);\n           var token = new Token(char);\n           this.tokens.push(token);\n           this.dispatch('newToken', [token, contextParams]);\n       }\n       this.dispatch('end', [this.tokens]);\n       return this.tokens;\n   };\n\n   // â­âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ®\n   // â Character Class Assertions â Checks if a char belongs to a certain class â\n   // â°ââ¾âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¯\n   // jscs:disable maximumLineLength\n   /**\n    * Check if a char is Arabic\n    * @param {string} c a single char\n    */\n   function isArabicChar(c) {\n       return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n   }\n\n   /**\n    * Check if a char is an isolated arabic char\n    * @param {string} c a single char\n    */\n   function isIsolatedArabicChar(char) {\n       return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n   }\n\n   /**\n    * Check if a char is an Arabic Tashkeel char\n    * @param {string} c a single char\n    */\n   function isTashkeelArabicChar(char) {\n       return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n   }\n\n   /**\n    * Check if a char is Latin\n    * @param {string} c a single char\n    */\n   function isLatinChar(c) {\n       return /[A-z]/.test(c);\n   }\n\n   /**\n    * Check if a char is whitespace char\n    * @param {string} c a single char\n    */\n   function isWhiteSpace(c) {\n       return /\\s/.test(c);\n   }\n\n   /**\n    * Query a feature by some of it's properties to lookup a glyph substitution.\n    */\n\n   /**\n    * Create feature query instance\n    * @param {Font} font opentype font instance\n    */\n   function FeatureQuery(font) {\n       this.font = font;\n       this.features = {};\n   }\n\n   /**\n    * @typedef SubstitutionAction\n    * @type Object\n    * @property {number} id substitution type\n    * @property {string} tag feature tag\n    * @property {any} substitution substitution value(s)\n    */\n\n   /**\n    * Create a substitution action instance\n    * @param {SubstitutionAction} action\n    */\n   function SubstitutionAction(action) {\n       this.id = action.id;\n       this.tag = action.tag;\n       this.substitution = action.substitution;\n   }\n\n   /**\n    * Lookup a coverage table\n    * @param {number} glyphIndex glyph index\n    * @param {CoverageTable} coverage coverage table\n    */\n   function lookupCoverage(glyphIndex, coverage) {\n       if (!glyphIndex) { return -1; }\n       switch (coverage.format) {\n           case 1:\n               return coverage.glyphs.indexOf(glyphIndex);\n\n           case 2:\n               var ranges = coverage.ranges;\n               for (var i = 0; i < ranges.length; i++) {\n                   var range = ranges[i];\n                   if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                       var offset = glyphIndex - range.start;\n                       return range.index + offset;\n                   }\n               }\n               break;\n           default:\n               return -1; // not found\n       }\n       return -1;\n   }\n\n   /**\n    * Handle a single substitution - format 1\n    * @param {ContextParams} contextParams context params to lookup\n    */\n   function singleSubstitutionFormat1(glyphIndex, subtable) {\n       var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n       if (substituteIndex === -1) { return null; }\n       return glyphIndex + subtable.deltaGlyphId;\n   }\n\n   /**\n    * Handle a single substitution - format 2\n    * @param {ContextParams} contextParams context params to lookup\n    */\n   function singleSubstitutionFormat2(glyphIndex, subtable) {\n       var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n       if (substituteIndex === -1) { return null; }\n       return subtable.substitute[substituteIndex];\n   }\n\n   /**\n    * Lookup a list of coverage tables\n    * @param {any} coverageList a list of coverage tables\n    * @param {ContextParams} contextParams context params to lookup\n    */\n   function lookupCoverageList(coverageList, contextParams) {\n       var lookupList = [];\n       for (var i = 0; i < coverageList.length; i++) {\n           var coverage = coverageList[i];\n           var glyphIndex = contextParams.current;\n           glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n           var lookupIndex = lookupCoverage(glyphIndex, coverage);\n           if (lookupIndex !== -1) {\n               lookupList.push(lookupIndex);\n           }\n       }\n       if (lookupList.length !== coverageList.length) { return -1; }\n       return lookupList;\n   }\n\n   /**\n    * Handle chaining context substitution - format 3\n    * @param {ContextParams} contextParams context params to lookup\n    */\n   function chainingSubstitutionFormat3(contextParams, subtable) {\n       var lookupsCount = (\n           subtable.inputCoverage.length +\n           subtable.lookaheadCoverage.length +\n           subtable.backtrackCoverage.length\n       );\n       if (contextParams.context.length < lookupsCount) { return []; }\n       // INPUT LOOKUP //\n       var inputLookups = lookupCoverageList(\n           subtable.inputCoverage, contextParams\n       );\n       if (inputLookups === -1) { return []; }\n       // LOOKAHEAD LOOKUP //\n       var lookaheadOffset = subtable.inputCoverage.length - 1;\n       if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n       var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n       while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n           lookaheadContext.shift();\n       }\n       var lookaheadParams = new ContextParams(lookaheadContext, 0);\n       var lookaheadLookups = lookupCoverageList(\n           subtable.lookaheadCoverage, lookaheadParams\n       );\n       // BACKTRACK LOOKUP //\n       var backtrackContext = [].concat(contextParams.backtrack);\n       backtrackContext.reverse();\n       while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n           backtrackContext.shift();\n       }\n       if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n       var backtrackParams = new ContextParams(backtrackContext, 0);\n       var backtrackLookups = lookupCoverageList(\n           subtable.backtrackCoverage, backtrackParams\n       );\n       var contextRulesMatch = (\n           inputLookups.length === subtable.inputCoverage.length &&\n           lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n           backtrackLookups.length === subtable.backtrackCoverage.length\n       );\n       var substitutions = [];\n       if (contextRulesMatch) {\n           for (var i = 0; i < subtable.lookupRecords.length; i++) {\n               var lookupRecord = subtable.lookupRecords[i];\n               var lookupListIndex = lookupRecord.lookupListIndex;\n               var lookupTable = this.getLookupByIndex(lookupListIndex);\n               for (var s = 0; s < lookupTable.subtables.length; s++) {\n                   var subtable$1 = lookupTable.subtables[s];\n                   var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                   var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                   if (substitutionType === '12') {\n                       for (var n = 0; n < inputLookups.length; n++) {\n                           var glyphIndex = contextParams.get(n);\n                           var substitution = lookup(glyphIndex);\n                           if (substitution) { substitutions.push(substitution); }\n                       }\n                   }\n               }\n           }\n       }\n       return substitutions;\n   }\n\n   /**\n    * Handle ligature substitution - format 1\n    * @param {ContextParams} contextParams context params to lookup\n    */\n   function ligatureSubstitutionFormat1(contextParams, subtable) {\n       // COVERAGE LOOKUP //\n       var glyphIndex = contextParams.current;\n       var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n       if (ligSetIndex === -1) { return null; }\n       // COMPONENTS LOOKUP\n       // (!) note, components are ordered in the written direction.\n       var ligature;\n       var ligatureSet = subtable.ligatureSets[ligSetIndex];\n       for (var s = 0; s < ligatureSet.length; s++) {\n           ligature = ligatureSet[s];\n           for (var l = 0; l < ligature.components.length; l++) {\n               var lookaheadItem = contextParams.lookahead[l];\n               var component = ligature.components[l];\n               if (lookaheadItem !== component) { break; }\n               if (l === ligature.components.length - 1) { return ligature; }\n           }\n       }\n       return null;\n   }\n\n   /**\n    * Handle decomposition substitution - format 1\n    * @param {number} glyphIndex glyph index\n    * @param {any} subtable subtable\n    */\n   function decompositionSubstitutionFormat1(glyphIndex, subtable) {\n       var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n       if (substituteIndex === -1) { return null; }\n       return subtable.sequences[substituteIndex];\n   }\n\n   /**\n    * Get default script features indexes\n    */\n   FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n       var scripts = this.font.tables.gsub.scripts;\n       for (var s = 0; s < scripts.length; s++) {\n           var script = scripts[s];\n           if (script.tag === 'DFLT') { return (\n               script.script.defaultLangSys.featureIndexes\n           ); }\n       }\n       return [];\n   };\n\n   /**\n    * Get feature indexes of a specific script\n    * @param {string} scriptTag script tag\n    */\n   FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n       var tables = this.font.tables;\n       if (!tables.gsub) { return []; }\n       if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n       var scripts = this.font.tables.gsub.scripts;\n       for (var i = 0; i < scripts.length; i++) {\n           var script = scripts[i];\n           if (script.tag === scriptTag && script.script.defaultLangSys) {\n               return script.script.defaultLangSys.featureIndexes;\n           } else {\n               var langSysRecords = script.langSysRecords;\n               if (!!langSysRecords) {\n                   for (var j = 0; j < langSysRecords.length; j++) {\n                       var langSysRecord = langSysRecords[j];\n                       if (langSysRecord.tag === scriptTag) {\n                           var langSys = langSysRecord.langSys;\n                           return langSys.featureIndexes;\n                       }\n                   }\n               }\n           }\n       }\n       return this.getDefaultScriptFeaturesIndexes();\n   };\n\n   /**\n    * Map a feature tag to a gsub feature\n    * @param {any} features gsub features\n    * @param {string} scriptTag script tag\n    */\n   FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n       var tags = {};\n       for (var i = 0; i < features.length; i++) {\n           var tag = features[i].tag;\n           var feature = features[i].feature;\n           tags[tag] = feature;\n       }\n       this.features[scriptTag].tags = tags;\n   };\n\n   /**\n    * Get features of a specific script\n    * @param {string} scriptTag script tag\n    */\n   FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n       var features = this.features[scriptTag];\n       if (this.features.hasOwnProperty(scriptTag)) { return features; }\n       var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n       if (!featuresIndexes) { return null; }\n       var gsub = this.font.tables.gsub;\n       features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n       this.features[scriptTag] = features;\n       this.mapTagsToFeatures(features, scriptTag);\n       return features;\n   };\n\n   /**\n    * Get substitution type\n    * @param {any} lookupTable lookup table\n    * @param {any} subtable subtable\n    */\n   FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n       var lookupType = lookupTable.lookupType.toString();\n       var substFormat = subtable.substFormat.toString();\n       return lookupType + substFormat;\n   };\n\n   /**\n    * Get lookup method\n    * @param {any} lookupTable lookup table\n    * @param {any} subtable subtable\n    */\n   FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n       var this$1 = this;\n\n       var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n       switch (substitutionType) {\n           case '11':\n               return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                   this$1, [glyphIndex, subtable]\n               ); };\n           case '12':\n               return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                   this$1, [glyphIndex, subtable]\n               ); };\n           case '63':\n               return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                   this$1, [contextParams, subtable]\n               ); };\n           case '41':\n               return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                   this$1, [contextParams, subtable]\n               ); };\n           case '21':\n               return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                   this$1, [glyphIndex, subtable]\n               ); };\n           default:\n               throw new Error(\n                   \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                   \"substFormat: \" + (subtable.substFormat) + \" \" +\n                   \"is not yet supported\"\n               );\n       }\n   };\n\n   /**\n    * [ LOOKUP TYPES ]\n    * -------------------------------\n    * Single                        1;\n    * Multiple                      2;\n    * Alternate                     3;\n    * Ligature                      4;\n    * Context                       5;\n    * ChainingContext               6;\n    * ExtensionSubstitution         7;\n    * ReverseChainingContext        8;\n    * -------------------------------\n    *\n    */\n\n   /**\n    * @typedef FQuery\n    * @type Object\n    * @param {string} tag feature tag\n    * @param {string} script feature script\n    * @param {ContextParams} contextParams context params\n    */\n\n   /**\n    * Lookup a feature using a query parameters\n    * @param {FQuery} query feature query\n    */\n   FeatureQuery.prototype.lookupFeature = function (query) {\n       var contextParams = query.contextParams;\n       var currentIndex = contextParams.index;\n       var feature = this.getFeature({\n           tag: query.tag, script: query.script\n       });\n       if (!feature) { return new Error(\n           \"font '\" + (this.font.names.fullName.en) + \"' \" +\n           \"doesn't support feature '\" + (query.tag) + \"' \" +\n           \"for script '\" + (query.script) + \"'.\"\n       ); }\n       var lookups = this.getFeatureLookups(feature);\n       var substitutions = [].concat(contextParams.context);\n       for (var l = 0; l < lookups.length; l++) {\n           var lookupTable = lookups[l];\n           var subtables = this.getLookupSubtables(lookupTable);\n           for (var s = 0; s < subtables.length; s++) {\n               var subtable = subtables[s];\n               var substType = this.getSubstitutionType(lookupTable, subtable);\n               var lookup = this.getLookupMethod(lookupTable, subtable);\n               var substitution = (void 0);\n               switch (substType) {\n                   case '11':\n                       substitution = lookup(contextParams.current);\n                       if (substitution) {\n                           substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                               id: 11, tag: query.tag, substitution: substitution\n                           }));\n                       }\n                       break;\n                   case '12':\n                       substitution = lookup(contextParams.current);\n                       if (substitution) {\n                           substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                               id: 12, tag: query.tag, substitution: substitution\n                           }));\n                       }\n                       break;\n                   case '63':\n                       substitution = lookup(contextParams);\n                       if (Array.isArray(substitution) && substitution.length) {\n                           substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                               id: 63, tag: query.tag, substitution: substitution\n                           }));\n                       }\n                       break;\n                   case '41':\n                       substitution = lookup(contextParams);\n                       if (substitution) {\n                           substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                               id: 41, tag: query.tag, substitution: substitution\n                           }));\n                       }\n                       break;\n                   case '21':\n                       substitution = lookup(contextParams.current);\n                       if (substitution) {\n                           substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                               id: 21, tag: query.tag, substitution: substitution\n                           }));\n                       }\n                       break;\n               }\n               contextParams = new ContextParams(substitutions, currentIndex);\n               if (Array.isArray(substitution) && !substitution.length) { continue; }\n               substitution = null;\n           }\n       }\n       return substitutions.length ? substitutions : null;\n   };\n\n   /**\n    * Checks if a font supports a specific features\n    * @param {FQuery} query feature query object\n    */\n   FeatureQuery.prototype.supports = function (query) {\n       if (!query.script) { return false; }\n       this.getScriptFeatures(query.script);\n       var supportedScript = this.features.hasOwnProperty(query.script);\n       if (!query.tag) { return supportedScript; }\n       var supportedFeature = (\n           this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n       );\n       return supportedScript && supportedFeature;\n   };\n\n   /**\n    * Get lookup table subtables\n    * @param {any} lookupTable lookup table\n    */\n   FeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n       return lookupTable.subtables || null;\n   };\n\n   /**\n    * Get lookup table by index\n    * @param {number} index lookup table index\n    */\n   FeatureQuery.prototype.getLookupByIndex = function (index) {\n       var lookups = this.font.tables.gsub.lookups;\n       return lookups[index] || null;\n   };\n\n   /**\n    * Get lookup tables for a feature\n    * @param {string} feature\n    */\n   FeatureQuery.prototype.getFeatureLookups = function (feature) {\n       // TODO: memoize\n       return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n   };\n\n   /**\n    * Query a feature by it's properties\n    * @param {any} query an object that describes the properties of a query\n    */\n   FeatureQuery.prototype.getFeature = function getFeature(query) {\n       if (!this.font) { return { FAIL: \"No font was found\"}; }\n       if (!this.features.hasOwnProperty(query.script)) {\n           this.getScriptFeatures(query.script);\n       }\n       var scriptFeatures = this.features[query.script];\n       if (!scriptFeatures) { return (\n           { FAIL: (\"No feature for script \" + (query.script))}\n       ); }\n       if (!scriptFeatures.tags[query.tag]) { return null; }\n       return this.features[query.script].tags[query.tag];\n   };\n\n   /**\n    * Arabic word context checkers\n    */\n\n   function arabicWordStartCheck(contextParams) {\n       var char = contextParams.current;\n       var prevChar = contextParams.get(-1);\n       return (\n           // ? arabic first char\n           (prevChar === null && isArabicChar(char)) ||\n           // ? arabic char preceded with a non arabic char\n           (!isArabicChar(prevChar) && isArabicChar(char))\n       );\n   }\n\n   function arabicWordEndCheck(contextParams) {\n       var nextChar = contextParams.get(1);\n       return (\n           // ? last arabic char\n           (nextChar === null) ||\n           // ? next char is not arabic\n           (!isArabicChar(nextChar))\n       );\n   }\n\n   var arabicWordCheck = {\n       startCheck: arabicWordStartCheck,\n       endCheck: arabicWordEndCheck\n   };\n\n   /**\n    * Arabic sentence context checkers\n    */\n\n   function arabicSentenceStartCheck(contextParams) {\n       var char = contextParams.current;\n       var prevChar = contextParams.get(-1);\n       return (\n           // ? an arabic char preceded with a non arabic char\n           (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n           !isArabicChar(prevChar)\n       );\n   }\n\n   function arabicSentenceEndCheck(contextParams) {\n       var nextChar = contextParams.get(1);\n       switch (true) {\n           case nextChar === null:\n               return true;\n           case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n               var nextIsWhitespace = isWhiteSpace(nextChar);\n               if (!nextIsWhitespace) { return true; }\n               if (nextIsWhitespace) {\n                   var arabicCharAhead = false;\n                   arabicCharAhead = (\n                       contextParams.lookahead.some(\n                           function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                       )\n                   );\n                   if (!arabicCharAhead) { return true; }\n               }\n               break;\n           default:\n               return false;\n       }\n   }\n\n   var arabicSentenceCheck = {\n       startCheck: arabicSentenceStartCheck,\n       endCheck: arabicSentenceEndCheck\n   };\n\n   /**\n    * Apply single substitution format 1\n    * @param {Array} substitutions substitutions\n    * @param {any} tokens a list of tokens\n    * @param {number} index token index\n    */\n   function singleSubstitutionFormat1$1(action, tokens, index) {\n       tokens[index].setState(action.tag, action.substitution);\n   }\n\n   /**\n    * Apply single substitution format 2\n    * @param {Array} substitutions substitutions\n    * @param {any} tokens a list of tokens\n    * @param {number} index token index\n    */\n   function singleSubstitutionFormat2$1(action, tokens, index) {\n       tokens[index].setState(action.tag, action.substitution);\n   }\n\n   /**\n    * Apply chaining context substitution format 3\n    * @param {Array} substitutions substitutions\n    * @param {any} tokens a list of tokens\n    * @param {number} index token index\n    */\n   function chainingSubstitutionFormat3$1(action, tokens, index) {\n       action.substitution.forEach(function (subst, offset) {\n           var token = tokens[index + offset];\n           token.setState(action.tag, subst);\n       });\n   }\n\n   /**\n    * Apply ligature substitution format 1\n    * @param {Array} substitutions substitutions\n    * @param {any} tokens a list of tokens\n    * @param {number} index token index\n    */\n   function ligatureSubstitutionFormat1$1(action, tokens, index) {\n       var token = tokens[index];\n       token.setState(action.tag, action.substitution.ligGlyph);\n       var compsCount = action.substitution.components.length;\n       for (var i = 0; i < compsCount; i++) {\n           token = tokens[index + i + 1];\n           token.setState('deleted', true);\n       }\n   }\n\n   /**\n    * Supported substitutions\n    */\n   var SUBSTITUTIONS = {\n       11: singleSubstitutionFormat1$1,\n       12: singleSubstitutionFormat2$1,\n       63: chainingSubstitutionFormat3$1,\n       41: ligatureSubstitutionFormat1$1\n   };\n\n   /**\n    * Apply substitutions to a list of tokens\n    * @param {Array} substitutions substitutions\n    * @param {any} tokens a list of tokens\n    * @param {number} index token index\n    */\n   function applySubstitution(action, tokens, index) {\n       if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n           SUBSTITUTIONS[action.id](action, tokens, index);\n       }\n   }\n\n   /**\n    * Apply Arabic presentation forms to a range of tokens\n    */\n\n   /**\n    * Check if a char can be connected to it's preceding char\n    * @param {ContextParams} charContextParams context params of a char\n    */\n   function willConnectPrev(charContextParams) {\n       var backtrack = [].concat(charContextParams.backtrack);\n       for (var i = backtrack.length - 1; i >= 0; i--) {\n           var prevChar = backtrack[i];\n           var isolated = isIsolatedArabicChar(prevChar);\n           var tashkeel = isTashkeelArabicChar(prevChar);\n           if (!isolated && !tashkeel) { return true; }\n           if (isolated) { return false; }\n       }\n       return false;\n   }\n\n   /**\n    * Check if a char can be connected to it's proceeding char\n    * @param {ContextParams} charContextParams context params of a char\n    */\n   function willConnectNext(charContextParams) {\n       if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n       for (var i = 0; i < charContextParams.lookahead.length; i++) {\n           var nextChar = charContextParams.lookahead[i];\n           var tashkeel = isTashkeelArabicChar(nextChar);\n           if (!tashkeel) { return true; }\n       }\n       return false;\n   }\n\n   /**\n    * Apply arabic presentation forms to a list of tokens\n    * @param {ContextRange} range a range of tokens\n    */\n   function arabicPresentationForms(range) {\n       var this$1 = this;\n\n       var script = 'arab';\n       var tags = this.featuresTags[script];\n       var tokens = this.tokenizer.getRangeTokens(range);\n       if (tokens.length === 1) { return; }\n       var contextParams = new ContextParams(\n           tokens.map(function (token) { return token.getState('glyphIndex'); }\n       ), 0);\n       var charContextParams = new ContextParams(\n           tokens.map(function (token) { return token.char; }\n       ), 0);\n       tokens.forEach(function (token, index) {\n           if (isTashkeelArabicChar(token.char)) { return; }\n           contextParams.setCurrentIndex(index);\n           charContextParams.setCurrentIndex(index);\n           var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n           if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n           if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n           var tag;\n           switch (CONNECT) {\n               case 1: (tag = 'fina'); break;\n               case 2: (tag = 'init'); break;\n               case 3: (tag = 'medi'); break;\n           }\n           if (tags.indexOf(tag) === -1) { return; }\n           var substitutions = this$1.query.lookupFeature({\n               tag: tag, script: script, contextParams: contextParams\n           });\n           if (substitutions instanceof Error) { return console.info(substitutions.message); }\n           substitutions.forEach(function (action, index) {\n               if (action instanceof SubstitutionAction) {\n                   applySubstitution(action, tokens, index);\n                   contextParams.context[index] = action.substitution;\n               }\n           });\n       });\n   }\n\n   /**\n    * Apply Arabic required ligatures feature to a range of tokens\n    */\n\n   /**\n    * Update context params\n    * @param {any} tokens a list of tokens\n    * @param {number} index current item index\n    */\n   function getContextParams(tokens, index) {\n       var context = tokens.map(function (token) { return token.activeState.value; });\n       return new ContextParams(context, index || 0);\n   }\n\n   /**\n    * Apply Arabic required ligatures to a context range\n    * @param {ContextRange} range a range of tokens\n    */\n   function arabicRequiredLigatures(range) {\n       var this$1 = this;\n\n       var script = 'arab';\n       var tokens = this.tokenizer.getRangeTokens(range);\n       var contextParams = getContextParams(tokens);\n       contextParams.context.forEach(function (glyphIndex, index) {\n           contextParams.setCurrentIndex(index);\n           var substitutions = this$1.query.lookupFeature({\n               tag: 'rlig', script: script, contextParams: contextParams\n           });\n           if (substitutions.length) {\n               substitutions.forEach(\n                   function (action) { return applySubstitution(action, tokens, index); }\n               );\n               contextParams = getContextParams(tokens);\n           }\n       });\n   }\n\n   /**\n    * Latin word context checkers\n    */\n\n   function latinWordStartCheck(contextParams) {\n       var char = contextParams.current;\n       var prevChar = contextParams.get(-1);\n       return (\n           // ? latin first char\n           (prevChar === null && isLatinChar(char)) ||\n           // ? latin char preceded with a non latin char\n           (!isLatinChar(prevChar) && isLatinChar(char))\n       );\n   }\n\n   function latinWordEndCheck(contextParams) {\n       var nextChar = contextParams.get(1);\n       return (\n           // ? last latin char\n           (nextChar === null) ||\n           // ? next char is not latin\n           (!isLatinChar(nextChar))\n       );\n   }\n\n   var latinWordCheck = {\n       startCheck: latinWordStartCheck,\n       endCheck: latinWordEndCheck\n   };\n\n   /**\n    * Apply Latin ligature feature to a range of tokens\n    */\n\n   /**\n    * Update context params\n    * @param {any} tokens a list of tokens\n    * @param {number} index current item index\n    */\n   function getContextParams$1(tokens, index) {\n       var context = tokens.map(function (token) { return token.activeState.value; });\n       return new ContextParams(context, index || 0);\n   }\n\n   /**\n    * Apply Arabic required ligatures to a context range\n    * @param {ContextRange} range a range of tokens\n    */\n   function latinLigature(range) {\n       var this$1 = this;\n\n       var script = 'latn';\n       var tokens = this.tokenizer.getRangeTokens(range);\n       var contextParams = getContextParams$1(tokens);\n       contextParams.context.forEach(function (glyphIndex, index) {\n           contextParams.setCurrentIndex(index);\n           var substitutions = this$1.query.lookupFeature({\n               tag: 'liga', script: script, contextParams: contextParams\n           });\n           if (substitutions.length) {\n               substitutions.forEach(\n                   function (action) { return applySubstitution(action, tokens, index); }\n               );\n               contextParams = getContextParams$1(tokens);\n           }\n       });\n   }\n\n   /**\n    * Infer bidirectional properties for a given text and apply\n    * the corresponding layout rules.\n    */\n\n   /**\n    * Create Bidi. features\n    * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n    */\n   function Bidi(baseDir) {\n       this.baseDir = baseDir || 'ltr';\n       this.tokenizer = new Tokenizer();\n       this.featuresTags = {};\n   }\n\n   /**\n    * Sets Bidi text\n    * @param {string} text a text input\n    */\n   Bidi.prototype.setText = function (text) {\n       this.text = text;\n   };\n\n   /**\n    * Store essential context checks:\n    * arabic word check for applying gsub features\n    * arabic sentence check for adjusting arabic layout\n    */\n   Bidi.prototype.contextChecks = ({\n       latinWordCheck: latinWordCheck,\n       arabicWordCheck: arabicWordCheck,\n       arabicSentenceCheck: arabicSentenceCheck\n   });\n\n   /**\n    * Register arabic word check\n    */\n   function registerContextChecker(checkId) {\n       var check = this.contextChecks[(checkId + \"Check\")];\n       return this.tokenizer.registerContextChecker(\n           checkId, check.startCheck, check.endCheck\n       );\n   }\n\n   /**\n    * Perform pre tokenization procedure then\n    * tokenize text input\n    */\n   function tokenizeText() {\n       registerContextChecker.call(this, 'latinWord');\n       registerContextChecker.call(this, 'arabicWord');\n       registerContextChecker.call(this, 'arabicSentence');\n       return this.tokenizer.tokenize(this.text);\n   }\n\n   /**\n    * Reverse arabic sentence layout\n    * TODO: check base dir before applying adjustments - priority low\n    */\n   function reverseArabicSentences() {\n       var this$1 = this;\n\n       var ranges = this.tokenizer.getContextRanges('arabicSentence');\n       ranges.forEach(function (range) {\n           var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n           this$1.tokenizer.replaceRange(\n               range.startIndex,\n               range.endOffset,\n               rangeTokens.reverse()\n           );\n       });\n   }\n\n   /**\n    * Register supported features tags\n    * @param {script} script script tag\n    * @param {Array} tags features tags list\n    */\n   Bidi.prototype.registerFeatures = function (script, tags) {\n       var this$1 = this;\n\n       var supportedTags = tags.filter(\n           function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n       );\n       if (!this.featuresTags.hasOwnProperty(script)) {\n           this.featuresTags[script] = supportedTags;\n       } else {\n           this.featuresTags[script] =\n           this.featuresTags[script].concat(supportedTags);\n       }\n   };\n\n   /**\n    * Apply GSUB features\n    * @param {Array} tagsList a list of features tags\n    * @param {string} script a script tag\n    * @param {Font} font opentype font instance\n    */\n   Bidi.prototype.applyFeatures = function (font, features) {\n       if (!font) { throw new Error(\n           'No valid font was provided to apply features'\n       ); }\n       if (!this.query) { this.query = new FeatureQuery(font); }\n       for (var f = 0; f < features.length; f++) {\n           var feature = features[f];\n           if (!this.query.supports({script: feature.script})) { continue; }\n           this.registerFeatures(feature.script, feature.tags);\n       }\n   };\n\n   /**\n    * Register a state modifier\n    * @param {string} modifierId state modifier id\n    * @param {function} condition a predicate function that returns true or false\n    * @param {function} modifier a modifier function to set token state\n    */\n   Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n       this.tokenizer.registerModifier(modifierId, condition, modifier);\n   };\n\n   /**\n    * Check if 'glyphIndex' is registered\n    */\n   function checkGlyphIndexStatus() {\n       if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n           throw new Error(\n               'glyphIndex modifier is required to apply ' +\n               'arabic presentation features.'\n           );\n       }\n   }\n\n   /**\n    * Apply arabic presentation forms features\n    */\n   function applyArabicPresentationForms() {\n       var this$1 = this;\n\n       var script = 'arab';\n       if (!this.featuresTags.hasOwnProperty(script)) { return; }\n       checkGlyphIndexStatus.call(this);\n       var ranges = this.tokenizer.getContextRanges('arabicWord');\n       ranges.forEach(function (range) {\n           arabicPresentationForms.call(this$1, range);\n       });\n   }\n\n   /**\n    * Apply required arabic ligatures\n    */\n   function applyArabicRequireLigatures() {\n       var this$1 = this;\n\n       var script = 'arab';\n       if (!this.featuresTags.hasOwnProperty(script)) { return; }\n       var tags = this.featuresTags[script];\n       if (tags.indexOf('rlig') === -1) { return; }\n       checkGlyphIndexStatus.call(this);\n       var ranges = this.tokenizer.getContextRanges('arabicWord');\n       ranges.forEach(function (range) {\n           arabicRequiredLigatures.call(this$1, range);\n       });\n   }\n\n   /**\n    * Apply required arabic ligatures\n    */\n   function applyLatinLigatures() {\n       var this$1 = this;\n\n       var script = 'latn';\n       if (!this.featuresTags.hasOwnProperty(script)) { return; }\n       var tags = this.featuresTags[script];\n       if (tags.indexOf('liga') === -1) { return; }\n       checkGlyphIndexStatus.call(this);\n       var ranges = this.tokenizer.getContextRanges('latinWord');\n       ranges.forEach(function (range) {\n           latinLigature.call(this$1, range);\n       });\n   }\n\n   /**\n    * Check if a context is registered\n    * @param {string} contextId context id\n    */\n   Bidi.prototype.checkContextReady = function (contextId) {\n       return !!this.tokenizer.getContext(contextId);\n   };\n\n   /**\n    * Apply features to registered contexts\n    */\n   Bidi.prototype.applyFeaturesToContexts = function () {\n       if (this.checkContextReady('arabicWord')) {\n           applyArabicPresentationForms.call(this);\n           applyArabicRequireLigatures.call(this);\n       }\n       if (this.checkContextReady('latinWord')) {\n           applyLatinLigatures.call(this);\n       }\n       if (this.checkContextReady('arabicSentence')) {\n           reverseArabicSentences.call(this);\n       }\n   };\n\n   /**\n    * process text input\n    * @param {string} text an input text\n    */\n   Bidi.prototype.processText = function(text) {\n       if (!this.text || this.text !== text) {\n           this.setText(text);\n           tokenizeText.call(this);\n           this.applyFeaturesToContexts();\n       }\n   };\n\n   /**\n    * Process a string of text to identify and adjust\n    * bidirectional text entities.\n    * @param {string} text input text\n    */\n   Bidi.prototype.getBidiText = function (text) {\n       this.processText(text);\n       return this.tokenizer.getText();\n   };\n\n   /**\n    * Get the current state index of each token\n    * @param {text} text an input text\n    */\n   Bidi.prototype.getTextGlyphs = function (text) {\n       this.processText(text);\n       var indexes = [];\n       for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n           var token = this.tokenizer.tokens[i];\n           if (token.state.deleted) { continue; }\n           var index = token.activeState.value;\n           indexes.push(Array.isArray(index) ? index[0] : index);\n       }\n       return indexes;\n   };\n\n   // The Font object\n\n   /**\n    * @typedef FontOptions\n    * @type Object\n    * @property {Boolean} empty - whether to create a new empty font\n    * @property {string} familyName\n    * @property {string} styleName\n    * @property {string=} fullName\n    * @property {string=} postScriptName\n    * @property {string=} designer\n    * @property {string=} designerURL\n    * @property {string=} manufacturer\n    * @property {string=} manufacturerURL\n    * @property {string=} license\n    * @property {string=} licenseURL\n    * @property {string=} version\n    * @property {string=} description\n    * @property {string=} copyright\n    * @property {string=} trademark\n    * @property {Number} unitsPerEm\n    * @property {Number} ascender\n    * @property {Number} descender\n    * @property {Number} createdTimestamp\n    * @property {string=} weightClass\n    * @property {string=} widthClass\n    * @property {string=} fsSelection\n    */\n\n   /**\n    * A Font represents a loaded OpenType font file.\n    * It contains a set of glyphs and methods to draw text on a drawing context,\n    * or to get a path representing the text.\n    * @exports opentype.Font\n    * @class\n    * @param {FontOptions}\n    * @constructor\n    */\n   function Font(options) {\n       options = options || {};\n       options.tables = options.tables || {};\n\n       if (!options.empty) {\n           // Check that we've provided the minimum set of names.\n           checkArgument(\n               options.familyName,\n               'When creating a new Font object, familyName is required.'\n           );\n           checkArgument(\n               options.styleName,\n               'When creating a new Font object, styleName is required.'\n           );\n           checkArgument(\n               options.unitsPerEm,\n               'When creating a new Font object, unitsPerEm is required.'\n           );\n           checkArgument(\n               options.ascender,\n               'When creating a new Font object, ascender is required.'\n           );\n           checkArgument(\n               options.descender <= 0,\n               'When creating a new Font object, negative descender value is required.'\n           );\n\n           this.unitsPerEm = options.unitsPerEm || 1000;\n           this.ascender = options.ascender;\n           this.descender = options.descender;\n           this.createdTimestamp = options.createdTimestamp;\n           this.tables = Object.assign(options.tables, {\n               os2: Object.assign(\n                   {\n                       usWeightClass:\n                           options.weightClass || this.usWeightClasses.MEDIUM,\n                       usWidthClass:\n                           options.widthClass || this.usWidthClasses.MEDIUM,\n                       fsSelection:\n                           options.fsSelection || this.fsSelectionValues.REGULAR,\n                   },\n                   options.tables.os2\n               ),\n           });\n       }\n\n       this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n       this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n       this.encoding = new DefaultEncoding(this);\n       this.position = new Position(this);\n       this.substitution = new Substitution(this);\n       this.tables = this.tables || {};\n\n       // needed for low memory mode only.\n       this._push = null;\n       this._hmtxTableData = {};\n\n       Object.defineProperty(this, 'hinting', {\n           get: function () {\n               if (this._hinting) { return this._hinting; }\n               if (this.outlinesFormat === 'truetype') {\n                   return (this._hinting = new Hinting(this));\n               }\n           },\n       });\n   }\n\n   /**\n    * Check if the font has a glyph for the given character.\n    * @param  {string}\n    * @return {Boolean}\n    */\n   Font.prototype.hasChar = function (c) {\n       return this.encoding.charToGlyphIndex(c) !== null;\n   };\n\n   /**\n    * Convert the given character to a single glyph index.\n    * Note that this function assumes that there is a one-to-one mapping between\n    * the given character and a glyph; for complex scripts this might not be the case.\n    * @param  {string}\n    * @return {Number}\n    */\n   Font.prototype.charToGlyphIndex = function (s) {\n       return this.encoding.charToGlyphIndex(s);\n   };\n\n   /**\n    * Convert the given character to a single Glyph object.\n    * Note that this function assumes that there is a one-to-one mapping between\n    * the given character and a glyph; for complex scripts this might not be the case.\n    * @param  {string}\n    * @return {opentype.Glyph}\n    */\n   Font.prototype.charToGlyph = function (c) {\n       var glyphIndex = this.charToGlyphIndex(c);\n       var glyph = this.glyphs.get(glyphIndex);\n       if (!glyph) {\n           // .notdef\n           glyph = this.glyphs.get(0);\n       }\n\n       return glyph;\n   };\n\n   /**\n    * Update features\n    * @param {any} options features options\n    */\n   Font.prototype.updateFeatures = function (options) {\n       // TODO: update all features options not only 'latn'.\n       return this.defaultRenderOptions.features.map(function (feature) {\n           if (feature.script === 'latn') {\n               return {\n                   script: 'latn',\n                   tags: feature.tags.filter(function (tag) { return options[tag]; }),\n               };\n           } else {\n               return feature;\n           }\n       });\n   };\n\n   /**\n    * Convert the given text to a list of Glyph objects.\n    * Note that there is no strict one-to-one mapping between characters and\n    * glyphs, so the list of returned glyphs can be larger or smaller than the\n    * length of the given string.\n    * @param  {string}\n    * @param  {GlyphRenderOptions} [options]\n    * @return {opentype.Glyph[]}\n    */\n   Font.prototype.stringToGlyphs = function (s, options) {\n       var this$1 = this;\n\n       var bidi = new Bidi();\n\n       // Create and register 'glyphIndex' state modifier\n       var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n       bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n       // roll-back to default features\n       var features = options\n           ? this.updateFeatures(options.features)\n           : this.defaultRenderOptions.features;\n\n       bidi.applyFeatures(this, features);\n\n       var indexes = bidi.getTextGlyphs(s);\n\n       var length = indexes.length;\n\n       // convert glyph indexes to glyph objects\n       var glyphs = new Array(length);\n       var notdef = this.glyphs.get(0);\n       for (var i = 0; i < length; i += 1) {\n           glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n       }\n       return glyphs;\n   };\n\n   /**\n    * Retrieve the value of the kerning pair between the left glyph (or its index)\n    * and the right glyph (or its index). If no kerning pair is found, return 0.\n    * The kerning value gets added to the advance width when calculating the spacing\n    * between glyphs.\n    * For GPOS kerning, this method uses the default script and language, which covers\n    * most use cases. To have greater control, use font.position.getKerningValue .\n    * @param  {opentype.Glyph} leftGlyph\n    * @param  {opentype.Glyph} rightGlyph\n    * @return {Number}\n    */\n   Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {\n       leftGlyph = leftGlyph.index || leftGlyph;\n       rightGlyph = rightGlyph.index || rightGlyph;\n       var gposKerning = this.position.defaultKerningTables;\n       if (gposKerning) {\n           return this.position.getKerningValue(\n               gposKerning,\n               leftGlyph,\n               rightGlyph\n           );\n       }\n       // \"kern\" table\n       return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n   };\n\n   /**\n    * @typedef GlyphRenderOptions\n    * @type Object\n    * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n    *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n    * @property {string} [language='dflt'] - language system used to determine which features to apply.\n    *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n    * @property {boolean} [kerning=true] - whether to include kerning values\n    * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n    *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n    */\n   Font.prototype.defaultRenderOptions = {\n       kerning: true,\n       features: [\n           /**\n            * these 4 features are required to render Arabic text properly\n            * and shouldn't be turned off when rendering arabic text.\n            */\n           { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n           { script: 'latn', tags: ['liga', 'rlig'] } ],\n   };\n\n   /**\n    * Helper function that invokes the given callback for each glyph in the given text.\n    * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n    * @param {string} text - The text to apply.\n    * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n    * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n    * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n    * @param  {GlyphRenderOptions=} options\n    * @param  {Function} callback\n    */\n   Font.prototype.forEachGlyph = function (\n       text,\n       x,\n       y,\n       fontSize,\n       options,\n       callback\n   ) {\n       x = x !== undefined ? x : 0;\n       y = y !== undefined ? y : 0;\n       fontSize = fontSize !== undefined ? fontSize : 72;\n       options = Object.assign({}, this.defaultRenderOptions, options);\n       var fontScale = (1 / this.unitsPerEm) * fontSize;\n       var glyphs = this.stringToGlyphs(text, options);\n       var kerningLookups;\n       if (options.kerning) {\n           var script = options.script || this.position.getDefaultScriptName();\n           kerningLookups = this.position.getKerningTables(\n               script,\n               options.language\n           );\n       }\n       for (var i = 0; i < glyphs.length; i += 1) {\n           var glyph = glyphs[i];\n           callback.call(this, glyph, x, y, fontSize, options);\n           if (glyph.advanceWidth) {\n               x += glyph.advanceWidth * fontScale;\n           }\n\n           if (options.kerning && i < glyphs.length - 1) {\n               // We should apply position adjustment lookups in a more generic way.\n               // Here we only use the xAdvance value.\n               var kerningValue = kerningLookups\n                   ? this.position.getKerningValue(\n                         kerningLookups,\n                         glyph.index,\n                         glyphs[i + 1].index\n                     )\n                   : this.getKerningValue(glyph, glyphs[i + 1]);\n               x += kerningValue * fontScale;\n           }\n\n           if (options.letterSpacing) {\n               x += options.letterSpacing * fontSize;\n           } else if (options.tracking) {\n               x += (options.tracking / 1000) * fontSize;\n           }\n       }\n       return x;\n   };\n\n   /**\n    * Create a Path object that represents the given text.\n    * @param  {string} text - The text to create.\n    * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n    * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n    * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n    * @param  {GlyphRenderOptions=} options\n    * @return {opentype.Path}\n    */\n   Font.prototype.getPath = function (text, x, y, fontSize, options) {\n       var fullPath = new Path();\n       this.forEachGlyph(\n           text,\n           x,\n           y,\n           fontSize,\n           options,\n           function (glyph, gX, gY, gFontSize) {\n               var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n               fullPath.extend(glyphPath);\n           }\n       );\n       return fullPath;\n   };\n\n   /**\n    * Create an array of Path objects that represent the glyphs of a given text.\n    * @param  {string} text - The text to create.\n    * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n    * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n    * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n    * @param  {GlyphRenderOptions=} options\n    * @return {opentype.Path[]}\n    */\n   Font.prototype.getPaths = function (text, x, y, fontSize, options) {\n       var glyphPaths = [];\n       this.forEachGlyph(\n           text,\n           x,\n           y,\n           fontSize,\n           options,\n           function (glyph, gX, gY, gFontSize) {\n               var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n               glyphPaths.push(glyphPath);\n           }\n       );\n\n       return glyphPaths;\n   };\n\n   /**\n    * Returns the advance width of a text.\n    *\n    * This is something different than Path.getBoundingBox() as for example a\n    * suffixed whitespace increases the advanceWidth but not the bounding box\n    * or an overhanging letter like a calligraphic 'f' might have a quite larger\n    * bounding box than its advance width.\n    *\n    * This corresponds to canvas2dContext.measureText(text).width\n    *\n    * @param  {string} text - The text to create.\n    * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n    * @param  {GlyphRenderOptions=} options\n    * @return advance width\n    */\n   Font.prototype.getAdvanceWidth = function (text, fontSize, options) {\n       return this.forEachGlyph(text, 0, 0, fontSize, options, function () {});\n   };\n\n   /**\n    * @private\n    */\n   Font.prototype.fsSelectionValues = {\n       ITALIC: 0x001, //1\n       UNDERSCORE: 0x002, //2\n       NEGATIVE: 0x004, //4\n       OUTLINED: 0x008, //8\n       STRIKEOUT: 0x010, //16\n       BOLD: 0x020, //32\n       REGULAR: 0x040, //64\n       USER_TYPO_METRICS: 0x080, //128\n       WWS: 0x100, //256\n       OBLIQUE: 0x200, //512\n   };\n\n   /**\n    * @private\n    */\n   Font.prototype.usWidthClasses = {\n       ULTRA_CONDENSED: 1,\n       EXTRA_CONDENSED: 2,\n       CONDENSED: 3,\n       SEMI_CONDENSED: 4,\n       MEDIUM: 5,\n       SEMI_EXPANDED: 6,\n       EXPANDED: 7,\n       EXTRA_EXPANDED: 8,\n       ULTRA_EXPANDED: 9,\n   };\n\n   /**\n    * @private\n    */\n   Font.prototype.usWeightClasses = {\n       THIN: 100,\n       EXTRA_LIGHT: 200,\n       LIGHT: 300,\n       NORMAL: 400,\n       MEDIUM: 500,\n       SEMI_BOLD: 600,\n       BOLD: 700,\n       EXTRA_BOLD: 800,\n       BLACK: 900,\n   };\n\n   // The `cmap` table stores the mappings from characters to glyphs.\n\n   function parseCmapTableFormat12(cmap, p) {\n       //Skip reserved.\n       p.parseUShort();\n\n       // Length in bytes of the sub-tables.\n       cmap.length = p.parseULong();\n       cmap.language = p.parseULong();\n\n       var groupCount;\n       cmap.groupCount = groupCount = p.parseULong();\n       cmap.glyphIndexMap = {};\n\n       for (var i = 0; i < groupCount; i += 1) {\n           var startCharCode = p.parseULong();\n           var endCharCode = p.parseULong();\n           var startGlyphId = p.parseULong();\n\n           for (var c = startCharCode; c <= endCharCode; c += 1) {\n               cmap.glyphIndexMap[c] = startGlyphId;\n               startGlyphId++;\n           }\n       }\n   }\n\n   function parseCmapTableFormat4(cmap, p, data, start, offset) {\n       // Length in bytes of the sub-tables.\n       cmap.length = p.parseUShort();\n       cmap.language = p.parseUShort();\n\n       // segCount is stored x 2.\n       var segCount;\n       cmap.segCount = segCount = p.parseUShort() >> 1;\n\n       // Skip searchRange, entrySelector, rangeShift.\n       p.skip('uShort', 3);\n\n       // The \"unrolled\" mapping from character codes to glyph indices.\n       cmap.glyphIndexMap = {};\n       var endCountParser = new parse.Parser(data, start + offset + 14);\n       var startCountParser = new parse.Parser(\n           data,\n           start + offset + 16 + segCount * 2\n       );\n       var idDeltaParser = new parse.Parser(\n           data,\n           start + offset + 16 + segCount * 4\n       );\n       var idRangeOffsetParser = new parse.Parser(\n           data,\n           start + offset + 16 + segCount * 6\n       );\n       var glyphIndexOffset = start + offset + 16 + segCount * 8;\n       for (var i = 0; i < segCount - 1; i += 1) {\n           var glyphIndex = (void 0);\n           var endCount = endCountParser.parseUShort();\n           var startCount = startCountParser.parseUShort();\n           var idDelta = idDeltaParser.parseShort();\n           var idRangeOffset = idRangeOffsetParser.parseUShort();\n           for (var c = startCount; c <= endCount; c += 1) {\n               if (idRangeOffset !== 0) {\n                   // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                   // Take the current offset in the idRangeOffset array.\n                   glyphIndexOffset =\n                       idRangeOffsetParser.offset +\n                       idRangeOffsetParser.relativeOffset -\n                       2;\n\n                   // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                   glyphIndexOffset += idRangeOffset;\n\n                   // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                   glyphIndexOffset += (c - startCount) * 2;\n                   glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                   if (glyphIndex !== 0) {\n                       glyphIndex = (glyphIndex + idDelta) & 0xffff;\n                   }\n               } else {\n                   glyphIndex = (c + idDelta) & 0xffff;\n               }\n\n               cmap.glyphIndexMap[c] = glyphIndex;\n           }\n       }\n   }\n\n   // Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n   // There are many available formats, but we only support the Windows format 4 and 12.\n   // This function returns a `CmapEncoding` object or null if no supported format could be found.\n   function parseCmapTable(data, start) {\n       var cmap = {};\n       cmap.version = parse.getUShort(data, start);\n       check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n       // The cmap table can contain many sub-tables, each with their own format.\n       // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n       cmap.numTables = parse.getUShort(data, start + 2);\n       var offset = -1;\n       for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n           var platformId = parse.getUShort(data, start + 4 + i * 8);\n           var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n           if (\n               (platformId === 3 &&\n                   (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n               (platformId === 0 &&\n                   (encodingId === 0 ||\n                       encodingId === 1 ||\n                       encodingId === 2 ||\n                       encodingId === 3 ||\n                       encodingId === 4))\n           ) {\n               offset = parse.getULong(data, start + 4 + i * 8 + 4);\n               break;\n           }\n       }\n\n       if (offset === -1) {\n           // There is no cmap table in the font that we support.\n           throw new Error('No valid cmap sub-tables found.');\n       }\n\n       var p = new parse.Parser(data, start + offset);\n       cmap.format = p.parseUShort();\n\n       if (cmap.format === 12) {\n           parseCmapTableFormat12(cmap, p);\n       } else if (cmap.format === 4) {\n           parseCmapTableFormat4(cmap, p, data, start, offset);\n       } else {\n           throw new Error(\n               'Only format 4 and 12 cmap tables are supported (found format ' +\n                   cmap.format +\n                   ').'\n           );\n       }\n\n       return cmap;\n   }\n\n   var cmap = { parse: parseCmapTable };\n\n   // The `CFF` table contains the glyph outlines in PostScript format.\n\n   // Subroutines are encoded using the negative half of the number space.\n   // See type 2 chapter 4.7 \"Subroutine operators\".\n   function calcCFFSubroutineBias(subrs) {\n       var bias;\n       if (subrs.length < 1240) {\n           bias = 107;\n       } else if (subrs.length < 33900) {\n           bias = 1131;\n       } else {\n           bias = 32768;\n       }\n\n       return bias;\n   }\n\n   // Parse a `CFF` INDEX array.\n   // An index array consists of a list of offsets, then a list of objects at those offsets.\n   function parseCFFIndex(data, start, conversionFn) {\n       var offsets = [];\n       var objects = [];\n       var count = parse.getCard16(data, start);\n       var objectOffset;\n       var endOffset;\n       if (count !== 0) {\n           var offsetSize = parse.getByte(data, start + 2);\n           objectOffset = start + (count + 1) * offsetSize + 2;\n           var pos = start + 3;\n           for (var i = 0; i < count + 1; i += 1) {\n               offsets.push(parse.getOffset(data, pos, offsetSize));\n               pos += offsetSize;\n           }\n\n           // The total size of the index array is 4 header bytes + the value of the last offset.\n           endOffset = objectOffset + offsets[count];\n       } else {\n           endOffset = start + 2;\n       }\n\n       for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n           var value = parse.getBytes(\n               data,\n               objectOffset + offsets[i$1],\n               objectOffset + offsets[i$1 + 1]\n           );\n           if (conversionFn) {\n               value = conversionFn(value);\n           }\n\n           objects.push(value);\n       }\n\n       return { objects: objects, startOffset: start, endOffset: endOffset };\n   }\n\n   function parseCFFIndexLowMemory(data, start) {\n       var offsets = [];\n       var count = parse.getCard16(data, start);\n       var objectOffset;\n       var endOffset;\n       if (count !== 0) {\n           var offsetSize = parse.getByte(data, start + 2);\n           objectOffset = start + (count + 1) * offsetSize + 2;\n           var pos = start + 3;\n           for (var i = 0; i < count + 1; i += 1) {\n               offsets.push(parse.getOffset(data, pos, offsetSize));\n               pos += offsetSize;\n           }\n\n           // The total size of the index array is 4 header bytes + the value of the last offset.\n           endOffset = objectOffset + offsets[count];\n       } else {\n           endOffset = start + 2;\n       }\n\n       return { offsets: offsets, startOffset: start, endOffset: endOffset };\n   }\n   function getCffIndexObject(i, offsets, data, start, conversionFn) {\n       var count = parse.getCard16(data, start);\n       var objectOffset = 0;\n       if (count !== 0) {\n           var offsetSize = parse.getByte(data, start + 2);\n           objectOffset = start + (count + 1) * offsetSize + 2;\n       }\n\n       var value = parse.getBytes(\n           data,\n           objectOffset + offsets[i],\n           objectOffset + offsets[i + 1]\n       );\n       if (conversionFn) {\n           value = conversionFn(value);\n       }\n       return value;\n   }\n\n   // Parse a `CFF` DICT real value.\n   function parseFloatOperand(parser) {\n       var s = '';\n       var eof = 15;\n       var lookup = [\n           '0',\n           '1',\n           '2',\n           '3',\n           '4',\n           '5',\n           '6',\n           '7',\n           '8',\n           '9',\n           '.',\n           'E',\n           'E-',\n           null,\n           '-' ];\n       while (true) {\n           var b = parser.parseByte();\n           var n1 = b >> 4;\n           var n2 = b & 15;\n\n           if (n1 === eof) {\n               break;\n           }\n\n           s += lookup[n1];\n\n           if (n2 === eof) {\n               break;\n           }\n\n           s += lookup[n2];\n       }\n\n       return parseFloat(s);\n   }\n\n   // Parse a `CFF` DICT operand.\n   function parseOperand(parser, b0) {\n       var b1;\n       var b2;\n       var b3;\n       var b4;\n       if (b0 === 28) {\n           b1 = parser.parseByte();\n           b2 = parser.parseByte();\n           return (b1 << 8) | b2;\n       }\n\n       if (b0 === 29) {\n           b1 = parser.parseByte();\n           b2 = parser.parseByte();\n           b3 = parser.parseByte();\n           b4 = parser.parseByte();\n           return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;\n       }\n\n       if (b0 === 30) {\n           return parseFloatOperand(parser);\n       }\n\n       if (b0 >= 32 && b0 <= 246) {\n           return b0 - 139;\n       }\n\n       if (b0 >= 247 && b0 <= 250) {\n           b1 = parser.parseByte();\n           return (b0 - 247) * 256 + b1 + 108;\n       }\n\n       if (b0 >= 251 && b0 <= 254) {\n           b1 = parser.parseByte();\n           return -(b0 - 251) * 256 - b1 - 108;\n       }\n\n       throw new Error('Invalid b0 ' + b0);\n   }\n\n   // Convert the entries returned by `parseDict` to a proper dictionary.\n   // If a value is a list of one, it is unpacked.\n   function entriesToObject(entries) {\n       var o = {};\n       for (var i = 0; i < entries.length; i += 1) {\n           var key = entries[i][0];\n           var values = entries[i][1];\n           var value = (void 0);\n           if (values.length === 1) {\n               value = values[0];\n           } else {\n               value = values;\n           }\n\n           if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n               throw new Error('Object ' + o + ' already has key ' + key);\n           }\n\n           o[key] = value;\n       }\n\n       return o;\n   }\n\n   // Parse a `CFF` DICT object.\n   // A dictionary contains key-value pairs in a compact tokenized format.\n   function parseCFFDict(data, start, size) {\n       start = start !== undefined ? start : 0;\n       var parser = new parse.Parser(data, start);\n       var entries = [];\n       var operands = [];\n       size = size !== undefined ? size : data.length;\n\n       while (parser.relativeOffset < size) {\n           var op = parser.parseByte();\n\n           // The first byte for each dict item distinguishes between operator (key) and operand (value).\n           // Values <= 21 are operators.\n           if (op <= 21) {\n               // Two-byte operators have an initial escape byte of 12.\n               if (op === 12) {\n                   op = 1200 + parser.parseByte();\n               }\n\n               entries.push([op, operands]);\n               operands = [];\n           } else {\n               // Since the operands (values) come before the operators (keys), we store all operands in a list\n               // until we encounter an operator.\n               operands.push(parseOperand(parser, op));\n           }\n       }\n\n       return entriesToObject(entries);\n   }\n\n   // Given a String Index (SID), return the value of the string.\n   // Strings below index 392 are standard CFF strings and are not encoded in the font.\n   function getCFFString(strings, index) {\n       if (index <= 390) {\n           index = cffStandardStrings[index];\n       } else {\n           index = strings[index - 391];\n       }\n\n       return index;\n   }\n\n   // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n   // This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\n   function interpretDict(dict, meta, strings) {\n       var newDict = {};\n       var value;\n\n       // Because we also want to include missing values, we start out from the meta list\n       // and lookup values in the dict.\n       for (var i = 0; i < meta.length; i += 1) {\n           var m = meta[i];\n\n           if (Array.isArray(m.type)) {\n               var values = [];\n               values.length = m.type.length;\n               for (var j = 0; j < m.type.length; j++) {\n                   value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                   if (value === undefined) {\n                       value =\n                           m.value !== undefined && m.value[j] !== undefined\n                               ? m.value[j]\n                               : null;\n                   }\n                   if (m.type[j] === 'SID') {\n                       value = getCFFString(strings, value);\n                   }\n                   values[j] = value;\n               }\n               newDict[m.name] = values;\n           } else {\n               value = dict[m.op];\n               if (value === undefined) {\n                   value = m.value !== undefined ? m.value : null;\n               }\n\n               if (m.type === 'SID') {\n                   value = getCFFString(strings, value);\n               }\n               newDict[m.name] = value;\n           }\n       }\n\n       return newDict;\n   }\n\n   // Parse the CFF header.\n   function parseCFFHeader(data, start) {\n       var header = {};\n       header.formatMajor = parse.getCard8(data, start);\n       header.formatMinor = parse.getCard8(data, start + 1);\n       header.size = parse.getCard8(data, start + 2);\n       header.offsetSize = parse.getCard8(data, start + 3);\n       header.startOffset = start;\n       header.endOffset = start + 4;\n       return header;\n   }\n\n   var TOP_DICT_META = [\n       { name: 'version', op: 0, type: 'SID' },\n       { name: 'notice', op: 1, type: 'SID' },\n       { name: 'copyright', op: 1200, type: 'SID' },\n       { name: 'fullName', op: 2, type: 'SID' },\n       { name: 'familyName', op: 3, type: 'SID' },\n       { name: 'weight', op: 4, type: 'SID' },\n       { name: 'isFixedPitch', op: 1201, type: 'number', value: 0 },\n       { name: 'italicAngle', op: 1202, type: 'number', value: 0 },\n       { name: 'underlinePosition', op: 1203, type: 'number', value: -100 },\n       { name: 'underlineThickness', op: 1204, type: 'number', value: 50 },\n       { name: 'paintType', op: 1205, type: 'number', value: 0 },\n       { name: 'charstringType', op: 1206, type: 'number', value: 2 },\n       {\n           name: 'fontMatrix',\n           op: 1207,\n           type: ['real', 'real', 'real', 'real', 'real', 'real'],\n           value: [0.001, 0, 0, 0.001, 0, 0],\n       },\n       { name: 'uniqueId', op: 13, type: 'number' },\n       {\n           name: 'fontBBox',\n           op: 5,\n           type: ['number', 'number', 'number', 'number'],\n           value: [0, 0, 0, 0],\n       },\n       { name: 'strokeWidth', op: 1208, type: 'number', value: 0 },\n       { name: 'xuid', op: 14, type: [], value: null },\n       { name: 'charset', op: 15, type: 'offset', value: 0 },\n       { name: 'encoding', op: 16, type: 'offset', value: 0 },\n       { name: 'charStrings', op: 17, type: 'offset', value: 0 },\n       { name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0] },\n       { name: 'ros', op: 1230, type: ['SID', 'SID', 'number'] },\n       { name: 'cidFontVersion', op: 1231, type: 'number', value: 0 },\n       { name: 'cidFontRevision', op: 1232, type: 'number', value: 0 },\n       { name: 'cidFontType', op: 1233, type: 'number', value: 0 },\n       { name: 'cidCount', op: 1234, type: 'number', value: 8720 },\n       { name: 'uidBase', op: 1235, type: 'number' },\n       { name: 'fdArray', op: 1236, type: 'offset' },\n       { name: 'fdSelect', op: 1237, type: 'offset' },\n       { name: 'fontName', op: 1238, type: 'SID' } ];\n\n   var PRIVATE_DICT_META = [\n       { name: 'subrs', op: 19, type: 'offset', value: 0 },\n       { name: 'defaultWidthX', op: 20, type: 'number', value: 0 },\n       { name: 'nominalWidthX', op: 21, type: 'number', value: 0 } ];\n\n   // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n   // The top dictionary contains the essential metadata for the font, together with the private dictionary.\n   function parseCFFTopDict(data, strings) {\n       var dict = parseCFFDict(data, 0, data.byteLength);\n       return interpretDict(dict, TOP_DICT_META, strings);\n   }\n\n   // Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\n   function parseCFFPrivateDict(data, start, size, strings) {\n       var dict = parseCFFDict(data, start, size);\n       return interpretDict(dict, PRIVATE_DICT_META, strings);\n   }\n\n   // Returns a list of \"Top DICT\"s found using an INDEX list.\n   // Used to read both the usual high-level Top DICTs and also the FDArray\n   // discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n   // a Private DICT that is read and saved into the Top DICT.\n   //\n   // In addition to the expected/optional values as outlined in TOP_DICT_META\n   // the following values might be saved into the Top DICT.\n   //\n   //    _subrs []        array of local CFF subroutines from Private DICT\n   //    _subrsBias       bias value computed from number of subroutines\n   //                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n   //    _defaultWidthX   default widths for CFF characters\n   //    _nominalWidthX   bias added to width embedded within glyph description\n   //\n   //    _privateDict     saved copy of parsed Private DICT from Top DICT\n   function gatherCFFTopDicts(data, start, cffIndex, strings) {\n       var topDictArray = [];\n       for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n           var topDictData = new DataView(\n               new Uint8Array(cffIndex[iTopDict]).buffer\n           );\n           var topDict = parseCFFTopDict(topDictData, strings);\n           topDict._subrs = [];\n           topDict._subrsBias = 0;\n           topDict._defaultWidthX = 0;\n           topDict._nominalWidthX = 0;\n           var privateSize = topDict.private[0];\n           var privateOffset = topDict.private[1];\n           if (privateSize !== 0 && privateOffset !== 0) {\n               var privateDict = parseCFFPrivateDict(\n                   data,\n                   privateOffset + start,\n                   privateSize,\n                   strings\n               );\n               topDict._defaultWidthX = privateDict.defaultWidthX;\n               topDict._nominalWidthX = privateDict.nominalWidthX;\n               if (privateDict.subrs !== 0) {\n                   var subrOffset = privateOffset + privateDict.subrs;\n                   var subrIndex = parseCFFIndex(data, subrOffset + start);\n                   topDict._subrs = subrIndex.objects;\n                   topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n               }\n               topDict._privateDict = privateDict;\n           }\n           topDictArray.push(topDict);\n       }\n       return topDictArray;\n   }\n\n   // Parse the CFF charset table, which contains internal names for all the glyphs.\n   // This function will return a list of glyph names.\n   // See Adobe TN #5176 chapter 13, \"Charsets\".\n   function parseCFFCharset(data, start, nGlyphs, strings) {\n       var sid;\n       var count;\n       var parser = new parse.Parser(data, start);\n\n       // The .notdef glyph is not included, so subtract 1.\n       nGlyphs -= 1;\n       var charset = ['.notdef'];\n\n       var format = parser.parseCard8();\n       if (format === 0) {\n           for (var i = 0; i < nGlyphs; i += 1) {\n               sid = parser.parseSID();\n               charset.push(getCFFString(strings, sid));\n           }\n       } else if (format === 1) {\n           while (charset.length <= nGlyphs) {\n               sid = parser.parseSID();\n               count = parser.parseCard8();\n               for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                   charset.push(getCFFString(strings, sid));\n                   sid += 1;\n               }\n           }\n       } else if (format === 2) {\n           while (charset.length <= nGlyphs) {\n               sid = parser.parseSID();\n               count = parser.parseCard16();\n               for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                   charset.push(getCFFString(strings, sid));\n                   sid += 1;\n               }\n           }\n       } else {\n           throw new Error('Unknown charset format ' + format);\n       }\n\n       return charset;\n   }\n\n   // Parse the CFF encoding data. Only one encoding can be specified per font.\n   // See Adobe TN #5176 chapter 12, \"Encodings\".\n   function parseCFFEncoding(data, start, charset) {\n       var code;\n       var enc = {};\n       var parser = new parse.Parser(data, start);\n       var format = parser.parseCard8();\n       if (format === 0) {\n           var nCodes = parser.parseCard8();\n           for (var i = 0; i < nCodes; i += 1) {\n               code = parser.parseCard8();\n               enc[code] = i;\n           }\n       } else if (format === 1) {\n           var nRanges = parser.parseCard8();\n           code = 1;\n           for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n               var first = parser.parseCard8();\n               var nLeft = parser.parseCard8();\n               for (var j = first; j <= first + nLeft; j += 1) {\n                   enc[j] = code;\n                   code += 1;\n               }\n           }\n       } else {\n           throw new Error('Unknown encoding format ' + format);\n       }\n\n       return new CffEncoding(enc, charset);\n   }\n\n   // Take in charstring code and return a Glyph object.\n   // The encoding is described in the Type 2 Charstring Format\n   // https://www.microsoft.com/typography/OTSPEC/charstr2.htm\n   function parseCFFCharstring(font, glyph, code) {\n       var c1x;\n       var c1y;\n       var c2x;\n       var c2y;\n       var p = new Path();\n       var stack = [];\n       var nStems = 0;\n       var haveWidth = false;\n       var open = false;\n       var x = 0;\n       var y = 0;\n       var subrs;\n       var subrsBias;\n       var defaultWidthX;\n       var nominalWidthX;\n       if (font.isCIDFont) {\n           var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n           var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n           subrs = fdDict._subrs;\n           subrsBias = fdDict._subrsBias;\n           defaultWidthX = fdDict._defaultWidthX;\n           nominalWidthX = fdDict._nominalWidthX;\n       } else {\n           subrs = font.tables.cff.topDict._subrs;\n           subrsBias = font.tables.cff.topDict._subrsBias;\n           defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n           nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n       }\n       var width = defaultWidthX;\n\n       function newContour(x, y) {\n           if (open) {\n               p.closePath();\n           }\n\n           p.moveTo(x, y);\n           open = true;\n       }\n\n       function parseStems() {\n           var hasWidthArg;\n\n           // The number of stem operators on the stack is always even.\n           // If the value is uneven, that means a width is specified.\n           hasWidthArg = stack.length % 2 !== 0;\n           if (hasWidthArg && !haveWidth) {\n               width = stack.shift() + nominalWidthX;\n           }\n\n           nStems += stack.length >> 1;\n           stack.length = 0;\n           haveWidth = true;\n       }\n\n       function parse(code) {\n           var b1;\n           var b2;\n           var b3;\n           var b4;\n           var codeIndex;\n           var subrCode;\n           var jpx;\n           var jpy;\n           var c3x;\n           var c3y;\n           var c4x;\n           var c4y;\n\n           var i = 0;\n           while (i < code.length) {\n               var v = code[i];\n               i += 1;\n               switch (v) {\n                   case 1: // hstem\n                       parseStems();\n                       break;\n                   case 3: // vstem\n                       parseStems();\n                       break;\n                   case 4: // vmoveto\n                       if (stack.length > 1 && !haveWidth) {\n                           width = stack.shift() + nominalWidthX;\n                           haveWidth = true;\n                       }\n\n                       y += stack.pop();\n                       newContour(x, y);\n                       break;\n                   case 5: // rlineto\n                       while (stack.length > 0) {\n                           x += stack.shift();\n                           y += stack.shift();\n                           p.lineTo(x, y);\n                       }\n\n                       break;\n                   case 6: // hlineto\n                       while (stack.length > 0) {\n                           x += stack.shift();\n                           p.lineTo(x, y);\n                           if (stack.length === 0) {\n                               break;\n                           }\n\n                           y += stack.shift();\n                           p.lineTo(x, y);\n                       }\n\n                       break;\n                   case 7: // vlineto\n                       while (stack.length > 0) {\n                           y += stack.shift();\n                           p.lineTo(x, y);\n                           if (stack.length === 0) {\n                               break;\n                           }\n\n                           x += stack.shift();\n                           p.lineTo(x, y);\n                       }\n\n                       break;\n                   case 8: // rrcurveto\n                       while (stack.length > 0) {\n                           c1x = x + stack.shift();\n                           c1y = y + stack.shift();\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           x = c2x + stack.shift();\n                           y = c2y + stack.shift();\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       }\n\n                       break;\n                   case 10: // callsubr\n                       codeIndex = stack.pop() + subrsBias;\n                       subrCode = subrs[codeIndex];\n                       if (subrCode) {\n                           parse(subrCode);\n                       }\n\n                       break;\n                   case 11: // return\n                       return;\n                   case 12: // flex operators\n                       v = code[i];\n                       i += 1;\n                       switch (v) {\n                           case 35: // flex\n                               // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                               c1x = x + stack.shift(); // dx1\n                               c1y = y + stack.shift(); // dy1\n                               c2x = c1x + stack.shift(); // dx2\n                               c2y = c1y + stack.shift(); // dy2\n                               jpx = c2x + stack.shift(); // dx3\n                               jpy = c2y + stack.shift(); // dy3\n                               c3x = jpx + stack.shift(); // dx4\n                               c3y = jpy + stack.shift(); // dy4\n                               c4x = c3x + stack.shift(); // dx5\n                               c4y = c3y + stack.shift(); // dy5\n                               x = c4x + stack.shift(); // dx6\n                               y = c4y + stack.shift(); // dy6\n                               stack.shift(); // flex depth\n                               p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                               p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                               break;\n                           case 34: // hflex\n                               // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                               c1x = x + stack.shift(); // dx1\n                               c1y = y; // dy1\n                               c2x = c1x + stack.shift(); // dx2\n                               c2y = c1y + stack.shift(); // dy2\n                               jpx = c2x + stack.shift(); // dx3\n                               jpy = c2y; // dy3\n                               c3x = jpx + stack.shift(); // dx4\n                               c3y = c2y; // dy4\n                               c4x = c3x + stack.shift(); // dx5\n                               c4y = y; // dy5\n                               x = c4x + stack.shift(); // dx6\n                               p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                               p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                               break;\n                           case 36: // hflex1\n                               // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                               c1x = x + stack.shift(); // dx1\n                               c1y = y + stack.shift(); // dy1\n                               c2x = c1x + stack.shift(); // dx2\n                               c2y = c1y + stack.shift(); // dy2\n                               jpx = c2x + stack.shift(); // dx3\n                               jpy = c2y; // dy3\n                               c3x = jpx + stack.shift(); // dx4\n                               c3y = c2y; // dy4\n                               c4x = c3x + stack.shift(); // dx5\n                               c4y = c3y + stack.shift(); // dy5\n                               x = c4x + stack.shift(); // dx6\n                               p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                               p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                               break;\n                           case 37: // flex1\n                               // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                               c1x = x + stack.shift(); // dx1\n                               c1y = y + stack.shift(); // dy1\n                               c2x = c1x + stack.shift(); // dx2\n                               c2y = c1y + stack.shift(); // dy2\n                               jpx = c2x + stack.shift(); // dx3\n                               jpy = c2y + stack.shift(); // dy3\n                               c3x = jpx + stack.shift(); // dx4\n                               c3y = jpy + stack.shift(); // dy4\n                               c4x = c3x + stack.shift(); // dx5\n                               c4y = c3y + stack.shift(); // dy5\n                               if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                   x = c4x + stack.shift();\n                               } else {\n                                   y = c4y + stack.shift();\n                               }\n\n                               p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                               p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                               break;\n                           default:\n                               console.log(\n                                   'Glyph ' +\n                                       glyph.index +\n                                       ': unknown operator ' +\n                                       1200 +\n                                       v\n                               );\n                               stack.length = 0;\n                       }\n                       break;\n                   case 14: // endchar\n                       if (stack.length > 0 && !haveWidth) {\n                           width = stack.shift() + nominalWidthX;\n                           haveWidth = true;\n                       }\n\n                       if (open) {\n                           p.closePath();\n                           open = false;\n                       }\n\n                       break;\n                   case 18: // hstemhm\n                       parseStems();\n                       break;\n                   case 19: // hintmask\n                   case 20: // cntrmask\n                       parseStems();\n                       i += (nStems + 7) >> 3;\n                       break;\n                   case 21: // rmoveto\n                       if (stack.length > 2 && !haveWidth) {\n                           width = stack.shift() + nominalWidthX;\n                           haveWidth = true;\n                       }\n\n                       y += stack.pop();\n                       x += stack.pop();\n                       newContour(x, y);\n                       break;\n                   case 22: // hmoveto\n                       if (stack.length > 1 && !haveWidth) {\n                           width = stack.shift() + nominalWidthX;\n                           haveWidth = true;\n                       }\n\n                       x += stack.pop();\n                       newContour(x, y);\n                       break;\n                   case 23: // vstemhm\n                       parseStems();\n                       break;\n                   case 24: // rcurveline\n                       while (stack.length > 2) {\n                           c1x = x + stack.shift();\n                           c1y = y + stack.shift();\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           x = c2x + stack.shift();\n                           y = c2y + stack.shift();\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       }\n\n                       x += stack.shift();\n                       y += stack.shift();\n                       p.lineTo(x, y);\n                       break;\n                   case 25: // rlinecurve\n                       while (stack.length > 6) {\n                           x += stack.shift();\n                           y += stack.shift();\n                           p.lineTo(x, y);\n                       }\n\n                       c1x = x + stack.shift();\n                       c1y = y + stack.shift();\n                       c2x = c1x + stack.shift();\n                       c2y = c1y + stack.shift();\n                       x = c2x + stack.shift();\n                       y = c2y + stack.shift();\n                       p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       break;\n                   case 26: // vvcurveto\n                       if (stack.length % 2) {\n                           x += stack.shift();\n                       }\n\n                       while (stack.length > 0) {\n                           c1x = x;\n                           c1y = y + stack.shift();\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           x = c2x;\n                           y = c2y + stack.shift();\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       }\n\n                       break;\n                   case 27: // hhcurveto\n                       if (stack.length % 2) {\n                           y += stack.shift();\n                       }\n\n                       while (stack.length > 0) {\n                           c1x = x + stack.shift();\n                           c1y = y;\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           x = c2x + stack.shift();\n                           y = c2y;\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       }\n\n                       break;\n                   case 28: // shortint\n                       b1 = code[i];\n                       b2 = code[i + 1];\n                       stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                       i += 2;\n                       break;\n                   case 29: // callgsubr\n                       codeIndex = stack.pop() + font.gsubrsBias;\n                       subrCode = font.gsubrs[codeIndex];\n                       if (subrCode) {\n                           parse(subrCode);\n                       }\n\n                       break;\n                   case 30: // vhcurveto\n                       while (stack.length > 0) {\n                           c1x = x;\n                           c1y = y + stack.shift();\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           x = c2x + stack.shift();\n                           y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                           if (stack.length === 0) {\n                               break;\n                           }\n\n                           c1x = x + stack.shift();\n                           c1y = y;\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           y = c2y + stack.shift();\n                           x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       }\n\n                       break;\n                   case 31: // hvcurveto\n                       while (stack.length > 0) {\n                           c1x = x + stack.shift();\n                           c1y = y;\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           y = c2y + stack.shift();\n                           x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                           if (stack.length === 0) {\n                               break;\n                           }\n\n                           c1x = x;\n                           c1y = y + stack.shift();\n                           c2x = c1x + stack.shift();\n                           c2y = c1y + stack.shift();\n                           x = c2x + stack.shift();\n                           y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                           p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                       }\n\n                       break;\n                   default:\n                       if (v < 32) {\n                           console.log(\n                               'Glyph ' + glyph.index + ': unknown operator ' + v\n                           );\n                       } else if (v < 247) {\n                           stack.push(v - 139);\n                       } else if (v < 251) {\n                           b1 = code[i];\n                           i += 1;\n                           stack.push((v - 247) * 256 + b1 + 108);\n                       } else if (v < 255) {\n                           b1 = code[i];\n                           i += 1;\n                           stack.push(-(v - 251) * 256 - b1 - 108);\n                       } else {\n                           b1 = code[i];\n                           b2 = code[i + 1];\n                           b3 = code[i + 2];\n                           b4 = code[i + 3];\n                           i += 4;\n                           stack.push(\n                               ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536\n                           );\n                       }\n               }\n           }\n       }\n\n       parse(code);\n\n       glyph.advanceWidth = width;\n       return p;\n   }\n\n   function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n       var fdSelect = [];\n       var fdIndex;\n       var parser = new parse.Parser(data, start);\n       var format = parser.parseCard8();\n       if (format === 0) {\n           // Simple list of nGlyphs elements\n           for (var iGid = 0; iGid < nGlyphs; iGid++) {\n               fdIndex = parser.parseCard8();\n               if (fdIndex >= fdArrayCount) {\n                   throw new Error(\n                       'CFF table CID Font FDSelect has bad FD index value ' +\n                           fdIndex +\n                           ' (FD count ' +\n                           fdArrayCount +\n                           ')'\n                   );\n               }\n               fdSelect.push(fdIndex);\n           }\n       } else if (format === 3) {\n           // Ranges\n           var nRanges = parser.parseCard16();\n           var first = parser.parseCard16();\n           if (first !== 0) {\n               throw new Error(\n                   'CFF Table CID Font FDSelect format 3 range has bad initial GID ' +\n                       first\n               );\n           }\n           var next;\n           for (var iRange = 0; iRange < nRanges; iRange++) {\n               fdIndex = parser.parseCard8();\n               next = parser.parseCard16();\n               if (fdIndex >= fdArrayCount) {\n                   throw new Error(\n                       'CFF table CID Font FDSelect has bad FD index value ' +\n                           fdIndex +\n                           ' (FD count ' +\n                           fdArrayCount +\n                           ')'\n                   );\n               }\n               if (next > nGlyphs) {\n                   throw new Error(\n                       'CFF Table CID Font FDSelect format 3 range has bad GID ' +\n                           next\n                   );\n               }\n               for (; first < next; first++) {\n                   fdSelect.push(fdIndex);\n               }\n               first = next;\n           }\n           if (next !== nGlyphs) {\n               throw new Error(\n                   'CFF Table CID Font FDSelect format 3 range has bad final GID ' +\n                       next\n               );\n           }\n       } else {\n           throw new Error(\n               'CFF Table CID Font FDSelect table has unsupported format ' + format\n           );\n       }\n       return fdSelect;\n   }\n\n   // Parse the `CFF` table, which contains the glyph outlines in PostScript format.\n   function parseCFFTable(data, start, font, opt) {\n       font.tables.cff = {};\n       var header = parseCFFHeader(data, start);\n       var nameIndex = parseCFFIndex(\n           data,\n           header.endOffset,\n           parse.bytesToString\n       );\n       var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n       var stringIndex = parseCFFIndex(\n           data,\n           topDictIndex.endOffset,\n           parse.bytesToString\n       );\n       var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n       font.gsubrs = globalSubrIndex.objects;\n       font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n       var topDictArray = gatherCFFTopDicts(\n           data,\n           start,\n           topDictIndex.objects,\n           stringIndex.objects\n       );\n       if (topDictArray.length !== 1) {\n           throw new Error(\n               \"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" +\n                   topDictArray.length\n           );\n       }\n\n       var topDict = topDictArray[0];\n       font.tables.cff.topDict = topDict;\n\n       if (topDict._privateDict) {\n           font.defaultWidthX = topDict._privateDict.defaultWidthX;\n           font.nominalWidthX = topDict._privateDict.nominalWidthX;\n       }\n\n       if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n           font.isCIDFont = true;\n       }\n\n       if (font.isCIDFont) {\n           var fdArrayOffset = topDict.fdArray;\n           var fdSelectOffset = topDict.fdSelect;\n           if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n               throw new Error(\n                   'Font is marked as a CID font, but FDArray and/or FDSelect information is missing'\n               );\n           }\n           fdArrayOffset += start;\n           var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n           var fdArray = gatherCFFTopDicts(\n               data,\n               start,\n               fdArrayIndex.objects,\n               stringIndex.objects\n           );\n           topDict._fdArray = fdArray;\n           fdSelectOffset += start;\n           topDict._fdSelect = parseCFFFDSelect(\n               data,\n               fdSelectOffset,\n               font.numGlyphs,\n               fdArray.length\n           );\n       }\n\n       var privateDictOffset = start + topDict.private[1];\n       var privateDict = parseCFFPrivateDict(\n           data,\n           privateDictOffset,\n           topDict.private[0],\n           stringIndex.objects\n       );\n       font.defaultWidthX = privateDict.defaultWidthX;\n       font.nominalWidthX = privateDict.nominalWidthX;\n\n       if (privateDict.subrs !== 0) {\n           var subrOffset = privateDictOffset + privateDict.subrs;\n           var subrIndex = parseCFFIndex(data, subrOffset);\n           font.subrs = subrIndex.objects;\n           font.subrsBias = calcCFFSubroutineBias(font.subrs);\n       } else {\n           font.subrs = [];\n           font.subrsBias = 0;\n       }\n\n       // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n       var charStringsIndex;\n       if (opt.lowMemory) {\n           charStringsIndex = parseCFFIndexLowMemory(\n               data,\n               start + topDict.charStrings\n           );\n           font.nGlyphs = charStringsIndex.offsets.length;\n       } else {\n           charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n           font.nGlyphs = charStringsIndex.objects.length;\n       }\n\n       var charset = parseCFFCharset(\n           data,\n           start + topDict.charset,\n           font.nGlyphs,\n           stringIndex.objects\n       );\n       if (topDict.encoding === 0) {\n           // Standard encoding\n           font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n       } else if (topDict.encoding === 1) {\n           // Expert encoding\n           font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n       } else {\n           font.cffEncoding = parseCFFEncoding(\n               data,\n               start + topDict.encoding,\n               charset\n           );\n       }\n\n       // Prefer the CMAP encoding to the CFF encoding.\n       font.encoding = font.encoding || font.cffEncoding;\n\n       font.glyphs = new glyphset.GlyphSet(font);\n       if (opt.lowMemory) {\n           font._push = function (i) {\n               var charString = getCffIndexObject(\n                   i,\n                   charStringsIndex.offsets,\n                   data,\n                   start + topDict.charStrings\n               );\n               font.glyphs.push(\n                   i,\n                   glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString)\n               );\n           };\n       } else {\n           for (var i = 0; i < font.nGlyphs; i += 1) {\n               var charString = charStringsIndex.objects[i];\n               font.glyphs.push(\n                   i,\n                   glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString)\n               );\n           }\n       }\n   }\n\n   var cff = { parse: parseCFFTable };\n\n   // The `fvar` table stores font variation axes and instances.\n\n   function parseFvarAxis(data, start, names) {\n       var axis = {};\n       var p = new parse.Parser(data, start);\n       axis.tag = p.parseTag();\n       axis.minValue = p.parseFixed();\n       axis.defaultValue = p.parseFixed();\n       axis.maxValue = p.parseFixed();\n       p.skip('uShort', 1); // reserved for flags; no values defined\n       axis.name = names[p.parseUShort()] || {};\n       return axis;\n   }\n\n   function parseFvarInstance(data, start, axes, names) {\n       var inst = {};\n       var p = new parse.Parser(data, start);\n       inst.name = names[p.parseUShort()] || {};\n       p.skip('uShort', 1); // reserved for flags; no values defined\n\n       inst.coordinates = {};\n       for (var i = 0; i < axes.length; ++i) {\n           inst.coordinates[axes[i].tag] = p.parseFixed();\n       }\n\n       return inst;\n   }\n\n   function parseFvarTable(data, start, names) {\n       var p = new parse.Parser(data, start);\n       var tableVersion = p.parseULong();\n       check.argument(\n           tableVersion === 0x00010000,\n           'Unsupported fvar table version.'\n       );\n       var offsetToData = p.parseOffset16();\n       // Skip countSizePairs.\n       p.skip('uShort', 1);\n       var axisCount = p.parseUShort();\n       var axisSize = p.parseUShort();\n       var instanceCount = p.parseUShort();\n       var instanceSize = p.parseUShort();\n\n       var axes = [];\n       for (var i = 0; i < axisCount; i++) {\n           axes.push(\n               parseFvarAxis(data, start + offsetToData + i * axisSize, names)\n           );\n       }\n\n       var instances = [];\n       var instanceStart = start + offsetToData + axisCount * axisSize;\n       for (var j = 0; j < instanceCount; j++) {\n           instances.push(\n               parseFvarInstance(\n                   data,\n                   instanceStart + j * instanceSize,\n                   axes,\n                   names\n               )\n           );\n       }\n\n       return { axes: axes, instances: instances };\n   }\n\n   var fvar = { parse: parseFvarTable };\n\n   // The `GDEF` table contains various glyph properties\n\n   var attachList = function() {\n       return {\n           coverage: this.parsePointer(Parser.coverage),\n           attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n       };\n   };\n\n   var caretValue = function() {\n       var format = this.parseUShort();\n       check.argument(format === 1 || format === 2 || format === 3,\n           'Unsupported CaretValue table version.');\n       if (format === 1) {\n           return { coordinate: this.parseShort() };\n       } else if (format === 2) {\n           return { pointindex: this.parseShort() };\n       } else if (format === 3) {\n           // Device / Variation Index tables unsupported\n           return { coordinate: this.parseShort() };\n       }\n   };\n\n   var ligGlyph = function() {\n       return this.parseList(Parser.pointer(caretValue));\n   };\n\n   var ligCaretList = function() {\n       return {\n           coverage: this.parsePointer(Parser.coverage),\n           ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n       };\n   };\n\n   var markGlyphSets = function() {\n       this.parseUShort(); // Version\n       return this.parseList(Parser.pointer(Parser.coverage));\n   };\n\n   function parseGDEFTable(data, start) {\n       start = start || 0;\n       var p = new Parser(data, start);\n       var tableVersion = p.parseVersion(1);\n       check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n           'Unsupported GDEF table version.');\n       var gdef = {\n           version: tableVersion,\n           classDef: p.parsePointer(Parser.classDef),\n           attachList: p.parsePointer(attachList),\n           ligCaretList: p.parsePointer(ligCaretList),\n           markAttachClassDef: p.parsePointer(Parser.classDef)\n       };\n       if (tableVersion >= 1.2) {\n           gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n       }\n       return gdef;\n   }\n   var gdef = { parse: parseGDEFTable };\n\n   // The `GPOS` table contains kerning pairs, among other things.\n\n   var subtableParsers = new Array(10); // subtableParsers[0] is unused\n\n   // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n   // this = Parser instance\n   subtableParsers[1] = function parseLookup1() {\n       var start = this.offset + this.relativeOffset;\n       var posformat = this.parseUShort();\n       if (posformat === 1) {\n           return {\n               posFormat: 1,\n               coverage: this.parsePointer(Parser.coverage),\n               value: this.parseValueRecord(),\n           };\n       } else if (posformat === 2) {\n           return {\n               posFormat: 2,\n               coverage: this.parsePointer(Parser.coverage),\n               values: this.parseValueRecordList(),\n           };\n       }\n       check.assert(\n           false,\n           '0x' +\n               start.toString(16) +\n               ': GPOS lookup type 1 format must be 1 or 2.'\n       );\n   };\n\n   // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\n   subtableParsers[2] = function parseLookup2() {\n       var start = this.offset + this.relativeOffset;\n       var posFormat = this.parseUShort();\n       check.assert(\n           posFormat === 1 || posFormat === 2,\n           '0x' +\n               start.toString(16) +\n               ': GPOS lookup type 2 format must be 1 or 2.'\n       );\n       var coverage = this.parsePointer(Parser.coverage);\n       var valueFormat1 = this.parseUShort();\n       var valueFormat2 = this.parseUShort();\n       if (posFormat === 1) {\n           // Adjustments for Glyph Pairs\n           return {\n               posFormat: posFormat,\n               coverage: coverage,\n               valueFormat1: valueFormat1,\n               valueFormat2: valueFormat2,\n               pairSets: this.parseList(\n                   Parser.pointer(\n                       Parser.list(function () {\n                           return {\n                               // pairValueRecord\n                               secondGlyph: this.parseUShort(),\n                               value1: this.parseValueRecord(valueFormat1),\n                               value2: this.parseValueRecord(valueFormat2),\n                           };\n                       })\n                   )\n               ),\n           };\n       } else if (posFormat === 2) {\n           var classDef1 = this.parsePointer(Parser.classDef);\n           var classDef2 = this.parsePointer(Parser.classDef);\n           var class1Count = this.parseUShort();\n           var class2Count = this.parseUShort();\n           return {\n               // Class Pair Adjustment\n               posFormat: posFormat,\n               coverage: coverage,\n               valueFormat1: valueFormat1,\n               valueFormat2: valueFormat2,\n               classDef1: classDef1,\n               classDef2: classDef2,\n               class1Count: class1Count,\n               class2Count: class2Count,\n               classRecords: this.parseList(\n                   class1Count,\n                   Parser.list(class2Count, function () {\n                       return {\n                           value1: this.parseValueRecord(valueFormat1),\n                           value2: this.parseValueRecord(valueFormat2),\n                       };\n                   })\n               ),\n           };\n       }\n   };\n\n   subtableParsers[3] = function parseLookup3() {\n       return { error: 'GPOS Lookup 3 not supported' };\n   };\n   subtableParsers[4] = function parseLookup4() {\n       return { error: 'GPOS Lookup 4 not supported' };\n   };\n   subtableParsers[5] = function parseLookup5() {\n       return { error: 'GPOS Lookup 5 not supported' };\n   };\n   subtableParsers[6] = function parseLookup6() {\n       return { error: 'GPOS Lookup 6 not supported' };\n   };\n   subtableParsers[7] = function parseLookup7() {\n       return { error: 'GPOS Lookup 7 not supported' };\n   };\n   subtableParsers[8] = function parseLookup8() {\n       return { error: 'GPOS Lookup 8 not supported' };\n   };\n   subtableParsers[9] = function parseLookup9() {\n       return { error: 'GPOS Lookup 9 not supported' };\n   };\n\n   // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\n   function parseGposTable(data, start) {\n       start = start || 0;\n       var p = new Parser(data, start);\n       var tableVersion = p.parseVersion(1);\n       check.argument(\n           tableVersion === 1 || tableVersion === 1.1,\n           'Unsupported GPOS table version ' + tableVersion\n       );\n\n       if (tableVersion === 1) {\n           return {\n               version: tableVersion,\n               scripts: p.parseScriptList(),\n               features: p.parseFeatureList(),\n               lookups: p.parseLookupList(subtableParsers),\n           };\n       } else {\n           return {\n               version: tableVersion,\n               scripts: p.parseScriptList(),\n               features: p.parseFeatureList(),\n               lookups: p.parseLookupList(subtableParsers),\n               variations: p.parseFeatureVariationsList(),\n           };\n       }\n   }\n\n   var gpos = { parse: parseGposTable };\n\n   // The `GSUB` table contains ligatures, among other things.\n\n   var subtableParsers$1 = new Array(9); // subtableParsers[0] is unused\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\n   subtableParsers$1[1] = function parseLookup1() {\n       var start = this.offset + this.relativeOffset;\n       var substFormat = this.parseUShort();\n       if (substFormat === 1) {\n           return {\n               substFormat: 1,\n               coverage: this.parsePointer(Parser.coverage),\n               deltaGlyphId: this.parseUShort(),\n           };\n       } else if (substFormat === 2) {\n           return {\n               substFormat: 2,\n               coverage: this.parsePointer(Parser.coverage),\n               substitute: this.parseOffset16List(),\n           };\n       }\n       check.assert(\n           false,\n           '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.'\n       );\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\n   subtableParsers$1[2] = function parseLookup2() {\n       var substFormat = this.parseUShort();\n       check.argument(\n           substFormat === 1,\n           'GSUB Multiple Substitution Subtable identifier-format must be 1'\n       );\n       return {\n           substFormat: substFormat,\n           coverage: this.parsePointer(Parser.coverage),\n           sequences: this.parseListOfLists(),\n       };\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\n   subtableParsers$1[3] = function parseLookup3() {\n       var substFormat = this.parseUShort();\n       check.argument(\n           substFormat === 1,\n           'GSUB Alternate Substitution Subtable identifier-format must be 1'\n       );\n       return {\n           substFormat: substFormat,\n           coverage: this.parsePointer(Parser.coverage),\n           alternateSets: this.parseListOfLists(),\n       };\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\n   subtableParsers$1[4] = function parseLookup4() {\n       var substFormat = this.parseUShort();\n       check.argument(\n           substFormat === 1,\n           'GSUB ligature table identifier-format must be 1'\n       );\n       return {\n           substFormat: substFormat,\n           coverage: this.parsePointer(Parser.coverage),\n           ligatureSets: this.parseListOfLists(function () {\n               return {\n                   ligGlyph: this.parseUShort(),\n                   components: this.parseUShortList(this.parseUShort() - 1),\n               };\n           }),\n       };\n   };\n\n   var lookupRecordDesc = {\n       sequenceIndex: Parser.uShort,\n       lookupListIndex: Parser.uShort,\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\n   subtableParsers$1[5] = function parseLookup5() {\n       var start = this.offset + this.relativeOffset;\n       var substFormat = this.parseUShort();\n\n       if (substFormat === 1) {\n           return {\n               substFormat: substFormat,\n               coverage: this.parsePointer(Parser.coverage),\n               ruleSets: this.parseListOfLists(function () {\n                   var glyphCount = this.parseUShort();\n                   var substCount = this.parseUShort();\n                   return {\n                       input: this.parseUShortList(glyphCount - 1),\n                       lookupRecords: this.parseRecordList(\n                           substCount,\n                           lookupRecordDesc\n                       ),\n                   };\n               }),\n           };\n       } else if (substFormat === 2) {\n           return {\n               substFormat: substFormat,\n               coverage: this.parsePointer(Parser.coverage),\n               classDef: this.parsePointer(Parser.classDef),\n               classSets: this.parseListOfLists(function () {\n                   var glyphCount = this.parseUShort();\n                   var substCount = this.parseUShort();\n                   return {\n                       classes: this.parseUShortList(glyphCount - 1),\n                       lookupRecords: this.parseRecordList(\n                           substCount,\n                           lookupRecordDesc\n                       ),\n                   };\n               }),\n           };\n       } else if (substFormat === 3) {\n           var glyphCount = this.parseUShort();\n           var substCount = this.parseUShort();\n           return {\n               substFormat: substFormat,\n               coverages: this.parseList(\n                   glyphCount,\n                   Parser.pointer(Parser.coverage)\n               ),\n               lookupRecords: this.parseRecordList(substCount, lookupRecordDesc),\n           };\n       }\n       check.assert(\n           false,\n           '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.'\n       );\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\n   subtableParsers$1[6] = function parseLookup6() {\n       var start = this.offset + this.relativeOffset;\n       var substFormat = this.parseUShort();\n       if (substFormat === 1) {\n           return {\n               substFormat: 1,\n               coverage: this.parsePointer(Parser.coverage),\n               chainRuleSets: this.parseListOfLists(function () {\n                   return {\n                       backtrack: this.parseUShortList(),\n                       input: this.parseUShortList(this.parseShort() - 1),\n                       lookahead: this.parseUShortList(),\n                       lookupRecords: this.parseRecordList(lookupRecordDesc),\n                   };\n               }),\n           };\n       } else if (substFormat === 2) {\n           return {\n               substFormat: 2,\n               coverage: this.parsePointer(Parser.coverage),\n               backtrackClassDef: this.parsePointer(Parser.classDef),\n               inputClassDef: this.parsePointer(Parser.classDef),\n               lookaheadClassDef: this.parsePointer(Parser.classDef),\n               chainClassSet: this.parseListOfLists(function () {\n                   return {\n                       backtrack: this.parseUShortList(),\n                       input: this.parseUShortList(this.parseShort() - 1),\n                       lookahead: this.parseUShortList(),\n                       lookupRecords: this.parseRecordList(lookupRecordDesc),\n                   };\n               }),\n           };\n       } else if (substFormat === 3) {\n           return {\n               substFormat: 3,\n               backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n               inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n               lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n               lookupRecords: this.parseRecordList(lookupRecordDesc),\n           };\n       }\n       check.assert(\n           false,\n           '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.'\n       );\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\n   subtableParsers$1[7] = function parseLookup7() {\n       // Extension Substitution subtable\n       var substFormat = this.parseUShort();\n       check.argument(\n           substFormat === 1,\n           'GSUB Extension Substitution subtable identifier-format must be 1'\n       );\n       var extensionLookupType = this.parseUShort();\n       var extensionParser = new Parser(\n           this.data,\n           this.offset + this.parseULong()\n       );\n       return {\n           substFormat: 1,\n           lookupType: extensionLookupType,\n           extension: subtableParsers$1[extensionLookupType].call(extensionParser),\n       };\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\n   subtableParsers$1[8] = function parseLookup8() {\n       var substFormat = this.parseUShort();\n       check.argument(\n           substFormat === 1,\n           'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1'\n       );\n       return {\n           substFormat: substFormat,\n           coverage: this.parsePointer(Parser.coverage),\n           backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n           lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n           substitutes: this.parseUShortList(),\n       };\n   };\n\n   // https://www.microsoft.com/typography/OTSPEC/gsub.htm\n   function parseGsubTable(data, start) {\n       start = start || 0;\n       var p = new Parser(data, start);\n       var tableVersion = p.parseVersion(1);\n       check.argument(\n           tableVersion === 1 || tableVersion === 1.1,\n           'Unsupported GSUB table version.'\n       );\n       if (tableVersion === 1) {\n           return {\n               version: tableVersion,\n               scripts: p.parseScriptList(),\n               features: p.parseFeatureList(),\n               lookups: p.parseLookupList(subtableParsers$1),\n           };\n       } else {\n           return {\n               version: tableVersion,\n               scripts: p.parseScriptList(),\n               features: p.parseFeatureList(),\n               lookups: p.parseLookupList(subtableParsers$1),\n               variations: p.parseFeatureVariationsList(),\n           };\n       }\n   }\n\n   var gsub = { parse: parseGsubTable };\n\n   // The `head` table contains global information about the font.\n\n   // Parse the header `head` table\n   function parseHeadTable(data, start) {\n       var head = {};\n       var p = new parse.Parser(data, start);\n       head.version = p.parseVersion();\n       head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n       head.checkSumAdjustment = p.parseULong();\n       head.magicNumber = p.parseULong();\n       check.argument(\n           head.magicNumber === 0x5f0f3cf5,\n           'Font header has wrong magic number.'\n       );\n       head.flags = p.parseUShort();\n       head.unitsPerEm = p.parseUShort();\n       head.created = p.parseLongDateTime();\n       head.modified = p.parseLongDateTime();\n       head.xMin = p.parseShort();\n       head.yMin = p.parseShort();\n       head.xMax = p.parseShort();\n       head.yMax = p.parseShort();\n       head.macStyle = p.parseUShort();\n       head.lowestRecPPEM = p.parseUShort();\n       head.fontDirectionHint = p.parseShort();\n       head.indexToLocFormat = p.parseShort();\n       head.glyphDataFormat = p.parseShort();\n       return head;\n   }\n\n   var head = { parse: parseHeadTable };\n\n   // The `hhea` table contains information for horizontal layout.\n\n   // Parse the horizontal header `hhea` table\n   function parseHheaTable(data, start) {\n       var hhea = {};\n       var p = new parse.Parser(data, start);\n       hhea.version = p.parseVersion();\n       hhea.ascender = p.parseShort();\n       hhea.descender = p.parseShort();\n       hhea.lineGap = p.parseShort();\n       hhea.advanceWidthMax = p.parseUShort();\n       hhea.minLeftSideBearing = p.parseShort();\n       hhea.minRightSideBearing = p.parseShort();\n       hhea.xMaxExtent = p.parseShort();\n       hhea.caretSlopeRise = p.parseShort();\n       hhea.caretSlopeRun = p.parseShort();\n       hhea.caretOffset = p.parseShort();\n       p.relativeOffset += 8;\n       hhea.metricDataFormat = p.parseShort();\n       hhea.numberOfHMetrics = p.parseUShort();\n       return hhea;\n   }\n\n   var hhea = { parse: parseHheaTable };\n\n   // The `hmtx` table contains the horizontal metrics for all glyphs.\n\n   function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n       var advanceWidth;\n       var leftSideBearing;\n       var p = new parse.Parser(data, start);\n       for (var i = 0; i < numGlyphs; i += 1) {\n           // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n           if (i < numMetrics) {\n               advanceWidth = p.parseUShort();\n               leftSideBearing = p.parseShort();\n           }\n\n           var glyph = glyphs.get(i);\n           glyph.advanceWidth = advanceWidth;\n           glyph.leftSideBearing = leftSideBearing;\n       }\n   }\n\n   function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n       font._hmtxTableData = {};\n\n       var advanceWidth;\n       var leftSideBearing;\n       var p = new parse.Parser(data, start);\n       for (var i = 0; i < numGlyphs; i += 1) {\n           // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n           if (i < numMetrics) {\n               advanceWidth = p.parseUShort();\n               leftSideBearing = p.parseShort();\n           }\n\n           font._hmtxTableData[i] = {\n               advanceWidth: advanceWidth,\n               leftSideBearing: leftSideBearing,\n           };\n       }\n   }\n\n   // Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n   // This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\n   function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n       if (opt.lowMemory)\n           { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n       else { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n   }\n\n   var hmtx = { parse: parseHmtxTable };\n\n   // The `kern` table contains kerning pairs.\n\n   function parseWindowsKernTable(p) {\n       var pairs = {};\n       // Skip nTables.\n       p.skip('uShort');\n       var subtableVersion = p.parseUShort();\n       check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n       // Skip subtableLength, subtableCoverage\n       p.skip('uShort', 2);\n       var nPairs = p.parseUShort();\n       // Skip searchRange, entrySelector, rangeShift.\n       p.skip('uShort', 3);\n       for (var i = 0; i < nPairs; i += 1) {\n           var leftIndex = p.parseUShort();\n           var rightIndex = p.parseUShort();\n           var value = p.parseShort();\n           pairs[leftIndex + ',' + rightIndex] = value;\n       }\n       return pairs;\n   }\n\n   function parseMacKernTable(p) {\n       var pairs = {};\n       // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n       // Skip the rest.\n       p.skip('uShort');\n       var nTables = p.parseULong();\n       //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n       if (nTables > 1) {\n           console.warn('Only the first kern subtable is supported.');\n       }\n       p.skip('uLong');\n       var coverage = p.parseUShort();\n       var subtableVersion = coverage & 0xFF;\n       p.skip('uShort');\n       if (subtableVersion === 0) {\n           var nPairs = p.parseUShort();\n           // Skip searchRange, entrySelector, rangeShift.\n           p.skip('uShort', 3);\n           for (var i = 0; i < nPairs; i += 1) {\n               var leftIndex = p.parseUShort();\n               var rightIndex = p.parseUShort();\n               var value = p.parseShort();\n               pairs[leftIndex + ',' + rightIndex] = value;\n           }\n       }\n       return pairs;\n   }\n\n   // Parse the `kern` table which contains kerning pairs.\n   function parseKernTable(data, start) {\n       var p = new parse.Parser(data, start);\n       var tableVersion = p.parseUShort();\n       if (tableVersion === 0) {\n           return parseWindowsKernTable(p);\n       } else if (tableVersion === 1) {\n           return parseMacKernTable(p);\n       } else {\n           throw new Error('Unsupported kern table version (' + tableVersion + ').');\n       }\n   }\n\n   var kern = { parse: parseKernTable };\n\n   // The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\n   function parseLtagTable(data, start) {\n       var p = new parse.Parser(data, start);\n       var tableVersion = p.parseULong();\n       check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n       // The 'ltag' specification does not define any flags; skip the field.\n       p.skip('uLong', 1);\n       var numTags = p.parseULong();\n\n       var tags = [];\n       for (var i = 0; i < numTags; i++) {\n           var tag = '';\n           var offset = start + p.parseUShort();\n           var length = p.parseUShort();\n           for (var j = offset; j < offset + length; ++j) {\n               tag += String.fromCharCode(data.getInt8(j));\n           }\n\n           tags.push(tag);\n       }\n\n       return tags;\n   }\n\n   var ltag = { parse: parseLtagTable };\n\n   // The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n   // Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n   // relative to the beginning of the glyphData table.\n   // The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n   // The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n   // version where offsets are stored as uLongs. The `head` table specifies which version to use\n   // (under indexToLocFormat).\n   function parseLocaTable(data, start, numGlyphs, shortVersion) {\n       var p = new parse.Parser(data, start);\n       var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n       // There is an extra entry after the last index element to compute the length of the last glyph.\n       // That's why we use numGlyphs + 1.\n       var glyphOffsets = [];\n       for (var i = 0; i < numGlyphs + 1; i += 1) {\n           var glyphOffset = parseFn.call(p);\n           if (shortVersion) {\n               // The short table version stores the actual offset divided by 2.\n               glyphOffset *= 2;\n           }\n\n           glyphOffsets.push(glyphOffset);\n       }\n\n       return glyphOffsets;\n   }\n\n   var loca = { parse: parseLocaTable };\n\n   // The `maxp` table establishes the memory requirements for the font.\n\n   // Parse the maximum profile `maxp` table.\n   function parseMaxpTable(data, start) {\n       var maxp = {};\n       var p = new parse.Parser(data, start);\n       maxp.version = p.parseVersion();\n       maxp.numGlyphs = p.parseUShort();\n       if (maxp.version === 1.0) {\n           maxp.maxPoints = p.parseUShort();\n           maxp.maxContours = p.parseUShort();\n           maxp.maxCompositePoints = p.parseUShort();\n           maxp.maxCompositeContours = p.parseUShort();\n           maxp.maxZones = p.parseUShort();\n           maxp.maxTwilightPoints = p.parseUShort();\n           maxp.maxStorage = p.parseUShort();\n           maxp.maxFunctionDefs = p.parseUShort();\n           maxp.maxInstructionDefs = p.parseUShort();\n           maxp.maxStackElements = p.parseUShort();\n           maxp.maxSizeOfInstructions = p.parseUShort();\n           maxp.maxComponentElements = p.parseUShort();\n           maxp.maxComponentDepth = p.parseUShort();\n       }\n\n       return maxp;\n   }\n\n   var maxp = { parse: parseMaxpTable };\n\n   // The `OS/2` table contains metrics required in OpenType fonts.\n\n   // Parse the OS/2 and Windows metrics `OS/2` table\n   function parseOS2Table(data, start) {\n       var os2 = {};\n       var p = new parse.Parser(data, start);\n       os2.version = p.parseUShort();\n       os2.xAvgCharWidth = p.parseShort();\n       os2.usWeightClass = p.parseUShort();\n       os2.usWidthClass = p.parseUShort();\n       os2.fsType = p.parseUShort();\n       os2.ySubscriptXSize = p.parseShort();\n       os2.ySubscriptYSize = p.parseShort();\n       os2.ySubscriptXOffset = p.parseShort();\n       os2.ySubscriptYOffset = p.parseShort();\n       os2.ySuperscriptXSize = p.parseShort();\n       os2.ySuperscriptYSize = p.parseShort();\n       os2.ySuperscriptXOffset = p.parseShort();\n       os2.ySuperscriptYOffset = p.parseShort();\n       os2.yStrikeoutSize = p.parseShort();\n       os2.yStrikeoutPosition = p.parseShort();\n       os2.sFamilyClass = p.parseShort();\n       os2.panose = [];\n       for (var i = 0; i < 10; i++) {\n           os2.panose[i] = p.parseByte();\n       }\n\n       os2.ulUnicodeRange1 = p.parseULong();\n       os2.ulUnicodeRange2 = p.parseULong();\n       os2.ulUnicodeRange3 = p.parseULong();\n       os2.ulUnicodeRange4 = p.parseULong();\n       os2.achVendID = String.fromCharCode(\n           p.parseByte(),\n           p.parseByte(),\n           p.parseByte(),\n           p.parseByte()\n       );\n       os2.fsSelection = p.parseUShort();\n       os2.usFirstCharIndex = p.parseUShort();\n       os2.usLastCharIndex = p.parseUShort();\n       os2.sTypoAscender = p.parseShort();\n       os2.sTypoDescender = p.parseShort();\n       os2.sTypoLineGap = p.parseShort();\n       os2.usWinAscent = p.parseUShort();\n       os2.usWinDescent = p.parseUShort();\n       if (os2.version >= 1) {\n           os2.ulCodePageRange1 = p.parseULong();\n           os2.ulCodePageRange2 = p.parseULong();\n       }\n\n       if (os2.version >= 2) {\n           os2.sxHeight = p.parseShort();\n           os2.sCapHeight = p.parseShort();\n           os2.usDefaultChar = p.parseUShort();\n           os2.usBreakChar = p.parseUShort();\n           os2.usMaxContent = p.parseUShort();\n       }\n\n       return os2;\n   }\n\n   var os2 = { parse: parseOS2Table };\n\n   // The `post` table stores additional PostScript information, such as glyph names.\n\n   // Parse the PostScript `post` table\n   function parsePostTable(data, start) {\n       var post = {};\n       var p = new parse.Parser(data, start);\n       post.version = p.parseVersion();\n       post.italicAngle = p.parseFixed();\n       post.underlinePosition = p.parseShort();\n       post.underlineThickness = p.parseShort();\n       post.isFixedPitch = p.parseULong();\n       post.minMemType42 = p.parseULong();\n       post.maxMemType42 = p.parseULong();\n       post.minMemType1 = p.parseULong();\n       post.maxMemType1 = p.parseULong();\n       post.names = [];\n       switch (post.version) {\n           case 1:\n               break;\n           case 2:\n               post.numberOfGlyphs = p.parseUShort();\n               post.glyphNameIndex = new Array(post.numberOfGlyphs);\n               for (var i = 0; i < post.numberOfGlyphs; i++) {\n                   post.glyphNameIndex[i] = p.parseUShort();\n               }\n               break;\n           case 2.5:\n               post.numberOfGlyphs = p.parseUShort();\n               post.offset = new Array(post.numberOfGlyphs);\n               for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                   post.offset[i$1] = p.parseChar();\n               }\n               break;\n       }\n       return post;\n   }\n\n   var post = { parse: parsePostTable };\n\n   // Data types used in the OpenType font file.\n\n   /**\n    * @exports opentype.decode\n    * @class\n    */\n   var decode = {};\n\n   /**\n    * @param {DataView} data\n    * @param {number} offset\n    * @param {number} numBytes\n    * @returns {string}\n    */\n   decode.UTF8 = function(data, offset, numBytes) {\n       var codePoints = [];\n       var numChars = numBytes;\n       for (var j = 0; j < numChars; j++, offset += 1) {\n           codePoints[j] = data.getUint8(offset);\n       }\n\n       return String.fromCharCode.apply(null, codePoints);\n   };\n\n   /**\n    * @param {DataView} data\n    * @param {number} offset\n    * @param {number} numBytes\n    * @returns {string}\n    */\n   decode.UTF16 = function(data, offset, numBytes) {\n       var codePoints = [];\n       var numChars = numBytes / 2;\n       for (var j = 0; j < numChars; j++, offset += 2) {\n           codePoints[j] = data.getUint16(offset);\n       }\n\n       return String.fromCharCode.apply(null, codePoints);\n   };\n\n   // Data for converting old eight-bit Macintosh encodings to Unicode.\n   // This representation is optimized for decoding; encoding is slower\n   // and needs more memory. The assumption is that all opentype.js users\n   // want to open fonts, but saving a font will be comparatively rare\n   // so it can be more expensive. Keyed by IANA character set name.\n   //\n   // Python script for generating these strings:\n   //\n   //     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n   //     print(s.encode('utf-8'))\n   /**\n    * @private\n    */\n   var eightBitMacEncodings = {\n       'x-mac-croatian':  // Python: 'mac_croatian'\n       'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Å â¢Â´Â¨â Å½ÃâÂ±â¤â¥âÂµâââÅ¡â«ÂªÂºÎ©Å¾Ã¸' +\n       'Â¿Â¡Â¬âÆâÄÂ«Äâ¦Â ÃÃÃÅÅÄâââââÃ·âï£¿Â©ââ¬â¹âºÃÂ»âÂ·âââ°ÃÄÃÄÃÃÃÃÃÃÃÄÃÃÃÃÄ±ËËÂ¯ÏÃËÂ¸ÃÃ¦Ë',\n       'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n       'ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â Â°ÒÂ£Â§â¢Â¶ÐÂ®Â©â¢ÐÑâ ÐÑâÂ±â¤â¥ÑÂµÒÐÐÑÐÑÐÑÐÑ' +\n       'ÑÐÂ¬âÆââÂ«Â»â¦Â ÐÑÐÑÑââââââÃ·âÐÑÐÑâÐÑÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ',\n       'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n       'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃá¸Â±â¤â¥á¸ÄÄá¸á¸á¸á¸Ä Ä¡á¹Ã¦Ã¸' +\n       'á¹á¹á¹É¼ÆÅ¿á¹ Â«Â»â¦Â ÃÃÃÅÅââââââá¹¡áºÃ¿Å¸á¹ªâ¬â¹âºÅ¶Å·á¹«Â·á»²á»³âÃÃÃÃÃÃÃÃÃÃÃâ£ÃÃÃÃÄ±ÃÃ½Å´Åµáºáºáºáºáºáº',\n       'x-mac-greek':  // Python: 'mac_greek'\n       'ÃÂ¹Â²ÃÂ³ÃÃÎÃ Ã¢Ã¤ÎÂ¨Ã§Ã©Ã¨ÃªÃ«Â£â¢Ã®Ã¯â¢Â½â°Ã´Ã¶Â¦â¬Ã¹Ã»Ã¼â ÎÎÎÎÎÎ ÃÂ®Â©Î£ÎªÂ§â Â°Â·ÎÂ±â¤â¥Â¥ÎÎÎÎÎÎÎÎ¦Î«Î¨Î©' +\n       'Î¬ÎÂ¬ÎÎ¡âÎ¤Â«Â»â¦Â Î¥Î§ÎÎÅââââââÃ·ÎÎÎÎÎ­Î®Î¯ÏÎÏÎ±Î²ÏÎ´ÎµÏÎ³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿ÏÏÏÏÏÎ¸ÏÏÏÏÎ¶ÏÏÎÎ°\\u00AD',\n       'x-mac-icelandic':  // Python: 'mac_iceland'\n       'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©Ã¦Ã¸' +\n       'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ââ¬ÃÃ°ÃÃ¾Ã½Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË',\n       'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n       'ááááááá±á²á³á´á¸á¹áááááááá¦á­á®á¯á°á²á³áááááááÂ°á¡á¥á¦â¢Â¶á§Â®Â©â¢á¨áªá«á»áááááááá¯á°á±á²á´áµáááá' +\n       'ááááªá¨á©áªá«á­â¦Â á®á¾áááââââââáááááááááááá¿áááááááááááááá±á²á³á´áµá¶áá á¡á¢á£á¤á¥á¦á¼ÅÅ',\n       'x-mac-ce':  // Python: 'mac_latin2'\n       'ÃÄÄÃÄÃÃÃ¡ÄÄÃ¤ÄÄÄÃ©Å¹ÅºÄÃ­ÄÄÄÄÃ³ÄÃ´Ã¶ÃµÃºÄÄÃ¼â Â°ÄÂ£Â§â¢Â¶ÃÂ®Â©â¢ÄÂ¨â Ä£Ä®Ä¯Äªâ¤â¥Ä«Ä¶ââÅÄ»Ä¼Ä½Ä¾Ä¹ÄºÅ' +\n       'ÅÅÂ¬âÅÅâÂ«Â»â¦Â ÅÅÃÅÅââââââÃ·âÅÅÅÅâ¹âºÅÅÅÅ ââÅ¡ÅÅÃÅ¤Å¥ÃÅ½Å¾ÅªÃÃÅ«Å®ÃÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë',\n       macintosh:  // Python: 'mac_roman'\n       'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©Ã¦Ã¸' +\n       'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ââ¬â¹âºï¬ï¬â¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË',\n       'x-mac-romanian':  // Python: 'mac_romanian'\n       'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÄÈâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©ÄÈ' +\n       'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ââ¬â¹âºÈÈâ¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË',\n       'x-mac-turkish':  // Python: 'mac_turkish'\n       'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©Ã¦Ã¸' +\n       'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ÄÄÄ°Ä±ÅÅâ¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃï¢ ËËÂ¯ËËËÂ¸ËËË'\n   };\n\n   /**\n    * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n    * string, or 'undefined' if the encoding is unsupported. For example, we do\n    * not support Chinese, Japanese or Korean because these would need large\n    * mapping tables.\n    * @param {DataView} dataView\n    * @param {number} offset\n    * @param {number} dataLength\n    * @param {string} encoding\n    * @returns {string}\n    */\n   decode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n       var table = eightBitMacEncodings[encoding];\n       if (table === undefined) {\n           return undefined;\n       }\n\n       var result = '';\n       for (var i = 0; i < dataLength; i++) {\n           var c = dataView.getUint8(offset + i);\n           // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n           // mapped to U+0000..U+007F; we only need to look up the others.\n           if (c <= 0x7F) {\n               result += String.fromCharCode(c);\n           } else {\n               result += table[c & 0x7F];\n           }\n       }\n\n       return result;\n   };\n\n   // The `GPOS` table contains kerning pairs, among other things.\n\n   // Parse the metadata `meta` table.\n   // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\n   function parseMetaTable(data, start) {\n       var p = new parse.Parser(data, start);\n       var tableVersion = p.parseULong();\n       check.argument(tableVersion === 1, 'Unsupported META table version.');\n       p.parseULong(); // flags - currently unused and set to 0\n       p.parseULong(); // tableOffset\n       var numDataMaps = p.parseULong();\n\n       var tags = {};\n       for (var i = 0; i < numDataMaps; i++) {\n           var tag = p.parseTag();\n           var dataOffset = p.parseULong();\n           var dataLength = p.parseULong();\n           var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n           tags[tag] = text;\n       }\n       return tags;\n   }\n\n   var meta = { parse: parseMetaTable };\n\n   // opentype.js\n\n   /**\n    * The opentype library.\n    * @namespace opentype\n    */\n\n   // Table Directory Entries //////////////////////////////////////////////\n   /**\n    * Parses OpenType table entries.\n    * @param  {DataView}\n    * @param  {Number}\n    * @return {Object[]}\n    */\n   function parseOpenTypeTableEntries(data, numTables) {\n       var tableEntries = [];\n       var p = 12;\n       for (var i = 0; i < numTables; i += 1) {\n           var tag = parse.getTag(data, p);\n           var checksum = parse.getULong(data, p + 4);\n           var offset = parse.getULong(data, p + 8);\n           var length = parse.getULong(data, p + 12);\n           tableEntries.push({\n               tag: tag,\n               checksum: checksum,\n               offset: offset,\n               length: length,\n               compression: false,\n           });\n           p += 16;\n       }\n\n       return tableEntries;\n   }\n\n   /**\n    * Parses WOFF table entries.\n    * @param  {DataView}\n    * @param  {Number}\n    * @return {Object[]}\n    */\n   function parseWOFFTableEntries(data, numTables) {\n       var tableEntries = [];\n       var p = 44; // offset to the first table directory entry.\n       for (var i = 0; i < numTables; i += 1) {\n           var tag = parse.getTag(data, p);\n           var offset = parse.getULong(data, p + 4);\n           var compLength = parse.getULong(data, p + 8);\n           var origLength = parse.getULong(data, p + 12);\n           var compression = (void 0);\n           if (compLength < origLength) {\n               compression = 'WOFF';\n           } else {\n               compression = false;\n           }\n\n           tableEntries.push({\n               tag: tag,\n               offset: offset,\n               compression: compression,\n               compressedLength: compLength,\n               length: origLength,\n           });\n           p += 20;\n       }\n\n       return tableEntries;\n   }\n\n   /**\n    * @typedef TableData\n    * @type Object\n    * @property {DataView} data - The DataView\n    * @property {number} offset - The data offset.\n    */\n\n   /**\n    * @param  {DataView}\n    * @param  {Object}\n    * @return {TableData}\n    */\n   function uncompressTable(data, tableEntry) {\n       if (tableEntry.compression === 'WOFF') {\n           var inBuffer = new Uint8Array(\n               data.buffer,\n               tableEntry.offset + 2,\n               tableEntry.compressedLength - 2\n           );\n           var outBuffer = new Uint8Array(tableEntry.length);\n           inflateSync(inBuffer, outBuffer);\n           if (outBuffer.byteLength !== tableEntry.length) {\n               throw new Error(\n                   'Decompression error: ' +\n                       tableEntry.tag +\n                       \" decompressed length doesn't match recorded length\"\n               );\n           }\n\n           var view = new DataView(outBuffer.buffer, 0);\n           return { data: view, offset: 0 };\n       } else {\n           return { data: data, offset: tableEntry.offset };\n       }\n   }\n\n   // Public API ///////////////////////////////////////////////////////////\n\n   /**\n    * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n    * Throws an error if the font could not be parsed.\n    * @param  {ArrayBuffer}\n    * @param  {Object} opt - options for parsing\n    * @return {opentype.Font}\n    */\n   function parseBuffer(buffer, opt) {\n       opt = opt === undefined || opt === null ? {} : opt;\n\n       var indexToLocFormat;\n\n       // Since the constructor can also be called to create new fonts from scratch, we indicate this\n       // should be an empty font that we'll fill with our own data.\n       var font = new Font({ empty: true });\n\n       // OpenType fonts use big endian byte ordering.\n       // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n       // Instead we use DataViews where we can specify endianness.\n       var data = new DataView(buffer, 0);\n       var numTables;\n       var tableEntries = [];\n       var signature = parse.getTag(data, 0);\n       if (\n           signature === String.fromCharCode(0, 1, 0, 0) ||\n           signature === 'true' ||\n           signature === 'typ1'\n       ) {\n           font.outlinesFormat = 'truetype';\n           numTables = parse.getUShort(data, 4);\n           tableEntries = parseOpenTypeTableEntries(data, numTables);\n       } else if (signature === 'OTTO') {\n           font.outlinesFormat = 'cff';\n           numTables = parse.getUShort(data, 4);\n           tableEntries = parseOpenTypeTableEntries(data, numTables);\n       } else if (signature === 'wOFF') {\n           var flavor = parse.getTag(data, 4);\n           if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n               font.outlinesFormat = 'truetype';\n           } else if (flavor === 'OTTO') {\n               font.outlinesFormat = 'cff';\n           } else {\n               throw new Error('Unsupported OpenType flavor ' + signature);\n           }\n\n           numTables = parse.getUShort(data, 12);\n           tableEntries = parseWOFFTableEntries(data, numTables);\n       } else {\n           throw new Error('Unsupported OpenType signature ' + signature);\n       }\n\n       var cffTableEntry;\n       var fvarTableEntry;\n       var glyfTableEntry;\n       var gdefTableEntry;\n       var gposTableEntry;\n       var gsubTableEntry;\n       var hmtxTableEntry;\n       var kernTableEntry;\n       var locaTableEntry;\n       var metaTableEntry;\n       var p;\n\n       for (var i = 0; i < numTables; i += 1) {\n           var tableEntry = tableEntries[i];\n           var table = (void 0);\n           switch (tableEntry.tag) {\n               case 'cmap':\n                   table = uncompressTable(data, tableEntry);\n                   font.tables.cmap = cmap.parse(table.data, table.offset);\n                   font.encoding = new CmapEncoding(font.tables.cmap);\n                   break;\n               case 'cvt ':\n                   table = uncompressTable(data, tableEntry);\n                   p = new parse.Parser(table.data, table.offset);\n                   font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                   break;\n               case 'fvar':\n                   fvarTableEntry = tableEntry;\n                   break;\n               case 'fpgm':\n                   table = uncompressTable(data, tableEntry);\n                   p = new parse.Parser(table.data, table.offset);\n                   font.tables.fpgm = p.parseByteList(tableEntry.length);\n                   break;\n               case 'head':\n                   table = uncompressTable(data, tableEntry);\n                   font.tables.head = head.parse(table.data, table.offset);\n                   font.unitsPerEm = font.tables.head.unitsPerEm;\n                   indexToLocFormat = font.tables.head.indexToLocFormat;\n                   break;\n               case 'hhea':\n                   table = uncompressTable(data, tableEntry);\n                   font.tables.hhea = hhea.parse(table.data, table.offset);\n                   font.ascender = font.tables.hhea.ascender;\n                   font.descender = font.tables.hhea.descender;\n                   font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                   break;\n               case 'hmtx':\n                   hmtxTableEntry = tableEntry;\n                   break;\n               case 'ltag':\n                   table = uncompressTable(data, tableEntry);\n                   ltagTable = ltag.parse(table.data, table.offset);\n                   break;\n               case 'maxp':\n                   table = uncompressTable(data, tableEntry);\n                   font.tables.maxp = maxp.parse(table.data, table.offset);\n                   font.numGlyphs = font.tables.maxp.numGlyphs;\n                   break;\n               case 'OS/2':\n                   table = uncompressTable(data, tableEntry);\n                   font.tables.os2 = os2.parse(table.data, table.offset);\n                   break;\n               case 'post':\n                   table = uncompressTable(data, tableEntry);\n                   font.tables.post = post.parse(table.data, table.offset);\n                   break;\n               case 'prep':\n                   table = uncompressTable(data, tableEntry);\n                   p = new parse.Parser(table.data, table.offset);\n                   font.tables.prep = p.parseByteList(tableEntry.length);\n                   break;\n               case 'glyf':\n                   glyfTableEntry = tableEntry;\n                   break;\n               case 'loca':\n                   locaTableEntry = tableEntry;\n                   break;\n               case 'CFF ':\n                   cffTableEntry = tableEntry;\n                   break;\n               case 'kern':\n                   kernTableEntry = tableEntry;\n                   break;\n               case 'GDEF':\n                   gdefTableEntry = tableEntry;\n                   break;\n               case 'GPOS':\n                   gposTableEntry = tableEntry;\n                   break;\n               case 'GSUB':\n                   gsubTableEntry = tableEntry;\n                   break;\n               case 'meta':\n                   metaTableEntry = tableEntry;\n                   break;\n           }\n       }\n\n       if (glyfTableEntry && locaTableEntry) {\n           var shortVersion = indexToLocFormat === 0;\n           var locaTable = uncompressTable(data, locaTableEntry);\n           var locaOffsets = loca.parse(\n               locaTable.data,\n               locaTable.offset,\n               font.numGlyphs,\n               shortVersion\n           );\n           var glyfTable = uncompressTable(data, glyfTableEntry);\n           font.glyphs = glyf.parse(\n               glyfTable.data,\n               glyfTable.offset,\n               locaOffsets,\n               font,\n               opt\n           );\n       } else if (cffTableEntry) {\n           var cffTable = uncompressTable(data, cffTableEntry);\n           cff.parse(cffTable.data, cffTable.offset, font, opt);\n       } else {\n           throw new Error(\"Font doesn't contain TrueType or CFF outlines.\");\n       }\n\n       var hmtxTable = uncompressTable(data, hmtxTableEntry);\n       hmtx.parse(\n           font,\n           hmtxTable.data,\n           hmtxTable.offset,\n           font.numberOfHMetrics,\n           font.numGlyphs,\n           font.glyphs,\n           opt\n       );\n       addGlyphNames(font, opt);\n\n       if (kernTableEntry) {\n           var kernTable = uncompressTable(data, kernTableEntry);\n           font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n       } else {\n           font.kerningPairs = {};\n       }\n\n       if (gdefTableEntry) {\n           var gdefTable = uncompressTable(data, gdefTableEntry);\n           font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n       }\n\n       if (gposTableEntry) {\n           var gposTable = uncompressTable(data, gposTableEntry);\n           font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n           font.position.init();\n       }\n\n       if (gsubTableEntry) {\n           var gsubTable = uncompressTable(data, gsubTableEntry);\n           font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n       }\n\n       if (fvarTableEntry) {\n           var fvarTable = uncompressTable(data, fvarTableEntry);\n           font.tables.fvar = fvar.parse(\n               fvarTable.data,\n               fvarTable.offset,\n               font.names\n           );\n       }\n\n       if (metaTableEntry) {\n           var metaTable = uncompressTable(data, metaTableEntry);\n           font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n           font.metas = font.tables.meta;\n       }\n\n       return font;\n   }\n\n   function load() {}\n   function loadSync() {}\n\n   var opentype = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      Font: Font,\n      Glyph: Glyph,\n      Path: Path,\n      _parse: parse,\n      parse: parseBuffer,\n      load: load,\n      loadSync: loadSync\n   });\n\n   exports.Font = Font;\n   exports.Glyph = Glyph;\n   exports.Path = Path;\n   exports._parse = parse;\n   exports.default = opentype;\n   exports.load = load;\n   exports.loadSync = loadSync;\n   exports.parse = parseBuffer;\n\n   Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=opentype.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNodWRpbmcvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLEtBQTREO0FBQy9ELEdBQUcsQ0FDd0Q7QUFDM0QsQ0FBQyw2QkFBNkI7O0FBRTlCLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQiw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsU0FBUztBQUNULHFCQUFxQixTQUFTO0FBQzlCLFNBQVM7QUFDVCxxQkFBcUIsU0FBUztBQUM5QixTQUFTO0FBQ1QscUJBQXFCLFNBQVM7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQSxt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QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsZUFBZTtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0QscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQSwwQkFBMEI7QUFDMUIsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsU0FBUztBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFNBQVM7QUFDM0IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsU0FBUztBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixTQUFTO0FBQzNCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhCQUE4QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0U7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xELDRDQUE0QyxtQ0FBbUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xELHFDQUFxQyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVEsaUJBQWlCLGtCQUFrQjtBQUN6RCxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVEsaUJBQWlCLG9CQUFvQjtBQUMzRCxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUSxpQkFBaUI7QUFDdkMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVEsYUFBYTtBQUNuQyxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVEsZ0RBQWdELG1DQUFtQztBQUN6RyxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFLG1DQUFtQyxvQ0FBb0M7QUFDdkUsbUNBQW1DLG9DQUFvQzs7QUFFdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsc0NBQXNDO0FBQ3RDLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsT0FBTztBQUM5Qjs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVB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QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qix1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0EsMkJBQTJCO0FBQzNCLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7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QTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdDQUF3QztBQUN4QywwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwQ0FBMEM7QUFDMUMsMERBQTBEO0FBQzFELDBDQUEwQztBQUMxQywwREFBMEQ7QUFDMUQsd0NBQXdDO0FBQ3hDLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwQ0FBMEM7QUFDMUMsMERBQTBEO0FBQzFELDBDQUEwQztBQUMxQywwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWM7QUFDZDs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGVBQWUsUUFBUTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixhQUFhOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsYUFBYTs7QUFFL0QsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9Ac2h1ZGluZy9vcGVudHlwZS5qcy9kaXN0L29wZW50eXBlLmpzP2Y1NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL29wZW50eXBlLmpzLm9yZyB2MS4zLjUgfCAoYykgRnJlZGVyaWsgRGUgQmxlc2VyIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBNSVQgTGljZW5zZSB8IFVzZXMgZmZsYXRlIGJ5IDEwMWFycm93eiBhbmQgc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdCBwb2x5ZmlsbCBieSBNYXRoaWFzIEJ5bmVuc1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5vcGVudHlwZSA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgIC8vIERFRkxBVEUgaXMgYSBjb21wbGV4IGZvcm1hdDsgdG8gcmVhZCB0aGlzIGNvZGUsIHlvdSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhlIFJGQyBmaXJzdDpcblxuICAgLy8gYWxpYXNlcyBmb3Igc2hvcnRlciBjb21wcmVzc2VkIGNvZGUgKG1vc3QgbWluaWZlcnMgZG9uJ3QgZG8gdGhpcylcbiAgIHZhciB1OCA9IFVpbnQ4QXJyYXksIHUxNiA9IFVpbnQxNkFycmF5LCB1MzIgPSBVaW50MzJBcnJheTtcbiAgIC8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG4gICB2YXIgZmxlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgLyogdW51c2VkICovIDAsIDAsIC8qIGltcG9zc2libGUgKi8gMF0pO1xuICAgLy8gZml4ZWQgZGlzdGFuY2UgZXh0cmEgYml0c1xuICAgLy8gc2VlIGZsZWIgbm90ZVxuICAgdmFyIGZkZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgLyogdW51c2VkICovIDAsIDBdKTtcbiAgIC8vIGNvZGUgbGVuZ3RoIGluZGV4IG1hcFxuICAgdmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbiAgIC8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbiAgIHZhciBmcmViID0gZnVuY3Rpb24gKGViLCBzdGFydCkge1xuICAgICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICAgICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgICAgICB9XG4gICAgICAgLy8gbnVtYmVycyBoZXJlIGFyZSBhdCBtYXggMTggYml0c1xuICAgICAgIHZhciByID0gbmV3IHUzMihiWzMwXSk7XG4gICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMDsgKytpKSB7XG4gICAgICAgICAgIGZvciAodmFyIGogPSBiW2ldOyBqIDwgYltpICsgMV07ICsraikge1xuICAgICAgICAgICAgICAgcltqXSA9ICgoaiAtIGJbaV0pIDw8IDUpIHwgaTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gW2IsIHJdO1xuICAgfTtcbiAgIHZhciBfYSA9IGZyZWIoZmxlYiwgMiksIGZsID0gX2FbMF0sIHJldmZsID0gX2FbMV07XG4gICAvLyB3ZSBjYW4gaWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIG90aGVyIG51bWJlcnMgYXJlIHdyb25nOyB0aGV5IG5ldmVyIGhhcHBlbiBhbnl3YXlcbiAgIGZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xuICAgdmFyIF9iID0gZnJlYihmZGViLCAwKSwgZmQgPSBfYlswXTtcbiAgIC8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxuICAgdmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjc2ODsgKytpKSB7XG4gICAgICAgLy8gcmV2ZXJzZSB0YWJsZSBhbGdvcml0aG0gZnJvbSBTT1xuICAgICAgIHZhciB4ID0gKChpICYgMHhBQUFBKSA+Pj4gMSkgfCAoKGkgJiAweDU1NTUpIDw8IDEpO1xuICAgICAgIHggPSAoKHggJiAweENDQ0MpID4+PiAyKSB8ICgoeCAmIDB4MzMzMykgPDwgMik7XG4gICAgICAgeCA9ICgoeCAmIDB4RjBGMCkgPj4+IDQpIHwgKCh4ICYgMHgwRjBGKSA8PCA0KTtcbiAgICAgICByZXZbaV0gPSAoKCh4ICYgMHhGRjAwKSA+Pj4gOCkgfCAoKHggJiAweDAwRkYpIDw8IDgpKSA+Pj4gMTtcbiAgIH1cbiAgIC8vIGNyZWF0ZSBodWZmbWFuIHRyZWUgZnJvbSB1OCBcIm1hcFwiOiBpbmRleCAtPiBjb2RlIGxlbmd0aCBmb3IgY29kZSBpbmRleFxuICAgLy8gbWIgKG1heCBiaXRzKSBtdXN0IGJlIGF0IG1vc3QgMTVcbiAgIC8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xuICAgdmFyIGhNYXAgPSAoZnVuY3Rpb24gKGNkLCBtYiwgcikge1xuICAgICAgIHZhciBzID0gY2QubGVuZ3RoO1xuICAgICAgIC8vIGluZGV4XG4gICAgICAgdmFyIGkgPSAwO1xuICAgICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiAjIG9mIGNvZGVzIHdpdGggYml0IGxlbmd0aCA9IGluZGV4XG4gICAgICAgdmFyIGwgPSBuZXcgdTE2KG1iKTtcbiAgICAgICAvLyBsZW5ndGggb2YgY2QgbXVzdCBiZSAyODggKHRvdGFsICMgb2YgY29kZXMpXG4gICAgICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgaWYgKGNkW2ldKVxuICAgICAgICAgICAgICAgeyArK2xbY2RbaV0gLSAxXTsgfVxuICAgICAgIH1cbiAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbWluaW11bSBjb2RlIGZvciBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICAgICB2YXIgbGUgPSBuZXcgdTE2KG1iKTtcbiAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWI7ICsraSkge1xuICAgICAgICAgICBsZVtpXSA9IChsZVtpIC0gMV0gKyBsW2kgLSAxXSkgPDwgMTtcbiAgICAgICB9XG4gICAgICAgdmFyIGNvO1xuICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBudW1iZXIgb2YgYWN0dWFsIGJpdHMsIHN5bWJvbCBmb3IgY29kZVxuICAgICAgICAgICBjbyA9IG5ldyB1MTYoMSA8PCBtYik7XG4gICAgICAgICAgIC8vIGJpdHMgdG8gcmVtb3ZlIGZvciByZXZlcnNlclxuICAgICAgICAgICB2YXIgcnZiID0gMTUgLSBtYjtcbiAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgICAgLy8gaWdub3JlIDAgbGVuZ3Roc1xuICAgICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgLy8gbnVtIGVuY29kaW5nIGJvdGggc3ltYm9sIGFuZCBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICB2YXIgc3YgPSAoaSA8PCA0KSB8IGNkW2ldO1xuICAgICAgICAgICAgICAgICAgIC8vIGZyZWUgYml0c1xuICAgICAgICAgICAgICAgICAgIHZhciByXzEgPSBtYiAtIGNkW2ldO1xuICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgdmFyIHYgPSBsZVtjZFtpXSAtIDFdKysgPDwgcl8xO1xuICAgICAgICAgICAgICAgICAgIC8vIG0gaXMgZW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IHYgfCAoKDEgPDwgcl8xKSAtIDEpOyB2IDw9IG07ICsrdikge1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVyeSAxNiBiaXQgdmFsdWUgc3RhcnRpbmcgd2l0aCB0aGUgY29kZSB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgIGNvW3Jldlt2XSA+Pj4gcnZiXSA9IHN2O1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICBlbHNlIHtcbiAgICAgICAgICAgY28gPSBuZXcgdTE2KHMpO1xuICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICAgICBjb1tpXSA9IHJldltsZVtjZFtpXSAtIDFdKytdID4+PiAoMTUgLSBjZFtpXSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGNvO1xuICAgfSk7XG4gICAvLyBmaXhlZCBsZW5ndGggdHJlZVxuICAgdmFyIGZsdCA9IG5ldyB1OCgyODgpO1xuICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNDQ7ICsraSlcbiAgICAgICB7IGZsdFtpXSA9IDg7IH1cbiAgIGZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICAgICB7IGZsdFtpXSA9IDk7IH1cbiAgIGZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICAgICB7IGZsdFtpXSA9IDc7IH1cbiAgIGZvciAodmFyIGkgPSAyODA7IGkgPCAyODg7ICsraSlcbiAgICAgICB7IGZsdFtpXSA9IDg7IH1cbiAgIC8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbiAgIHZhciBmZHQgPSBuZXcgdTgoMzIpO1xuICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgICAgIHsgZmR0W2ldID0gNTsgfVxuICAgLy8gZml4ZWQgbGVuZ3RoIG1hcFxuICAgdmFyIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbiAgIC8vIGZpeGVkIGRpc3RhbmNlIG1hcFxuICAgdmFyIGZkcm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAxKTtcbiAgIC8vIGZpbmQgbWF4IG9mIGFycmF5XG4gICB2YXIgbWF4ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICB2YXIgbSA9IGFbMF07XG4gICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgIGlmIChhW2ldID4gbSlcbiAgICAgICAgICAgICAgIHsgbSA9IGFbaV07IH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIG07XG4gICB9O1xuICAgLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbiAgIHZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbiAgIH07XG4gICAvLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbiAgIHZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xuICAgfTtcbiAgIC8vIGdldCBlbmQgb2YgYnl0ZVxuICAgdmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwICsgNykgLyA4KSB8IDA7IH07XG4gICAvLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbiAgIC8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxuICAgdmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgICAgeyBzID0gMDsgfVxuICAgICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICAgICB7IGUgPSB2Lmxlbmd0aDsgfVxuICAgICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgICAgdmFyIG4gPSBuZXcgKHYuQllURVNfUEVSX0VMRU1FTlQgPT0gMiA/IHUxNiA6IHYuQllURVNfUEVSX0VMRU1FTlQgPT0gNCA/IHUzMiA6IHU4KShlIC0gcyk7XG4gICAgICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgICAgcmV0dXJuIG47XG4gICB9O1xuICAgLy8gZXJyb3IgY29kZXNcbiAgIHZhciBlYyA9IFtcbiAgICAgICAndW5leHBlY3RlZCBFT0YnLFxuICAgICAgICdpbnZhbGlkIGJsb2NrIHR5cGUnLFxuICAgICAgICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJyxcbiAgICAgICAnaW52YWxpZCBkaXN0YW5jZScsXG4gICAgICAgJ3N0cmVhbSBmaW5pc2hlZCcsXG4gICAgICAgJ25vIHN0cmVhbSBoYW5kbGVyJyxcbiAgICAgICAsXG4gICAgICAgJ25vIGNhbGxiYWNrJyxcbiAgICAgICAnaW52YWxpZCBVVEYtOCBkYXRhJyxcbiAgICAgICAnZXh0cmEgZmllbGQgdG9vIGxvbmcnLFxuICAgICAgICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknLFxuICAgICAgICdmaWxlbmFtZSB0b28gbG9uZycsXG4gICAgICAgJ3N0cmVhbSBmaW5pc2hpbmcnLFxuICAgICAgICdpbnZhbGlkIHppcCBkYXRhJ1xuICAgICAgIC8vIGRldGVybWluZWQgYnkgdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcbiAgIF07XG4gICB2YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICAgICBlLmNvZGUgPSBpbmQ7XG4gICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgICAgICB7IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGUsIGVycik7IH1cbiAgICAgICBpZiAoIW50KVxuICAgICAgICAgICB7IHRocm93IGU7IH1cbiAgICAgICByZXR1cm4gZTtcbiAgIH07XG4gICAvLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbiAgIHZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICAgICBpZiAoIXNsIHx8IChzdCAmJiBzdC5mICYmICFzdC5sKSlcbiAgICAgICAgICAgeyByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTsgfVxuICAgICAgIC8vIGhhdmUgdG8gZXN0aW1hdGUgc2l6ZVxuICAgICAgIHZhciBub0J1ZiA9ICFidWYgfHwgc3Q7XG4gICAgICAgLy8gbm8gc3RhdGVcbiAgICAgICB2YXIgbm9TdCA9ICFzdCB8fCBzdC5pO1xuICAgICAgIGlmICghc3QpXG4gICAgICAgICAgIHsgc3QgPSB7fTsgfVxuICAgICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgICAgIGlmICghYnVmKVxuICAgICAgICAgICB7IGJ1ZiA9IG5ldyB1OChzbCAqIDMpOyB9XG4gICAgICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgICAgICAgaWYgKGwgPiBibCkge1xuICAgICAgICAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICAgICB2YXIgbmJ1ZiA9IG5ldyB1OChNYXRoLm1heChibCAqIDIsIGwpKTtcbiAgICAgICAgICAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICAgICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgICAvLyAgbGFzdCBjaHVuayAgICAgICAgIGJpdHBvcyAgICAgICAgICAgYnl0ZXNcbiAgICAgICB2YXIgZmluYWwgPSBzdC5mIHx8IDAsIHBvcyA9IHN0LnAgfHwgMCwgYnQgPSBzdC5iIHx8IDAsIGxtID0gc3QubCwgZG0gPSBzdC5kLCBsYnQgPSBzdC5tLCBkYnQgPSBzdC5uO1xuICAgICAgIC8vIHRvdGFsIGJpdHNcbiAgICAgICB2YXIgdGJ0cyA9IHNsICogODtcbiAgICAgICBkbyB7XG4gICAgICAgICAgIGlmICghbG0pIHtcbiAgICAgICAgICAgICAgIC8vIEJGSU5BTCAtIHRoaXMgaXMgb25seSAxIHdoZW4gbGFzdCBjaHVuayBpcyBuZXh0XG4gICAgICAgICAgICAgICBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZXJyKDApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgICAgeyBjYnVmKGJ0ICsgbCk7IH1cbiAgICAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDgsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICAgICB7IGxtID0gZmxybSwgZG0gPSBmZHJtLCBsYnQgPSA5LCBkYnQgPSA1OyB9XG4gICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAvLyAgbGl0ZXJhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzXG4gICAgICAgICAgICAgICAgICAgdmFyIGhMaXQgPSBiaXRzKGRhdCwgcG9zLCAzMSkgKyAyNTcsIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBtYXAgdG8gZ2V0IHJlYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICBjbHRbY2xpbVtpXV0gPSBiaXRzKGRhdCwgcG9zICsgaSAqIDMsIDcpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLCBjbGJtc2sgPSAoMSA8PCBjbGIpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgbWFwXG4gICAgICAgICAgICAgICAgICAgdmFyIGNsbSA9IGhNYXAoY2x0LCBjbGIsIDEpO1xuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IHIgJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gciA+Pj4gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdG8gY29weVxuICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDcpLCBwb3MgKz0gMzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG4gPSAxMSArIGJpdHMoZGF0LCBwb3MsIDEyNyksIHBvcyArPSA3OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGR0W2krK10gPSBjOyB9XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgLy8gICAgbGVuZ3RoIHRyZWUgICAgICAgICAgICAgICAgIGRpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICB2YXIgbHQgPSBsZHQuc3ViYXJyYXkoMCwgaExpdCksIGR0ID0gbGR0LnN1YmFycmF5KGhMaXQpO1xuICAgICAgICAgICAgICAgICAgIC8vIG1heCBsZW5ndGggYml0c1xuICAgICAgICAgICAgICAgICAgIGxidCA9IG1heChsdCk7XG4gICAgICAgICAgICAgICAgICAgLy8gbWF4IGRpc3QgYml0c1xuICAgICAgICAgICAgICAgICAgIGRidCA9IG1heChkdCk7XG4gICAgICAgICAgICAgICAgICAgbG0gPSBoTWFwKGx0LCBsYnQsIDEpO1xuICAgICAgICAgICAgICAgICAgIGRtID0gaE1hcChkdCwgZGJ0LCAxKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB7IGVycigxKTsgfVxuICAgICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgeyBlcnIoMCk7IH1cbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgICAgICAgLy8gTWF4aW11bSBjaHVuayBzaXplIChwcmFjdGljYWxseSwgdGhlb3JldGljYWxseSBpbmZpbml0ZSkgaXMgMl4xNztcbiAgICAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgICAgeyBjYnVmKGJ0ICsgMTMxMDcyKTsgfVxuICAgICAgICAgICB2YXIgbG1zID0gKDEgPDwgbGJ0KSAtIDEsIGRtcyA9ICgxIDw8IGRidCkgLSAxO1xuICAgICAgICAgICB2YXIgbHBvcyA9IHBvcztcbiAgICAgICAgICAgZm9yICg7OyBscG9zID0gcG9zKSB7XG4gICAgICAgICAgICAgICAvLyBiaXRzIHJlYWQsIGNvZGVcbiAgICAgICAgICAgICAgIHZhciBjID0gbG1bYml0czE2KGRhdCwgcG9zKSAmIGxtc10sIHN5bSA9IGMgPj4+IDQ7XG4gICAgICAgICAgICAgICBwb3MgKz0gYyAmIDE1O1xuICAgICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgeyBlcnIoMCk7IH1cbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICAgICB7IGVycigyKTsgfVxuICAgICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICAgICB7IGJ1ZltidCsrXSA9IHN5bTsgfVxuICAgICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4+IDQ7XG4gICAgICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICAgICB7IGVycigzKTsgfVxuICAgICAgICAgICAgICAgICAgIHBvcyArPSBkICYgMTU7XG4gICAgICAgICAgICAgICAgICAgdmFyIGR0ID0gZmRbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgaWYgKGRzeW0gPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gZmRlYltkc3ltXTtcbiAgICAgICAgICAgICAgICAgICAgICAgZHQgKz0gYml0czE2KGRhdCwgcG9zKSAmICgoMSA8PCBiKSAtIDEpLCBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB7IGVycigwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgICAgICAgICAgICB7IGNidWYoYnQgKyAxMzEwNzIpOyB9XG4gICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgICAgaWYgKGxtKVxuICAgICAgICAgICAgICAgeyBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDsgfVxuICAgICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgICAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG4gICB9O1xuICAgLy8gZW1wdHlcbiAgIHZhciBldCA9IC8qI19fUFVSRV9fKi8gbmV3IHU4KDApO1xuICAgLyoqXG4gICAgKiBFeHBhbmRzIERFRkxBVEUgZGF0YSB3aXRoIG5vIHdyYXBwZXJcbiAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAgICAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAgICAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICAgICovXG4gICBmdW5jdGlvbiBpbmZsYXRlU3luYyhkYXRhLCBvdXQpIHtcbiAgICAgICByZXR1cm4gaW5mbHQoZGF0YSwgb3V0KTtcbiAgIH1cbiAgIC8vIHRleHQgZGVjb2RlclxuICAgdmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4gICAvLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG4gICB2YXIgdGRzID0gMDtcbiAgIHRyeSB7XG4gICAgICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICB0ZHMgPSAxO1xuICAgfVxuICAgY2F0Y2ggKGUpIHsgfVxuXG4gICAvLyBHZW9tZXRyaWMgb2JqZWN0c1xuXG4gICAvLyBpbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi9iYm94JztcblxuICAgLyoqXG4gICAgKiBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuICAgICogUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG4gICAgKiBAZXhwb3J0cyBvcGVudHlwZS5QYXRoXG4gICAgKiBAY2xhc3NcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICBmdW5jdGlvbiBQYXRoKCkge1xuICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICovXG4gICBQYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgIHR5cGU6ICdNJyxcbiAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgeTogeSxcbiAgICAgICB9KTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAqL1xuICAgUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICB0eXBlOiAnTCcsXG4gICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgIHk6IHksXG4gICAgICAgfSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIERyYXdzIGN1YmljIGN1cnZlXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIGN1cnZlVG9cbiAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICAgICovXG5cbiAgIC8qKlxuICAgICogRHJhd3MgY3ViaWMgY3VydmVcbiAgICAqIEBmdW5jdGlvblxuICAgICogYmV6aWVyQ3VydmVUb1xuICAgICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gICAgKiBAc2VlIGN1cnZlVG9cbiAgICAqL1xuICAgUGF0aC5wcm90b3R5cGUuY3VydmVUbyA9IFBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoXG4gICAgICAgeDEsXG4gICAgICAgeTEsXG4gICAgICAgeDIsXG4gICAgICAgeTIsXG4gICAgICAgeCxcbiAgICAgICB5XG4gICApIHtcbiAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgIHkyOiB5MixcbiAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgeTogeSxcbiAgICAgICB9KTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIHF1YWRyYXRpY0N1cnZlVG9cbiAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAgICAqL1xuXG4gICAvKipcbiAgICAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBxdWFkVG9cbiAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAgICAqL1xuICAgUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uIChcbiAgICAgICB4MSxcbiAgICAgICB5MSxcbiAgICAgICB4LFxuICAgICAgIHlcbiAgICkge1xuICAgICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgIHR5cGU6ICdRJyxcbiAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgIHk6IHksXG4gICAgICAgfSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENsb3NlcyB0aGUgcGF0aFxuICAgICogQGZ1bmN0aW9uIGNsb3NlUGF0aFxuICAgICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBDbG9zZSB0aGUgcGF0aFxuICAgICogQGZ1bmN0aW9uIGNsb3NlXG4gICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAgICAqL1xuICAgUGF0aC5wcm90b3R5cGUuY2xvc2UgPSBQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgdHlwZTogJ1onLFxuICAgICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBBZGQgdGhlIGdpdmVuIHBhdGggb3IgbGlzdCBvZiBjb21tYW5kcyB0byB0aGUgY29tbWFuZHMgb2YgdGhpcyBwYXRoLlxuICAgICogQHBhcmFtICB7QXJyYXl9IHBhdGhPckNvbW1hbmRzIC0gYW5vdGhlciBvcGVudHlwZS5QYXRoLCBhbiBvcGVudHlwZS5Cb3VuZGluZ0JveCwgb3IgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG4gICAgKi9cbiAgIFBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChwYXRoT3JDb21tYW5kcykge1xuICAgICAgIGlmIChwYXRoT3JDb21tYW5kcy5jb21tYW5kcykge1xuICAgICAgICAgICBwYXRoT3JDb21tYW5kcyA9IHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzO1xuICAgICAgIH1cbiAgICAgICAvLyBlbHNlIGlmIChwYXRoT3JDb21tYW5kcyBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgLy8gICAgIGNvbnN0IGJveCA9IHBhdGhPckNvbW1hbmRzO1xuICAgICAgIC8vICAgICB0aGlzLm1vdmVUbyhib3gueDEsIGJveC55MSk7XG4gICAgICAgLy8gICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkxKTtcbiAgICAgICAvLyAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTIpO1xuICAgICAgIC8vICAgICB0aGlzLmxpbmVUbyhib3gueDEsIGJveC55Mik7XG4gICAgICAgLy8gICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgIC8vIH1cblxuICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuY29tbWFuZHMsIHBhdGhPckNvbW1hbmRzKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4gICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAgICAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAqL1xuICAgUGF0aC5wcm90b3R5cGUudG9QYXRoRGF0YSA9IGZ1bmN0aW9uIChkZWNpbWFsUGxhY2VzKSB7XG4gICAgICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG4gICAgICAgZnVuY3Rpb24gZmxvYXRUb1N0cmluZyh2KSB7XG4gICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHYpID09PSB2KSB7XG4gICAgICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIHYudG9GaXhlZChkZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIGZ1bmN0aW9uIHBhY2tWYWx1ZXMoKSB7XG4gICAgICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHMkMVtpXTtcbiAgICAgICAgICAgICAgIGlmICh2ID49IDAgJiYgaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcyArPSBmbG9hdFRvU3RyaW5nKHYpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgfVxuXG4gICAgICAgdmFyIGQgPSAnJztcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIHJldHVybiBkO1xuICAgfTtcblxuICAgLy8gR2x5cGggZW5jb2RpbmdcblxuICAgdmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAgICAnLm5vdGRlZicsXG4gICAgICAgJ3NwYWNlJyxcbiAgICAgICAnZXhjbGFtJyxcbiAgICAgICAncXVvdGVkYmwnLFxuICAgICAgICdudW1iZXJzaWduJyxcbiAgICAgICAnZG9sbGFyJyxcbiAgICAgICAncGVyY2VudCcsXG4gICAgICAgJ2FtcGVyc2FuZCcsXG4gICAgICAgJ3F1b3RlcmlnaHQnLFxuICAgICAgICdwYXJlbmxlZnQnLFxuICAgICAgICdwYXJlbnJpZ2h0JyxcbiAgICAgICAnYXN0ZXJpc2snLFxuICAgICAgICdwbHVzJyxcbiAgICAgICAnY29tbWEnLFxuICAgICAgICdoeXBoZW4nLFxuICAgICAgICdwZXJpb2QnLFxuICAgICAgICdzbGFzaCcsXG4gICAgICAgJ3plcm8nLFxuICAgICAgICdvbmUnLFxuICAgICAgICd0d28nLFxuICAgICAgICd0aHJlZScsXG4gICAgICAgJ2ZvdXInLFxuICAgICAgICdmaXZlJyxcbiAgICAgICAnc2l4JyxcbiAgICAgICAnc2V2ZW4nLFxuICAgICAgICdlaWdodCcsXG4gICAgICAgJ25pbmUnLFxuICAgICAgICdjb2xvbicsXG4gICAgICAgJ3NlbWljb2xvbicsXG4gICAgICAgJ2xlc3MnLFxuICAgICAgICdlcXVhbCcsXG4gICAgICAgJ2dyZWF0ZXInLFxuICAgICAgICdxdWVzdGlvbicsXG4gICAgICAgJ2F0JyxcbiAgICAgICAnQScsXG4gICAgICAgJ0InLFxuICAgICAgICdDJyxcbiAgICAgICAnRCcsXG4gICAgICAgJ0UnLFxuICAgICAgICdGJyxcbiAgICAgICAnRycsXG4gICAgICAgJ0gnLFxuICAgICAgICdJJyxcbiAgICAgICAnSicsXG4gICAgICAgJ0snLFxuICAgICAgICdMJyxcbiAgICAgICAnTScsXG4gICAgICAgJ04nLFxuICAgICAgICdPJyxcbiAgICAgICAnUCcsXG4gICAgICAgJ1EnLFxuICAgICAgICdSJyxcbiAgICAgICAnUycsXG4gICAgICAgJ1QnLFxuICAgICAgICdVJyxcbiAgICAgICAnVicsXG4gICAgICAgJ1cnLFxuICAgICAgICdYJyxcbiAgICAgICAnWScsXG4gICAgICAgJ1onLFxuICAgICAgICdicmFja2V0bGVmdCcsXG4gICAgICAgJ2JhY2tzbGFzaCcsXG4gICAgICAgJ2JyYWNrZXRyaWdodCcsXG4gICAgICAgJ2FzY2lpY2lyY3VtJyxcbiAgICAgICAndW5kZXJzY29yZScsXG4gICAgICAgJ3F1b3RlbGVmdCcsXG4gICAgICAgJ2EnLFxuICAgICAgICdiJyxcbiAgICAgICAnYycsXG4gICAgICAgJ2QnLFxuICAgICAgICdlJyxcbiAgICAgICAnZicsXG4gICAgICAgJ2cnLFxuICAgICAgICdoJyxcbiAgICAgICAnaScsXG4gICAgICAgJ2onLFxuICAgICAgICdrJyxcbiAgICAgICAnbCcsXG4gICAgICAgJ20nLFxuICAgICAgICduJyxcbiAgICAgICAnbycsXG4gICAgICAgJ3AnLFxuICAgICAgICdxJyxcbiAgICAgICAncicsXG4gICAgICAgJ3MnLFxuICAgICAgICd0JyxcbiAgICAgICAndScsXG4gICAgICAgJ3YnLFxuICAgICAgICd3JyxcbiAgICAgICAneCcsXG4gICAgICAgJ3knLFxuICAgICAgICd6JyxcbiAgICAgICAnYnJhY2VsZWZ0JyxcbiAgICAgICAnYmFyJyxcbiAgICAgICAnYnJhY2VyaWdodCcsXG4gICAgICAgJ2FzY2lpdGlsZGUnLFxuICAgICAgICdleGNsYW1kb3duJyxcbiAgICAgICAnY2VudCcsXG4gICAgICAgJ3N0ZXJsaW5nJyxcbiAgICAgICAnZnJhY3Rpb24nLFxuICAgICAgICd5ZW4nLFxuICAgICAgICdmbG9yaW4nLFxuICAgICAgICdzZWN0aW9uJyxcbiAgICAgICAnY3VycmVuY3knLFxuICAgICAgICdxdW90ZXNpbmdsZScsXG4gICAgICAgJ3F1b3RlZGJsbGVmdCcsXG4gICAgICAgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICAgICdndWlsc2luZ2xsZWZ0JyxcbiAgICAgICAnZ3VpbHNpbmdscmlnaHQnLFxuICAgICAgICdmaScsXG4gICAgICAgJ2ZsJyxcbiAgICAgICAnZW5kYXNoJyxcbiAgICAgICAnZGFnZ2VyJyxcbiAgICAgICAnZGFnZ2VyZGJsJyxcbiAgICAgICAncGVyaW9kY2VudGVyZWQnLFxuICAgICAgICdwYXJhZ3JhcGgnLFxuICAgICAgICdidWxsZXQnLFxuICAgICAgICdxdW90ZXNpbmdsYmFzZScsXG4gICAgICAgJ3F1b3RlZGJsYmFzZScsXG4gICAgICAgJ3F1b3RlZGJscmlnaHQnLFxuICAgICAgICdndWlsbGVtb3RyaWdodCcsXG4gICAgICAgJ2VsbGlwc2lzJyxcbiAgICAgICAncGVydGhvdXNhbmQnLFxuICAgICAgICdxdWVzdGlvbmRvd24nLFxuICAgICAgICdncmF2ZScsXG4gICAgICAgJ2FjdXRlJyxcbiAgICAgICAnY2lyY3VtZmxleCcsXG4gICAgICAgJ3RpbGRlJyxcbiAgICAgICAnbWFjcm9uJyxcbiAgICAgICAnYnJldmUnLFxuICAgICAgICdkb3RhY2NlbnQnLFxuICAgICAgICdkaWVyZXNpcycsXG4gICAgICAgJ3JpbmcnLFxuICAgICAgICdjZWRpbGxhJyxcbiAgICAgICAnaHVuZ2FydW1sYXV0JyxcbiAgICAgICAnb2dvbmVrJyxcbiAgICAgICAnY2Fyb24nLFxuICAgICAgICdlbWRhc2gnLFxuICAgICAgICdBRScsXG4gICAgICAgJ29yZGZlbWluaW5lJyxcbiAgICAgICAnTHNsYXNoJyxcbiAgICAgICAnT3NsYXNoJyxcbiAgICAgICAnT0UnLFxuICAgICAgICdvcmRtYXNjdWxpbmUnLFxuICAgICAgICdhZScsXG4gICAgICAgJ2RvdGxlc3NpJyxcbiAgICAgICAnbHNsYXNoJyxcbiAgICAgICAnb3NsYXNoJyxcbiAgICAgICAnb2UnLFxuICAgICAgICdnZXJtYW5kYmxzJyxcbiAgICAgICAnb25lc3VwZXJpb3InLFxuICAgICAgICdsb2dpY2Fsbm90JyxcbiAgICAgICAnbXUnLFxuICAgICAgICd0cmFkZW1hcmsnLFxuICAgICAgICdFdGgnLFxuICAgICAgICdvbmVoYWxmJyxcbiAgICAgICAncGx1c21pbnVzJyxcbiAgICAgICAnVGhvcm4nLFxuICAgICAgICdvbmVxdWFydGVyJyxcbiAgICAgICAnZGl2aWRlJyxcbiAgICAgICAnYnJva2VuYmFyJyxcbiAgICAgICAnZGVncmVlJyxcbiAgICAgICAndGhvcm4nLFxuICAgICAgICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAgICAndHdvc3VwZXJpb3InLFxuICAgICAgICdyZWdpc3RlcmVkJyxcbiAgICAgICAnbWludXMnLFxuICAgICAgICdldGgnLFxuICAgICAgICdtdWx0aXBseScsXG4gICAgICAgJ3RocmVlc3VwZXJpb3InLFxuICAgICAgICdjb3B5cmlnaHQnLFxuICAgICAgICdBYWN1dGUnLFxuICAgICAgICdBY2lyY3VtZmxleCcsXG4gICAgICAgJ0FkaWVyZXNpcycsXG4gICAgICAgJ0FncmF2ZScsXG4gICAgICAgJ0FyaW5nJyxcbiAgICAgICAnQXRpbGRlJyxcbiAgICAgICAnQ2NlZGlsbGEnLFxuICAgICAgICdFYWN1dGUnLFxuICAgICAgICdFY2lyY3VtZmxleCcsXG4gICAgICAgJ0VkaWVyZXNpcycsXG4gICAgICAgJ0VncmF2ZScsXG4gICAgICAgJ0lhY3V0ZScsXG4gICAgICAgJ0ljaXJjdW1mbGV4JyxcbiAgICAgICAnSWRpZXJlc2lzJyxcbiAgICAgICAnSWdyYXZlJyxcbiAgICAgICAnTnRpbGRlJyxcbiAgICAgICAnT2FjdXRlJyxcbiAgICAgICAnT2NpcmN1bWZsZXgnLFxuICAgICAgICdPZGllcmVzaXMnLFxuICAgICAgICdPZ3JhdmUnLFxuICAgICAgICdPdGlsZGUnLFxuICAgICAgICdTY2Fyb24nLFxuICAgICAgICdVYWN1dGUnLFxuICAgICAgICdVY2lyY3VtZmxleCcsXG4gICAgICAgJ1VkaWVyZXNpcycsXG4gICAgICAgJ1VncmF2ZScsXG4gICAgICAgJ1lhY3V0ZScsXG4gICAgICAgJ1lkaWVyZXNpcycsXG4gICAgICAgJ1pjYXJvbicsXG4gICAgICAgJ2FhY3V0ZScsXG4gICAgICAgJ2FjaXJjdW1mbGV4JyxcbiAgICAgICAnYWRpZXJlc2lzJyxcbiAgICAgICAnYWdyYXZlJyxcbiAgICAgICAnYXJpbmcnLFxuICAgICAgICdhdGlsZGUnLFxuICAgICAgICdjY2VkaWxsYScsXG4gICAgICAgJ2VhY3V0ZScsXG4gICAgICAgJ2VjaXJjdW1mbGV4JyxcbiAgICAgICAnZWRpZXJlc2lzJyxcbiAgICAgICAnZWdyYXZlJyxcbiAgICAgICAnaWFjdXRlJyxcbiAgICAgICAnaWNpcmN1bWZsZXgnLFxuICAgICAgICdpZGllcmVzaXMnLFxuICAgICAgICdpZ3JhdmUnLFxuICAgICAgICdudGlsZGUnLFxuICAgICAgICdvYWN1dGUnLFxuICAgICAgICdvY2lyY3VtZmxleCcsXG4gICAgICAgJ29kaWVyZXNpcycsXG4gICAgICAgJ29ncmF2ZScsXG4gICAgICAgJ290aWxkZScsXG4gICAgICAgJ3NjYXJvbicsXG4gICAgICAgJ3VhY3V0ZScsXG4gICAgICAgJ3VjaXJjdW1mbGV4JyxcbiAgICAgICAndWRpZXJlc2lzJyxcbiAgICAgICAndWdyYXZlJyxcbiAgICAgICAneWFjdXRlJyxcbiAgICAgICAneWRpZXJlc2lzJyxcbiAgICAgICAnemNhcm9uJyxcbiAgICAgICAnZXhjbGFtc21hbGwnLFxuICAgICAgICdIdW5nYXJ1bWxhdXRzbWFsbCcsXG4gICAgICAgJ2RvbGxhcm9sZHN0eWxlJyxcbiAgICAgICAnZG9sbGFyc3VwZXJpb3InLFxuICAgICAgICdhbXBlcnNhbmRzbWFsbCcsXG4gICAgICAgJ0FjdXRlc21hbGwnLFxuICAgICAgICdwYXJlbmxlZnRzdXBlcmlvcicsXG4gICAgICAgJ3BhcmVucmlnaHRzdXBlcmlvcicsXG4gICAgICAgJzI2NiBmZicsXG4gICAgICAgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAgICAnemVyb29sZHN0eWxlJyxcbiAgICAgICAnb25lb2xkc3R5bGUnLFxuICAgICAgICd0d29vbGRzdHlsZScsXG4gICAgICAgJ3RocmVlb2xkc3R5bGUnLFxuICAgICAgICdmb3Vyb2xkc3R5bGUnLFxuICAgICAgICdmaXZlb2xkc3R5bGUnLFxuICAgICAgICdzaXhvbGRzdHlsZScsXG4gICAgICAgJ3NldmVub2xkc3R5bGUnLFxuICAgICAgICdlaWdodG9sZHN0eWxlJyxcbiAgICAgICAnbmluZW9sZHN0eWxlJyxcbiAgICAgICAnY29tbWFzdXBlcmlvcicsXG4gICAgICAgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLFxuICAgICAgICdwZXJpb2RzdXBlcmlvcicsXG4gICAgICAgJ3F1ZXN0aW9uc21hbGwnLFxuICAgICAgICdhc3VwZXJpb3InLFxuICAgICAgICdic3VwZXJpb3InLFxuICAgICAgICdjZW50c3VwZXJpb3InLFxuICAgICAgICdkc3VwZXJpb3InLFxuICAgICAgICdlc3VwZXJpb3InLFxuICAgICAgICdpc3VwZXJpb3InLFxuICAgICAgICdsc3VwZXJpb3InLFxuICAgICAgICdtc3VwZXJpb3InLFxuICAgICAgICduc3VwZXJpb3InLFxuICAgICAgICdvc3VwZXJpb3InLFxuICAgICAgICdyc3VwZXJpb3InLFxuICAgICAgICdzc3VwZXJpb3InLFxuICAgICAgICd0c3VwZXJpb3InLFxuICAgICAgICdmZicsXG4gICAgICAgJ2ZmaScsXG4gICAgICAgJ2ZmbCcsXG4gICAgICAgJ3BhcmVubGVmdGluZmVyaW9yJyxcbiAgICAgICAncGFyZW5yaWdodGluZmVyaW9yJyxcbiAgICAgICAnQ2lyY3VtZmxleHNtYWxsJyxcbiAgICAgICAnaHlwaGVuc3VwZXJpb3InLFxuICAgICAgICdHcmF2ZXNtYWxsJyxcbiAgICAgICAnQXNtYWxsJyxcbiAgICAgICAnQnNtYWxsJyxcbiAgICAgICAnQ3NtYWxsJyxcbiAgICAgICAnRHNtYWxsJyxcbiAgICAgICAnRXNtYWxsJyxcbiAgICAgICAnRnNtYWxsJyxcbiAgICAgICAnR3NtYWxsJyxcbiAgICAgICAnSHNtYWxsJyxcbiAgICAgICAnSXNtYWxsJyxcbiAgICAgICAnSnNtYWxsJyxcbiAgICAgICAnS3NtYWxsJyxcbiAgICAgICAnTHNtYWxsJyxcbiAgICAgICAnTXNtYWxsJyxcbiAgICAgICAnTnNtYWxsJyxcbiAgICAgICAnT3NtYWxsJyxcbiAgICAgICAnUHNtYWxsJyxcbiAgICAgICAnUXNtYWxsJyxcbiAgICAgICAnUnNtYWxsJyxcbiAgICAgICAnU3NtYWxsJyxcbiAgICAgICAnVHNtYWxsJyxcbiAgICAgICAnVXNtYWxsJyxcbiAgICAgICAnVnNtYWxsJyxcbiAgICAgICAnV3NtYWxsJyxcbiAgICAgICAnWHNtYWxsJyxcbiAgICAgICAnWXNtYWxsJyxcbiAgICAgICAnWnNtYWxsJyxcbiAgICAgICAnY29sb25tb25ldGFyeScsXG4gICAgICAgJ29uZWZpdHRlZCcsXG4gICAgICAgJ3J1cGlhaCcsXG4gICAgICAgJ1RpbGRlc21hbGwnLFxuICAgICAgICdleGNsYW1kb3duc21hbGwnLFxuICAgICAgICdjZW50b2xkc3R5bGUnLFxuICAgICAgICdMc2xhc2hzbWFsbCcsXG4gICAgICAgJ1NjYXJvbnNtYWxsJyxcbiAgICAgICAnWmNhcm9uc21hbGwnLFxuICAgICAgICdEaWVyZXNpc3NtYWxsJyxcbiAgICAgICAnQnJldmVzbWFsbCcsXG4gICAgICAgJ0Nhcm9uc21hbGwnLFxuICAgICAgICdEb3RhY2NlbnRzbWFsbCcsXG4gICAgICAgJ01hY3JvbnNtYWxsJyxcbiAgICAgICAnZmlndXJlZGFzaCcsXG4gICAgICAgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAgICAnT2dvbmVrc21hbGwnLFxuICAgICAgICdSaW5nc21hbGwnLFxuICAgICAgICdDZWRpbGxhc21hbGwnLFxuICAgICAgICdxdWVzdGlvbmRvd25zbWFsbCcsXG4gICAgICAgJ29uZWVpZ2h0aCcsXG4gICAgICAgJ3RocmVlZWlnaHRocycsXG4gICAgICAgJ2ZpdmVlaWdodGhzJyxcbiAgICAgICAnc2V2ZW5laWdodGhzJyxcbiAgICAgICAnb25ldGhpcmQnLFxuICAgICAgICd0d290aGlyZHMnLFxuICAgICAgICd6ZXJvc3VwZXJpb3InLFxuICAgICAgICdmb3Vyc3VwZXJpb3InLFxuICAgICAgICdmaXZlc3VwZXJpb3InLFxuICAgICAgICdzaXhzdXBlcmlvcicsXG4gICAgICAgJ3NldmVuc3VwZXJpb3InLFxuICAgICAgICdlaWdodHN1cGVyaW9yJyxcbiAgICAgICAnbmluZXN1cGVyaW9yJyxcbiAgICAgICAnemVyb2luZmVyaW9yJyxcbiAgICAgICAnb25laW5mZXJpb3InLFxuICAgICAgICd0d29pbmZlcmlvcicsXG4gICAgICAgJ3RocmVlaW5mZXJpb3InLFxuICAgICAgICdmb3VyaW5mZXJpb3InLFxuICAgICAgICdmaXZlaW5mZXJpb3InLFxuICAgICAgICdzaXhpbmZlcmlvcicsXG4gICAgICAgJ3NldmVuaW5mZXJpb3InLFxuICAgICAgICdlaWdodGluZmVyaW9yJyxcbiAgICAgICAnbmluZWluZmVyaW9yJyxcbiAgICAgICAnY2VudGluZmVyaW9yJyxcbiAgICAgICAnZG9sbGFyaW5mZXJpb3InLFxuICAgICAgICdwZXJpb2RpbmZlcmlvcicsXG4gICAgICAgJ2NvbW1haW5mZXJpb3InLFxuICAgICAgICdBZ3JhdmVzbWFsbCcsXG4gICAgICAgJ0FhY3V0ZXNtYWxsJyxcbiAgICAgICAnQWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ0F0aWxkZXNtYWxsJyxcbiAgICAgICAnQWRpZXJlc2lzc21hbGwnLFxuICAgICAgICdBcmluZ3NtYWxsJyxcbiAgICAgICAnQUVzbWFsbCcsXG4gICAgICAgJ0NjZWRpbGxhc21hbGwnLFxuICAgICAgICdFZ3JhdmVzbWFsbCcsXG4gICAgICAgJ0VhY3V0ZXNtYWxsJyxcbiAgICAgICAnRWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAgICAnSWdyYXZlc21hbGwnLFxuICAgICAgICdJYWN1dGVzbWFsbCcsXG4gICAgICAgJ0ljaXJjdW1mbGV4c21hbGwnLFxuICAgICAgICdJZGllcmVzaXNzbWFsbCcsXG4gICAgICAgJ0V0aHNtYWxsJyxcbiAgICAgICAnTnRpbGRlc21hbGwnLFxuICAgICAgICdPZ3JhdmVzbWFsbCcsXG4gICAgICAgJ09hY3V0ZXNtYWxsJyxcbiAgICAgICAnT2NpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ090aWxkZXNtYWxsJyxcbiAgICAgICAnT2RpZXJlc2lzc21hbGwnLFxuICAgICAgICdPRXNtYWxsJyxcbiAgICAgICAnT3NsYXNoc21hbGwnLFxuICAgICAgICdVZ3JhdmVzbWFsbCcsXG4gICAgICAgJ1VhY3V0ZXNtYWxsJyxcbiAgICAgICAnVWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ1VkaWVyZXNpc3NtYWxsJyxcbiAgICAgICAnWWFjdXRlc21hbGwnLFxuICAgICAgICdUaG9ybnNtYWxsJyxcbiAgICAgICAnWWRpZXJlc2lzc21hbGwnLFxuICAgICAgICcwMDEuMDAwJyxcbiAgICAgICAnMDAxLjAwMScsXG4gICAgICAgJzAwMS4wMDInLFxuICAgICAgICcwMDEuMDAzJyxcbiAgICAgICAnQmxhY2snLFxuICAgICAgICdCb2xkJyxcbiAgICAgICAnQm9vaycsXG4gICAgICAgJ0xpZ2h0JyxcbiAgICAgICAnTWVkaXVtJyxcbiAgICAgICAnUmVndWxhcicsXG4gICAgICAgJ1JvbWFuJyxcbiAgICAgICAnU2VtaWJvbGQnIF07XG5cbiAgIHZhciBjZmZTdGFuZGFyZEVuY29kaW5nID0gW1xuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdzcGFjZScsXG4gICAgICAgJ2V4Y2xhbScsXG4gICAgICAgJ3F1b3RlZGJsJyxcbiAgICAgICAnbnVtYmVyc2lnbicsXG4gICAgICAgJ2RvbGxhcicsXG4gICAgICAgJ3BlcmNlbnQnLFxuICAgICAgICdhbXBlcnNhbmQnLFxuICAgICAgICdxdW90ZXJpZ2h0JyxcbiAgICAgICAncGFyZW5sZWZ0JyxcbiAgICAgICAncGFyZW5yaWdodCcsXG4gICAgICAgJ2FzdGVyaXNrJyxcbiAgICAgICAncGx1cycsXG4gICAgICAgJ2NvbW1hJyxcbiAgICAgICAnaHlwaGVuJyxcbiAgICAgICAncGVyaW9kJyxcbiAgICAgICAnc2xhc2gnLFxuICAgICAgICd6ZXJvJyxcbiAgICAgICAnb25lJyxcbiAgICAgICAndHdvJyxcbiAgICAgICAndGhyZWUnLFxuICAgICAgICdmb3VyJyxcbiAgICAgICAnZml2ZScsXG4gICAgICAgJ3NpeCcsXG4gICAgICAgJ3NldmVuJyxcbiAgICAgICAnZWlnaHQnLFxuICAgICAgICduaW5lJyxcbiAgICAgICAnY29sb24nLFxuICAgICAgICdzZW1pY29sb24nLFxuICAgICAgICdsZXNzJyxcbiAgICAgICAnZXF1YWwnLFxuICAgICAgICdncmVhdGVyJyxcbiAgICAgICAncXVlc3Rpb24nLFxuICAgICAgICdhdCcsXG4gICAgICAgJ0EnLFxuICAgICAgICdCJyxcbiAgICAgICAnQycsXG4gICAgICAgJ0QnLFxuICAgICAgICdFJyxcbiAgICAgICAnRicsXG4gICAgICAgJ0cnLFxuICAgICAgICdIJyxcbiAgICAgICAnSScsXG4gICAgICAgJ0onLFxuICAgICAgICdLJyxcbiAgICAgICAnTCcsXG4gICAgICAgJ00nLFxuICAgICAgICdOJyxcbiAgICAgICAnTycsXG4gICAgICAgJ1AnLFxuICAgICAgICdRJyxcbiAgICAgICAnUicsXG4gICAgICAgJ1MnLFxuICAgICAgICdUJyxcbiAgICAgICAnVScsXG4gICAgICAgJ1YnLFxuICAgICAgICdXJyxcbiAgICAgICAnWCcsXG4gICAgICAgJ1knLFxuICAgICAgICdaJyxcbiAgICAgICAnYnJhY2tldGxlZnQnLFxuICAgICAgICdiYWNrc2xhc2gnLFxuICAgICAgICdicmFja2V0cmlnaHQnLFxuICAgICAgICdhc2NpaWNpcmN1bScsXG4gICAgICAgJ3VuZGVyc2NvcmUnLFxuICAgICAgICdxdW90ZWxlZnQnLFxuICAgICAgICdhJyxcbiAgICAgICAnYicsXG4gICAgICAgJ2MnLFxuICAgICAgICdkJyxcbiAgICAgICAnZScsXG4gICAgICAgJ2YnLFxuICAgICAgICdnJyxcbiAgICAgICAnaCcsXG4gICAgICAgJ2knLFxuICAgICAgICdqJyxcbiAgICAgICAnaycsXG4gICAgICAgJ2wnLFxuICAgICAgICdtJyxcbiAgICAgICAnbicsXG4gICAgICAgJ28nLFxuICAgICAgICdwJyxcbiAgICAgICAncScsXG4gICAgICAgJ3InLFxuICAgICAgICdzJyxcbiAgICAgICAndCcsXG4gICAgICAgJ3UnLFxuICAgICAgICd2JyxcbiAgICAgICAndycsXG4gICAgICAgJ3gnLFxuICAgICAgICd5JyxcbiAgICAgICAneicsXG4gICAgICAgJ2JyYWNlbGVmdCcsXG4gICAgICAgJ2JhcicsXG4gICAgICAgJ2JyYWNlcmlnaHQnLFxuICAgICAgICdhc2NpaXRpbGRlJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnZXhjbGFtZG93bicsXG4gICAgICAgJ2NlbnQnLFxuICAgICAgICdzdGVybGluZycsXG4gICAgICAgJ2ZyYWN0aW9uJyxcbiAgICAgICAneWVuJyxcbiAgICAgICAnZmxvcmluJyxcbiAgICAgICAnc2VjdGlvbicsXG4gICAgICAgJ2N1cnJlbmN5JyxcbiAgICAgICAncXVvdGVzaW5nbGUnLFxuICAgICAgICdxdW90ZWRibGxlZnQnLFxuICAgICAgICdndWlsbGVtb3RsZWZ0JyxcbiAgICAgICAnZ3VpbHNpbmdsbGVmdCcsXG4gICAgICAgJ2d1aWxzaW5nbHJpZ2h0JyxcbiAgICAgICAnZmknLFxuICAgICAgICdmbCcsXG4gICAgICAgJycsXG4gICAgICAgJ2VuZGFzaCcsXG4gICAgICAgJ2RhZ2dlcicsXG4gICAgICAgJ2RhZ2dlcmRibCcsXG4gICAgICAgJ3BlcmlvZGNlbnRlcmVkJyxcbiAgICAgICAnJyxcbiAgICAgICAncGFyYWdyYXBoJyxcbiAgICAgICAnYnVsbGV0JyxcbiAgICAgICAncXVvdGVzaW5nbGJhc2UnLFxuICAgICAgICdxdW90ZWRibGJhc2UnLFxuICAgICAgICdxdW90ZWRibHJpZ2h0JyxcbiAgICAgICAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICAgICdlbGxpcHNpcycsXG4gICAgICAgJ3BlcnRob3VzYW5kJyxcbiAgICAgICAnJyxcbiAgICAgICAncXVlc3Rpb25kb3duJyxcbiAgICAgICAnJyxcbiAgICAgICAnZ3JhdmUnLFxuICAgICAgICdhY3V0ZScsXG4gICAgICAgJ2NpcmN1bWZsZXgnLFxuICAgICAgICd0aWxkZScsXG4gICAgICAgJ21hY3JvbicsXG4gICAgICAgJ2JyZXZlJyxcbiAgICAgICAnZG90YWNjZW50JyxcbiAgICAgICAnZGllcmVzaXMnLFxuICAgICAgICcnLFxuICAgICAgICdyaW5nJyxcbiAgICAgICAnY2VkaWxsYScsXG4gICAgICAgJycsXG4gICAgICAgJ2h1bmdhcnVtbGF1dCcsXG4gICAgICAgJ29nb25laycsXG4gICAgICAgJ2Nhcm9uJyxcbiAgICAgICAnZW1kYXNoJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnQUUnLFxuICAgICAgICcnLFxuICAgICAgICdvcmRmZW1pbmluZScsXG4gICAgICAgJycsXG4gICAgICAgJycsXG4gICAgICAgJycsXG4gICAgICAgJycsXG4gICAgICAgJ0xzbGFzaCcsXG4gICAgICAgJ09zbGFzaCcsXG4gICAgICAgJ09FJyxcbiAgICAgICAnb3JkbWFzY3VsaW5lJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnYWUnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdkb3RsZXNzaScsXG4gICAgICAgJycsXG4gICAgICAgJycsXG4gICAgICAgJ2xzbGFzaCcsXG4gICAgICAgJ29zbGFzaCcsXG4gICAgICAgJ29lJyxcbiAgICAgICAnZ2VybWFuZGJscycgXTtcblxuICAgdmFyIGNmZkV4cGVydEVuY29kaW5nID0gW1xuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdzcGFjZScsXG4gICAgICAgJ2V4Y2xhbXNtYWxsJyxcbiAgICAgICAnSHVuZ2FydW1sYXV0c21hbGwnLFxuICAgICAgICcnLFxuICAgICAgICdkb2xsYXJvbGRzdHlsZScsXG4gICAgICAgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAgICAnYW1wZXJzYW5kc21hbGwnLFxuICAgICAgICdBY3V0ZXNtYWxsJyxcbiAgICAgICAncGFyZW5sZWZ0c3VwZXJpb3InLFxuICAgICAgICdwYXJlbnJpZ2h0c3VwZXJpb3InLFxuICAgICAgICd0d29kb3RlbmxlYWRlcicsXG4gICAgICAgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAgICAnY29tbWEnLFxuICAgICAgICdoeXBoZW4nLFxuICAgICAgICdwZXJpb2QnLFxuICAgICAgICdmcmFjdGlvbicsXG4gICAgICAgJ3plcm9vbGRzdHlsZScsXG4gICAgICAgJ29uZW9sZHN0eWxlJyxcbiAgICAgICAndHdvb2xkc3R5bGUnLFxuICAgICAgICd0aHJlZW9sZHN0eWxlJyxcbiAgICAgICAnZm91cm9sZHN0eWxlJyxcbiAgICAgICAnZml2ZW9sZHN0eWxlJyxcbiAgICAgICAnc2l4b2xkc3R5bGUnLFxuICAgICAgICdzZXZlbm9sZHN0eWxlJyxcbiAgICAgICAnZWlnaHRvbGRzdHlsZScsXG4gICAgICAgJ25pbmVvbGRzdHlsZScsXG4gICAgICAgJ2NvbG9uJyxcbiAgICAgICAnc2VtaWNvbG9uJyxcbiAgICAgICAnY29tbWFzdXBlcmlvcicsXG4gICAgICAgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLFxuICAgICAgICdwZXJpb2RzdXBlcmlvcicsXG4gICAgICAgJ3F1ZXN0aW9uc21hbGwnLFxuICAgICAgICcnLFxuICAgICAgICdhc3VwZXJpb3InLFxuICAgICAgICdic3VwZXJpb3InLFxuICAgICAgICdjZW50c3VwZXJpb3InLFxuICAgICAgICdkc3VwZXJpb3InLFxuICAgICAgICdlc3VwZXJpb3InLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdpc3VwZXJpb3InLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdsc3VwZXJpb3InLFxuICAgICAgICdtc3VwZXJpb3InLFxuICAgICAgICduc3VwZXJpb3InLFxuICAgICAgICdvc3VwZXJpb3InLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdyc3VwZXJpb3InLFxuICAgICAgICdzc3VwZXJpb3InLFxuICAgICAgICd0c3VwZXJpb3InLFxuICAgICAgICcnLFxuICAgICAgICdmZicsXG4gICAgICAgJ2ZpJyxcbiAgICAgICAnZmwnLFxuICAgICAgICdmZmknLFxuICAgICAgICdmZmwnLFxuICAgICAgICdwYXJlbmxlZnRpbmZlcmlvcicsXG4gICAgICAgJycsXG4gICAgICAgJ3BhcmVucmlnaHRpbmZlcmlvcicsXG4gICAgICAgJ0NpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ2h5cGhlbnN1cGVyaW9yJyxcbiAgICAgICAnR3JhdmVzbWFsbCcsXG4gICAgICAgJ0FzbWFsbCcsXG4gICAgICAgJ0JzbWFsbCcsXG4gICAgICAgJ0NzbWFsbCcsXG4gICAgICAgJ0RzbWFsbCcsXG4gICAgICAgJ0VzbWFsbCcsXG4gICAgICAgJ0ZzbWFsbCcsXG4gICAgICAgJ0dzbWFsbCcsXG4gICAgICAgJ0hzbWFsbCcsXG4gICAgICAgJ0lzbWFsbCcsXG4gICAgICAgJ0pzbWFsbCcsXG4gICAgICAgJ0tzbWFsbCcsXG4gICAgICAgJ0xzbWFsbCcsXG4gICAgICAgJ01zbWFsbCcsXG4gICAgICAgJ05zbWFsbCcsXG4gICAgICAgJ09zbWFsbCcsXG4gICAgICAgJ1BzbWFsbCcsXG4gICAgICAgJ1FzbWFsbCcsXG4gICAgICAgJ1JzbWFsbCcsXG4gICAgICAgJ1NzbWFsbCcsXG4gICAgICAgJ1RzbWFsbCcsXG4gICAgICAgJ1VzbWFsbCcsXG4gICAgICAgJ1ZzbWFsbCcsXG4gICAgICAgJ1dzbWFsbCcsXG4gICAgICAgJ1hzbWFsbCcsXG4gICAgICAgJ1lzbWFsbCcsXG4gICAgICAgJ1pzbWFsbCcsXG4gICAgICAgJ2NvbG9ubW9uZXRhcnknLFxuICAgICAgICdvbmVmaXR0ZWQnLFxuICAgICAgICdydXBpYWgnLFxuICAgICAgICdUaWxkZXNtYWxsJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAgICAnY2VudG9sZHN0eWxlJyxcbiAgICAgICAnTHNsYXNoc21hbGwnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdTY2Fyb25zbWFsbCcsXG4gICAgICAgJ1pjYXJvbnNtYWxsJyxcbiAgICAgICAnRGllcmVzaXNzbWFsbCcsXG4gICAgICAgJ0JyZXZlc21hbGwnLFxuICAgICAgICdDYXJvbnNtYWxsJyxcbiAgICAgICAnJyxcbiAgICAgICAnRG90YWNjZW50c21hbGwnLFxuICAgICAgICcnLFxuICAgICAgICcnLFxuICAgICAgICdNYWNyb25zbWFsbCcsXG4gICAgICAgJycsXG4gICAgICAgJycsXG4gICAgICAgJ2ZpZ3VyZWRhc2gnLFxuICAgICAgICdoeXBoZW5pbmZlcmlvcicsXG4gICAgICAgJycsXG4gICAgICAgJycsXG4gICAgICAgJ09nb25la3NtYWxsJyxcbiAgICAgICAnUmluZ3NtYWxsJyxcbiAgICAgICAnQ2VkaWxsYXNtYWxsJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnb25lcXVhcnRlcicsXG4gICAgICAgJ29uZWhhbGYnLFxuICAgICAgICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAgICAncXVlc3Rpb25kb3duc21hbGwnLFxuICAgICAgICdvbmVlaWdodGgnLFxuICAgICAgICd0aHJlZWVpZ2h0aHMnLFxuICAgICAgICdmaXZlZWlnaHRocycsXG4gICAgICAgJ3NldmVuZWlnaHRocycsXG4gICAgICAgJ29uZXRoaXJkJyxcbiAgICAgICAndHdvdGhpcmRzJyxcbiAgICAgICAnJyxcbiAgICAgICAnJyxcbiAgICAgICAnemVyb3N1cGVyaW9yJyxcbiAgICAgICAnb25lc3VwZXJpb3InLFxuICAgICAgICd0d29zdXBlcmlvcicsXG4gICAgICAgJ3RocmVlc3VwZXJpb3InLFxuICAgICAgICdmb3Vyc3VwZXJpb3InLFxuICAgICAgICdmaXZlc3VwZXJpb3InLFxuICAgICAgICdzaXhzdXBlcmlvcicsXG4gICAgICAgJ3NldmVuc3VwZXJpb3InLFxuICAgICAgICdlaWdodHN1cGVyaW9yJyxcbiAgICAgICAnbmluZXN1cGVyaW9yJyxcbiAgICAgICAnemVyb2luZmVyaW9yJyxcbiAgICAgICAnb25laW5mZXJpb3InLFxuICAgICAgICd0d29pbmZlcmlvcicsXG4gICAgICAgJ3RocmVlaW5mZXJpb3InLFxuICAgICAgICdmb3VyaW5mZXJpb3InLFxuICAgICAgICdmaXZlaW5mZXJpb3InLFxuICAgICAgICdzaXhpbmZlcmlvcicsXG4gICAgICAgJ3NldmVuaW5mZXJpb3InLFxuICAgICAgICdlaWdodGluZmVyaW9yJyxcbiAgICAgICAnbmluZWluZmVyaW9yJyxcbiAgICAgICAnY2VudGluZmVyaW9yJyxcbiAgICAgICAnZG9sbGFyaW5mZXJpb3InLFxuICAgICAgICdwZXJpb2RpbmZlcmlvcicsXG4gICAgICAgJ2NvbW1haW5mZXJpb3InLFxuICAgICAgICdBZ3JhdmVzbWFsbCcsXG4gICAgICAgJ0FhY3V0ZXNtYWxsJyxcbiAgICAgICAnQWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ0F0aWxkZXNtYWxsJyxcbiAgICAgICAnQWRpZXJlc2lzc21hbGwnLFxuICAgICAgICdBcmluZ3NtYWxsJyxcbiAgICAgICAnQUVzbWFsbCcsXG4gICAgICAgJ0NjZWRpbGxhc21hbGwnLFxuICAgICAgICdFZ3JhdmVzbWFsbCcsXG4gICAgICAgJ0VhY3V0ZXNtYWxsJyxcbiAgICAgICAnRWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAgICAnSWdyYXZlc21hbGwnLFxuICAgICAgICdJYWN1dGVzbWFsbCcsXG4gICAgICAgJ0ljaXJjdW1mbGV4c21hbGwnLFxuICAgICAgICdJZGllcmVzaXNzbWFsbCcsXG4gICAgICAgJ0V0aHNtYWxsJyxcbiAgICAgICAnTnRpbGRlc21hbGwnLFxuICAgICAgICdPZ3JhdmVzbWFsbCcsXG4gICAgICAgJ09hY3V0ZXNtYWxsJyxcbiAgICAgICAnT2NpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ090aWxkZXNtYWxsJyxcbiAgICAgICAnT2RpZXJlc2lzc21hbGwnLFxuICAgICAgICdPRXNtYWxsJyxcbiAgICAgICAnT3NsYXNoc21hbGwnLFxuICAgICAgICdVZ3JhdmVzbWFsbCcsXG4gICAgICAgJ1VhY3V0ZXNtYWxsJyxcbiAgICAgICAnVWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgICAgJ1VkaWVyZXNpc3NtYWxsJyxcbiAgICAgICAnWWFjdXRlc21hbGwnLFxuICAgICAgICdUaG9ybnNtYWxsJyxcbiAgICAgICAnWWRpZXJlc2lzc21hbGwnIF07XG5cbiAgIC8qKlxuICAgICogVGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgZm9udHMgY3JlYXRlZCBmcm9tIHNjcmF0Y2guXG4gICAgKiBJdCBsb29wcyB0aHJvdWdoIGFsbCBnbHlwaHMgYW5kIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSB1bmljb2RlIHZhbHVlLlxuICAgICogU2luY2UgaXQncyBsaW5lYXIgdGltZSwgb3RoZXIgZW5jb2RpbmdzIHdpbGwgYmUgZmFzdGVyLlxuICAgICogQGV4cG9ydHMgb3BlbnR5cGUuRGVmYXVsdEVuY29kaW5nXG4gICAgKiBAY2xhc3NcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICAgICovXG4gICBmdW5jdGlvbiBEZWZhdWx0RW5jb2RpbmcoZm9udCkge1xuICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICB9XG5cbiAgIERlZmF1bHRFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgdmFyIGNvZGUgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzO1xuICAgICAgIGlmIChnbHlwaHMpIHtcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gbnVsbDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG4gICAgKiBAY2xhc3NcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuICAgICovXG4gICBmdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgICAgIHRoaXMuY21hcCA9IGNtYXA7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2x5cGggaW5kZXguXG4gICAgKi9cbiAgIENtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY29kZVBvaW50QXQoMCldIHx8IDA7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBleHBvcnRzIG9wZW50eXBlLkNmZkVuY29kaW5nXG4gICAgKiBAY2xhc3NcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIC0gVGhlIGVuY29kaW5nXG4gICAgKiBAcGFyYW0ge0FycmF5fSBjaGFyc2V0IC0gVGhlIGNoYXJhY3RlciBzZXQuXG4gICAgKi9cbiAgIGZ1bmN0aW9uIENmZkVuY29kaW5nKGVuY29kaW5nLCBjaGFyc2V0KSB7XG4gICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQHBhcmFtICB7c3RyaW5nfSBzIC0gVGhlIGNoYXJhY3RlclxuICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXguXG4gICAgKi9cbiAgIENmZkVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICB2YXIgY29kZSA9IHMuY29kZVBvaW50QXQoMCk7XG4gICAgICAgdmFyIGNoYXJOYW1lID0gdGhpcy5lbmNvZGluZ1tjb2RlXTtcbiAgICAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xuICAgfTtcblxuICAgZnVuY3Rpb24gYWRkR2x5cGhOYW1lc0FsbChmb250KSB7XG4gICAgICAgdmFyIGdseXBoO1xuICAgICAgIHZhciBnbHlwaEluZGV4TWFwID0gZm9udC50YWJsZXMuY21hcC5nbHlwaEluZGV4TWFwO1xuICAgICAgIHZhciBjaGFyQ29kZXMgPSBPYmplY3Qua2V5cyhnbHlwaEluZGV4TWFwKTtcblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgIHZhciBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGdseXBoSW5kZXhNYXBbY107XG4gICAgICAgICAgIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgICAgICAgICBnbHlwaC5hZGRVbmljb2RlKHBhcnNlSW50KGMpKTtcbiAgICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCkge1xuICAgICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwID0ge307XG5cbiAgICAgICB2YXIgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgYyA9IGNoYXJDb2Rlc1tpXTtcbiAgICAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICAgICBpZiAoZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgdW5pY29kZXM6IFtwYXJzZUludChjKV0sXG4gICAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0udW5pY29kZXMucHVzaChwYXJzZUludChjKSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogQGFsaWFzIG9wZW50eXBlLmFkZEdseXBoTmFtZXNcbiAgICAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAgICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgICovXG4gICBmdW5jdGlvbiBhZGRHbHlwaE5hbWVzKGZvbnQsIG9wdCkge1xuICAgICAgIGlmIChvcHQubG93TWVtb3J5KSB7XG4gICAgICAgICAgIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgYWRkR2x5cGhOYW1lc0FsbChmb250KTtcbiAgICAgICB9XG4gICB9XG5cbiAgIC8vIFJ1bi10aW1lIGNoZWNraW5nIG9mIHByZWNvbmRpdGlvbnMuXG5cbiAgIGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgIH1cblxuICAgLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBwcmVkaWNhdGUgaXMgdHJ1ZS5cbiAgIC8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgIGZ1bmN0aW9uIGFyZ3VtZW50KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgICAgIGZhaWwobWVzc2FnZSk7XG4gICAgICAgfVxuICAgfVxuICAgdmFyIGNoZWNrID0geyBmYWlsOiBmYWlsLCBhcmd1bWVudDogYXJndW1lbnQsIGFzc2VydDogYXJndW1lbnQgfTtcblxuICAgLy8gVGhlIEdseXBoIG9iamVjdFxuICAgLy8gaW1wb3J0IGdseWYgZnJvbSAnLi90YWJsZXMvZ2x5ZicgQ2FuJ3QgYmUgaW1wb3J0ZWQgaGVyZSwgYmVjYXVzZSBpdCdzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuXG4gICBmdW5jdGlvbiBnZXRQYXRoRGVmaW5pdGlvbihnbHlwaCwgcGF0aCkge1xuICAgICAgIHZhciBfcGF0aCA9IHBhdGggfHwgbmV3IFBhdGgoKTtcbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICBpZiAodHlwZW9mIF9wYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgX3BhdGggPSBfcGF0aCgpO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXR1cm4gX3BhdGg7XG4gICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgX3BhdGggPSBwO1xuICAgICAgICAgICB9LFxuICAgICAgIH07XG4gICB9XG4gICAvKipcbiAgICAqIEB0eXBlZGVmIEdseXBoT3B0aW9uc1xuICAgICogQHR5cGUgT2JqZWN0XG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIC0gVGhlIGdseXBoIG5hbWVcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5pY29kZV1cbiAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt1bmljb2Rlc11cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeE1pbl1cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1pbl1cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeE1heF1cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1heF1cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWR2YW5jZVdpZHRoXVxuICAgICovXG5cbiAgIC8vIEEgR2x5cGggaXMgYW4gaW5kaXZpZHVhbCBtYXJrIHRoYXQgb2Z0ZW4gY29ycmVzcG9uZHMgdG8gYSBjaGFyYWN0ZXIuXG4gICAvLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cbiAgIC8vIEdseXBocyBhcmUgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBvZiBhIGZvbnQuXG4gICAvL1xuICAgLy8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuICAgLyoqXG4gICAgKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFxuICAgICogQGNsYXNzXG4gICAgKiBAcGFyYW0ge0dseXBoT3B0aW9uc31cbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICBmdW5jdGlvbiBHbHlwaChvcHRpb25zKSB7XG4gICAgICAgLy8gQnkgcHV0dGluZyBhbGwgdGhlIGNvZGUgb24gYSBwcm90b3R5cGUgZnVuY3Rpb24gKHdoaWNoIGlzIG9ubHkgZGVjbGFyZWQgb25jZSlcbiAgICAgICAvLyB3ZSByZWR1Y2UgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIGxhcmdlciBmb250cyBieSBzb21lIDIlXG4gICAgICAgdGhpcy5iaW5kQ29uc3RydWN0b3JWYWx1ZXMob3B0aW9ucyk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQHBhcmFtICB7R2x5cGhPcHRpb25zfVxuICAgICovXG4gICBHbHlwaC5wcm90b3R5cGUuYmluZENvbnN0cnVjdG9yVmFsdWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuXG4gICAgICAgLy8gVGhlc2UgdGhyZWUgdmFsdWVzIGNhbm5vdCBiZSBkZWZlcnJlZCBmb3IgbWVtb3J5IG9wdGltaXphdGlvbjpcbiAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcbiAgICAgICB0aGlzLnVuaWNvZGUgPSBvcHRpb25zLnVuaWNvZGUgfHwgdW5kZWZpbmVkO1xuICAgICAgIHRoaXMudW5pY29kZXMgPVxuICAgICAgICAgICBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICA/IFtvcHRpb25zLnVuaWNvZGVdXG4gICAgICAgICAgICAgICA6IFtdO1xuXG4gICAgICAgLy8gQnV0IGJ5IGJpbmRpbmcgdGhlc2UgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnksIHdlIHJlZHVjZSBjYW5cbiAgICAgICAvLyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBieSBhbG1vc3QgMyUgZm9yIGxhcmdlciBmb250cy5cbiAgICAgICBpZiAoJ3hNaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluO1xuICAgICAgIH1cblxuICAgICAgIGlmICgneU1pbicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICB0aGlzLnlNaW4gPSBvcHRpb25zLnlNaW47XG4gICAgICAgfVxuXG4gICAgICAgaWYgKCd4TWF4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgIHRoaXMueE1heCA9IG9wdGlvbnMueE1heDtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoJ3lNYXgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4O1xuICAgICAgIH1cblxuICAgICAgIGlmICgnYWR2YW5jZVdpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgIHRoaXMuYWR2YW5jZVdpZHRoID0gb3B0aW9ucy5hZHZhbmNlV2lkdGg7XG4gICAgICAgfVxuXG4gICAgICAgLy8gVGhlIHBhdGggZm9yIGEgZ2x5cGggaXMgdGhlIG1vc3QgbWVtb3J5IGludGVuc2l2ZSwgYW5kIGlzIGJvdW5kIGFzIGEgdmFsdWVcbiAgICAgICAvLyB3aXRoIGEgZ2V0dGVyL3NldHRlciB0byBlbnN1cmUgd2UgYWN0dWFsbHkgZG8gcGF0aCBwYXJzaW5nIG9ubHkgb25jZSB0aGVcbiAgICAgICAvLyBwYXRoIGlzIGFjdHVhbGx5IG5lZWRlZCBieSBhbnl0aGluZy5cbiAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhdGgnLCBnZXRQYXRoRGVmaW5pdGlvbih0aGlzLCBvcHRpb25zLnBhdGgpKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9XG4gICAgKi9cbiAgIEdseXBoLnByb3RvdHlwZS5hZGRVbmljb2RlID0gZnVuY3Rpb24gKHVuaWNvZGUpIHtcbiAgICAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICAgICB9XG5cbiAgICAgICB0aGlzLnVuaWNvZGVzLnB1c2godW5pY29kZSk7XG4gICB9O1xuXG4gICAvLyAvKipcbiAgIC8vICAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSBib3VuZGluZyBib3ggZm9yIHRoaXMgZ2x5cGguXG4gICAvLyAgKiBAcmV0dXJuIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbiAgIC8vICAqL1xuICAgLy8gR2x5cGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAvLyAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCb3VuZGluZ0JveCgpO1xuICAgLy8gfTtcblxuICAgLyoqXG4gICAgKiBDb252ZXJ0IHRoZSBnbHlwaCB0byBhIFBhdGggd2UgY2FuIGRyYXcgb24gYSBkcmF3aW5nIGNvbnRleHQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAgICAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAgICAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGlmIGhpbnRpbmcgaXMgdG8gYmUgdXNlZCwgdGhlIGZvbnRcbiAgICAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gICAgKi9cbiAgIEdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmb250KSB7XG4gICAgICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgICAgIHZhciBjb21tYW5kcztcbiAgICAgICB2YXIgaFBvaW50cztcbiAgICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgdmFyIHhTY2FsZSA9IG9wdGlvbnMueFNjYWxlO1xuICAgICAgIHZhciB5U2NhbGUgPSBvcHRpb25zLnlTY2FsZTtcblxuICAgICAgIGlmIChvcHRpb25zLmhpbnRpbmcgJiYgZm9udCAmJiBmb250LmhpbnRpbmcpIHtcbiAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBoaW50aW5nLCB0aGUgaGludGluZyBlbmdpbmUgdGFrZXMgY2FyZVxuICAgICAgICAgICAvLyBvZiBzY2FsaW5nIHRoZSBwb2ludHMgKG5vdCB0aGUgcGF0aCkgYmVmb3JlIGhpbnRpbmcuXG4gICAgICAgICAgIGhQb2ludHMgPSB0aGlzLnBhdGggJiYgZm9udC5oaW50aW5nLmV4ZWModGhpcywgZm9udFNpemUpO1xuICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBoaW50aW5nIGVuZ2luZSBmYWlsZWQgaFBvaW50cyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgLy8gYW5kIHRodXMgcmV2ZXJ0cyB0byBwbGFpbiByZW5kaW5nXG4gICAgICAgfVxuXG4gICAgICAgaWYgKGhQb2ludHMpIHtcbiAgICAgICAgICAgLy8gQ2FsbCBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMgaW5zdGVhZCBvZiBgZ2x5Zi5nZXRQYXRoKGhQb2ludHMpLmNvbW1hbmRzYCB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgICAgY29tbWFuZHMgPSBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMoaFBvaW50cyk7XG4gICAgICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgICAgLy8gVE9ETyBpbiBjYXNlIG9mIGhpbnRpbmcgeHlTY2FsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgICAgIHhTY2FsZSA9IHlTY2FsZSA9IDE7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgICAgICAgIHZhciBzY2FsZSA9ICgxIC8gKHRoaXMucGF0aC51bml0c1BlckVtIHx8IDEwMDApKSAqIGZvbnRTaXplO1xuICAgICAgICAgICBpZiAoeFNjYWxlID09PSB1bmRlZmluZWQpIHsgeFNjYWxlID0gc2NhbGU7IH1cbiAgICAgICAgICAgaWYgKHlTY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHlTY2FsZSA9IHNjYWxlOyB9XG4gICAgICAgfVxuXG4gICAgICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCArIGNtZC54ICogeFNjYWxlLCB5ICsgLWNtZC55ICogeVNjYWxlKTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICAgICBwLmxpbmVUbyh4ICsgY21kLnggKiB4U2NhbGUsIHkgKyAtY21kLnkgKiB5U2NhbGUpO1xuICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICB4ICsgY21kLngxICogeFNjYWxlLFxuICAgICAgICAgICAgICAgICAgIHkgKyAtY21kLnkxICogeVNjYWxlLFxuICAgICAgICAgICAgICAgICAgIHggKyBjbWQueCAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgICAgICB5ICsgLWNtZC55ICogeVNjYWxlXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgICAgIHAuY3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICB4ICsgY21kLngxICogeFNjYWxlLFxuICAgICAgICAgICAgICAgICAgIHkgKyAtY21kLnkxICogeVNjYWxlLFxuICAgICAgICAgICAgICAgICAgIHggKyBjbWQueDIgKiB4U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgeSArIC1jbWQueTIgKiB5U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgeCArIGNtZC54ICogeFNjYWxlLFxuICAgICAgICAgICAgICAgICAgIHkgKyAtY21kLnkgKiB5U2NhbGVcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIHJldHVybiBwO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbiAgICAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuICAgICogcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbiAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICovXG4gICBHbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgIH1cblxuICAgICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgdmFyIHB0ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgICAgY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJ1xuICAgICAgICk7XG4gICAgICAgcmV0dXJuIGNvbnRvdXJzO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBDYWxjdWxhdGUgdGhlIHhNaW4veU1pbi94TWF4L3lNYXgvbHNiL3JzYiBmb3IgYSBHbHlwaC5cbiAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAqL1xuICAgR2x5cGgucHJvdG90eXBlLmdldE1ldHJpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgdmFyIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgICAgIHZhciB4Q29vcmRzID0gW107XG4gICAgICAgdmFyIHlDb29yZHMgPSBbXTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcbiAgICAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueCk7XG4gICAgICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgdmFyIG1ldHJpY3MgPSB7XG4gICAgICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IHRoaXMubGVmdFNpZGVCZWFyaW5nLFxuICAgICAgIH07XG5cbiAgICAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1pbikpIHtcbiAgICAgICAgICAgbWV0cmljcy54TWluID0gMDtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1heCkpIHtcbiAgICAgICAgICAgbWV0cmljcy54TWF4ID0gdGhpcy5hZHZhbmNlV2lkdGg7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNaW4pKSB7XG4gICAgICAgICAgIG1ldHJpY3MueU1pbiA9IDA7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNYXgpKSB7XG4gICAgICAgICAgIG1ldHJpY3MueU1heCA9IDA7XG4gICAgICAgfVxuXG4gICAgICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID1cbiAgICAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggLVxuICAgICAgICAgICBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtXG4gICAgICAgICAgIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgICAgIHJldHVybiBtZXRyaWNzO1xuICAgfTtcblxuICAgLy8gVGhlIEdseXBoU2V0IG9iamVjdFxuXG4gICAvLyBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGUgZ2x5cGggdGhhdCBkZXBlbmRzIG9uIHRoZSBwYXRoIGJlaW5nIGxvYWRlZC5cbiAgIGZ1bmN0aW9uIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSkge1xuICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCB7XG4gICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgLy8gUmVxdWVzdCB0aGUgcGF0aCBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhlIHBhdGggaXMgbG9hZGVkLlxuICAgICAgICAgICAgICAgZ2x5cGgucGF0aDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICByZXR1cm4gZ2x5cGhbaW50ZXJuYWxOYW1lXTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgIGdseXBoW2ludGVybmFsTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEEgR2x5cGhTZXQgcmVwcmVzZW50cyBhbGwgZ2x5cGhzIGF2YWlsYWJsZSBpbiB0aGUgZm9udCwgYnV0IG1vZGVsbGVkIHVzaW5nXG4gICAgKiBhIGRlZmVycmVkIGdseXBoIGxvYWRlciwgZm9yIHJldHJpZXZpbmcgZ2x5cGhzIG9ubHkgb25jZSB0aGV5IGFyZSBhYnNvbHV0ZWx5XG4gICAgKiBuZWNlc3NhcnksIHRvIGtlZXAgdGhlIG1lbW9yeSBmb290cHJpbnQgZG93bi5cbiAgICAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoU2V0XG4gICAgKiBAY2xhc3NcbiAgICAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAgICAqIEBwYXJhbSB7QXJyYXl9XG4gICAgKi9cbiAgIGZ1bmN0aW9uIEdseXBoU2V0KGZvbnQsIGdseXBocykge1xuICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICAgICBpZiAoQXJyYXkuaXNBcnJheShnbHlwaHMpKSB7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgICAgICAgICBnbHlwaC5wYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICB0aGlzLmdseXBoc1tpXSA9IGdseXBoO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5sZW5ndGggPSAoZ2x5cGhzICYmIGdseXBocy5sZW5ndGgpIHx8IDA7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICAgICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gICAgKi9cbiAgIEdseXBoU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAvLyB0aGlzLmdseXBoc1tpbmRleF0gaXMgJ3VuZGVmaW5lZCcgd2hlbiBsb3cgbWVtb3J5IG1vZGUgaXMgb24uIGdseXBoIGlzIHB1c2hlZCBvbiByZXF1ZXN0IG9ubHkuXG4gICAgICAgaWYgKHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgIHRoaXMuZm9udC5fcHVzaChpbmRleCk7XG4gICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2luZGV4XTtcbiAgICAgICAgICAgdmFyIHVuaWNvZGVPYmogPSB0aGlzLmZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2luZGV4XTtcblxuICAgICAgICAgICBpZiAodW5pY29kZU9iaikge1xuICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1bmljb2RlT2JqLnVuaWNvZGVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgIHsgZ2x5cGguYWRkVW5pY29kZSh1bmljb2RlT2JqLnVuaWNvZGVzW2pdKTsgfVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdLmFkdmFuY2VXaWR0aCA9XG4gICAgICAgICAgICAgICB0aGlzLmZvbnQuX2htdHhUYWJsZURhdGFbaW5kZXhdLmFkdmFuY2VXaWR0aDtcbiAgICAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdLmxlZnRTaWRlQmVhcmluZyA9XG4gICAgICAgICAgICAgICB0aGlzLmZvbnQuX2htdHhUYWJsZURhdGFbaW5kZXhdLmxlZnRTaWRlQmVhcmluZztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gdGhpcy5nbHlwaHNbaW5kZXhdKCk7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gdGhpcy5nbHlwaHNbaW5kZXhdO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gICAgKiBAcGFyYW0gIHtPYmplY3R9XG4gICAgKi9cbiAgIEdseXBoU2V0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGluZGV4LCBsb2FkZXIpIHtcbiAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSBsb2FkZXI7XG4gICAgICAgdGhpcy5sZW5ndGgrKztcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGFsaWFzIG9wZW50eXBlLmdseXBoTG9hZGVyXG4gICAgKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gICAgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAgICAqL1xuICAgZnVuY3Rpb24gZ2x5cGhMb2FkZXIoZm9udCwgaW5kZXgpIHtcbiAgICAgICByZXR1cm4gbmV3IEdseXBoKHsgaW5kZXg6IGluZGV4LCBmb250OiBmb250IH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcbiAgICAqIHRoZSBcInBvaW50c1wiIGFuZCBcInBhdGhcIiBwcm9wZXJ0aWVzLCB3aGljaCBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAgICAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG4gICAgKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcbiAgICAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAgICAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cbiAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcbiAgICAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICAgICovXG4gICBmdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7IGluZGV4OiBpbmRleCwgZm9udDogZm9udCB9KTtcblxuICAgICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgdmFyIHBhdGggPSBidWlsZFBhdGgoZm9udC5nbHlwaHMsIGdseXBoKTtcbiAgICAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1pbicsICdfeE1pbicpO1xuICAgICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNYXgnLCAnX3hNYXgnKTtcbiAgICAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWluJywgJ195TWluJyk7XG4gICAgICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1heCcsICdfeU1heCcpO1xuXG4gICAgICAgICAgIHJldHVybiBnbHlwaDtcbiAgICAgICB9O1xuICAgfVxuICAgLyoqXG4gICAgKiBAYWxpYXMgb3BlbnR5cGUuY2ZmR2x5cGhMb2FkZXJcbiAgICAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUNGRkNoYXJzdHJpbmdcbiAgICAqIEBwYXJhbSAge3N0cmluZ30gY2hhcnN0cmluZ1xuICAgICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gICAgKi9cbiAgIGZ1bmN0aW9uIGNmZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJzdHJpbmcpIHtcbiAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB2YXIgZ2x5cGggPSBuZXcgR2x5cGgoeyBpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnQgfSk7XG5cbiAgICAgICAgICAgZ2x5cGgucGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIHZhciBwYXRoID0gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjaGFyc3RyaW5nKTtcbiAgICAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIHJldHVybiBnbHlwaDtcbiAgICAgICB9O1xuICAgfVxuXG4gICB2YXIgZ2x5cGhzZXQgPSB7IEdseXBoU2V0OiBHbHlwaFNldCwgZ2x5cGhMb2FkZXI6IGdseXBoTG9hZGVyLCB0dGZHbHlwaExvYWRlcjogdHRmR2x5cGhMb2FkZXIsIGNmZkdseXBoTG9hZGVyOiBjZmZHbHlwaExvYWRlciB9O1xuXG4gICAvLyBUaGUgTGF5b3V0IG9iamVjdCBpcyB0aGUgcHJvdG90eXBlIG9mIFN1YnN0aXR1dGlvbiBvYmplY3RzLCBhbmQgcHJvdmlkZXNcblxuICAgZnVuY3Rpb24gc2VhcmNoVGFnKGFyciwgdGFnKSB7XG4gICAgICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgICAgdmFyIGltaW4gPSAwO1xuICAgICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF0udGFnO1xuICAgICAgICAgICBpZiAodmFsID09PSB0YWcpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHRhZykge1xuICAgICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgaW1heCA9IGltaWQgLSAxO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgICAgIHJldHVybiAtaW1pbiAtIDE7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG4gICAgICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgICAgdmFyIGltaW4gPSAwO1xuICAgICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF07XG4gICAgICAgICAgIGlmICh2YWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgaW1heCA9IGltaWQgLSAxO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgICAgIHJldHVybiAtaW1pbiAtIDE7XG4gICB9XG5cbiAgIC8vIGJpbmFyeSBzZWFyY2ggaW4gYSBsaXN0IG9mIHJhbmdlcyAoY292ZXJhZ2UsIGNsYXNzIGRlZmluaXRpb24pXG4gICBmdW5jdGlvbiBzZWFyY2hSYW5nZShyYW5nZXMsIHZhbHVlKSB7XG4gICAgICAgLy8ganNoaW50IGJpdHdpc2U6IGZhbHNlXG4gICAgICAgdmFyIHJhbmdlO1xuICAgICAgIHZhciBpbWluID0gMDtcbiAgICAgICB2YXIgaW1heCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWlkXTtcbiAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgIGlmIChzdGFydCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCA8IHZhbHVlKSB7XG4gICAgICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBpbWF4ID0gaW1pZCAtIDE7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgaWYgKGltaW4gPiAwKSB7XG4gICAgICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaW4gLSAxXTtcbiAgICAgICAgICAgaWYgKHZhbHVlID4gcmFuZ2UuZW5kKSB7IHJldHVybiAwOyB9XG4gICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogQGV4cG9ydHMgb3BlbnR5cGUuTGF5b3V0XG4gICAgKiBAY2xhc3NcbiAgICAqL1xuICAgZnVuY3Rpb24gTGF5b3V0KGZvbnQsIHRhYmxlTmFtZSkge1xuICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gICB9XG5cbiAgIExheW91dC5wcm90b3R5cGUgPSB7XG4gICAgICAgLyoqXG4gICAgICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqIEBmdW5jdGlvbiBzZWFyY2hUYWdcbiAgICAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGFnXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgIHNlYXJjaFRhZzogc2VhcmNoVGFnLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgbnVtYmVyc1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcbiAgICAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBHZXQgb3IgY3JlYXRlIHRoZSBMYXlvdXQgdGFibGUgKEdTVUIsIEdQT1MgZXRjKS5cbiAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgR1NVQiBvciBHUE9TIHRhYmxlLlxuICAgICAgICAqL1xuICAgICAgIGdldFRhYmxlOiBmdW5jdGlvbiAoY3JlYXRlKSB7XG4gICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXTtcbiAgICAgICAgICAgaWYgKCFsYXlvdXQgJiYgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICBsYXlvdXQgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGJldCBmb3IgYSBzY3JpcHQgbmFtZS5cbiAgICAgICAgKiBSZXR1cm5zICdERkxUJyBpZiBpdCBleGlzdHMuXG4gICAgICAgICogSWYgbm90LCByZXR1cm5zICdsYXRuJyBpZiBpdCBleGlzdHMuXG4gICAgICAgICogSWYgbmVpdGhlciBleGlzdCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICAgICovXG4gICAgICAgZ2V0RGVmYXVsdFNjcmlwdE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoKTtcbiAgICAgICAgICAgaWYgKCFsYXlvdXQpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICB2YXIgaGFzTGF0biA9IGZhbHNlO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dC5zY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICB2YXIgbmFtZSA9IGxheW91dC5zY3JpcHRzW2ldLnRhZztcbiAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnREZMVCcpIHsgcmV0dXJuIG5hbWU7IH1cbiAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnbGF0bicpIHsgaGFzTGF0biA9IHRydWU7IH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoaGFzTGF0bikgeyByZXR1cm4gJ2xhdG4nOyB9XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgYWxsIExhbmdTeXNSZWNvcmRzIGluIHRoZSBnaXZlbiBzY3JpcHQuXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIHNjcmlwdCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGFnIGFuZCBzY3JpcHQgcHJvcGVydGllcy5cbiAgICAgICAgKi9cbiAgICAgICBnZXRTY3JpcHRUYWJsZTogZnVuY3Rpb24gKHNjcmlwdCwgY3JlYXRlKSB7XG4gICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKGNyZWF0ZSk7XG4gICAgICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgICAgIHNjcmlwdCA9IHNjcmlwdCB8fCAnREZMVCc7XG4gICAgICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGxheW91dC5zY3JpcHRzO1xuICAgICAgICAgICAgICAgdmFyIHBvcyA9IHNlYXJjaFRhZyhsYXlvdXQuc2NyaXB0cywgc2NyaXB0KTtcbiAgICAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW3Bvc10uc2NyaXB0O1xuICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgc2NyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHNjcmlwdCxcbiAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICBzY3JpcHRzLnNwbGljZSgtMSAtIHBvcywgMCwgc2NyKTtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NyLnNjcmlwdDtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIGEgbGFuZ3VhZ2Ugc3lzdGVtIHRhYmxlXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIGxhbmdTeXNUYWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgKi9cbiAgICAgICBnZXRMYW5nU3lzVGFibGU6IGZ1bmN0aW9uIChzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcbiAgICAgICAgICAgdmFyIHNjcmlwdFRhYmxlID0gdGhpcy5nZXRTY3JpcHRUYWJsZShzY3JpcHQsIGNyZWF0ZSk7XG4gICAgICAgICAgIGlmIChzY3JpcHRUYWJsZSkge1xuICAgICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZSA9PT0gJ2RmbHQnIHx8IGxhbmd1YWdlID09PSAnREZMVCcpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUuZGVmYXVsdExhbmdTeXM7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHNbcG9zXS5sYW5nU3lzO1xuICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIHBvcywgMCwgbGFuZ1N5c1JlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBHZXQgYSBzcGVjaWZpYyBmZWF0dXJlIHRhYmxlLlxuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIE9uZSBvZiB0aGUgY29kZXMgbGlzdGVkIGF0IGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZmVhdHVyZWxpc3QuaHRtXG4gICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBmZWF0dXJlIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAqL1xuICAgICAgIGdldEZlYXR1cmVUYWJsZTogZnVuY3Rpb24gKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSkge1xuICAgICAgICAgICB2YXIgbGFuZ1N5c1RhYmxlID0gdGhpcy5nZXRMYW5nU3lzVGFibGUoc2NyaXB0LCBsYW5ndWFnZSwgY3JlYXRlKTtcbiAgICAgICAgICAgaWYgKGxhbmdTeXNUYWJsZSkge1xuICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVSZWNvcmQ7XG4gICAgICAgICAgICAgICB2YXIgZmVhdEluZGV4ZXMgPSBsYW5nU3lzVGFibGUuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgICAgICAgICB2YXIgYWxsRmVhdHVyZXMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5mZWF0dXJlcztcbiAgICAgICAgICAgICAgIC8vIFRoZSBGZWF0dXJlSW5kZXggYXJyYXkgb2YgaW5kaWNlcyBpcyBpbiBhcmJpdHJhcnkgb3JkZXIsXG4gICAgICAgICAgICAgICAvLyBldmVuIGlmIGFsbEZlYXR1cmVzIGlzIHNvcnRlZCBhbHBoYWJldGljYWxseSBieSBmZWF0dXJlIHRhZy5cbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0gYWxsRmVhdHVyZXNbZmVhdEluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlUmVjb3JkLnRhZyA9PT0gZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxGZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgLy8gQXV0b21hdGljIG9yZGVyaW5nIG9mIGZlYXR1cmVzIHdvdWxkIHJlcXVpcmUgdG8gc2hpZnQgZmVhdHVyZSBpbmRleGVzIGluIHRoZSBzY3JpcHQgbGlzdC5cbiAgICAgICAgICAgICAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID09PSAwIHx8IGZlYXR1cmUgPj0gYWxsRmVhdHVyZXNbaW5kZXggLSAxXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICdGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci4nXG4gICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICB0YWc6IGZlYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfSxcbiAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgZmVhdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBHZXQgdGhlIGxvb2t1cCB0YWJsZXMgb2YgYSBnaXZlbiB0eXBlIGZvciBhIHNjcmlwdC9sYW5ndWFnZS9mZWF0dXJlLlxuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgY29kZVxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb29rdXBUeXBlIC0gMSB0byA5XG4gICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBsb29rdXAgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdCwgd2l0aCBubyBzdWJ0YWJsZXMuXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICAgICovXG4gICAgICAgZ2V0TG9va3VwVGFibGVzOiBmdW5jdGlvbiAoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgbG9va3VwVHlwZSwgY3JlYXRlKSB7XG4gICAgICAgICAgIHZhciBmZWF0dXJlVGFibGUgPSB0aGlzLmdldEZlYXR1cmVUYWJsZShcbiAgICAgICAgICAgICAgIHNjcmlwdCxcbiAgICAgICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgICAgICAgIGNyZWF0ZVxuICAgICAgICAgICApO1xuICAgICAgICAgICB2YXIgdGFibGVzID0gW107XG4gICAgICAgICAgIGlmIChmZWF0dXJlVGFibGUpIHtcbiAgICAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZTtcbiAgICAgICAgICAgICAgIHZhciBsb29rdXBMaXN0SW5kZXhlcyA9IGZlYXR1cmVUYWJsZS5sb29rdXBMaXN0SW5kZXhlcztcbiAgICAgICAgICAgICAgIHZhciBhbGxMb29rdXBzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0ubG9va3VwcztcbiAgICAgICAgICAgICAgIC8vIGxvb2t1cExpc3RJbmRleGVzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLCBzbyB1c2UgbmFpdmUgc2VhcmNoLlxuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29rdXBMaXN0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0gYWxsTG9va3Vwc1tsb29rdXBMaXN0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgPT09IGxvb2t1cFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGFibGVzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmICh0YWJsZXMubGVuZ3RoID09PSAwICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBGbGFnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICBzdWJ0YWJsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICBhbGxMb29rdXBzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiB0YWJsZXM7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY2xhc3MtZGVmaW5pdGlvbi10YWJsZVxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbGFzc0RlZlRhYmxlIC0gYW4gT3BlblR5cGUgTGF5b3V0IGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuICAgICAgICAqL1xuICAgICAgIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc0RlZlRhYmxlLCBnbHlwaEluZGV4KSB7XG4gICAgICAgICAgIHN3aXRjaCAoY2xhc3NEZWZUYWJsZS5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaCA8PSBnbHlwaEluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoICsgY2xhc3NEZWZUYWJsZS5jbGFzc2VzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NEZWZUYWJsZS5jbGFzc2VzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCAtIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaFxuICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjbGFzc0RlZlRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY2xhc3NJZCA6IDA7XG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgICogRmluZCBhIGdseXBoIGluIGEgY292ZXJhZ2UgdGFibGVcbiAgICAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY292ZXJhZ2UtdGFibGVcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY292ZXJhZ2VUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjb3ZlcmFnZSB0YWJsZVxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBnbHlwaCB0byBmaW5kXG4gICAgICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG4gICAgICAgICovXG4gICAgICAgZ2V0Q292ZXJhZ2VJbmRleDogZnVuY3Rpb24gKGNvdmVyYWdlVGFibGUsIGdseXBoSW5kZXgpIHtcbiAgICAgICAgICAgc3dpdGNoIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJpblNlYXJjaChjb3ZlcmFnZVRhYmxlLmdseXBocywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IC0xO1xuICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlYXJjaFJhbmdlKGNvdmVyYWdlVGFibGUucmFuZ2VzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5pbmRleCArIGdseXBoSW5kZXggLSByYW5nZS5zdGFydCA6IC0xO1xuICAgICAgICAgICB9XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZ2x5cGggaW5kZXhlcyBvZiBhIGNvdmVyYWdlIHRhYmxlLlxuICAgICAgICAqIEZvcm1hdCAxOiB0aGUgbGlzdCBpcyBzdG9yZWQgcmF3XG4gICAgICAgICogRm9ybWF0IDI6IGNvbXBhY3QgbGlzdCBhcyByYW5nZSByZWNvcmRzLlxuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gY292ZXJhZ2VUYWJsZVxuICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAqL1xuICAgICAgIGV4cGFuZENvdmVyYWdlOiBmdW5jdGlvbiAoY292ZXJhZ2VUYWJsZSkge1xuICAgICAgICAgICBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBjb3ZlcmFnZVRhYmxlLmdseXBocztcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHZhciBnbHlwaHMgPSBbXTtcbiAgICAgICAgICAgICAgIHZhciByYW5nZXMgPSBjb3ZlcmFnZVRhYmxlLnJhbmdlcztcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGdseXBocy5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHJldHVybiBnbHlwaHM7XG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuICAgfTtcblxuICAgLy8gVGhlIFBvc2l0aW9uIG9iamVjdCBwcm92aWRlcyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZVxuXG4gICAvKipcbiAgICAqIEBleHBvcnRzIG9wZW50eXBlLlBvc2l0aW9uXG4gICAgKiBAY2xhc3NcbiAgICAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICAgICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgIGZ1bmN0aW9uIFBvc2l0aW9uKGZvbnQpIHtcbiAgICAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3BvcycpO1xuICAgfVxuXG4gICBQb3NpdGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4gICAvKipcbiAgICAqIEluaXQgc29tZSBkYXRhIGZvciBmYXN0ZXIgYW5kIGVhc2llciBhY2Nlc3MgbGF0ZXIuXG4gICAgKi9cbiAgIFBvc2l0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgdmFyIHNjcmlwdCA9IHRoaXMuZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcbiAgICAgICB0aGlzLmRlZmF1bHRLZXJuaW5nVGFibGVzID0gdGhpcy5nZXRLZXJuaW5nVGFibGVzKHNjcmlwdCk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEZpbmQgYSBnbHlwaCBwYWlyIGluIGEgbGlzdCBvZiBsb29rdXAgdGFibGVzIG9mIHR5cGUgMiBhbmQgcmV0cmlldmUgdGhlIHhBZHZhbmNlIGtlcm5pbmcgdmFsdWUuXG4gICAgKlxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBsZWZ0SW5kZXggLSBsZWZ0IGdseXBoIGluZGV4XG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJpZ2h0SW5kZXggLSByaWdodCBnbHlwaCBpbmRleFxuICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgKi9cbiAgIFBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihrZXJuaW5nTG9va3VwcywgbGVmdEluZGV4LCByaWdodEluZGV4KSB7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuaW5nTG9va3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgc3VidGFibGVzID0ga2VybmluZ0xvb2t1cHNbaV0uc3VidGFibGVzO1xuICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnRhYmxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2pdO1xuICAgICAgICAgICAgICAgdmFyIGNvdkluZGV4ID0gdGhpcy5nZXRDb3ZlcmFnZUluZGV4KHN1YnRhYmxlLmNvdmVyYWdlLCBsZWZ0SW5kZXgpO1xuICAgICAgICAgICAgICAgaWYgKGNvdkluZGV4IDwgMCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgc3dpdGNoIChzdWJ0YWJsZS5wb3NGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDFcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJTZXQgPSBzdWJ0YWJsZS5wYWlyU2V0c1tjb3ZJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpclNldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIuc2Vjb25kR2x5cGggPT09IHJpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci52YWx1ZTEgJiYgcGFpci52YWx1ZTEueEFkdmFuY2UgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBsZWZ0IGdseXBoIGZvdW5kLCBub3QgcmlnaHQgZ2x5cGggLSB0cnkgbmV4dCBzdWJ0YWJsZVxuICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMlxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MxID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMSwgbGVmdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzMiA9IHRoaXMuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjIsIHJpZ2h0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciQxID0gc3VidGFibGUuY2xhc3NSZWNvcmRzW2NsYXNzMV1bY2xhc3MyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIkMS52YWx1ZTEgJiYgcGFpciQxLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIHJldHVybiAwO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBMaXN0IGFsbCBrZXJuaW5nIGxvb2t1cCB0YWJsZXMuXG4gICAgKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXSAtIHVzZSBmb250LnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCkgZm9yIGEgYmV0dGVyIGRlZmF1bHQgdmFsdWVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICAgICogQHJldHVybiB7b2JqZWN0W119IFRoZSBsaXN0IG9mIGtlcm5pbmcgbG9va3VwIHRhYmxlcyAobWF5IGJlIGVtcHR5KSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIEdQT1MgdGFibGUgKGFuZCB3ZSBzaG91bGQgdXNlIHRoZSBrZXJuIHRhYmxlKVxuICAgICovXG4gICBQb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1RhYmxlcyA9IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICAgICBpZiAodGhpcy5mb250LnRhYmxlcy5ncG9zKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCAna2VybicsIDIpO1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8vIFRoZSBTdWJzdGl0dXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG5cbiAgIC8qKlxuICAgICogQGV4cG9ydHMgb3BlbnR5cGUuU3Vic3RpdHV0aW9uXG4gICAgKiBAY2xhc3NcbiAgICAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICAgICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgIGZ1bmN0aW9uIFN1YnN0aXR1dGlvbihmb250KSB7XG4gICAgICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dzdWInKTtcbiAgIH1cblxuICAgLy8gQ2hlY2sgaWYgMiBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcmUgZXF1YWwuXG4gICBmdW5jdGlvbiBhcnJheXNFcXVhbChhcjEsIGFyMikge1xuICAgICAgIHZhciBuID0gYXIxLmxlbmd0aDtcbiAgICAgICBpZiAobiAhPT0gYXIyLmxlbmd0aCkge1xuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgIGlmIChhcjFbaV0gIT09IGFyMltpXSkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuXG4gICAvLyBGaW5kIHRoZSBmaXJzdCBzdWJ0YWJsZSBvZiBhIGxvb2t1cCB0YWJsZSBpbiBhIHBhcnRpY3VsYXIgZm9ybWF0LlxuICAgZnVuY3Rpb24gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIGZvcm1hdCwgZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlcztcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgICAgICByZXR1cm4gc3VidGFibGU7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgaWYgKGRlZmF1bHRTdWJ0YWJsZSkge1xuICAgICAgICAgICBzdWJ0YWJsZXMucHVzaChkZWZhdWx0U3VidGFibGUpO1xuICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN1YnRhYmxlO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfVxuXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuICAgLyoqXG4gICAgKiBDcmVhdGUgYSBkZWZhdWx0IEdTVUIgdGFibGUuXG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IGdzdWIgLSBUaGUgR1NVQiB0YWJsZS5cbiAgICAqL1xuICAgU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgLy8gR2VuZXJhdGUgYSBkZWZhdWx0IGVtcHR5IEdTVUIgdGFibGUgd2l0aCBqdXN0IGEgREZMVCBzY3JpcHQgYW5kIGRmbHQgbGFuZyBzeXMuXG4gICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgc2NyaXB0czogW1xuICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgIHRhZzogJ0RGTFQnLFxuICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgICAgbG9va3VwczogW10sXG4gICAgICAgfTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogTGlzdCBhbGwgc2luZ2xlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDEpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcsICdzczAxJy4uLilcbiAgICAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAgICAqL1xuICAgU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEpO1xuICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gc3VidGFibGUuZGVsdGFHbHlwaElkO1xuICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogZ2x5cGggKyBkZWx0YSB9KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRlID0gc3VidGFibGUuc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogc3Vic3RpdHV0ZVtqXSB9KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIExpc3QgYWxsIG11bHRpcGxlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDIpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2NjbXAnLCAnc3RjaCcpXG4gICAgKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gICAgKi9cbiAgIFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0TXVsdGlwbGUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDIpO1xuICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuXG4gICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudHMgPSBzdWJ0YWJsZS5zZXF1ZW5jZXNbal07XG4gICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IHJlcGxhY2VtZW50cyB9KTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcbiAgIH07XG5cbiAgIC8qKlxuICAgICogTGlzdCBhbGwgYWx0ZXJuYXRlcyAobG9va3VwIHR5cGUgMykgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnYWFsdCcsICdzYWx0Jy4uLilcbiAgICAqIEByZXR1cm4ge0FycmF5fSBhbHRlcm5hdGVzIC0gVGhlIGxpc3Qgb2YgYWx0ZXJuYXRlc1xuICAgICovXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEFsdGVybmF0ZXMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgICAgIHZhciBhbHRlcm5hdGVzID0gW107XG4gICAgICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDMpO1xuICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlU2V0cyA9IHN1YnRhYmxlLmFsdGVybmF0ZVNldHM7XG4gICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZXMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogYWx0ZXJuYXRlU2V0c1tqXSB9KTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gYWx0ZXJuYXRlcztcbiAgIH07XG5cbiAgIC8qKlxuICAgICogTGlzdCBhbGwgbGlnYXR1cmVzIChsb29rdXAgdHlwZSA0KSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAgICAqIFRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgbGlnYXR1cmUgb2JqZWN0cyBsaWtlIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gICAgKiBAcmV0dXJuIHtBcnJheX0gbGlnYXR1cmVzIC0gVGhlIGxpc3Qgb2YgbGlnYXR1cmVzLlxuICAgICovXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldExpZ2F0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgICAgdmFyIGxpZ2F0dXJlcyA9IFtdO1xuICAgICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCA0KTtcbiAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgICAgdmFyIGxpZ2F0dXJlU2V0cyA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0cztcbiAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0R2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgICAgdmFyIGxpZ1NldCA9IGxpZ2F0dXJlU2V0c1tqXTtcbiAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpZ1NldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlnID0gbGlnU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICBsaWdhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IFtzdGFydEdseXBoXS5jb25jYXQobGlnLmNvbXBvbmVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGxpZy5saWdHbHlwaCxcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIHJldHVybiBsaWdhdHVyZXM7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEFkZCBvciBtb2RpZnkgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuICAgICogRm9ybWF0IDIsIG1vcmUgZmxleGlibGUsIGlzIGFsd2F5cyB1c2VkLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogaWQgfSAoZm9ybWF0IDEgaXMgbm90IHN1cHBvcnRlZClcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICAgICovXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZFNpbmdsZSA9IGZ1bmN0aW9uIChcbiAgICAgICBmZWF0dXJlLFxuICAgICAgIHN1YnN0aXR1dGlvbixcbiAgICAgICBzY3JpcHQsXG4gICAgICAgbGFuZ3VhZ2VcbiAgICkge1xuICAgICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKFxuICAgICAgICAgICBzY3JpcHQsXG4gICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAxLFxuICAgICAgICAgICB0cnVlXG4gICAgICAgKVswXTtcbiAgICAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMiwge1xuICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAxIHN1YnRhYmxlLCBmb3JtYXQgMiwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICAgICBzdWJzdGl0dXRlOiBbXSxcbiAgICAgICB9KTtcbiAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgICAgJ1NpbmdsZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArXG4gICAgICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXRcbiAgICAgICApO1xuICAgICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICAgICBzdWJ0YWJsZS5zdWJzdGl0dXRlLnNwbGljZShwb3MsIDAsIDApO1xuICAgICAgIH1cbiAgICAgICBzdWJ0YWJsZS5zdWJzdGl0dXRlW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEFkZCBvciBtb2RpZnkgYSBtdWx0aXBsZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDIpXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2NjbXAnLCAnc3RjaCcpXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogW2lkXSB9IGZvciBmb3JtYXQgMi5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICAgICovXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZE11bHRpcGxlID0gZnVuY3Rpb24gKFxuICAgICAgIGZlYXR1cmUsXG4gICAgICAgc3Vic3RpdHV0aW9uLFxuICAgICAgIHNjcmlwdCxcbiAgICAgICBsYW5ndWFnZVxuICAgKSB7XG4gICAgICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICAgICBzdWJzdGl0dXRpb24uYnkgaW5zdGFuY2VvZiBBcnJheSAmJiBzdWJzdGl0dXRpb24uYnkubGVuZ3RoID4gMSxcbiAgICAgICAgICAgJ011bHRpcGxlOiBcImJ5XCIgbXVzdCBiZSBhbiBhcnJheSBvZiB0d28gb3IgbW9yZSBpZHMnXG4gICAgICAgKTtcbiAgICAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhcbiAgICAgICAgICAgc2NyaXB0LFxuICAgICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgICAgMixcbiAgICAgICAgICAgdHJ1ZVxuICAgICAgIClbMF07XG4gICAgICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDEsIHtcbiAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMiBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgICAgc2VxdWVuY2VzOiBbXSxcbiAgICAgICB9KTtcbiAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgICAgJ011bHRpcGxlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICtcbiAgICAgICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdFxuICAgICAgICk7XG4gICAgICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgICAgIHN1YnRhYmxlLnNlcXVlbmNlcy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICAgICB9XG4gICAgICAgc3VidGFibGUuc2VxdWVuY2VzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEFkZCBvciBtb2RpZnkgYW4gYWx0ZXJuYXRlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMylcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICAgICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IFtpZHNdIH1cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICAgICovXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZEFsdGVybmF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgICBmZWF0dXJlLFxuICAgICAgIHN1YnN0aXR1dGlvbixcbiAgICAgICBzY3JpcHQsXG4gICAgICAgbGFuZ3VhZ2VcbiAgICkge1xuICAgICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKFxuICAgICAgICAgICBzY3JpcHQsXG4gICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAzLFxuICAgICAgICAgICB0cnVlXG4gICAgICAgKVswXTtcbiAgICAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwge1xuICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAzIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICAgICBhbHRlcm5hdGVTZXRzOiBbXSxcbiAgICAgICB9KTtcbiAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgICAgJ0FsdGVybmF0ZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArXG4gICAgICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXRcbiAgICAgICApO1xuICAgICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLnNwbGljZShwb3MsIDAsIDApO1xuICAgICAgIH1cbiAgICAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEFkZCBhIGxpZ2F0dXJlIChsb29rdXAgdHlwZSA0KVxuICAgICogTGlnYXR1cmVzIHdpdGggbW9yZSBjb21wb25lbnRzIG11c3QgYmUgc3RvcmVkIGFoZWFkIG9mIHRob3NlIHdpdGggZmV3ZXIgY29tcG9uZW50cyBpbiBvcmRlciB0byBiZSBmb3VuZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbGlnYXR1cmUgLSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAgICAqL1xuICAgU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRMaWdhdHVyZSA9IGZ1bmN0aW9uIChcbiAgICAgICBmZWF0dXJlLFxuICAgICAgIGxpZ2F0dXJlLFxuICAgICAgIHNjcmlwdCxcbiAgICAgICBsYW5ndWFnZVxuICAgKSB7XG4gICAgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoXG4gICAgICAgICAgIHNjcmlwdCxcbiAgICAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgICAgIGZlYXR1cmUsXG4gICAgICAgICAgIDQsXG4gICAgICAgICAgIHRydWVcbiAgICAgICApWzBdO1xuICAgICAgIHZhciBzdWJ0YWJsZSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXTtcbiAgICAgICBpZiAoIXN1YnRhYmxlKSB7XG4gICAgICAgICAgIHN1YnRhYmxlID0ge1xuICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgNCBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICAgICAgICAgbGlnYXR1cmVTZXRzOiBbXSxcbiAgICAgICAgICAgfTtcbiAgICAgICAgICAgbG9va3VwVGFibGUuc3VidGFibGVzWzBdID0gc3VidGFibGU7XG4gICAgICAgfVxuICAgICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLFxuICAgICAgICAgICAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgK1xuICAgICAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0XG4gICAgICAgKTtcbiAgICAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IGxpZ2F0dXJlLnN1YlswXTtcbiAgICAgICB2YXIgbGlnQ29tcG9uZW50cyA9IGxpZ2F0dXJlLnN1Yi5zbGljZSgxKTtcbiAgICAgICB2YXIgbGlnYXR1cmVUYWJsZSA9IHtcbiAgICAgICAgICAgbGlnR2x5cGg6IGxpZ2F0dXJlLmJ5LFxuICAgICAgICAgICBjb21wb25lbnRzOiBsaWdDb21wb25lbnRzLFxuICAgICAgIH07XG4gICAgICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgIC8vIGxpZ2F0dXJlU2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1twb3NdO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAvLyBJZiBsaWdhdHVyZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuLlxuICAgICAgICAgICAgICAgaWYgKGFycmF5c0VxdWFsKGxpZ2F0dXJlU2V0W2ldLmNvbXBvbmVudHMsIGxpZ0NvbXBvbmVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG4gICAgICAgICAgIGxpZ2F0dXJlU2V0LnB1c2gobGlnYXR1cmVUYWJsZSk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cbiAgICAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG4gICAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBMaXN0IGFsbCBmZWF0dXJlIGRhdGEgZm9yIGEgZ2l2ZW4gc2NyaXB0IGFuZCBsYW5ndWFnZS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAgICAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAgICAqL1xuICAgU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24gKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG4gICAgICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICB9XG4gICAgICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgdGhpcy5nZXRBbHRlcm5hdGVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICBjYXNlICdkbGlnJzpcbiAgICAgICAgICAgY2FzZSAnbGlnYSc6XG4gICAgICAgICAgIGNhc2UgJ3JsaWcnOlxuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGlnYXR1cmVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICBjYXNlICdjY21wJzpcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpcGxlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpZ2F0dXJlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgY2FzZSAnc3RjaCc6XG4gICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aXBsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQWRkIGEgc3Vic3RpdHV0aW9uIHRvIGEgZmVhdHVyZSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICAgICovXG4gICBTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG4gICAgICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgIH1cbiAgICAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgICAgY2FzZSAnYWFsdCc6XG4gICAgICAgICAgIGNhc2UgJ3NhbHQnOlxuICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWIuYnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBbHRlcm5hdGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgY2FzZSAnZGxpZyc6XG4gICAgICAgICAgIGNhc2UgJ2xpZ2EnOlxuICAgICAgICAgICBjYXNlICdybGlnJzpcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExpZ2F0dXJlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgICAgIGNhc2UgJ2NjbXAnOlxuICAgICAgICAgICAgICAgaWYgKHN1Yi5ieSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTXVsdGlwbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExpZ2F0dXJlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgfVxuICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICB9O1xuXG4gICBmdW5jdGlvbiBjaGVja0FyZ3VtZW50KGV4cHJlc3Npb24sIG1lc3NhZ2UpIHtcbiAgICAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICAgICB9XG4gICB9XG5cbiAgIC8vIFBhcnNpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuICAgLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgYnl0ZSBmcm9tIHRoZSBEYXRhVmlldy5cbiAgIGZ1bmN0aW9uIGdldEJ5dGUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgfVxuXG4gICAvLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4gICAvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG4gICBmdW5jdGlvbiBnZXRVU2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICB9XG5cbiAgIC8vIFJldHJpZXZlIGEgc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbiAgIC8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbiAgIGZ1bmN0aW9uIGdldFNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICB9XG5cbiAgIC8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDMyLWJpdCBsb25nIGZyb20gdGhlIERhdGFWaWV3LlxuICAgLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuICAgZnVuY3Rpb24gZ2V0VUxvbmcoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICB9XG5cbiAgIC8vIFJldHJpZXZlIGEgMzItYml0IHNpZ25lZCBmaXhlZC1wb2ludCBudW1iZXIgKDE2LjE2KSBmcm9tIHRoZSBEYXRhVmlldy5cbiAgIC8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbiAgIGZ1bmN0aW9uIGdldEZpeGVkKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgICB2YXIgZGVjaW1hbCA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xuICAgICAgIHZhciBmcmFjdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSk7XG4gICAgICAgcmV0dXJuIGRlY2ltYWwgKyBmcmFjdGlvbiAvIDY1NTM1O1xuICAgfVxuXG4gICAvLyBSZXRyaWV2ZSBhIDQtY2hhcmFjdGVyIHRhZyBmcm9tIHRoZSBEYXRhVmlldy5cbiAgIC8vIFRhZ3MgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGFibGVzLlxuICAgZnVuY3Rpb24gZ2V0VGFnKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDQ7IGkgKz0gMSkge1xuICAgICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRJbnQ4KGkpKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gdGFnO1xuICAgfVxuXG4gICAvLyBSZXRyaWV2ZSBhbiBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG4gICAvLyBPZmZzZXRzIGFyZSAxIHRvIDQgYnl0ZXMgaW4gbGVuZ3RoLCBkZXBlbmRpbmcgb24gdGhlIG9mZlNpemUgYXJndW1lbnQuXG4gICBmdW5jdGlvbiBnZXRPZmZzZXQoZGF0YVZpZXcsIG9mZnNldCwgb2ZmU2l6ZSkge1xuICAgICAgIHZhciB2ID0gMDtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZlNpemU7IGkgKz0gMSkge1xuICAgICAgICAgICB2IDw8PSA4O1xuICAgICAgICAgICB2ICs9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB2O1xuICAgfVxuXG4gICAvLyBSZXRyaWV2ZSBhIG51bWJlciBvZiBieXRlcyBmcm9tIHN0YXJ0IG9mZnNldCB0byB0aGUgZW5kIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbiAgIGZ1bmN0aW9uIGdldEJ5dGVzKGRhdGFWaWV3LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDEpIHtcbiAgICAgICAgICAgYnl0ZXMucHVzaChkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgfVxuXG4gICAvLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGJ5dGVzIHRvIGEgc3RyaW5nLlxuICAgZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBzO1xuICAgfVxuXG4gICB2YXIgdHlwZU9mZnNldHMgPSB7XG4gICAgICAgYnl0ZTogMSxcbiAgICAgICB1U2hvcnQ6IDIsXG4gICAgICAgc2hvcnQ6IDIsXG4gICAgICAgdUxvbmc6IDQsXG4gICAgICAgZml4ZWQ6IDQsXG4gICAgICAgbG9uZ0RhdGVUaW1lOiA4LFxuICAgICAgIHRhZzogNFxuICAgfTtcblxuICAgLy8gQSBzdGF0ZWZ1bCBwYXJzZXIgdGhhdCBjaGFuZ2VzIHRoZSBvZmZzZXQgd2hlbmV2ZXIgYSB2YWx1ZSBpcyByZXRyaWV2ZWQuXG4gICAvLyBUaGUgZGF0YSBpcyBhIERhdGFWaWV3LlxuICAgZnVuY3Rpb24gUGFyc2VyKGRhdGEsIG9mZnNldCkge1xuICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IDA7XG4gICB9XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgICAgcmV0dXJuIHY7XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgICAgcmV0dXJuIHY7XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDggPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICAgICByZXR1cm4gdjtcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkMTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNJRCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICAgICByZXR1cm4gdjtcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGMkRvdDE0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KSAvIDE2Mzg0O1xuICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICAgICByZXR1cm4gdjtcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICAgICByZXR1cm4gdjtcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcblxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgdmFyIHYgPSBnZXRGaXhlZCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgICAgIHJldHVybiB2O1xuICAgfTtcblxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgfTtcblxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKDQpO1xuICAgfTtcblxuICAgLy8gTE9OR0RBVEVUSU1FIGlzIGEgNjQtYml0IGludGVnZXIuXG4gICAvLyBKYXZhU2NyaXB0IGFuZCB1bml4IHRpbWVzdGFtcHMgdHJhZGl0aW9uYWxseSB1c2UgMzIgYml0cywgc28gd2VcbiAgIC8vIG9ubHkgdGFrZSB0aGUgbGFzdCAzMiBiaXRzLlxuICAgLy8gKyBTaW5jZSB1bnRpbCAyMDM4IHRob3NlIGJpdHMgd2lsbCBiZSBmaWxsZWQgYnkgemVyb3Mgd2UgY2FuIGlnbm9yZSB0aGVtLlxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvbmdEYXRlVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyA0KTtcbiAgICAgICAvLyBTdWJ0cmFjdCBzZWNvbmRzIGJldHdlZW4gMDEvMDEvMTkwNCBhbmQgMDEvMDEvMTk3MFxuICAgICAgIC8vIHRvIGNvbnZlcnQgQXBwbGUgTWFjIHRpbWVzdGFtcCB0byBTdGFuZGFyZCBVbml4IHRpbWVzdGFtcFxuICAgICAgIHYgLT0gMjA4Mjg0NDgwMDtcbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgICAgcmV0dXJuIHY7XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmVyc2lvbiA9IGZ1bmN0aW9uKG1pbm9yQmFzZSkge1xuICAgICAgIHZhciBtYWpvciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cbiAgICAgICAvLyBIb3cgdG8gaW50ZXJwcmV0IHRoZSBtaW5vciB2ZXJzaW9uIGlzIHZlcnkgdmFndWUgaW4gdGhlIHNwZWMuIDB4NTAwMCBpcyA1LCAweDEwMDAgaXMgMVxuICAgICAgIC8vIERlZmF1bHQgcmV0dXJucyB0aGUgY29ycmVjdCBudW1iZXIgaWYgbWlub3IgPSAweE4wMDAgd2hlcmUgTiBpcyAwLTlcbiAgICAgICAvLyBTZXQgbWlub3JCYXNlIHRvIDEgZm9yIHRhYmxlcyB0aGF0IHVzZSBtaW5vciA9IE4gd2hlcmUgTiBpcyAwLTlcbiAgICAgICB2YXIgbWlub3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyAyKTtcbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgICAgaWYgKG1pbm9yQmFzZSA9PT0gdW5kZWZpbmVkKSB7IG1pbm9yQmFzZSA9IDB4MTAwMDsgfVxuICAgICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gbWlub3JCYXNlIC8gMTA7XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbih0eXBlLCBhbW91bnQpIHtcbiAgICAgICBpZiAoYW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICB9XG5cbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IHR5cGVPZmZzZXRzW3R5cGVdICogYW1vdW50O1xuICAgfTtcblxuICAgLy8vLy8gUGFyc2luZyBsaXN0cyBhbmQgcmVjb3JkcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgIC8vIFBhcnNlIGEgbGlzdCBvZiAzMiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmdMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpOyB9XG4gICAgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICBvZmZzZXRzW2ldID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgIH1cblxuICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiA0O1xuICAgICAgIHJldHVybiBvZmZzZXRzO1xuICAgfTtcblxuICAgLy8gUGFyc2UgYSBsaXN0IG9mIDE2IGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy4gVGhlIGxlbmd0aCBvZiB0aGUgbGlzdCBjYW4gYmUgcmVhZCBvbiB0aGUgc3RyZWFtXG4gICAvLyBvciBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNkxpc3QgPVxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpOyB9XG4gICAgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICBvZmZzZXRzW2ldID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCk7XG4gICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgIH1cblxuICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgICAgIHJldHVybiBvZmZzZXRzO1xuICAgfTtcblxuICAgLy8gUGFyc2VzIGEgbGlzdCBvZiAxNiBiaXQgc2lnbmVkIGludGVnZXJzLlxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0KTtcbiAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgICAgcmV0dXJuIGxpc3Q7XG4gICB9O1xuXG4gICAvLyBQYXJzZXMgYSBsaXN0IG9mIGJ5dGVzLlxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGVMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgIGxpc3RbaV0gPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQrKyk7XG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudDtcbiAgICAgICByZXR1cm4gbGlzdDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogUGFyc2UgYSBsaXN0IG9mIGl0ZW1zLlxuICAgICogUmVjb3JkIGNvdW50IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgICogaXRlbUNhbGxiYWNrIGlzIG9uZSBvZiB0aGUgUGFyc2VyIG1ldGhvZHMuXG4gICAgKi9cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgICAgIGl0ZW1DYWxsYmFjayA9IGNvdW50O1xuICAgICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICB9XG4gICAgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBsaXN0O1xuICAgfTtcblxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICAgICBpZiAoIWl0ZW1DYWxsYmFjaykge1xuICAgICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcbiAgICAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTtcbiAgICAgICB9XG4gICAgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBsaXN0O1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBQYXJzZSBhIGxpc3Qgb2YgcmVjb3Jkcy5cbiAgICAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAqIEV4YW1wbGUgb2YgcmVjb3JkRGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cbiAgICAqL1xuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG4gICAgICAgaWYgKCFyZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgICAgICByZWNvcmREZXNjcmlwdGlvbiA9IGNvdW50O1xuICAgICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICB9XG4gICAgICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgIHZhciByZWMgPSB7fTtcbiAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgLy8gSWYgdGhlIGNvdW50IGFyZ3VtZW50IGlzIGFic2VudCwgcmVhZCBpdCBpbiB0aGUgc3RyZWFtLlxuICAgICAgIGlmICghcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcbiAgICAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTtcbiAgICAgICB9XG4gICAgICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgIHZhciByZWMgPSB7fTtcbiAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICB9O1xuXG4gICAvLyBQYXJzZSBhIGRhdGEgc3RydWN0dXJlIGludG8gYW4gb2JqZWN0XG4gICAvLyBFeGFtcGxlIG9mIGRlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhkZXNjcmlwdGlvbik7XG4gICAgICAgICAgIHZhciBzdHJ1Y3QgPSB7fTtcbiAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gZGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgIHN0cnVjdFtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFBhcnNlIGEgR1BPUyB2YWx1ZVJlY29yZFxuICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG4gICAgKiB2YWx1ZUZvcm1hdCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAqL1xuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkID0gZnVuY3Rpb24odmFsdWVGb3JtYXQpIHtcbiAgICAgICBpZiAodmFsdWVGb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICB9XG4gICAgICAgaWYgKHZhbHVlRm9ybWF0ID09PSAwKSB7XG4gICAgICAgICAgIC8vIHZhbHVlRm9ybWF0MiBpbiBrZXJuaW5nIHBhaXJzIGlzIG1vc3Qgb2Z0ZW4gMFxuICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2UgcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGFuIGVtcHR5IG9iamVjdCwgdG8gc2F2ZSBzcGFjZVxuICAgICAgICAgICByZXR1cm47XG4gICAgICAgfVxuICAgICAgIHZhciB2YWx1ZVJlY29yZCA9IHt9O1xuXG4gICAgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAxKSB7IHZhbHVlUmVjb3JkLnhQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMikgeyB2YWx1ZVJlY29yZC55UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDQpIHsgdmFsdWVSZWNvcmQueEFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwOCkgeyB2YWx1ZVJlY29yZC55QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cbiAgICAgICAvLyBEZXZpY2UgdGFibGUgKG5vbi12YXJpYWJsZSBmb250KSAvIFZhcmlhdGlvbkluZGV4IHRhYmxlICh2YXJpYWJsZSBmb250KSBub3Qgc3VwcG9ydGVkXG4gICAgICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZnItZnIvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2RldlZhcklkeFRibHNcbiAgICAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMTApIHsgdmFsdWVSZWNvcmQueFBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMjApIHsgdmFsdWVSZWNvcmQueVBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwNDApIHsgdmFsdWVSZWNvcmQueEFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwODApIHsgdmFsdWVSZWNvcmQueUFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cblxuICAgICAgIHJldHVybiB2YWx1ZVJlY29yZDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogUGFyc2UgYSBsaXN0IG9mIEdQT1MgdmFsdWVSZWNvcmRzXG4gICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyN2YWx1ZS1yZWNvcmRcbiAgICAqIHZhbHVlRm9ybWF0IGFuZCB2YWx1ZUNvdW50IGFyZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAqL1xuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICB2YXIgdmFsdWVDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KHZhbHVlQ291bnQpO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgIHZhbHVlc1tpXSA9IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdCk7XG4gICAgICAgfVxuICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgdmFyIHN0cnVjdE9mZnNldCA9IHRoaXMucGFyc2VPZmZzZXQxNigpO1xuICAgICAgIGlmIChzdHJ1Y3RPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0ID0+IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHN0cnVjdE9mZnNldCkucGFyc2VTdHJ1Y3QoZGVzY3JpcHRpb24pO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfTtcblxuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgdmFyIHN0cnVjdE9mZnNldCA9IHRoaXMucGFyc2VPZmZzZXQzMigpO1xuICAgICAgIGlmIChzdHJ1Y3RPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0ID0+IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHN0cnVjdE9mZnNldCkucGFyc2VTdHJ1Y3QoZGVzY3JpcHRpb24pO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBQYXJzZSBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiAxNi1iaXQgaW50ZWdlcnMsXG4gICAgKiBvciBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiBvZmZzZXRzIHRvIGFueSBraW5kIG9mIGl0ZW1zLlxuICAgICogSWYgaXRlbUNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCwgYSBsaXN0IG9mIGxpc3Qgb2YgVVNob3J0IGlzIGFzc3VtZWQuXG4gICAgKiBJZiBwcm92aWRlZCwgaXRlbUNhbGxiYWNrIGlzIGNhbGxlZCBvbiBlYWNoIGl0ZW0gYW5kIG11c3QgcGFyc2UgdGhlIGl0ZW0uXG4gICAgKiBTZWUgZXhhbXBsZXMgaW4gdGFibGVzL2dzdWIuanNcbiAgICAqL1xuICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3RPZkxpc3RzID0gZnVuY3Rpb24oaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbaV07XG4gICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgLy8gTlVMTCBvZmZzZXRcbiAgICAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG4gICAgICAgICAgICAgICBsaXN0W2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHN0YXJ0O1xuICAgICAgICAgICBpZiAoaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICB2YXIgc3ViT2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcbiAgICAgICAgICAgICAgIHZhciBzdWJMaXN0ID0gbmV3IEFycmF5KHN1Yk9mZnNldHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViT2Zmc2V0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSBzdGFydCArIHN1Yk9mZnNldHNbal07XG4gICAgICAgICAgICAgICAgICAgc3ViTGlzdFtqXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgbGlzdFtpXSA9IHN1Ykxpc3Q7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBsaXN0W2ldID0gdGhpcy5wYXJzZVVTaG9ydExpc3QoKTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gcmVsYXRpdmVPZmZzZXQ7XG4gICAgICAgcmV0dXJuIGxpc3Q7XG4gICB9O1xuXG4gICAvLy8vLyBDb21wbGV4IHRhYmxlcyBwYXJzaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbiAgIC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG4gICAvLyBwYXJzZXIub2Zmc2V0IG11c3QgcG9pbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZSBjb250YWluaW5nIHRoZSBjb3ZlcmFnZS5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIHZhciBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICAgICBnbHlwaHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGNvdW50KVxuICAgICAgICAgICB9O1xuICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgICAgIHZhciByYW5nZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgIHJhbmdlc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgICAgIGVuZDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLnBhcnNlVVNob3J0KClcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIGZvcm1hdDogMixcbiAgICAgICAgICAgICAgIHJhbmdlczogcmFuZ2VzXG4gICAgICAgICAgIH07XG4gICAgICAgfVxuICAgICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuICAgfTtcblxuICAgLy8gUGFyc2UgYSBDbGFzcyBEZWZpbml0aW9uIFRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuICAgLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgICAgIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICAgICAgICAgfTtcbiAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgICAgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgICAgc3RhcnQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgICAgZW5kOiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgICAgIGNsYXNzSWQ6IFBhcnNlci51U2hvcnRcbiAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgIH07XG4gICAgICAgfVxuICAgICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ2xhc3NEZWYgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuICAgfTtcblxuICAgLy8vLy8gU3RhdGljIG1ldGhvZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgIC8vIFRoZXNlIGNvbnZlbmllbmNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYXMgY2FsbGJhY2tzIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggXCJ0aGlzXCIgY29udGV4dCBzZXQgdG8gYSBQYXJzZXIgaW5zdGFuY2UuXG5cbiAgIFBhcnNlci5saXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgICAgIH07XG4gICB9O1xuXG4gICBQYXJzZXIubGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0MzIoY291bnQsIGl0ZW1DYWxsYmFjayk7XG4gICAgICAgfTtcbiAgIH07XG5cbiAgIFBhcnNlci5yZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICAgICB9O1xuICAgfTtcblxuICAgUGFyc2VyLnJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0MzIoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICAgICB9O1xuICAgfTtcblxuICAgUGFyc2VyLnBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKGRlc2NyaXB0aW9uKTtcbiAgICAgICB9O1xuICAgfTtcblxuICAgUGFyc2VyLnBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihkZXNjcmlwdGlvbik7XG4gICAgICAgfTtcbiAgIH07XG5cbiAgIFBhcnNlci50YWcgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnO1xuICAgUGFyc2VyLmJ5dGUgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcbiAgIFBhcnNlci51U2hvcnQgPSBQYXJzZXIub2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuICAgUGFyc2VyLnVTaG9ydExpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdDtcbiAgIFBhcnNlci51TG9uZyA9IFBhcnNlci5vZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcbiAgIFBhcnNlci51TG9uZ0xpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmdMaXN0O1xuICAgUGFyc2VyLnN0cnVjdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3Q7XG4gICBQYXJzZXIuY292ZXJhZ2UgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2U7XG4gICBQYXJzZXIuY2xhc3NEZWYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWY7XG5cbiAgIC8vLy8vIFNjcmlwdCwgRmVhdHVyZSwgTG9va3VwIGxpc3RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuXG4gICB2YXIgbGFuZ1N5c1RhYmxlID0ge1xuICAgICAgIHJlc2VydmVkOiBQYXJzZXIudVNob3J0LFxuICAgICAgIHJlcUZlYXR1cmVJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICBmZWF0dXJlSW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3RcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICAgICBzY3JpcHQ6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpLFxuICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgICAgICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgICAgICAgICAgICAgbGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKVxuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgfSlcbiAgICAgICB9KSkgfHwgW107XG4gICB9O1xuXG4gICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgICAgIGZlYXR1cmU6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgICAgIGZlYXR1cmVQYXJhbXM6IFBhcnNlci5vZmZzZXQxNixcbiAgICAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxuICAgICAgICAgICB9KVxuICAgICAgIH0pKSB8fCBbXTtcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMb29rdXBMaXN0ID0gZnVuY3Rpb24obG9va3VwVGFibGVQYXJzZXJzKSB7XG4gICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5saXN0KFBhcnNlci5wb2ludGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB2YXIgbG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgY2hlY2suYXJndW1lbnQoMSA8PSBsb29rdXBUeXBlICYmIGxvb2t1cFR5cGUgPD0gOSwgJ0dQT1MvR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVHlwZSArICcgdW5rbm93bi4nKTtcbiAgICAgICAgICAgdmFyIGxvb2t1cEZsYWcgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgICAgbG9va3VwRmxhZzogbG9va3VwRmxhZyxcbiAgICAgICAgICAgICAgIHN1YnRhYmxlczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobG9va3VwVGFibGVQYXJzZXJzW2xvb2t1cFR5cGVdKSksXG4gICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gdGhpcy5wYXJzZVVTaG9ydCgpIDogdW5kZWZpbmVkXG4gICAgICAgICAgIH07XG4gICAgICAgfSkpKSB8fCBbXTtcbiAgIH07XG5cbiAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdmFyIG1ham9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgY2hlY2suYXJndW1lbnQobWFqb3JWZXJzaW9uID09PSAxICYmIG1pbm9yVmVyc2lvbiA8IDEsICdHUE9TL0dTVUIgZmVhdHVyZSB2YXJpYXRpb25zIHRhYmxlIHVua25vd24uJyk7XG4gICAgICAgICAgIHZhciBmZWF0dXJlVmFyaWF0aW9ucyA9IHRoaXMucGFyc2VSZWNvcmRMaXN0MzIoe1xuICAgICAgICAgICAgICAgY29uZGl0aW9uU2V0T2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzIsXG4gICAgICAgICAgICAgICBmZWF0dXJlVGFibGVTdWJzdGl0dXRpb25PZmZzZXQ6IFBhcnNlci5vZmZzZXQzMlxuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVWYXJpYXRpb25zO1xuICAgICAgIH0pIHx8IFtdO1xuICAgfTtcblxuICAgdmFyIHBhcnNlID0ge1xuICAgICAgIGdldEJ5dGU6IGdldEJ5dGUsXG4gICAgICAgZ2V0Q2FyZDg6IGdldEJ5dGUsXG4gICAgICAgZ2V0VVNob3J0OiBnZXRVU2hvcnQsXG4gICAgICAgZ2V0Q2FyZDE2OiBnZXRVU2hvcnQsXG4gICAgICAgZ2V0U2hvcnQ6IGdldFNob3J0LFxuICAgICAgIGdldFVMb25nOiBnZXRVTG9uZyxcbiAgICAgICBnZXRGaXhlZDogZ2V0Rml4ZWQsXG4gICAgICAgZ2V0VGFnOiBnZXRUYWcsXG4gICAgICAgZ2V0T2Zmc2V0OiBnZXRPZmZzZXQsXG4gICAgICAgZ2V0Qnl0ZXM6IGdldEJ5dGVzLFxuICAgICAgIGJ5dGVzVG9TdHJpbmc6IGJ5dGVzVG9TdHJpbmcsXG4gICAgICAgUGFyc2VyOiBQYXJzZXIsXG4gICB9O1xuXG4gICAvLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuXG4gICAvLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBkYXRhIGZvciBhIGdseXBoLlxuICAgZnVuY3Rpb24gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHJldmlvdXNWYWx1ZSwgc2hvcnRWZWN0b3JCaXRNYXNrLCBzYW1lQml0TWFzaykge1xuICAgICAgIHZhciB2O1xuICAgICAgIGlmICgoZmxhZyAmIHNob3J0VmVjdG9yQml0TWFzaykgPiAwKSB7XG4gICAgICAgICAgIC8vIFRoZSBjb29yZGluYXRlIGlzIDEgYnl0ZSBsb25nLlxuICAgICAgICAgICB2ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgLy8gVGhlIGBzYW1lYCBiaXQgaXMgcmUtdXNlZCBmb3Igc2hvcnQgdmFsdWVzIHRvIHNpZ25pZnkgdGhlIHNpZ24gb2YgdGhlIHZhbHVlLlxuICAgICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPT09IDApIHtcbiAgICAgICAgICAgICAgIHYgPSAtdjtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgdjtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAvLyAgVGhlIGNvb3JkaW5hdGUgaXMgMiBieXRlcyBsb25nLlxuICAgICAgICAgICAvLyBJZiB0aGUgYHNhbWVgIGJpdCBpcyBzZXQsIHRoZSBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBjb29yZGluYXRlLlxuICAgICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGFzIGEgc2lnbmVkIDE2LWJpdCBkZWx0YSB2YWx1ZS5cbiAgICAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gdjtcbiAgIH1cblxuICAgLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbiAgIGZ1bmN0aW9uIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHN0YXJ0KSB7XG4gICAgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICAgICBnbHlwaC5udW1iZXJPZkNvbnRvdXJzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgZ2x5cGguX3hNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBnbHlwaC5feU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGdseXBoLl94TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgZ2x5cGguX3lNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICB2YXIgZmxhZ3M7XG4gICAgICAgdmFyIGZsYWc7XG5cbiAgICAgICBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA+IDApIHtcbiAgICAgICAgICAgLy8gVGhpcyBnbHlwaCBpcyBub3QgYSBjb21wb3NpdGUuXG4gICAgICAgICAgIHZhciBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaC5udW1iZXJPZkNvbnRvdXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgIGVuZFBvaW50SW5kaWNlcy5wdXNoKHAucGFyc2VVU2hvcnQoKSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB2YXIgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgICAgZmxhZyA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICAgLy8gSWYgYml0IDMgaXMgc2V0LCB3ZSByZXBlYXQgdGhpcyBmbGFnIG4gdGltZXMsIHdoZXJlIG4gaXMgdGhlIG5leHQgYnl0ZS5cbiAgICAgICAgICAgICAgIGlmICgoZmxhZyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgIHZhciByZXBlYXRDb3VudCA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgIGkkMiArPSAxO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KGZsYWdzLmxlbmd0aCA9PT0gbnVtYmVyT2ZDb29yZGluYXRlcywgJ0JhZCBmbGFncy4nKTtcblxuICAgICAgICAgICBpZiAoZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgICAgICAgIC8vIFgvWSBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIHBvaW50LCBleGNlcHQgZm9yIHRoZSBmaXJzdCBwb2ludCB3aGljaCBpcyByZWxhdGl2ZSB0byAwLDAuXG4gICAgICAgICAgICAgICBpZiAobnVtYmVyT2ZDb29yZGluYXRlcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDMgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQub25DdXJ2ZSA9ICEhKGZsYWcgJiAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQubGFzdFBvaW50T2ZDb250b3VyID0gZW5kUG9pbnRJbmRpY2VzLmluZGV4T2YoaSQzKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgdmFyIHB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDQgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICB2YXIgcHkgPSAwO1xuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgICAgIH1cbiAgICAgICB9IGVsc2UgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPT09IDApIHtcbiAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZ2x5cGguaXNDb21wb3NpdGUgPSB0cnVlO1xuICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgZ2x5cGguY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICB2YXIgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4OiBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICAgIHNjYWxlMDE6IDAsXG4gICAgICAgICAgICAgICAgICAgc2NhbGUxMDogMCxcbiAgICAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICAgICAgICAgZHk6IDBcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VVU2hvcnQoKSwgcC5wYXJzZVVTaG9ydCgpXTtcbiAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc2NhbGVcbiAgICAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDY0KSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFuIFggLyBZIHNjYWxlXG4gICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDEyOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIDJ4MiB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTAxID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUxMCA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGdseXBoLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgbW9yZUNvbXBvbmVudHMgPSAhIShmbGFncyAmIDMyKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoZmxhZ3MgJiAweDEwMCkge1xuICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICAgICBmb3IgKHZhciBpJDYgPSAwOyBpJDYgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSQ2ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgIH1cblxuICAgLy8gVHJhbnNmb3JtIGFuIGFycmF5IG9mIHBvaW50cyBhbmQgcmV0dXJuIGEgbmV3IGFycmF5LlxuICAgZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtKSB7XG4gICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgdmFyIG5ld1B0ID0ge1xuICAgICAgICAgICAgICAgeDogdHJhbnNmb3JtLnhTY2FsZSAqIHB0LnggKyB0cmFuc2Zvcm0uc2NhbGUwMSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHgsXG4gICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm0uc2NhbGUxMCAqIHB0LnggKyB0cmFuc2Zvcm0ueVNjYWxlICogcHQueSArIHRyYW5zZm9ybS5keSxcbiAgICAgICAgICAgICAgIG9uQ3VydmU6IHB0Lm9uQ3VydmUsXG4gICAgICAgICAgICAgICBsYXN0UG9pbnRPZkNvbnRvdXI6IHB0Lmxhc3RQb2ludE9mQ29udG91clxuICAgICAgICAgICB9O1xuICAgICAgICAgICBuZXdQb2ludHMucHVzaChuZXdQdCk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIG5ld1BvaW50cztcbiAgIH1cblxuICAgZnVuY3Rpb24gZ2V0Q29udG91cnMocG9pbnRzKSB7XG4gICAgICAgdmFyIGNvbnRvdXJzID0gW107XG4gICAgICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICBjdXJyZW50Q29udG91ci5wdXNoKHB0KTtcbiAgICAgICAgICAgaWYgKHB0Lmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgICAgY29udG91cnMucHVzaChjdXJyZW50Q29udG91cik7XG4gICAgICAgICAgICAgICBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgY2hlY2suYXJndW1lbnQoY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLCAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJyk7XG4gICAgICAgcmV0dXJuIGNvbnRvdXJzO1xuICAgfVxuXG4gICAvLyBDb252ZXJ0IHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lIHRvIGEgUGF0aC5cbiAgIGZ1bmN0aW9uIGdldFBhdGgocG9pbnRzKSB7XG4gICAgICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgICAgIHJldHVybiBwO1xuICAgICAgIH1cblxuICAgICAgIHZhciBjb250b3VycyA9IGdldENvbnRvdXJzKHBvaW50cyk7XG5cbiAgICAgICBmb3IgKHZhciBjb250b3VySW5kZXggPSAwOyBjb250b3VySW5kZXggPCBjb250b3Vycy5sZW5ndGg7ICsrY29udG91ckluZGV4KSB7XG4gICAgICAgICAgIHZhciBjb250b3VyID0gY29udG91cnNbY29udG91ckluZGV4XTtcblxuICAgICAgICAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgICAgICAgIHZhciBjdXJyID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICB2YXIgbmV4dCA9IGNvbnRvdXJbMF07XG5cbiAgICAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgcC5tb3ZlVG8oY3Vyci54LCBjdXJyLnkpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgaWYgKG5leHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgIHAubW92ZVRvKG5leHQueCwgbmV4dC55KTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgLy8gSWYgYm90aCBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9mZi1jdXJ2ZSwgc3RhcnQgYXQgdGhlaXIgbWlkZGxlLlxuICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHt4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjV9O1xuICAgICAgICAgICAgICAgICAgIHAubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICBwcmV2ID0gY3VycjtcbiAgICAgICAgICAgICAgIGN1cnIgPSBuZXh0O1xuICAgICAgICAgICAgICAgbmV4dCA9IGNvbnRvdXJbKGkgKyAxKSAlIGNvbnRvdXIubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICAgICAgICAgICAgIHAubGluZVRvKGN1cnIueCwgY3Vyci55KTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIHByZXYyID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICB2YXIgbmV4dDIgPSBuZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldjIgPSB7IHg6IChjdXJyLnggKyBwcmV2LngpICogMC41LCB5OiAoY3Vyci55ICsgcHJldi55KSAqIDAuNSB9O1xuICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIG5leHQyID0geyB4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3Vyci54LCBjdXJyLnksIG5leHQyLngsIG5leHQyLnkpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHA7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGJ1aWxkUGF0aChnbHlwaHMsIGdseXBoKSB7XG4gICAgICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG4gICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGguY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGdseXBoLmNvbXBvbmVudHNbal07XG4gICAgICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG4gICAgICAgICAgICAgICBjb21wb25lbnRHbHlwaC5nZXRQYXRoKCk7XG4gICAgICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdID4gZ2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMV0gPiBjb21wb25lbnRHbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXRjaGVkIHBvaW50cyBvdXQgb2YgcmFuZ2UgaW4gJyArIGdseXBoLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFB0ID0gZ2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZFB0ID0gY29tcG9uZW50R2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHhTY2FsZTogY29tcG9uZW50LnhTY2FsZSwgc2NhbGUwMTogY29tcG9uZW50LnNjYWxlMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTEwOiBjb21wb25lbnQuc2NhbGUxMCwgeVNjYWxlOiBjb21wb25lbnQueVNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZHg6IDAsIGR5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFB0ID0gdHJhbnNmb3JtUG9pbnRzKFtzZWNvbmRQdF0sIHRyYW5zZm9ybSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keCA9IGZpcnN0UHQueCAtIHNlY29uZFB0Lng7XG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keSA9IGZpcnN0UHQueSAtIHNlY29uZFB0Lnk7XG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gZ2x5cGgucG9pbnRzLmNvbmNhdCh0cmFuc2Zvcm1lZFBvaW50cyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xuICAgfVxuXG4gICBmdW5jdGlvbiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICAgICAvLyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb2NhIHRhYmxlIGlzIGludmFsaWQuXG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGdseXBocztcbiAgIH1cblxuICAgZnVuY3Rpb24gcGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICAgICBmb250Ll9wdXNoID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICAgICB9XG4gICAgICAgfTtcblxuICAgICAgIHJldHVybiBnbHlwaHM7XG4gICB9XG5cbiAgIC8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG4gICBmdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCwgb3B0KSB7XG4gICAgICAgaWYgKG9wdC5sb3dNZW1vcnkpXG4gICAgICAgICAgIHsgcmV0dXJuIHBhcnNlR2x5ZlRhYmxlT25Mb3dNZW1vcnkoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpOyB9XG4gICAgICAgZWxzZVxuICAgICAgICAgICB7IHJldHVybiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCk7IH1cbiAgIH1cblxuICAgdmFyIGdseWYgPSB7IGdldFBhdGg6IGdldFBhdGgsIHBhcnNlOiBwYXJzZUdseWZUYWJsZX07XG5cbiAgIC8qIEEgVHJ1ZVR5cGUgZm9udCBoaW50aW5nIGludGVycHJldGVyLlxuICAgKlxuICAgKiAoYykgMjAxNyBBeGVsIEtpdHRlbmJlcmdlclxuICAgKlxuICAgKiBUaGlzIGludGVycHJldGVyIGhhcyBiZWVuIGltcGxlbWVudGVkIGFjY29yZGluZyB0byB0aGlzIGRvY3VtZW50YXRpb246XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDUvQ2hhcDUuaHRtbFxuICAgKlxuICAgKiBBY2NvcmRpbmcgdG8gdGhlIGRvY3VtZW50YXRpb24gRjI0RE9UNiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHBpeGVscy5cbiAgICogVGhhdCBtZWFucyBjYWxjdWxhdGlvbiBpcyAxLzY0IHBpeGVsIGFjY3VyYXRlIGFuZCB1c2VzIGludGVnZXIgb3BlcmF0aW9ucy5cbiAgICogSG93ZXZlciwgSmF2YXNjcmlwdCBoYXMgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9ucyBieSBkZWZhdWx0IGFuZCBvbmx5XG4gICAqIHRob3NlIGFyZSBhdmFpbGFibGUuIE9uZSBjb3VsZCBtYWtlIGEgY2FzZSB0byBzaW11bGF0ZSB0aGUgMS82NCBhY2N1cmFjeVxuICAgKiBleGFjdGx5IGJ5IHRydW5jYXRpbmcgYWZ0ZXIgZXZlcnkgZGl2aXNpb24gb3BlcmF0aW9uXG4gICAqIChmb3IgZXhhbXBsZSB3aXRoIDw8IDApIHRvIGdldCBwaXhlbCBleGFjdGx5IHJlc3VsdHMgYXMgb3RoZXIgVHJ1ZVR5cGVcbiAgICogaW1wbGVtZW50YXRpb25zLiBJdCBtYXkgbWFrZSBzZW5zZSBzaW5jZSBzb21lIGZvbnRzIGFyZSBwaXhlbCBvcHRpbWl6ZWRcbiAgICogYnkgaGFuZCB1c2luZyBERUxUQVAgaW5zdHJ1Y3Rpb25zLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0XG4gICAqIGFuZCByYXRoZXIgdXNlcyBmdWxsIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cbiAgICpcbiAgICogeFNjYWxlLCB5U2NhbGUgYW5kIHJvdGF0aW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAgKlxuICAgKiBBIGZldyBub24tdHJpdmlhbCBpbnN0cnVjdGlvbnMgYXJlIG1pc3NpbmcgYXMgSSBkaWRuJ3QgZW5jb3VudGVyIHlldFxuICAgKiBhIGZvbnQgdGhhdCB1c2VkIHRoZW0gdG8gdGVzdCBhIHBvc3NpYmxlIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBTb21lIGZvbnRzIHNlZW0gdG8gdXNlIHVuZG9jdW1lbnRlZCBmZWF0dXJlcyByZWdhcmRpbmcgdGhlIHR3aWxpZ2h0IHpvbmUuXG4gICAqIE9ubHkgc29tZSBvZiB0aGVtIGFyZSBpbXBsZW1lbnRlZCBhcyB0aGV5IHdlcmUgZW5jb3VudGVyZWQuXG4gICAqXG4gICAqIFRoZSBleHBvcnRzLkRFQlVHIHN0YXRlbWVudHMgYXJlIHJlbW92ZWQgb24gdGhlIG1pbmlmaWVkIGRpc3RyaWJ1dGlvbiBmaWxlLlxuICAgKi9cblxuICAgdmFyIGluc3RydWN0aW9uVGFibGU7XG4gICB2YXIgZXhlYztcbiAgIHZhciBleGVjR2x5cGg7XG4gICB2YXIgZXhlY0NvbXBvbmVudDtcblxuICAgLypcbiAgICogQ3JlYXRlcyBhIGhpbnRpbmcgb2JqZWN0LlxuICAgKlxuICAgKiBUaGVyZSBvdWdodCB0byBiZSBleGFjdGx5IG9uZVxuICAgKiBmb3IgZWFjaCB0cnVldHlwZSBmb250IHRoYXQgaXMgdXNlZCBmb3IgaGludGluZy5cbiAgICovXG4gICBmdW5jdGlvbiBIaW50aW5nKGZvbnQpIHtcbiAgICAgICAvLyB0aGUgZm9udCB0aGlzIGhpbnRpbmcgb2JqZWN0IGlzIGZvclxuICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cbiAgICAgICB0aGlzLmdldENvbW1hbmRzID0gZnVuY3Rpb24gKGhQb2ludHMpIHtcbiAgICAgICAgICAgcmV0dXJuIGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kcztcbiAgICAgICB9O1xuXG4gICAgICAgLy8gY2FjaGVkIHN0YXRlc1xuICAgICAgIHRoaXMuX2ZwZ21TdGF0ZSAgPVxuICAgICAgIHRoaXMuX3ByZXBTdGF0ZSAgPVxuICAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgICAvLyBlcnJvclN0YXRlXG4gICAgICAgLy8gMCAuLi4gYWxsIG9rYXlcbiAgICAgICAvLyAxIC4uLiBoYWQgYW4gZXJyb3IgaW4gYSBnbHlmLFxuICAgICAgIC8vICAgICAgIGNvbnRpbnVlIHdvcmtpbmcgYnV0IHN0b3Agc3BhbW1pbmdcbiAgICAgICAvLyAgICAgICB0aGUgY29uc29sZVxuICAgICAgIC8vIDIgLi4uIGVycm9yIGF0IHByZXAsIHN0b3AgaGludGluZyBhdCB0aGlzIHBwZW1cbiAgICAgICAvLyAzIC4uLiBlcnJvciBhdCBmcGVnLCBzdG9wIGhpbnRpbmcgZm9yIHRoaXMgZm9udCBhdCBhbGxcbiAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMDtcbiAgIH1cblxuICAgLypcbiAgICogTm90IHJvdW5kaW5nLlxuICAgKi9cbiAgIGZ1bmN0aW9uIHJvdW5kT2ZmKHYpIHtcbiAgICAgICByZXR1cm4gdjtcbiAgIH1cblxuICAgLypcbiAgICogUm91bmRpbmcgdG8gZ3JpZC5cbiAgICovXG4gICBmdW5jdGlvbiByb3VuZFRvR3JpZCh2KSB7XG4gICAgICAgLy9Sb3VuZGluZyBpbiBUVCBpcyBzdXBwb3NlZCB0byBcInN5bW1ldHJpY2FsIGFyb3VuZCB6ZXJvXCJcbiAgICAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5yb3VuZChNYXRoLmFicyh2KSk7XG4gICB9XG5cbiAgIC8qXG4gICAqIFJvdW5kaW5nIHRvIGRvdWJsZSBncmlkLlxuICAgKi9cbiAgIGZ1bmN0aW9uIHJvdW5kVG9Eb3VibGVHcmlkKHYpIHtcbiAgICAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5yb3VuZChNYXRoLmFicyh2ICogMikpIC8gMjtcbiAgIH1cblxuICAgLypcbiAgICogUm91bmRpbmcgdG8gaGFsZiBncmlkLlxuICAgKi9cbiAgIGZ1bmN0aW9uIHJvdW5kVG9IYWxmR3JpZCh2KSB7XG4gICAgICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIChNYXRoLnJvdW5kKE1hdGguYWJzKHYpICsgMC41KSAtIDAuNSk7XG4gICB9XG5cbiAgIC8qXG4gICAqIFJvdW5kaW5nIHRvIHVwIHRvIGdyaWQuXG4gICAqL1xuICAgZnVuY3Rpb24gcm91bmRVcFRvR3JpZCh2KSB7XG4gICAgICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGguY2VpbChNYXRoLmFicyh2KSk7XG4gICB9XG5cbiAgIC8qXG4gICAqIFJvdW5kaW5nIHRvIGRvd24gdG8gZ3JpZC5cbiAgICovXG4gICBmdW5jdGlvbiByb3VuZERvd25Ub0dyaWQodikge1xuICAgICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmZsb29yKE1hdGguYWJzKHYpKTtcbiAgIH1cblxuICAgLypcbiAgICogU3VwZXIgcm91bmRpbmcuXG4gICAqL1xuICAgdmFyIHJvdW5kU3VwZXIgPSBmdW5jdGlvbiAodikge1xuICAgICAgIHZhciBwZXJpb2QgPSB0aGlzLnNyUGVyaW9kO1xuICAgICAgIHZhciBwaGFzZSA9IHRoaXMuc3JQaGFzZTtcbiAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5zclRocmVzaG9sZDtcbiAgICAgICB2YXIgc2lnbiA9IDE7XG5cbiAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgdiA9IC12O1xuICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgfVxuXG4gICAgICAgdiArPSB0aHJlc2hvbGQgLSBwaGFzZTtcblxuICAgICAgIHYgPSBNYXRoLnRydW5jKHYgLyBwZXJpb2QpICogcGVyaW9kO1xuXG4gICAgICAgdiArPSBwaGFzZTtcblxuICAgICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8veGdyaWRmaXQuc291cmNlZm9yZ2UubmV0L3JvdW5kLmh0bWxcbiAgICAgICBpZiAodiA8IDApIHsgcmV0dXJuIHBoYXNlICogc2lnbjsgfVxuXG4gICAgICAgcmV0dXJuIHYgKiBzaWduO1xuICAgfTtcblxuICAgLypcbiAgICogVW5pdCB2ZWN0b3Igb2YgeC1heGlzLlxuICAgKi9cbiAgIHZhciB4VW5pdFZlY3RvciA9IHtcbiAgICAgICB4OiAxLFxuXG4gICAgICAgeTogMCxcblxuICAgICAgIGF4aXM6ICd4JyxcblxuICAgICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgICAgIHJldHVybiAobzEgPyBwMS54byA6IHAxLngpIC0gKG8yID8gcDIueG8gOiBwMi54KTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgICAgLy9cbiAgICAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgICAgdmFyIGRvMTtcbiAgICAgICAgICAgdmFyIGRvMjtcbiAgICAgICAgICAgdmFyIGRvYTE7XG4gICAgICAgICAgIHZhciBkb2EyO1xuICAgICAgICAgICB2YXIgZG0xO1xuICAgICAgICAgICB2YXIgZG0yO1xuICAgICAgICAgICB2YXIgZHQ7XG5cbiAgICAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgZG8xID0gcC54byAtIHJwMS54bztcbiAgICAgICAgICAgICAgIGRvMiA9IHAueG8gLSBycDIueG87XG4gICAgICAgICAgICAgICBkbTEgPSBycDEueCAtIHJwMS54bztcbiAgICAgICAgICAgICAgIGRtMiA9IHJwMi54IC0gcnAyLnhvO1xuICAgICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpc1xuICAgICAgIG5vcm1hbFNsb3BlOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG5cbiAgICAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuICAgICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCcuXG4gICAgICAgLy9cbiAgICAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgICAgLy9cbiAgICAgICAvLyBwICAgLi4uIHBvaW50IHRvIHNldFxuICAgICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4gICAgICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuICAgICAgIC8vIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4gICAgICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4gICAgICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuICAgICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICBwLnggPSAob3JnID8gcnAueG8gOiBycC54KSArIGQ7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgICAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgICAgICAgIHAueCA9IHJwZHggKyAocC55IC0gcnBkeSkgLyBwdi5ub3JtYWxTbG9wZTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG4gICAgICAgc2xvcGU6IDAsXG5cbiAgICAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuICAgICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICBwLnhUb3VjaGVkID0gdHJ1ZTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG4gICAgICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgcmV0dXJuIHAueFRvdWNoZWQ7XG4gICAgICAgfSxcblxuICAgICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICBwLnhUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgfVxuICAgfTtcblxuICAgLypcbiAgICogVW5pdCB2ZWN0b3Igb2YgeS1heGlzLlxuICAgKi9cbiAgIHZhciB5VW5pdFZlY3RvciA9IHtcbiAgICAgICB4OiAwLFxuXG4gICAgICAgeTogMSxcblxuICAgICAgIGF4aXM6ICd5JyxcblxuICAgICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgICAgIHJldHVybiAobzEgPyBwMS55byA6IHAxLnkpIC0gKG8yID8gcDIueW8gOiBwMi55KTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgICAgLy9cbiAgICAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgICAgdmFyIGRvMTtcbiAgICAgICAgICAgdmFyIGRvMjtcbiAgICAgICAgICAgdmFyIGRvYTE7XG4gICAgICAgICAgIHZhciBkb2EyO1xuICAgICAgICAgICB2YXIgZG0xO1xuICAgICAgICAgICB2YXIgZG0yO1xuICAgICAgICAgICB2YXIgZHQ7XG5cbiAgICAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgZG8xID0gcC55byAtIHJwMS55bztcbiAgICAgICAgICAgICAgIGRvMiA9IHAueW8gLSBycDIueW87XG4gICAgICAgICAgICAgICBkbTEgPSBycDEueSAtIHJwMS55bztcbiAgICAgICAgICAgICAgIGRtMiA9IHJwMi55IC0gcnAyLnlvO1xuICAgICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpcy5cbiAgICAgICBub3JtYWxTbG9wZTogMCxcblxuICAgICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJ1xuICAgICAgIC8vXG4gICAgICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgICAgIC8vXG4gICAgICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgcC55ID0gKG9yZyA/IHJwLnlvIDogcnAueSkgKyBkO1xuICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICAgICBwLnkgPSBycGR5ICsgcHYubm9ybWFsU2xvcGUgKiAocC54IC0gcnBkeCk7XG4gICAgICAgfSxcblxuICAgICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgICAgIHNsb3BlOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG5cbiAgICAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuICAgICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICBwLnlUb3VjaGVkID0gdHJ1ZTtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG4gICAgICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgcmV0dXJuIHAueVRvdWNoZWQ7XG4gICAgICAgfSxcblxuICAgICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgfVxuICAgfTtcblxuICAgT2JqZWN0LmZyZWV6ZSh4VW5pdFZlY3Rvcik7XG4gICBPYmplY3QuZnJlZXplKHlVbml0VmVjdG9yKTtcblxuICAgLypcbiAgICogQ3JlYXRlcyBhIHVuaXQgdmVjdG9yIHRoYXQgaXMgbm90IHgtIG9yIHktYXhpcy5cbiAgICovXG4gICBmdW5jdGlvbiBVbml0VmVjdG9yKHgsIHkpIHtcbiAgICAgICB0aGlzLnggPSB4O1xuICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgICAgIHRoaXMuc2xvcGUgPSB5IC8geDtcbiAgICAgICB0aGlzLm5vcm1hbFNsb3BlID0gLXggLyB5O1xuICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICB9XG5cbiAgIC8qXG4gICAqIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAqIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAqL1xuICAgVW5pdFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIsIG8xLCBvMikge1xuICAgICAgIHJldHVybiAoXG4gICAgICAgICAgIHRoaXMueCAqIHhVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKSArXG4gICAgICAgICAgIHRoaXMueSAqIHlVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKVxuICAgICAgICk7XG4gICB9O1xuXG4gICAvKlxuICAgKiBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiAgICogcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgKiBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgKlxuICAgKiBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAqL1xuICAgVW5pdFZlY3Rvci5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICB2YXIgZG0xO1xuICAgICAgIHZhciBkbTI7XG4gICAgICAgdmFyIGRvMTtcbiAgICAgICB2YXIgZG8yO1xuICAgICAgIHZhciBkb2ExO1xuICAgICAgIHZhciBkb2EyO1xuICAgICAgIHZhciBkdDtcblxuICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgIH07XG5cbiAgIC8qXG4gICAqIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAqIGJ5IHRoZSBkaXN0YW5jZSAnZCdcbiAgICpcbiAgICogU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgKlxuICAgKiBwICAgLi4uICBwb2ludCB0byBzZXRcbiAgICogcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICogZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuICAgKiBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgKiBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICovXG4gICBVbml0VmVjdG9yLnByb3RvdHlwZS5zZXRSZWxhdGl2ZSA9IGZ1bmN0aW9uKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgcHYgPSBwdiB8fCB0aGlzO1xuXG4gICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgIHZhciBwdm5zID0gcHYubm9ybWFsU2xvcGU7XG4gICAgICAgdmFyIGZ2cyA9IHRoaXMuc2xvcGU7XG5cbiAgICAgICB2YXIgcHggPSBwLng7XG4gICAgICAgdmFyIHB5ID0gcC55O1xuXG4gICAgICAgcC54ID0gKGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHkpIC8gKGZ2cyAtIHB2bnMpO1xuICAgICAgIHAueSA9IGZ2cyAqIChwLnggLSBweCkgKyBweTtcbiAgIH07XG5cbiAgIC8qXG4gICAqIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAqL1xuICAgVW5pdFZlY3Rvci5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbihwKSB7XG4gICAgICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgICAgcC55VG91Y2hlZCA9IHRydWU7XG4gICB9O1xuXG4gICAvKlxuICAgKiBSZXR1cm5zIGEgdW5pdCB2ZWN0b3Igd2l0aCB4L3kgY29vcmRpbmF0ZXMuXG4gICAqL1xuICAgZnVuY3Rpb24gZ2V0VW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgICAgICB4IC89IGQ7XG4gICAgICAgeSAvPSBkO1xuXG4gICAgICAgaWYgKHggPT09IDEgJiYgeSA9PT0gMCkgeyByZXR1cm4geFVuaXRWZWN0b3I7IH1cbiAgICAgICBlbHNlIGlmICh4ID09PSAwICYmIHkgPT09IDEpIHsgcmV0dXJuIHlVbml0VmVjdG9yOyB9XG4gICAgICAgZWxzZSB7IHJldHVybiBuZXcgVW5pdFZlY3Rvcih4LCB5KTsgfVxuICAgfVxuXG4gICAvKlxuICAgKiBDcmVhdGVzIGEgcG9pbnQgaW4gdGhlIGhpbnRpbmcgZW5naW5lLlxuICAgKi9cbiAgIGZ1bmN0aW9uIEhQb2ludChcbiAgICAgICB4LFxuICAgICAgIHksXG4gICAgICAgbGFzdFBvaW50T2ZDb250b3VyLFxuICAgICAgIG9uQ3VydmVcbiAgICkge1xuICAgICAgIHRoaXMueCA9IHRoaXMueG8gPSBNYXRoLnJvdW5kKHggKiA2NCkgLyA2NDsgLy8gaGludGVkIHggdmFsdWUgYW5kIG9yaWdpbmFsIHgtdmFsdWVcbiAgICAgICB0aGlzLnkgPSB0aGlzLnlvID0gTWF0aC5yb3VuZCh5ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB5IHZhbHVlIGFuZCBvcmlnaW5hbCB5LXZhbHVlXG5cbiAgICAgICB0aGlzLmxhc3RQb2ludE9mQ29udG91ciA9IGxhc3RQb2ludE9mQ29udG91cjtcbiAgICAgICB0aGlzLm9uQ3VydmUgPSBvbkN1cnZlO1xuICAgICAgIHRoaXMucHJldlBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuICAgICAgIHRoaXMubmV4dFBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuICAgICAgIHRoaXMueFRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICB0aGlzLnlUb3VjaGVkID0gZmFsc2U7XG5cbiAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICB9XG5cbiAgIC8qXG4gICAqIFJldHVybnMgdGhlIG5leHQgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91ci5cbiAgICpcbiAgICogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cbiAgICovXG4gICBIUG9pbnQucHJvdG90eXBlLm5leHRUb3VjaGVkID0gZnVuY3Rpb24odikge1xuICAgICAgIHZhciBwID0gdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXI7XG5cbiAgICAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLm5leHRQb2ludE9uQ29udG91cjsgfVxuXG4gICAgICAgcmV0dXJuIHA7XG4gICB9O1xuXG4gICAvKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyXG4gICAqXG4gICAqIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG4gICAqL1xuICAgSFBvaW50LnByb3RvdHlwZS5wcmV2VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICB2YXIgcCA9IHRoaXMucHJldlBvaW50T25Db250b3VyO1xuXG4gICAgICAgd2hpbGUgKCF2LnRvdWNoZWQocCkgJiYgcCAhPT0gdGhpcykgeyBwID0gcC5wcmV2UG9pbnRPbkNvbnRvdXI7IH1cblxuICAgICAgIHJldHVybiBwO1xuICAgfTtcblxuICAgLypcbiAgICogVGhlIHplcm8gcG9pbnQuXG4gICAqL1xuICAgdmFyIEhQWmVybyA9IE9iamVjdC5mcmVlemUobmV3IEhQb2ludCgwLCAwKSk7XG5cbiAgIC8qXG4gICAqIFRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cbiAgICpcbiAgICogTm90ZTogRnJlZXppbmcgdGhlIGRlZmF1bHRTdGF0ZSBhbmQgdGhlbiBkZXJpdmluZyBmcm9tIGl0XG4gICAqIG1ha2VzIHRoZSBWOCBKYXZhc2NyaXB0IGVuZ2luZSBnb2luZyBhd2t3YXJkLFxuICAgKiBzbyB0aGlzIGlzIGF2b2lkZWQsIGFsYmVpdCB0aGUgZGVmYXVsdFN0YXRlIHNob3VsZG4ndFxuICAgKiBldmVyIGNoYW5nZS5cbiAgICovXG4gICB2YXIgZGVmYXVsdFN0YXRlID0ge1xuICAgICAgIGN2Q3V0SW46IDE3IC8gMTYsICAgIC8vIGNvbnRyb2wgdmFsdWUgY3V0IGluXG4gICAgICAgZGVsdGFCYXNlOiA5LFxuICAgICAgIGRlbHRhU2hpZnQ6IDAuMTI1LFxuICAgICAgIGxvb3A6IDEsICAgICAgICAgICAgIC8vIGxvb3BzIHNvbWUgaW5zdHJ1Y3Rpb25zXG4gICAgICAgbWluRGlzOiAxLCAgICAgICAgICAgLy8gbWluaW11bSBkaXN0YW5jZVxuICAgICAgIGF1dG9GbGlwOiB0cnVlXG4gICB9O1xuXG4gICAvKlxuICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIuXG4gICAqXG4gICAqIGVudiAgLi4uICdmcGdtJyBvciAncHJlcCcgb3IgJ2dseWYnXG4gICAqIHByb2cgLi4uIHRoZSBwcm9ncmFtXG4gICAqL1xuICAgZnVuY3Rpb24gU3RhdGUoZW52LCBwcm9nKSB7XG4gICAgICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgIHRoaXMucHJvZyA9IHByb2c7XG5cbiAgICAgICBzd2l0Y2ggKGVudikge1xuICAgICAgICAgICBjYXNlICdnbHlmJyA6XG4gICAgICAgICAgICAgICB0aGlzLnpwMCA9IHRoaXMuenAxID0gdGhpcy56cDIgPSAxO1xuICAgICAgICAgICAgICAgdGhpcy5ycDAgPSB0aGlzLnJwMSA9IHRoaXMucnAyID0gMDtcbiAgICAgICAgICAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuICAgICAgICAgICBjYXNlICdwcmVwJyA6XG4gICAgICAgICAgICAgICB0aGlzLmZ2ID0gdGhpcy5wdiA9IHRoaXMuZHB2ID0geFVuaXRWZWN0b3I7XG4gICAgICAgICAgICAgICB0aGlzLnJvdW5kID0gcm91bmRUb0dyaWQ7XG4gICAgICAgfVxuICAgfVxuXG4gICAvKlxuICAgKiBFeGVjdXRlcyBhIGdseXBoIHByb2dyYW0uXG4gICAqXG4gICAqIFRoaXMgZG9lcyB0aGUgaGludGluZyBmb3IgZWFjaCBnbHlwaC5cbiAgICpcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBtb3ZlZCBwb2ludHMuXG4gICAqXG4gICAqIGdseXBoOiB0aGUgZ2x5cGggdG8gaGludFxuICAgKiBwcGVtOiB0aGUgc2l6ZSB0aGUgZ2x5cGggaXMgcmVuZGVyZWQgZm9yXG4gICAqL1xuICAgSGludGluZy5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGdseXBoLCBwcGVtKSB7XG4gICAgICAgaWYgKHR5cGVvZiBwcGVtICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IHNpemUgaXMgbm90IGEgbnVtYmVyIScpO1xuICAgICAgIH1cblxuICAgICAgIC8vIFJlY2VpdmVkIGEgZmF0YWwgZXJyb3IsIGRvbid0IGRvIGFueSBoaW50aW5nIGFueW1vcmUuXG4gICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAyKSB7IHJldHVybjsgfVxuXG4gICAgICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgdmFyIHByZXBTdGF0ZSA9IHRoaXMuX3ByZXBTdGF0ZTtcblxuICAgICAgIGlmICghcHJlcFN0YXRlIHx8IHByZXBTdGF0ZS5wcGVtICE9PSBwcGVtKSB7XG4gICAgICAgICAgIHZhciBmcGdtU3RhdGUgPSB0aGlzLl9mcGdtU3RhdGU7XG5cbiAgICAgICAgICAgaWYgKCFmcGdtU3RhdGUpIHtcbiAgICAgICAgICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBmcGdtIHN0YXRlLlxuICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gICAgICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUgPSBkZWZhdWx0U3RhdGU7XG5cbiAgICAgICAgICAgICAgIGZwZ21TdGF0ZSA9XG4gICAgICAgICAgICAgICB0aGlzLl9mcGdtU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgIG5ldyBTdGF0ZSgnZnBnbScsIGZvbnQudGFibGVzLmZwZ20pO1xuXG4gICAgICAgICAgICAgICBmcGdtU3RhdGUuZnVuY3MgPSBbIF07XG4gICAgICAgICAgICAgICBmcGdtU3RhdGUuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgRlBHTS0tLScpO1xuICAgICAgICAgICAgICAgICAgIGZwZ21TdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgZXhlYyhmcGdtU3RhdGUpO1xuICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIEZQR006JyArIGUpO1xuICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBwcmVwIHByb2dyYW0gZm9yIHRoaXMgcHBlbSBzZXR0aW5nLlxuICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gc2V0IGN2dCB2YWx1ZXNcbiAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRvIGJlIHJlbmRlcmVkIGZvbnQgc2l6ZS5cblxuICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUgPSBmcGdtU3RhdGU7XG4gICAgICAgICAgIHByZXBTdGF0ZSA9XG4gICAgICAgICAgIHRoaXMuX3ByZXBTdGF0ZSA9XG4gICAgICAgICAgICAgICBuZXcgU3RhdGUoJ3ByZXAnLCBmb250LnRhYmxlcy5wcmVwKTtcblxuICAgICAgICAgICBwcmVwU3RhdGUucHBlbSA9IHBwZW07XG5cbiAgICAgICAgICAgLy8gQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGN2dCB0YWJsZVxuICAgICAgICAgICAvLyBhbmQgc2NhbGVzIGl0IHRvIHRoZSBjdXJyZW50IHBwZW0gc2V0dGluZy5cbiAgICAgICAgICAgdmFyIG9DdnQgPSBmb250LnRhYmxlcy5jdnQ7XG4gICAgICAgICAgIGlmIChvQ3Z0KSB7XG4gICAgICAgICAgICAgICB2YXIgY3Z0ID0gcHJlcFN0YXRlLmN2dCA9IG5ldyBBcnJheShvQ3Z0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBwcGVtIC8gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvQ3Z0Lmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgY3Z0W2NdID0gb0N2dFtjXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcHJlcFN0YXRlLmN2dCA9IFtdO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIFBSRVAtLS0nKTtcbiAgICAgICAgICAgICAgIHByZXBTdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgZXhlYyhwcmVwU3RhdGUpO1xuICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBQUkVQOicgKyBlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAyO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAxKSB7IHJldHVybjsgfVxuXG4gICAgICAgdHJ5IHtcbiAgICAgICAgICAgcmV0dXJuIGV4ZWNHbHlwaChnbHlwaCwgcHJlcFN0YXRlKTtcbiAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMSkge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3I6JyArIGUpO1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IGZ1cnRoZXIgaGludGluZyBlcnJvcnMgYXJlIHNpbGVuY2VkJyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDE7XG4gICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgfVxuICAgfTtcblxuICAgLypcbiAgICogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBnbHlwaC5cbiAgICovXG4gICBleGVjR2x5cGggPSBmdW5jdGlvbihnbHlwaCwgcHJlcFN0YXRlKSB7XG4gICAgICAgLy8gb3JpZ2luYWwgcG9pbnQgcG9zaXRpb25zXG4gICAgICAgdmFyIHhTY2FsZSA9IHByZXBTdGF0ZS5wcGVtIC8gcHJlcFN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbiAgICAgICB2YXIgeVNjYWxlID0geFNjYWxlO1xuICAgICAgIHZhciBjb21wb25lbnRzID0gZ2x5cGguY29tcG9uZW50cztcbiAgICAgICB2YXIgY29udG91cnM7XG4gICAgICAgdmFyIGdab25lO1xuICAgICAgIHZhciBzdGF0ZTtcblxuICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IHByZXBTdGF0ZTtcbiAgICAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgR0xZUEgtLS0nKTtcbiAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBleGVjQ29tcG9uZW50KGdseXBoLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICAgICBnWm9uZSA9IHN0YXRlLmdab25lO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHZhciBmb250ID0gcHJlcFN0YXRlLmZvbnQ7XG4gICAgICAgICAgIGdab25lID0gW107XG4gICAgICAgICAgIGNvbnRvdXJzID0gW107XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgICAgdmFyIGNnID0gZm9udC5nbHlwaHMuZ2V0KGMuZ2x5cGhJbmRleCk7XG5cbiAgICAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgY2cuaW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QICcgKyBpICsgJy0tLScpO1xuICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgZXhlY0NvbXBvbmVudChjZywgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcbiAgICAgICAgICAgICAgIC8vIGFwcGVuZHMgdGhlIGNvbXB1dGVkIHBvaW50cyB0byB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAgICAvLyBwb3N0IHByb2Nlc3NlcyB0aGUgY29tcG9uZW50IHBvaW50c1xuICAgICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5yb3VuZChjLmR4ICogeFNjYWxlKTtcbiAgICAgICAgICAgICAgIHZhciBkeSA9IE1hdGgucm91bmQoYy5keSAqIHlTY2FsZSk7XG4gICAgICAgICAgICAgICB2YXIgZ3ogPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgICAgIHZhciBjYyA9IHN0YXRlLmNvbnRvdXJzO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgcGkgPSAwOyBwaSA8IGd6Lmxlbmd0aDsgcGkrKykge1xuICAgICAgICAgICAgICAgICAgIHZhciBwID0gZ3pbcGldO1xuICAgICAgICAgICAgICAgICAgIHAueFRvdWNoZWQgPSBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgcC54byA9IHAueCA9IHAueCArIGR4O1xuICAgICAgICAgICAgICAgICAgIHAueW8gPSBwLnkgPSBwLnkgKyBkeTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgdmFyIGdMZW4gPSBnWm9uZS5sZW5ndGg7XG4gICAgICAgICAgICAgICBnWm9uZS5wdXNoLmFwcGx5KGdab25lLCBneik7XG4gICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgY29udG91cnMucHVzaChjY1tqXSArIGdMZW4pO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKGdseXBoLmluc3RydWN0aW9ucyAmJiAhc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHtcbiAgICAgICAgICAgICAgIC8vIHRoZSBjb21wb3NpdGUgaGFzIGluc3RydWN0aW9ucyBvbiBpdHMgb3duXG4gICAgICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgICAgICAgIHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gZ1pvbmU7XG5cbiAgICAgICAgICAgICAgIHN0YXRlLmNvbnRvdXJzID0gY29udG91cnM7XG5cbiAgICAgICAgICAgICAgIC8vIG5vdGU6IEhQWmVybyBjYW5ub3QgYmUgdXNlZCBoZXJlLCBzaW5jZVxuICAgICAgICAgICAgICAgLy8gICAgICAgdGhlIHBvaW50IG1pZ2h0IGJlIG1vZGlmaWVkXG4gICAgICAgICAgICAgICBnWm9uZS5wdXNoKFxuICAgICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgICAgICAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG4gICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVBPU0lURS0tLScpO1xuICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgIGdab25lLmxlbmd0aCAtPSAyO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGdab25lO1xuICAgfTtcblxuICAgLypcbiAgICogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBjb21wb25lbnQgb2YgYSBtdWx0aS1jb21wb25lbnQgZ2x5cGhcbiAgICogb3Igb2YgdGhlIGdseXBoIGl0c2VsZiBmb3IgYSBub24tY29tcG9uZW50IGdseXBoLlxuICAgKi9cbiAgIGV4ZWNDb21wb25lbnQgPSBmdW5jdGlvbihnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKVxuICAge1xuICAgICAgIHZhciBwb2ludHMgPSBnbHlwaC5wb2ludHMgfHwgW107XG4gICAgICAgdmFyIHBMZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgIHZhciBnWm9uZSA9IHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gW107XG4gICAgICAgdmFyIGNvbnRvdXJzID0gc3RhdGUuY29udG91cnMgPSBbXTtcblxuICAgICAgIC8vIFNjYWxlcyB0aGUgb3JpZ2luYWwgcG9pbnRzIGFuZFxuICAgICAgIC8vIG1ha2VzIGNvcGllcyBmb3IgdGhlIGhpbnRlZCBwb2ludHMuXG4gICAgICAgdmFyIGNwOyAvLyBjdXJyZW50IHBvaW50XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgICAgY3AgPSBwb2ludHNbaV07XG5cbiAgICAgICAgICAgZ1pvbmVbaV0gPSBuZXcgSFBvaW50KFxuICAgICAgICAgICAgICAgY3AueCAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgIGNwLnkgKiB5U2NhbGUsXG4gICAgICAgICAgICAgICBjcC5sYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgICAgICAgICAgICBjcC5vbkN1cnZlXG4gICAgICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgICAgLy8gQ2hhaW4gbGlua3MgdGhlIGNvbnRvdXJzLlxuICAgICAgIHZhciBzcDsgLy8gc3RhcnQgcG9pbnRcbiAgICAgICB2YXIgbnA7IC8vIG5leHQgcG9pbnRcblxuICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBMZW47IGkkMSsrKSB7XG4gICAgICAgICAgIGNwID0gZ1pvbmVbaSQxXTtcblxuICAgICAgICAgICBpZiAoIXNwKSB7XG4gICAgICAgICAgICAgICBzcCA9IGNwO1xuICAgICAgICAgICAgICAgY29udG91cnMucHVzaChpJDEpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKGNwLmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgICAgY3AubmV4dFBvaW50T25Db250b3VyID0gc3A7XG4gICAgICAgICAgICAgICBzcC5wcmV2UG9pbnRPbkNvbnRvdXIgPSBjcDtcbiAgICAgICAgICAgICAgIHNwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgbnAgPSBnWm9uZVtpJDEgKyAxXTtcbiAgICAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IG5wO1xuICAgICAgICAgICAgICAgbnAucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICBpZiAoc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICBjb25zb2xlLmxvZygnUFJPQ0VTU0lORyBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcExlbjsgaSQyKyspIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMiwgZ1pvbmVbaSQyXS54LCBnWm9uZVtpJDJdLnkpO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgZ1pvbmUucHVzaChcbiAgICAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcbiAgICAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG4gICAgICAgKTtcblxuICAgICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgICAgLy8gUmVtb3ZlcyB0aGUgZXh0cmEgcG9pbnRzLlxuICAgICAgIGdab25lLmxlbmd0aCAtPSAyO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgY29uc29sZS5sb2coJ0ZJTklTSEVEIEdMWVBIJywgc3RhdGUuc3RhY2spO1xuICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBwTGVuOyBpJDMrKykge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coaSQzLCBnWm9uZVtpJDNdLngsIGdab25lW2kkM10ueSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICB9O1xuXG4gICAvKlxuICAgKiBFeGVjdXRlcyB0aGUgcHJvZ3JhbSBsb2FkZWQgaW4gc3RhdGUuXG4gICAqL1xuICAgZXhlYyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgICAgaWYgKCFwcm9nKSB7IHJldHVybjsgfVxuXG4gICAgICAgdmFyIHBMZW4gPSBwcm9nLmxlbmd0aDtcbiAgICAgICB2YXIgaW5zO1xuXG4gICAgICAgZm9yIChzdGF0ZS5pcCA9IDA7IHN0YXRlLmlwIDwgcExlbjsgc3RhdGUuaXArKykge1xuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBzdGF0ZS5zdGVwKys7IH1cbiAgICAgICAgICAgaW5zID0gaW5zdHJ1Y3Rpb25UYWJsZVtwcm9nW3N0YXRlLmlwXV07XG5cbiAgICAgICAgICAgaWYgKCFpbnMpIHtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAndW5rbm93biBpbnN0cnVjdGlvbjogMHgnICtcbiAgICAgICAgICAgICAgICAgICBOdW1iZXIocHJvZ1tzdGF0ZS5pcF0pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlucyhzdGF0ZSk7XG5cbiAgICAgICAgICAgLy8gdmVyeSBleHRlbnNpdmUgZGVidWdnaW5nIGZvciBlYWNoIHN0ZXBcbiAgICAgICAgICAgLypcbiAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgIHZhciBkYTtcbiAgICAgICAgICAgICAgIGlmIChzdGF0ZS5nWm9uZSkge1xuICAgICAgICAgICAgICAgICAgIGRhID0gW107XG4gICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5nWm9uZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0daJywgZGEpO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBpZiAoc3RhdGUudFpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudFpvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgZGEucHVzaChpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnggKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS55ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnhUb3VjaGVkID8gJ3gnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFonLCBkYSk7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFjay5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICcuLi4nLCBzdGF0ZS5zdGFjay5zbGljZShzdGF0ZS5zdGFjay5sZW5ndGggLSAxMClcbiAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5zdGFjay5sZW5ndGgsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICAqL1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qXG4gICAqIEluaXRpYWxpemVzIHRoZSB0d2lsaWdodCB6b25lLlxuICAgKlxuICAgKiBUaGlzIGlzIG9ubHkgZG9uZSBpZiBhIFNaUHggaW5zdHJ1Y3Rpb25cbiAgICogcmVmZXJzIHRvIHRoZSB0d2lsaWdodCB6b25lLlxuICAgKi9cbiAgIGZ1bmN0aW9uIGluaXRUWm9uZShzdGF0ZSlcbiAgIHtcbiAgICAgICB2YXIgdFpvbmUgPSBzdGF0ZS50Wm9uZSA9IG5ldyBBcnJheShzdGF0ZS5nWm9uZS5sZW5ndGgpO1xuXG4gICAgICAgLy8gbm8gaWRlYSBpZiB0aGlzIGlzIGFjdHVhbGx5IGNvcnJlY3QuLi5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRab25lLmxlbmd0aDsgaSsrKVxuICAgICAgIHtcbiAgICAgICAgICAgdFpvbmVbaV0gPSBuZXcgSFBvaW50KDAsIDApO1xuICAgICAgIH1cbiAgIH1cblxuICAgLypcbiAgICogU2tpcHMgdGhlIGluc3RydWN0aW9uIHBvaW50ZXIgYWhlYWQgb3ZlciBhbiBJRi9FTFNFIGJsb2NrLlxuICAgKiBoYW5kbGVFbHNlIC4uIGlmIHRydWUgYnJlYWtzIG9uIG1hdGNoaW5nIEVMU0VcbiAgICovXG4gICBmdW5jdGlvbiBza2lwKHN0YXRlLCBoYW5kbGVFbHNlKVxuICAge1xuICAgICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICAgICB2YXIgbmVzdGluZyA9IDE7XG4gICAgICAgdmFyIGlucztcblxuICAgICAgIGRvIHtcbiAgICAgICAgICAgaW5zID0gcHJvZ1srK2lwXTtcbiAgICAgICAgICAgaWYgKGlucyA9PT0gMHg1OCkgLy8gSUZcbiAgICAgICAgICAgICAgIHsgbmVzdGluZysrOyB9XG4gICAgICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg1OSkgLy8gRUlGXG4gICAgICAgICAgICAgICB7IG5lc3RpbmctLTsgfVxuICAgICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDApIC8vIE5QVVNIQlxuICAgICAgICAgICAgICAgeyBpcCArPSBwcm9nW2lwICsgMV0gKyAxOyB9XG4gICAgICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MSkgLy8gTlBVU0hXXG4gICAgICAgICAgICAgICB7IGlwICs9IDIgKiBwcm9nW2lwICsgMV0gKyAxOyB9XG4gICAgICAgICAgIGVsc2UgaWYgKGlucyA+PSAweEIwICYmIGlucyA8PSAweEI3KSAvLyBQVVNIQlxuICAgICAgICAgICAgICAgeyBpcCArPSBpbnMgLSAweEIwICsgMTsgfVxuICAgICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCOCAmJiBpbnMgPD0gMHhCRikgLy8gUFVTSFdcbiAgICAgICAgICAgICAgIHsgaXAgKz0gKGlucyAtIDB4QjggKyAxKSAqIDI7IH1cbiAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlRWxzZSAmJiBuZXN0aW5nID09PSAxICYmIGlucyA9PT0gMHgxQikgLy8gRUxTRVxuICAgICAgICAgICAgICAgeyBicmVhazsgfVxuICAgICAgIH0gd2hpbGUgKG5lc3RpbmcgPiAwKTtcblxuICAgICAgIHN0YXRlLmlwID0gaXA7XG4gICB9XG5cbiAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcbiAgICogICAgICAgICAgQW5kIHRoZW4gYSBsb3Qgb2YgaW5zdHJ1Y3Rpb25zLi4uICAgICAgICAgICAgICAgICpcbiAgICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgLy8gU1ZUQ0FbYV0gU2V0IGZyZWVkb20gYW5kIHByb2plY3Rpb24gVmVjdG9ycyBUbyBDb29yZGluYXRlIEF4aXNcbiAgIC8vIDB4MDAtMHgwMVxuICAgZnVuY3Rpb24gU1ZUQ0Eodiwgc3RhdGUpIHtcbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1ZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgICAgIHN0YXRlLmZ2ID0gc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xuICAgfVxuXG4gICAvLyBTUFZUQ0FbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuICAgLy8gMHgwMi0weDAzXG4gICBmdW5jdGlvbiBTUFZUQ0Eodiwgc3RhdGUpIHtcbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IHY7XG4gICB9XG5cbiAgIC8vIFNGVlRDQVthXSBTZXQgRnJlZWRvbSBWZWN0b3IgdG8gQ29vcmRpbmF0ZSBBeGlzXG4gICAvLyAweDA0LTB4MDVcbiAgIGZ1bmN0aW9uIFNGVlRDQSh2LCBzdGF0ZSkge1xuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgICAgIHN0YXRlLmZ2ID0gdjtcbiAgIH1cblxuICAgLy8gU1BWVExbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIFRvIExpbmVcbiAgIC8vIDB4MDYtMHgwN1xuICAgZnVuY3Rpb24gU1BWVEwoYSwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICAgICB2YXIgZHg7XG4gICAgICAgdmFyIGR5O1xuXG4gICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICAgICB9XG5cbiAgICAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbiAgIH1cblxuICAgLy8gU0ZWVExbYV0gU2V0IEZyZWVkb20gVmVjdG9yIFRvIExpbmVcbiAgIC8vIDB4MDgtMHgwOVxuICAgZnVuY3Rpb24gU0ZWVEwoYSwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTRlZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICAgICB2YXIgZHg7XG4gICAgICAgdmFyIGR5O1xuXG4gICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICAgICB9XG5cbiAgICAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbiAgIH1cblxuICAgLy8gU1BWRlNbXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgRnJvbSBTdGFja1xuICAgLy8gMHgwQVxuICAgZnVuY3Rpb24gU1BWRlMoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciB4ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWRlNbXScsIHksIHgpOyB9XG5cbiAgICAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG4gICB9XG5cbiAgIC8vIFNGVkZTW10gU2V0IEZyZWVkb20gVmVjdG9yIEZyb20gU3RhY2tcbiAgIC8vIDB4MEJcbiAgIGZ1bmN0aW9uIFNGVkZTKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG4gICAgICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xuICAgfVxuXG4gICAvLyBHUFZbXSBHZXQgUHJvamVjdGlvbiBWZWN0b3JcbiAgIC8vIDB4MENcbiAgIGZ1bmN0aW9uIEdQVihzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dQVltdJyk7IH1cblxuICAgICAgIHN0YWNrLnB1c2gocHYueCAqIDB4NDAwMCk7XG4gICAgICAgc3RhY2sucHVzaChwdi55ICogMHg0MDAwKTtcbiAgIH1cblxuICAgLy8gR0ZWW10gR2V0IEZyZWVkb20gVmVjdG9yXG4gICAvLyAweDBDXG4gICBmdW5jdGlvbiBHRlYoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRlZbXScpOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKGZ2LnggKiAweDQwMDApO1xuICAgICAgIHN0YWNrLnB1c2goZnYueSAqIDB4NDAwMCk7XG4gICB9XG5cbiAgIC8vIFNGVlRQVltdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBQcm9qZWN0aW9uIFZlY3RvclxuICAgLy8gMHgwRVxuICAgZnVuY3Rpb24gU0ZWVFBWKHN0YXRlKSB7XG4gICAgICAgc3RhdGUuZnYgPSBzdGF0ZS5wdjtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUUFZbXScpOyB9XG4gICB9XG5cbiAgIC8vIElTRUNUW10gbW92ZXMgcG9pbnQgcCB0byB0aGUgSW50ZXJTRUNUaW9uIG9mIHR3byBsaW5lc1xuICAgLy8gMHgwRlxuICAgZnVuY3Rpb24gSVNFQ1Qoc3RhdGUpXG4gICB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHBhMGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgcGExaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwYjBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHBiMWkgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgejAgPSBzdGF0ZS56MDtcbiAgICAgICB2YXIgejEgPSBzdGF0ZS56MTtcbiAgICAgICB2YXIgcGEwID0gejBbcGEwaV07XG4gICAgICAgdmFyIHBhMSA9IHowW3BhMWldO1xuICAgICAgIHZhciBwYjAgPSB6MVtwYjBpXTtcbiAgICAgICB2YXIgcGIxID0gejFbcGIxaV07XG4gICAgICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnSVNFQ1RbXSwgJywgcGEwaSwgcGExaSwgcGIwaSwgcGIxaSwgcGkpOyB9XG5cbiAgICAgICAvLyBtYXRoIGZyb21cbiAgICAgICAvLyBlbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M2xpbmVfaW50ZXJzZWN0aW9uI0dpdmVuX3R3b19wb2ludHNfb25fZWFjaF9saW5lXG5cbiAgICAgICB2YXIgeDEgPSBwYTAueDtcbiAgICAgICB2YXIgeTEgPSBwYTAueTtcbiAgICAgICB2YXIgeDIgPSBwYTEueDtcbiAgICAgICB2YXIgeTIgPSBwYTEueTtcbiAgICAgICB2YXIgeDMgPSBwYjAueDtcbiAgICAgICB2YXIgeTMgPSBwYjAueTtcbiAgICAgICB2YXIgeDQgPSBwYjEueDtcbiAgICAgICB2YXIgeTQgPSBwYjEueTtcblxuICAgICAgIHZhciBkaXYgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG4gICAgICAgdmFyIGYxID0geDEgKiB5MiAtIHkxICogeDI7XG4gICAgICAgdmFyIGYyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cbiAgICAgICBwLnggPSAoZjEgKiAoeDMgLSB4NCkgLSBmMiAqICh4MSAtIHgyKSkgLyBkaXY7XG4gICAgICAgcC55ID0gKGYxICogKHkzIC0geTQpIC0gZjIgKiAoeTEgLSB5MikpIC8gZGl2O1xuICAgfVxuXG4gICAvLyBTUlAwW10gU2V0IFJlZmVyZW5jZSBQb2ludCAwXG4gICAvLyAweDEwXG4gICBmdW5jdGlvbiBTUlAwKHN0YXRlKSB7XG4gICAgICAgc3RhdGUucnAwID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMFtdJywgc3RhdGUucnAwKTsgfVxuICAgfVxuXG4gICAvLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAxXG4gICAvLyAweDExXG4gICBmdW5jdGlvbiBTUlAxKHN0YXRlKSB7XG4gICAgICAgc3RhdGUucnAxID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMVtdJywgc3RhdGUucnAxKTsgfVxuICAgfVxuXG4gICAvLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAyXG4gICAvLyAweDEyXG4gICBmdW5jdGlvbiBTUlAyKHN0YXRlKSB7XG4gICAgICAgc3RhdGUucnAyID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMltdJywgc3RhdGUucnAyKTsgfVxuICAgfVxuXG4gICAvLyBTWlAwW10gU2V0IFpvbmUgUG9pbnRlciAwXG4gICAvLyAweDEzXG4gICBmdW5jdGlvbiBTWlAwKHN0YXRlKSB7XG4gICAgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAwW10nLCBuKTsgfVxuXG4gICAgICAgc3RhdGUuenAwID0gbjtcblxuICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgICAgfVxuICAgfVxuXG4gICAvLyBTWlAxW10gU2V0IFpvbmUgUG9pbnRlciAxXG4gICAvLyAweDE0XG4gICBmdW5jdGlvbiBTWlAxKHN0YXRlKSB7XG4gICAgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAxW10nLCBuKTsgfVxuXG4gICAgICAgc3RhdGUuenAxID0gbjtcblxuICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgICAgfVxuICAgfVxuXG4gICAvLyBTWlAyW10gU2V0IFpvbmUgUG9pbnRlciAyXG4gICAvLyAweDE1XG4gICBmdW5jdGlvbiBTWlAyKHN0YXRlKSB7XG4gICAgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAyW10nLCBuKTsgfVxuXG4gICAgICAgc3RhdGUuenAyID0gbjtcblxuICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgICAgfVxuICAgfVxuXG4gICAvLyBTWlBTW10gU2V0IFpvbmUgUG9pbnRlclNcbiAgIC8vIDB4MTZcbiAgIGZ1bmN0aW9uIFNaUFMoc3RhdGUpIHtcbiAgICAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUFNbXScsIG4pOyB9XG5cbiAgICAgICBzdGF0ZS56cDAgPSBzdGF0ZS56cDEgPSBzdGF0ZS56cDIgPSBuO1xuXG4gICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgICAgIH1cbiAgIH1cblxuICAgLy8gU0xPT1BbXSBTZXQgTE9PUCB2YXJpYWJsZVxuICAgLy8gMHgxN1xuICAgZnVuY3Rpb24gU0xPT1Aoc3RhdGUpIHtcbiAgICAgICBzdGF0ZS5sb29wID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0xPT1BbXScsIHN0YXRlLmxvb3ApOyB9XG4gICB9XG5cbiAgIC8vIFJUR1tdIFJvdW5kIFRvIEdyaWRcbiAgIC8vIDB4MThcbiAgIGZ1bmN0aW9uIFJURyhzdGF0ZSkge1xuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEdbXScpOyB9XG5cbiAgICAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9HcmlkO1xuICAgfVxuXG4gICAvLyBSVEhHW10gUm91bmQgVG8gSGFsZiBHcmlkXG4gICAvLyAweDE5XG4gICBmdW5jdGlvbiBSVEhHKHN0YXRlKSB7XG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUSEdbXScpOyB9XG5cbiAgICAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9IYWxmR3JpZDtcbiAgIH1cblxuICAgLy8gU01EW10gU2V0IE1pbmltdW0gRGlzdGFuY2VcbiAgIC8vIDB4MUFcbiAgIGZ1bmN0aW9uIFNNRChzdGF0ZSkge1xuICAgICAgIHZhciBkID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU01EW10nLCBkKTsgfVxuXG4gICAgICAgc3RhdGUubWluRGlzID0gZCAvIDB4NDA7XG4gICB9XG5cbiAgIC8vIEVMU0VbXSBFTFNFIGNsYXVzZVxuICAgLy8gMHgxQlxuICAgZnVuY3Rpb24gRUxTRShzdGF0ZSkge1xuICAgICAgIC8vIFRoaXMgaW5zdHJ1Y3Rpb24gaGFzIGJlZW4gcmVhY2hlZCBieSBleGVjdXRpbmcgYSB0aGVuIGJyYW5jaFxuICAgICAgIC8vIHNvIGl0IGp1c3Qgc2tpcHMgYWhlYWQgdW50aWwgbWF0Y2hpbmcgRUlGLlxuICAgICAgIC8vXG4gICAgICAgLy8gSW4gY2FzZSB0aGUgSUYgd2FzIG5lZ2F0aXZlIHRoZSBJRltdIGluc3RydWN0aW9uIGFscmVhZHlcbiAgICAgICAvLyBza2lwcGVkIGZvcndhcmQgb3ZlciB0aGUgRUxTRVtdXG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUxTRVtdJyk7IH1cblxuICAgICAgIHNraXAoc3RhdGUsIGZhbHNlKTtcbiAgIH1cblxuICAgLy8gSk1QUltdIEp1TVAgUmVsYXRpdmVcbiAgIC8vIDB4MUNcbiAgIGZ1bmN0aW9uIEpNUFIoc3RhdGUpIHtcbiAgICAgICB2YXIgbyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0pNUFJbXScsIG8pOyB9XG5cbiAgICAgICAvLyBBIGp1bXAgYnkgMSB3b3VsZCBkbyBub3RoaW5nLlxuICAgICAgIHN0YXRlLmlwICs9IG8gLSAxO1xuICAgfVxuXG4gICAvLyBTQ1ZUQ0lbXSBTZXQgQ29udHJvbCBWYWx1ZSBUYWJsZSBDdXQtSW5cbiAgIC8vIDB4MURcbiAgIGZ1bmN0aW9uIFNDVlRDSShzdGF0ZSkge1xuICAgICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NWVENJW10nLCBuKTsgfVxuXG4gICAgICAgc3RhdGUuY3ZDdXRJbiA9IG4gLyAweDQwO1xuICAgfVxuXG4gICAvLyBEVVBbXSBEVVBsaWNhdGUgdG9wIHN0YWNrIGVsZW1lbnRcbiAgIC8vIDB4MjBcbiAgIGZ1bmN0aW9uIERVUChzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RVUFtdJyk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pO1xuICAgfVxuXG4gICAvLyBQT1BbXSBQT1AgdG9wIHN0YWNrIGVsZW1lbnRcbiAgIC8vIDB4MjFcbiAgIGZ1bmN0aW9uIFBPUChzdGF0ZSkge1xuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQT1BbXScpOyB9XG5cbiAgICAgICBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgIH1cblxuICAgLy8gQ0xFQVJbXSBDTEVBUiB0aGUgc3RhY2tcbiAgIC8vIDB4MjJcbiAgIGZ1bmN0aW9uIENMRUFSKHN0YXRlKSB7XG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NMRUFSW10nKTsgfVxuXG4gICAgICAgc3RhdGUuc3RhY2subGVuZ3RoID0gMDtcbiAgIH1cblxuICAgLy8gU1dBUFtdIFNXQVAgdGhlIHRvcCB0d28gZWxlbWVudHMgb24gdGhlIHN0YWNrXG4gICAvLyAweDIzXG4gICBmdW5jdGlvbiBTV0FQKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1dBUFtdJyk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goYSk7XG4gICAgICAgc3RhY2sucHVzaChiKTtcbiAgIH1cblxuICAgLy8gREVQVEhbXSBERVBUSCBvZiB0aGUgc3RhY2tcbiAgIC8vIDB4MjRcbiAgIGZ1bmN0aW9uIERFUFRIKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVQVEhbXScpOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKHN0YWNrLmxlbmd0aCk7XG4gICB9XG5cbiAgIC8vIExPT1BDQUxMW10gTE9PUENBTEwgZnVuY3Rpb25cbiAgIC8vIDB4MkFcbiAgIGZ1bmN0aW9uIExPT1BDQUxMKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMT09QQ0FMTFtdJywgZm4sIGMpOyB9XG5cbiAgICAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG4gICAgICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuICAgICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cbiAgICAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICsrc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgIGkgKyAxIDwgYyA/ICduZXh0IGxvb3BjYWxsJyA6ICdkb25lIGxvb3BjYWxsJyxcbiAgICAgICAgICAgICAgIGlcbiAgICAgICAgICAgKTsgfVxuICAgICAgIH1cblxuICAgICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG4gICB9XG5cbiAgIC8vIENBTExbXSBDQUxMIGZ1bmN0aW9uXG4gICAvLyAweDJCXG4gICBmdW5jdGlvbiBDQUxMKHN0YXRlKSB7XG4gICAgICAgdmFyIGZuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0FMTFtdJywgZm4pOyB9XG5cbiAgICAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG4gICAgICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuICAgICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cbiAgICAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cbiAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygrK3N0YXRlLnN0ZXAsICdyZXR1cm5pbmcgZnJvbScsIGZuKTsgfVxuICAgfVxuXG4gICAvLyBDSU5ERVhbXSBDb3B5IHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgIC8vIDB4MjVcbiAgIGZ1bmN0aW9uIENJTkRFWChzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0lOREVYW10nLCBrKTsgfVxuXG4gICAgICAgLy8gSW4gY2FzZSBvZiBrID09IDEsIGl0IGNvcGllcyB0aGUgbGFzdCBlbGVtZW50IGFmdGVyIHBvcHBpbmdcbiAgICAgICAvLyB0aHVzIHN0YWNrLmxlbmd0aCAtIGsuXG4gICAgICAgc3RhY2sucHVzaChzdGFja1tzdGFjay5sZW5ndGggLSBrXSk7XG4gICB9XG5cbiAgIC8vIE1JTkRFWFtdIE1vdmUgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgLy8gMHgyNlxuICAgZnVuY3Rpb24gTUlOREVYKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIGsgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5ERVhbXScsIGspOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBrLCAxKVswXSk7XG4gICB9XG5cbiAgIC8vIEZERUZbXSBGdW5jdGlvbiBERUZpbml0aW9uXG4gICAvLyAweDJDXG4gICBmdW5jdGlvbiBGREVGKHN0YXRlKSB7XG4gICAgICAgaWYgKHN0YXRlLmVudiAhPT0gJ2ZwZ20nKSB7IHRocm93IG5ldyBFcnJvcignRkRFRiBub3QgYWxsb3dlZCBoZXJlJyk7IH1cbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgICAgdmFyIGlwID0gc3RhdGUuaXA7XG5cbiAgICAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgaXBCZWdpbiA9IGlwO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZERUZbXScsIGZuKTsgfVxuXG4gICAgICAgd2hpbGUgKHByb2dbKytpcF0gIT09IDB4MkQpeyB9XG5cbiAgICAgICBzdGF0ZS5pcCA9IGlwO1xuICAgICAgIHN0YXRlLmZ1bmNzW2ZuXSA9IHByb2cuc2xpY2UoaXBCZWdpbiArIDEsIGlwKTtcbiAgIH1cblxuICAgLy8gTURBUFthXSBNb3ZlIERpcmVjdCBBYnNvbHV0ZSBQb2ludFxuICAgLy8gMHgyRS0weDJGXG4gICBmdW5jdGlvbiBNREFQKHJvdW5kLCBzdGF0ZSkge1xuICAgICAgIHZhciBwaSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EQVBbJyArIHJvdW5kICsgJ10nLCBwaSk7IH1cblxuICAgICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgICAgIGlmIChyb3VuZCkgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIEhQWmVybywgZCwgcHYpO1xuICAgICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG4gICB9XG5cbiAgIC8vIElVUFthXSBJbnRlcnBvbGF0ZSBVbnRvdWNoZWQgUG9pbnRzIHRocm91Z2ggdGhlIG91dGxpbmVcbiAgIC8vIDB4MzBcbiAgIGZ1bmN0aW9uIElVUCh2LCBzdGF0ZSkge1xuICAgICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuICAgICAgIHZhciBwTGVuID0gejIubGVuZ3RoIC0gMjtcbiAgICAgICB2YXIgY3A7XG4gICAgICAgdmFyIHBwO1xuICAgICAgIHZhciBucDtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJVVBbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgICAgIGNwID0gejJbaV07IC8vIGN1cnJlbnQgcG9pbnRcblxuICAgICAgICAgICAvLyBpZiB0aGlzIHBvaW50IGhhcyBiZWVuIHRvdWNoZWQgZ28gb25cbiAgICAgICAgICAgaWYgKHYudG91Y2hlZChjcCkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgICBwcCA9IGNwLnByZXZUb3VjaGVkKHYpO1xuXG4gICAgICAgICAgIC8vIG5vIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWQ/XG4gICAgICAgICAgIGlmIChwcCA9PT0gY3ApIHsgY29udGludWU7IH1cblxuICAgICAgICAgICBucCA9IGNwLm5leHRUb3VjaGVkKHYpO1xuXG4gICAgICAgICAgIGlmIChwcCA9PT0gbnApIHtcbiAgICAgICAgICAgICAgIC8vIG9ubHkgb25lIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICAgICAgIC8vIHNvIHNpbXBseSBtb3ZlcyB0aGUgcG9pbnQgbGlrZSB0aGF0XG5cbiAgICAgICAgICAgICAgIHYuc2V0UmVsYXRpdmUoY3AsIGNwLCB2LmRpc3RhbmNlKHBwLCBwcCwgZmFsc2UsIHRydWUpLCB2LCB0cnVlKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHYuaW50ZXJwb2xhdGUoY3AsIHBwLCBucCwgdik7XG4gICAgICAgfVxuICAgfVxuXG4gICAvLyBTSFBbXSBTSGlmdCBQb2ludCB1c2luZyByZWZlcmVuY2UgcG9pbnRcbiAgIC8vIDB4MzItMHgzM1xuICAgZnVuY3Rpb24gU0hQKGEsIHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgICAgIHdoaWxlIChsb29wLS0pXG4gICAgICAge1xuICAgICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6XG4gICAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAnU0hQWycgKyAoYSA/ICdycDEnIDogJ3JwMicpICsgJ10nLCBwaVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIHN0YXRlLmxvb3AgPSAxO1xuICAgfVxuXG4gICAvLyBTSENbXSBTSGlmdCBDb250b3VyIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuICAgLy8gMHgzNi0weDM3XG4gICBmdW5jdGlvbiBTSEMoYSwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgICAgdmFyIGNpID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHNwID0gc3RhdGUuejJbc3RhdGUuY29udG91cnNbY2ldXTtcbiAgICAgICB2YXIgcCA9IHNwO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIQ1snICsgYSArICddJywgY2kpOyB9XG5cbiAgICAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgZG8ge1xuICAgICAgICAgICBpZiAocCAhPT0gcnApIHsgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpOyB9XG4gICAgICAgICAgIHAgPSBwLm5leHRQb2ludE9uQ29udG91cjtcbiAgICAgICB9IHdoaWxlIChwICE9PSBzcCk7XG4gICB9XG5cbiAgIC8vIFNIWltdIFNIaWZ0IFpvbmUgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4gICAvLyAweDM2LTB4MzdcbiAgIGZ1bmN0aW9uIFNIWihhLCBzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0haWycgKyBhICsgJ10nLCBlKTsgfVxuXG4gICAgICAgdmFyIHo7XG4gICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgIGNhc2UgMCA6IHogPSBzdGF0ZS50Wm9uZTsgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgMSA6IHogPSBzdGF0ZS5nWm9uZTsgYnJlYWs7XG4gICAgICAgICAgIGRlZmF1bHQgOiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZScpO1xuICAgICAgIH1cblxuICAgICAgIHZhciBwO1xuICAgICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgdmFyIHBMZW4gPSB6Lmxlbmd0aCAtIDI7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspXG4gICAgICAge1xuICAgICAgICAgICBwID0geltpXTtcbiAgICAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICAgICAvL2lmIChwICE9PSBycCkgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgIH1cbiAgIH1cblxuICAgLy8gU0hQSVhbXSBTSGlmdCBwb2ludCBieSBhIFBJWGVsIGFtb3VudFxuICAgLy8gMHgzOFxuICAgZnVuY3Rpb24gU0hQSVgoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDB4NDA7XG4gICAgICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICdTSFBJWFtdJywgcGksIGRcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkKTtcbiAgICAgICAgICAgZnYudG91Y2gocCk7XG4gICAgICAgfVxuXG4gICAgICAgc3RhdGUubG9vcCA9IDE7XG4gICB9XG5cbiAgIC8vIElQW10gSW50ZXJwb2xhdGUgUG9pbnRcbiAgIC8vIDB4MzlcbiAgIGZ1bmN0aW9uIElQKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHJwMWkgPSBzdGF0ZS5ycDE7XG4gICAgICAgdmFyIHJwMmkgPSBzdGF0ZS5ycDI7XG4gICAgICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgICAgIHZhciBycDEgPSBzdGF0ZS56MFtycDFpXTtcbiAgICAgICB2YXIgcnAyID0gc3RhdGUuejFbcnAyaV07XG4gICAgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuICAgICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAnSVBbXScsIHBpLCBycDFpLCAnPC0+JywgcnAyaVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGZ2LmludGVycG9sYXRlKHAsIHJwMSwgcnAyLCBwdik7XG5cbiAgICAgICAgICAgZnYudG91Y2gocCk7XG4gICAgICAgfVxuXG4gICAgICAgc3RhdGUubG9vcCA9IDE7XG4gICB9XG5cbiAgIC8vIE1TSVJQW2FdIE1vdmUgU3RhY2sgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbiAgIC8vIDB4M0EtMHgzQlxuICAgZnVuY3Rpb24gTVNJUlAoYSwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gNjQ7XG4gICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG4gICAgICAgdmFyIHJwMCA9IHN0YXRlLnowW3N0YXRlLnJwMF07XG4gICAgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIGQsIHB2KTtcbiAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNU0lSUFsnICsgYSArICddJywgZCwgcGkpOyB9XG5cbiAgICAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgICAgc3RhdGUucnAyID0gcGk7XG4gICAgICAgaWYgKGEpIHsgc3RhdGUucnAwID0gcGk7IH1cbiAgIH1cblxuICAgLy8gQUxJR05SUFtdIEFsaWduIHRvIHJlZmVyZW5jZSBwb2ludC5cbiAgIC8vIDB4M0NcbiAgIGZ1bmN0aW9uIEFMSUdOUlAoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICAgICB2YXIgcnAwID0gc3RhdGUuejBbcnAwaV07XG4gICAgICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuXG4gICAgICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgdmFyIHAgPSB6MVtwaV07XG5cbiAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAnQUxJR05SUFtdJywgcGlcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIDAsIHB2KTtcbiAgICAgICAgICAgZnYudG91Y2gocCk7XG4gICAgICAgfVxuXG4gICAgICAgc3RhdGUubG9vcCA9IDE7XG4gICB9XG5cbiAgIC8vIFJUR1tdIFJvdW5kIFRvIERvdWJsZSBHcmlkXG4gICAvLyAweDNEXG4gICBmdW5jdGlvbiBSVERHKHN0YXRlKSB7XG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUREdbXScpOyB9XG5cbiAgICAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9Eb3VibGVHcmlkO1xuICAgfVxuXG4gICAvLyBNSUFQW2FdIE1vdmUgSW5kaXJlY3QgQWJzb2x1dGUgUG9pbnRcbiAgIC8vIDB4M0UtMHgzRlxuICAgZnVuY3Rpb24gTUlBUChyb3VuZCwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgICAgIHZhciBjdiA9IHN0YXRlLmN2dFtuXTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICdNSUFQWycgKyByb3VuZCArICddJyxcbiAgICAgICAgICAgICAgIG4sICcoJywgY3YsICcpJywgcGlcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cbiAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICAgaWYgKE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuXG4gICAgICAgICAgIGQgPSBzdGF0ZS5yb3VuZChkKTtcbiAgICAgICB9XG5cbiAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcblxuICAgICAgIGlmIChzdGF0ZS56cDAgPT09IDApIHtcbiAgICAgICAgICAgcC54byA9IHAueDtcbiAgICAgICAgICAgcC55byA9IHAueTtcbiAgICAgICB9XG5cbiAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xuICAgfVxuXG4gICAvLyBOUFVTQltdIFBVU0ggTiBCeXRlc1xuICAgLy8gMHg0MFxuICAgZnVuY3Rpb24gTlBVU0hCKHN0YXRlKSB7XG4gICAgICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIQltdJywgbik7IH1cblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgICAgIHN0YXRlLmlwID0gaXA7XG4gICB9XG5cbiAgIC8vIE5QVVNIV1tdIFBVU0ggTiBXb3Jkc1xuICAgLy8gMHg0MVxuICAgZnVuY3Rpb24gTlBVU0hXKHN0YXRlKSB7XG4gICAgICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSFdbXScsIG4pOyB9XG5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICAgICB9XG5cbiAgICAgICBzdGF0ZS5pcCA9IGlwO1xuICAgfVxuXG4gICAvLyBXU1tdIFdyaXRlIFN0b3JlXG4gICAvLyAweDQyXG4gICBmdW5jdGlvbiBXUyhzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgICAgaWYgKCFzdG9yZSkgeyBzdG9yZSA9IHN0YXRlLnN0b3JlID0gW107IH1cblxuICAgICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXUycsIHYsIGwpOyB9XG5cbiAgICAgICBzdG9yZVtsXSA9IHY7XG4gICB9XG5cbiAgIC8vIFJTW10gUmVhZCBTdG9yZVxuICAgLy8gMHg0M1xuICAgZnVuY3Rpb24gUlMoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlMnLCBsKTsgfVxuXG4gICAgICAgdmFyIHYgPSAoc3RvcmUgJiYgc3RvcmVbbF0pIHx8IDA7XG5cbiAgICAgICBzdGFjay5wdXNoKHYpO1xuICAgfVxuXG4gICAvLyBXQ1ZUUFtdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gUGl4ZWwgdW5pdHNcbiAgIC8vIDB4NDRcbiAgIGZ1bmN0aW9uIFdDVlRQKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVFAnLCB2LCBsKTsgfVxuXG4gICAgICAgc3RhdGUuY3Z0W2xdID0gdiAvIDB4NDA7XG4gICB9XG5cbiAgIC8vIFJDVlRbXSBSZWFkIENvbnRyb2wgVmFsdWUgVGFibGUgZW50cnlcbiAgIC8vIDB4NDVcbiAgIGZ1bmN0aW9uIFJDVlQoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgY3Z0ZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JDVlQnLCBjdnRlKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChzdGF0ZS5jdnRbY3Z0ZV0gKiAweDQwKTtcbiAgIH1cblxuICAgLy8gR0NbXSBHZXQgQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgb250byB0aGUgcHJvamVjdGlvbiB2ZWN0b3JcbiAgIC8vIDB4NDYtMHg0N1xuICAgZnVuY3Rpb24gR0MoYSwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHQ1snICsgYSArICddJywgcGkpOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKHN0YXRlLmRwdi5kaXN0YW5jZShwLCBIUFplcm8sIGEsIGZhbHNlKSAqIDB4NDApO1xuICAgfVxuXG4gICAvLyBNRFthXSBNZWFzdXJlIERpc3RhbmNlXG4gICAvLyAweDQ5LTB4NEFcbiAgIGZ1bmN0aW9uIE1EKGEsIHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHBpMiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwaTEgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgcDIgPSBzdGF0ZS56MVtwaTJdO1xuICAgICAgIHZhciBwMSA9IHN0YXRlLnowW3BpMV07XG4gICAgICAgdmFyIGQgPSBzdGF0ZS5kcHYuZGlzdGFuY2UocDEsIHAyLCBhLCBhKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNRFsnICsgYSArICddJywgcGkyLCBwaTEsICctPicsIGQpOyB9XG5cbiAgICAgICBzdGF0ZS5zdGFjay5wdXNoKE1hdGgucm91bmQoZCAqIDY0KSk7XG4gICB9XG5cbiAgIC8vIE1QUEVNW10gTWVhc3VyZSBQaXhlbHMgUGVyIEVNXG4gICAvLyAweDRCXG4gICBmdW5jdGlvbiBNUFBFTShzdGF0ZSkge1xuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNUFBFTVtdJyk7IH1cbiAgICAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLnBwZW0pO1xuICAgfVxuXG4gICAvLyBGTElQT05bXSBzZXQgdGhlIGF1dG8gRkxJUCBCb29sZWFuIHRvIE9OXG4gICAvLyAweDREXG4gICBmdW5jdGlvbiBGTElQT04oc3RhdGUpIHtcbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxJUE9OW10nKTsgfVxuICAgICAgIHN0YXRlLmF1dG9GbGlwID0gdHJ1ZTtcbiAgIH1cblxuICAgLy8gTFRbXSBMZXNzIFRoYW5cbiAgIC8vIDB4NTBcbiAgIGZ1bmN0aW9uIExUKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRbXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goZTEgPCBlMiA/IDEgOiAwKTtcbiAgIH1cblxuICAgLy8gTFRFUVtdIExlc3MgVGhhbiBvciBFUXVhbFxuICAgLy8gMHg1M1xuICAgZnVuY3Rpb24gTFRFUShzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xURVFbXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goZTEgPD0gZTIgPyAxIDogMCk7XG4gICB9XG5cbiAgIC8vIEdURVFbXSBHcmVhdGVyIFRoYW5cbiAgIC8vIDB4NTJcbiAgIGZ1bmN0aW9uIEdUKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RbXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goZTEgPiBlMiA/IDEgOiAwKTtcbiAgIH1cblxuICAgLy8gR1RFUVtdIEdyZWF0ZXIgVGhhbiBvciBFUXVhbFxuICAgLy8gMHg1M1xuICAgZnVuY3Rpb24gR1RFUShzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dURVFbXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goZTEgPj0gZTIgPyAxIDogMCk7XG4gICB9XG5cbiAgIC8vIEVRW10gRVF1YWxcbiAgIC8vIDB4NTRcbiAgIGZ1bmN0aW9uIEVRKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVFbXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goZTIgPT09IGUxID8gMSA6IDApO1xuICAgfVxuXG4gICAvLyBORVFbXSBOb3QgRVF1YWxcbiAgIC8vIDB4NTVcbiAgIGZ1bmN0aW9uIE5FUShzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChlMiAhPT0gZTEgPyAxIDogMCk7XG4gICB9XG5cbiAgIC8vIE9ERFtdIE9ERFxuICAgLy8gMHg1NlxuICAgZnVuY3Rpb24gT0REKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPRERbXScsIG4pOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMSA6IDApO1xuICAgfVxuXG4gICAvLyBFVkVOW10gRVZFTlxuICAgLy8gMHg1N1xuICAgZnVuY3Rpb24gRVZFTihzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVZFTltdJywgbik7IH1cblxuICAgICAgIHN0YWNrLnB1c2goTWF0aC50cnVuYyhuKSAlIDIgPyAwIDogMSk7XG4gICB9XG5cbiAgIC8vIElGW10gSUYgdGVzdFxuICAgLy8gMHg1OFxuICAgZnVuY3Rpb24gSUYoc3RhdGUpIHtcbiAgICAgICB2YXIgdGVzdCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lGW10nLCB0ZXN0KTsgfVxuXG4gICAgICAgLy8gaWYgdGVzdCBpcyB0cnVlIGl0IGp1c3QgY29udGludWVzXG4gICAgICAgLy8gaWYgbm90IHRoZSBpcCBpcyBza2lwcGVkIHVudGlsIG1hdGNoaW5nIEVMU0Ugb3IgRUlGXG4gICAgICAgaWYgKCF0ZXN0KSB7XG4gICAgICAgICAgIHNraXAoc3RhdGUsIHRydWUpO1xuXG4gICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICAnRUlGW10nKTsgfVxuICAgICAgIH1cbiAgIH1cblxuICAgLy8gRUlGW10gRW5kIElGXG4gICAvLyAweDU5XG4gICBmdW5jdGlvbiBFSUYoc3RhdGUpIHtcbiAgICAgICAvLyB0aGlzIGNhbiBiZSByZWFjaGVkIG5vcm1hbGx5IHdoZW5cbiAgICAgICAvLyBleGVjdXRpbmcgYW4gZWxzZSBicmFuY2guXG4gICAgICAgLy8gLT4ganVzdCBpZ25vcmUgaXRcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFSUZbXScpOyB9XG4gICB9XG5cbiAgIC8vIEFORFtdIGxvZ2ljYWwgQU5EXG4gICAvLyAweDVBXG4gICBmdW5jdGlvbiBBTkQoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBTkRbXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goZTIgJiYgZTEgPyAxIDogMCk7XG4gICB9XG5cbiAgIC8vIE9SW10gbG9naWNhbCBPUlxuICAgLy8gMHg1QlxuICAgZnVuY3Rpb24gT1Ioc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPUltdJywgZTIsIGUxKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChlMiB8fCBlMSA/IDEgOiAwKTtcbiAgIH1cblxuICAgLy8gTk9UW10gbG9naWNhbCBOT1RcbiAgIC8vIDB4NUNcbiAgIGZ1bmN0aW9uIE5PVChzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTk9UW10nLCBlKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChlID8gMCA6IDEpO1xuICAgfVxuXG4gICAvLyBERUxUQVAxW10gREVMVEEgZXhjZXB0aW9uIFAxXG4gICAvLyBERUxUQVAyW10gREVMVEEgZXhjZXB0aW9uIFAyXG4gICAvLyBERUxUQVAzW10gREVMVEEgZXhjZXB0aW9uIFAzXG4gICAvLyAweDVELCAweDcxLCAweDcyXG4gICBmdW5jdGlvbiBERUxUQVAxMjMoYiwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcbiAgICAgICB2YXIgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuICAgICAgIHZhciB6MCA9IHN0YXRlLnowO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBUFsnICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgdmFyIGFyZyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgdmFyIG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQRklYJywgcGksICdieScsIG1hZyAqIGRzKTsgfVxuXG4gICAgICAgICAgIHZhciBwID0gejBbcGldO1xuICAgICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBtYWcgKiBkcywgcHYpO1xuICAgICAgIH1cbiAgIH1cblxuICAgLy8gU0RCW10gU2V0IERlbHRhIEJhc2UgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4gICAvLyAweDVFXG4gICBmdW5jdGlvbiBTREIoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEQltdJywgbik7IH1cblxuICAgICAgIHN0YXRlLmRlbHRhQmFzZSA9IG47XG4gICB9XG5cbiAgIC8vIFNEU1tdIFNldCBEZWx0YSBTaGlmdCBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbiAgIC8vIDB4NUZcbiAgIGZ1bmN0aW9uIFNEUyhzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RTW10nLCBuKTsgfVxuXG4gICAgICAgc3RhdGUuZGVsdGFTaGlmdCA9IE1hdGgucG93KDAuNSwgbik7XG4gICB9XG5cbiAgIC8vIEFERFtdIEFERFxuICAgLy8gMHg2MFxuICAgZnVuY3Rpb24gQUREKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUREW10nLCBuMiwgbjEpOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKG4xICsgbjIpO1xuICAgfVxuXG4gICAvLyBTVUJbXSBTVUJcbiAgIC8vIDB4NjFcbiAgIGZ1bmN0aW9uIFNVQihzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NVQltdJywgbjIsIG4xKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChuMSAtIG4yKTtcbiAgIH1cblxuICAgLy8gRElWW10gRElWXG4gICAvLyAweDYyXG4gICBmdW5jdGlvbiBESVYoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdESVZbXScsIG4yLCBuMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2gobjEgKiA2NCAvIG4yKTtcbiAgIH1cblxuICAgLy8gTVVMW10gTVVMXG4gICAvLyAweDYzXG4gICBmdW5jdGlvbiBNVUwoc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNVUxbXScsIG4yLCBuMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2gobjEgKiBuMiAvIDY0KTtcbiAgIH1cblxuICAgLy8gQUJTW10gQUJTb2x1dGUgdmFsdWVcbiAgIC8vIDB4NjRcbiAgIGZ1bmN0aW9uIEFCUyhzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUJTW10nLCBuKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChNYXRoLmFicyhuKSk7XG4gICB9XG5cbiAgIC8vIE5FR1tdIE5FR2F0ZVxuICAgLy8gMHg2NVxuICAgZnVuY3Rpb24gTkVHKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORUdbXScsIG4pOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKC1uKTtcbiAgIH1cblxuICAgLy8gRkxPT1JbXSBGTE9PUlxuICAgLy8gMHg2NlxuICAgZnVuY3Rpb24gRkxPT1Ioc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMT09SW10nLCBuKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChNYXRoLmZsb29yKG4gLyAweDQwKSAqIDB4NDApO1xuICAgfVxuXG4gICAvLyBDRUlMSU5HW10gQ0VJTElOR1xuICAgLy8gMHg2N1xuICAgZnVuY3Rpb24gQ0VJTElORyhzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0VJTElOR1tdJywgbik7IH1cblxuICAgICAgIHN0YWNrLnB1c2goTWF0aC5jZWlsKG4gLyAweDQwKSAqIDB4NDApO1xuICAgfVxuXG4gICAvLyBST1VORFthYl0gUk9VTkQgdmFsdWVcbiAgIC8vIDB4NjgtMHg2QlxuICAgZnVuY3Rpb24gUk9VTkQoZHQsIHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST1VORFtdJyk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goc3RhdGUucm91bmQobiAvIDB4NDApICogMHg0MCk7XG4gICB9XG5cbiAgIC8vIFdDVlRGW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBGdW5pdHNcbiAgIC8vIDB4NzBcbiAgIGZ1bmN0aW9uIFdDVlRGKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRGW10nLCB2LCBsKTsgfVxuXG4gICAgICAgc3RhdGUuY3Z0W2xdID0gdiAqIHN0YXRlLnBwZW0gLyBzdGF0ZS5mb250LnVuaXRzUGVyRW07XG4gICB9XG5cbiAgIC8vIERFTFRBQzFbXSBERUxUQSBleGNlcHRpb24gQzFcbiAgIC8vIERFTFRBQzJbXSBERUxUQSBleGNlcHRpb24gQzJcbiAgIC8vIERFTFRBQzNbXSBERUxUQSBleGNlcHRpb24gQzNcbiAgIC8vIDB4NzMsIDB4NzQsIDB4NzVcbiAgIGZ1bmN0aW9uIERFTFRBQzEyMyhiLCBzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuICAgICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgICAgIHZhciBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuICAgICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cblxuICAgICAgICAgICB2YXIgZGVsdGEgPSBtYWcgKiBkcztcblxuICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDRklYJywgYywgJ2J5JywgZGVsdGEpOyB9XG5cbiAgICAgICAgICAgc3RhdGUuY3Z0W2NdICs9IGRlbHRhO1xuICAgICAgIH1cbiAgIH1cblxuICAgLy8gU1JPVU5EW10gU3VwZXIgUk9VTkRcbiAgIC8vIDB4NzZcbiAgIGZ1bmN0aW9uIFNST1VORChzdGF0ZSkge1xuICAgICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JPVU5EW10nLCBuKTsgfVxuXG4gICAgICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgICAgdmFyIHBlcmlvZDtcblxuICAgICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgICAgcGVyaW9kID0gMC41O1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgICAgIHBlcmlvZCA9IDE7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgICAgcGVyaW9kID0gMjtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgICAgIH1cblxuICAgICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgICAgfVxuXG4gICAgICAgbiAmPSAweDBGO1xuXG4gICAgICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxuICAgfVxuXG4gICAvLyBTNDVST1VORFtdIFN1cGVyIFJPVU5EIDQ1IGRlZ3JlZXNcbiAgIC8vIDB4NzdcbiAgIGZ1bmN0aW9uIFM0NVJPVU5EKHN0YXRlKSB7XG4gICAgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTNDVST1VORFtdJywgbik7IH1cblxuICAgICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgICAgIHZhciBwZXJpb2Q7XG5cbiAgICAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKSAvIDI7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgICAgIHBlcmlvZCA9IDIgKiBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgICAgIH1cblxuICAgICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgICAgfVxuXG4gICAgICAgbiAmPSAweDBGO1xuXG4gICAgICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxuICAgfVxuXG4gICAvLyBST0ZGW10gUm91bmQgT2ZmXG4gICAvLyAweDdBXG4gICBmdW5jdGlvbiBST0ZGKHN0YXRlKSB7XG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPRkZbXScpOyB9XG5cbiAgICAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kT2ZmO1xuICAgfVxuXG4gICAvLyBSVVRHW10gUm91bmQgVXAgVG8gR3JpZFxuICAgLy8gMHg3Q1xuICAgZnVuY3Rpb24gUlVURyhzdGF0ZSkge1xuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVVRHW10nKTsgfVxuXG4gICAgICAgc3RhdGUucm91bmQgPSByb3VuZFVwVG9HcmlkO1xuICAgfVxuXG4gICAvLyBSRFRHW10gUm91bmQgRG93biBUbyBHcmlkXG4gICAvLyAweDdEXG4gICBmdW5jdGlvbiBSRFRHKHN0YXRlKSB7XG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JEVEdbXScpOyB9XG5cbiAgICAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kRG93blRvR3JpZDtcbiAgIH1cblxuICAgLy8gU0NBTkNUUkxbXSBTQ0FOIGNvbnZlcnNpb24gQ29uVFJvTFxuICAgLy8gMHg4NVxuICAgZnVuY3Rpb24gU0NBTkNUUkwoc3RhdGUpIHtcbiAgICAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5DVFJMW10nLCBuKTsgfVxuICAgfVxuXG4gICAvLyBTRFBWVExbYV0gU2V0IER1YWwgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuICAgLy8gMHg4Ni0weDg3XG4gICBmdW5jdGlvbiBTRFBWVEwoYSwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFBWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgICAgdmFyIGR4O1xuICAgICAgIHZhciBkeTtcblxuICAgICAgIGlmICghYSkge1xuICAgICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgICAgfVxuXG4gICAgICAgc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xuICAgfVxuXG4gICAvLyBHRVRJTkZPW10gR0VUIElORk9ybWF0aW9uXG4gICAvLyAweDg4XG4gICBmdW5jdGlvbiBHRVRJTkZPKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIHNlbCA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciByID0gMDtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRVRJTkZPW10nLCBzZWwpOyB9XG5cbiAgICAgICAvLyB2MzUgYXMgaW4gbm8gc3VicGl4ZWwgaGludGluZ1xuICAgICAgIGlmIChzZWwgJiAweDAxKSB7IHIgPSAzNTsgfVxuXG4gICAgICAgLy8gVE9ETyByb3RhdGlvbiBhbmQgc3RyZXRjaCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuICAgICAgIC8vIGFuZCB0aHVzIHRob3NlIEdFVElORk8gYXJlIGFsd2F5cyAwLlxuXG4gICAgICAgLy8gb3BlbnR5cGUuanMgaXMgYWx3YXlzIGdyYXkgc2NhbGluZ1xuICAgICAgIGlmIChzZWwgJiAweDIwKSB7IHIgfD0gMHgxMDAwOyB9XG5cbiAgICAgICBzdGFjay5wdXNoKHIpO1xuICAgfVxuXG4gICAvLyBST0xMW10gUk9MTCB0aGUgdG9wIHRocmVlIHN0YWNrIGVsZW1lbnRzXG4gICAvLyAweDhBXG4gICBmdW5jdGlvbiBST0xMKHN0YXRlKSB7XG4gICAgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9MTFtdJyk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goYik7XG4gICAgICAgc3RhY2sucHVzaChhKTtcbiAgICAgICBzdGFjay5wdXNoKGMpO1xuICAgfVxuXG4gICAvLyBNQVhbXSBNQVhpbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcbiAgIC8vIDB4OEJcbiAgIGZ1bmN0aW9uIE1BWChzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01BWFtdJywgZTIsIGUxKTsgfVxuXG4gICAgICAgc3RhY2sucHVzaChNYXRoLm1heChlMSwgZTIpKTtcbiAgIH1cblxuICAgLy8gTUlOW10gTUlOaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4gICAvLyAweDhDXG4gICBmdW5jdGlvbiBNSU4oc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5bXScsIGUyLCBlMSk7IH1cblxuICAgICAgIHN0YWNrLnB1c2goTWF0aC5taW4oZTEsIGUyKSk7XG4gICB9XG5cbiAgIC8vIFNDQU5UWVBFW10gU0NBTlRZUEVcbiAgIC8vIDB4OERcbiAgIGZ1bmN0aW9uIFNDQU5UWVBFKHN0YXRlKSB7XG4gICAgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5UWVBFW10nLCBuKTsgfVxuICAgfVxuXG4gICAvLyBJTlNUQ1RSTFtdIElOU1RDVFJMXG4gICAvLyAweDhEXG4gICBmdW5jdGlvbiBJTlNUQ1RSTChzdGF0ZSkge1xuICAgICAgIHZhciBzID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgICAgdmFyIHYgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJTlNUQ1RSTFtdJywgcywgdik7IH1cblxuICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICBjYXNlIDEgOiBzdGF0ZS5pbmhpYml0R3JpZEZpdCA9ICEhdjsgcmV0dXJuO1xuICAgICAgICAgICBjYXNlIDIgOiBzdGF0ZS5pZ25vcmVDdnQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIElOU1RDVFJMW10gc2VsZWN0b3InKTtcbiAgICAgICB9XG4gICB9XG5cbiAgIC8vIFBVU0hCW2FiY10gUFVTSCBCeXRlc1xuICAgLy8gMHhCMC0weEI3XG4gICBmdW5jdGlvbiBQVVNIQihuLCBzdGF0ZSkge1xuICAgICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQVVNIQlsnICsgbiArICddJyk7IH1cblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgICAgIHN0YXRlLmlwID0gaXA7XG4gICB9XG5cbiAgIC8vIFBVU0hXW2FiY10gUFVTSCBXb3Jkc1xuICAgLy8gMHhCOC0weEJGXG4gICBmdW5jdGlvbiBQVVNIVyhuLCBzdGF0ZSkge1xuICAgICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLmlwLCAnUFVTSFdbJyArIG4gKyAnXScpOyB9XG5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICAgICB9XG5cbiAgICAgICBzdGF0ZS5pcCA9IGlwO1xuICAgfVxuXG4gICAvLyBNRFJQW2FiY2RlXSBNb3ZlIERpcmVjdCBSZWxhdGl2ZSBQb2ludFxuICAgLy8gMHhEMC0weEVGXG4gICAvLyAoaWYgaW5kaXJlY3QgaXMgMClcbiAgIC8vXG4gICAvLyBhbmRcbiAgIC8vXG4gICAvLyBNSVJQW2FiY2RlXSBNb3ZlIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG4gICAvLyAweEUwLTB4RkZcbiAgIC8vIChpZiBpbmRpcmVjdCBpcyAxKVxuXG4gICBmdW5jdGlvbiBNRFJQX01JUlAoaW5kaXJlY3QsIHNldFJwMCwga2VlcEQsIHJvLCBkdCwgc3RhdGUpIHtcbiAgICAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICAgICB2YXIgY3Z0ZSA9IGluZGlyZWN0ICYmIHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuICAgICAgIHZhciBycCA9IHN0YXRlLnowW3JwMGldO1xuICAgICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuXG4gICAgICAgdmFyIG1kID0gc3RhdGUubWluRGlzO1xuICAgICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcbiAgICAgICB2YXIgb2Q7IC8vIG9yaWdpbmFsIGRpc3RhbmNlXG4gICAgICAgdmFyIGQ7IC8vIG1vdmluZyBkaXN0YW5jZVxuICAgICAgIHZhciBzaWduOyAvLyBzaWduIG9mIGRpc3RhbmNlXG4gICAgICAgdmFyIGN2O1xuXG4gICAgICAgZCA9IG9kID0gcHYuZGlzdGFuY2UocCwgcnAsIHRydWUsIHRydWUpO1xuICAgICAgIHNpZ24gPSBkID49IDAgPyAxIDogLTE7IC8vIE1hdGguc2lnbiB3b3VsZCBiZSAwIGluIGNhc2Ugb2YgMFxuXG4gICAgICAgLy8gVE9ETyBjb25zaWRlciBhdXRvRmxpcFxuICAgICAgIGQgPSBNYXRoLmFicyhkKTtcblxuICAgICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICAgICBjdiA9IHN0YXRlLmN2dFtjdnRlXTtcblxuICAgICAgICAgICBpZiAocm8gJiYgTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGtlZXBEICYmIGQgPCBtZCkgeyBkID0gbWQ7IH1cblxuICAgICAgIGlmIChybykgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwLCBzaWduICogZCwgcHYpO1xuICAgICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgKGluZGlyZWN0ID8gJ01JUlBbJyA6ICdNRFJQWycpICtcbiAgICAgICAgICAgICAgIChzZXRScDAgPyAnTScgOiAnbScpICtcbiAgICAgICAgICAgICAgIChrZWVwRCA/ICc+JyA6ICdfJykgK1xuICAgICAgICAgICAgICAgKHJvID8gJ1InIDogJ18nKSArXG4gICAgICAgICAgICAgICAoZHQgPT09IDAgPyAnR3InIDogKGR0ID09PSAxID8gJ0JsJyA6IChkdCA9PT0gMiA/ICdXaCcgOiAnJykpKSArXG4gICAgICAgICAgICAgICAnXScsXG4gICAgICAgICAgICAgICBpbmRpcmVjdCA/XG4gICAgICAgICAgICAgICAgICAgY3Z0ZSArICcoJyArIHN0YXRlLmN2dFtjdnRlXSArICcsJyArICBjdiArICcpJyA6XG4gICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICBwaSxcbiAgICAgICAgICAgICAgICcoZCA9Jywgb2QsICctPicsIHNpZ24gKiBkLCAnKSdcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgICAgc3RhdGUucnAyID0gcGk7XG4gICAgICAgaWYgKHNldFJwMCkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxuICAgfVxuXG4gICAvKlxuICAgKiBUaGUgaW5zdHJ1Y3Rpb24gdGFibGUuXG4gICAqL1xuICAgaW5zdHJ1Y3Rpb25UYWJsZSA9IFtcbiAgICAgICAvKiAweDAwICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgICAgLyogMHgwMSAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgICAgIC8qIDB4MDIgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgICAgLyogMHgwMyAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAgICAvKiAweDA0ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgICAgIC8qIDB4MDUgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgICAgLyogMHgwNiAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHgwNyAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHgwOCAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHgwOSAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHgwQSAqLyBTUFZGUyxcbiAgICAgICAvKiAweDBCICovIFNGVkZTLFxuICAgICAgIC8qIDB4MEMgKi8gR1BWLFxuICAgICAgIC8qIDB4MEQgKi8gR0ZWLFxuICAgICAgIC8qIDB4MEUgKi8gU0ZWVFBWLFxuICAgICAgIC8qIDB4MEYgKi8gSVNFQ1QsXG4gICAgICAgLyogMHgxMCAqLyBTUlAwLFxuICAgICAgIC8qIDB4MTEgKi8gU1JQMSxcbiAgICAgICAvKiAweDEyICovIFNSUDIsXG4gICAgICAgLyogMHgxMyAqLyBTWlAwLFxuICAgICAgIC8qIDB4MTQgKi8gU1pQMSxcbiAgICAgICAvKiAweDE1ICovIFNaUDIsXG4gICAgICAgLyogMHgxNiAqLyBTWlBTLFxuICAgICAgIC8qIDB4MTcgKi8gU0xPT1AsXG4gICAgICAgLyogMHgxOCAqLyBSVEcsXG4gICAgICAgLyogMHgxOSAqLyBSVEhHLFxuICAgICAgIC8qIDB4MUEgKi8gU01ELFxuICAgICAgIC8qIDB4MUIgKi8gRUxTRSxcbiAgICAgICAvKiAweDFDICovIEpNUFIsXG4gICAgICAgLyogMHgxRCAqLyBTQ1ZUQ0ksXG4gICAgICAgLyogMHgxRSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dDSVxuICAgICAgIC8qIDB4MUYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXXG4gICAgICAgLyogMHgyMCAqLyBEVVAsXG4gICAgICAgLyogMHgyMSAqLyBQT1AsXG4gICAgICAgLyogMHgyMiAqLyBDTEVBUixcbiAgICAgICAvKiAweDIzICovIFNXQVAsXG4gICAgICAgLyogMHgyNCAqLyBERVBUSCxcbiAgICAgICAvKiAweDI1ICovIENJTkRFWCxcbiAgICAgICAvKiAweDI2ICovIE1JTkRFWCxcbiAgICAgICAvKiAweDI3ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEFMSUdOUFRTXG4gICAgICAgLyogMHgyOCAqLyB1bmRlZmluZWQsXG4gICAgICAgLyogMHgyOSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBVVFBcbiAgICAgICAvKiAweDJBICovIExPT1BDQUxMLFxuICAgICAgIC8qIDB4MkIgKi8gQ0FMTCxcbiAgICAgICAvKiAweDJDICovIEZERUYsXG4gICAgICAgLyogMHgyRCAqLyB1bmRlZmluZWQsICAgLy8gRU5ERiAoZWF0ZW4gYnkgRkRFRilcbiAgICAgICAvKiAweDJFICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgICAgIC8qIDB4MkYgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHgzMCAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAgICAvKiAweDMxICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgICAgIC8qIDB4MzIgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAgICAvKiAweDMzICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHgzNCAqLyBTSEMuYmluZCh1bmRlZmluZWQsIDApLFxuICAgICAgIC8qIDB4MzUgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAgICAvKiAweDM2ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHgzNyAqLyBTSFouYmluZCh1bmRlZmluZWQsIDEpLFxuICAgICAgIC8qIDB4MzggKi8gU0hQSVgsXG4gICAgICAgLyogMHgzOSAqLyBJUCxcbiAgICAgICAvKiAweDNBICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAgICAvKiAweDNCICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAgICAvKiAweDNDICovIEFMSUdOUlAsXG4gICAgICAgLyogMHgzRCAqLyBSVERHLFxuICAgICAgIC8qIDB4M0UgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHgzRiAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAgICAvKiAweDQwICovIE5QVVNIQixcbiAgICAgICAvKiAweDQxICovIE5QVVNIVyxcbiAgICAgICAvKiAweDQyICovIFdTLFxuICAgICAgIC8qIDB4NDMgKi8gUlMsXG4gICAgICAgLyogMHg0NCAqLyBXQ1ZUUCxcbiAgICAgICAvKiAweDQ1ICovIFJDVlQsXG4gICAgICAgLyogMHg0NiAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHg0NyAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHg0OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTQ0ZTXG4gICAgICAgLyogMHg0OSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHg0QSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHg0QiAqLyBNUFBFTSxcbiAgICAgICAvKiAweDRDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE1QU1xuICAgICAgIC8qIDB4NEQgKi8gRkxJUE9OLFxuICAgICAgIC8qIDB4NEUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUE9GRlxuICAgICAgIC8qIDB4NEYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gREVCVUdcbiAgICAgICAvKiAweDUwICovIExULFxuICAgICAgIC8qIDB4NTEgKi8gTFRFUSxcbiAgICAgICAvKiAweDUyICovIEdULFxuICAgICAgIC8qIDB4NTMgKi8gR1RFUSxcbiAgICAgICAvKiAweDU0ICovIEVRLFxuICAgICAgIC8qIDB4NTUgKi8gTkVRLFxuICAgICAgIC8qIDB4NTYgKi8gT0RELFxuICAgICAgIC8qIDB4NTcgKi8gRVZFTixcbiAgICAgICAvKiAweDU4ICovIElGLFxuICAgICAgIC8qIDB4NTkgKi8gRUlGLFxuICAgICAgIC8qIDB4NUEgKi8gQU5ELFxuICAgICAgIC8qIDB4NUIgKi8gT1IsXG4gICAgICAgLyogMHg1QyAqLyBOT1QsXG4gICAgICAgLyogMHg1RCAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgICAgIC8qIDB4NUUgKi8gU0RCLFxuICAgICAgIC8qIDB4NUYgKi8gU0RTLFxuICAgICAgIC8qIDB4NjAgKi8gQURELFxuICAgICAgIC8qIDB4NjEgKi8gU1VCLFxuICAgICAgIC8qIDB4NjIgKi8gRElWLFxuICAgICAgIC8qIDB4NjMgKi8gTVVMLFxuICAgICAgIC8qIDB4NjQgKi8gQUJTLFxuICAgICAgIC8qIDB4NjUgKi8gTkVHLFxuICAgICAgIC8qIDB4NjYgKi8gRkxPT1IsXG4gICAgICAgLyogMHg2NyAqLyBDRUlMSU5HLFxuICAgICAgIC8qIDB4NjggKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgICAgIC8qIDB4NjkgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgICAgIC8qIDB4NkEgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgICAgIC8qIDB4NkIgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgICAgIC8qIDB4NkMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgICAgIC8qIDB4NkQgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgICAgIC8qIDB4NkUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgICAgIC8qIDB4NkYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgICAgIC8qIDB4NzAgKi8gV0NWVEYsXG4gICAgICAgLyogMHg3MSAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgICAgIC8qIDB4NzIgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAgICAvKiAweDczICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgICAgLyogMHg3NCAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgICAgIC8qIDB4NzUgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAgICAvKiAweDc2ICovIFNST1VORCxcbiAgICAgICAvKiAweDc3ICovIFM0NVJPVU5ELFxuICAgICAgIC8qIDB4NzggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPVFtdXG4gICAgICAgLyogMHg3OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9GW11cbiAgICAgICAvKiAweDdBICovIFJPRkYsXG4gICAgICAgLyogMHg3QiAqLyB1bmRlZmluZWQsXG4gICAgICAgLyogMHg3QyAqLyBSVVRHLFxuICAgICAgIC8qIDB4N0QgKi8gUkRURyxcbiAgICAgICAvKiAweDdFICovIFBPUCwgLy8gYWN0dWFsbHkgU0FOR1csIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG4gICAgICAgLyogMHg3RiAqLyBQT1AsIC8vIGFjdHVhbGx5IEFBLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgICAgIC8qIDB4ODAgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFBUXG4gICAgICAgLyogMHg4MSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPTlxuICAgICAgIC8qIDB4ODIgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT0ZGXG4gICAgICAgLyogMHg4MyAqLyB1bmRlZmluZWQsXG4gICAgICAgLyogMHg4NCAqLyB1bmRlZmluZWQsXG4gICAgICAgLyogMHg4NSAqLyBTQ0FOQ1RSTCxcbiAgICAgICAvKiAweDg2ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgICAgLyogMHg4NyAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgICAgIC8qIDB4ODggKi8gR0VUSU5GTyxcbiAgICAgICAvKiAweDg5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIElERUZcbiAgICAgICAvKiAweDhBICovIFJPTEwsXG4gICAgICAgLyogMHg4QiAqLyBNQVgsXG4gICAgICAgLyogMHg4QyAqLyBNSU4sXG4gICAgICAgLyogMHg4RCAqLyBTQ0FOVFlQRSxcbiAgICAgICAvKiAweDhFICovIElOU1RDVFJMLFxuICAgICAgIC8qIDB4OEYgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTAgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTEgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTIgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTMgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTQgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTUgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTYgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTcgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTggKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OTkgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OUEgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OUIgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OUMgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OUQgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OUUgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4OUYgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTAgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTEgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTIgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTMgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTQgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTUgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTYgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTcgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTggKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QTkgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QUEgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QUIgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QUMgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QUQgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QUUgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QUYgKi8gdW5kZWZpbmVkLFxuICAgICAgIC8qIDB4QjAgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgICAgIC8qIDB4QjEgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgICAgIC8qIDB4QjIgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgICAgIC8qIDB4QjMgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgICAgIC8qIDB4QjQgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgICAgIC8qIDB4QjUgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgICAgIC8qIDB4QjYgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgICAgIC8qIDB4QjcgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgICAgIC8qIDB4QjggKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgICAgIC8qIDB4QjkgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgICAgIC8qIDB4QkEgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgICAgIC8qIDB4QkIgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgICAgIC8qIDB4QkMgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgICAgIC8qIDB4QkQgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgICAgIC8qIDB4QkUgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgICAgIC8qIDB4QkYgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgICAgIC8qIDB4QzAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAvKiAweEMxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMSksXG4gICAgICAgLyogMHhDMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDIpLFxuICAgICAgIC8qIDB4QzMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAzKSxcbiAgICAgICAvKiAweEM0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMCksXG4gICAgICAgLyogMHhDNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDEpLFxuICAgICAgIC8qIDB4QzYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAyKSxcbiAgICAgICAvKiAweEM3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMyksXG4gICAgICAgLyogMHhDOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDApLFxuICAgICAgIC8qIDB4QzkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAxKSxcbiAgICAgICAvKiAweENBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMiksXG4gICAgICAgLyogMHhDQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDMpLFxuICAgICAgIC8qIDB4Q0MgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAwKSxcbiAgICAgICAvKiAweENEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMSksXG4gICAgICAgLyogMHhDRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDIpLFxuICAgICAgIC8qIDB4Q0YgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAzKSxcbiAgICAgICAvKiAweEQwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMCksXG4gICAgICAgLyogMHhEMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDEpLFxuICAgICAgIC8qIDB4RDIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAyKSxcbiAgICAgICAvKiAweEQzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMyksXG4gICAgICAgLyogMHhENCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDApLFxuICAgICAgIC8qIDB4RDUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAxKSxcbiAgICAgICAvKiAweEQ2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMiksXG4gICAgICAgLyogMHhENyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDMpLFxuICAgICAgIC8qIDB4RDggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAwKSxcbiAgICAgICAvKiAweEQ5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMSksXG4gICAgICAgLyogMHhEQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDIpLFxuICAgICAgIC8qIDB4REIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAzKSxcbiAgICAgICAvKiAweERDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMCksXG4gICAgICAgLyogMHhERCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDEpLFxuICAgICAgIC8qIDB4REUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAyKSxcbiAgICAgICAvKiAweERGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMyksXG4gICAgICAgLyogMHhFMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDApLFxuICAgICAgIC8qIDB4RTEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAxKSxcbiAgICAgICAvKiAweEUyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMiksXG4gICAgICAgLyogMHhFMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDMpLFxuICAgICAgIC8qIDB4RTQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAwKSxcbiAgICAgICAvKiAweEU1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMSksXG4gICAgICAgLyogMHhFNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDIpLFxuICAgICAgIC8qIDB4RTcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAzKSxcbiAgICAgICAvKiAweEU4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMCksXG4gICAgICAgLyogMHhFOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDEpLFxuICAgICAgIC8qIDB4RUEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAyKSxcbiAgICAgICAvKiAweEVCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMyksXG4gICAgICAgLyogMHhFQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDApLFxuICAgICAgIC8qIDB4RUQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAxKSxcbiAgICAgICAvKiAweEVFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMiksXG4gICAgICAgLyogMHhFRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDMpLFxuICAgICAgIC8qIDB4RjAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAwKSxcbiAgICAgICAvKiAweEYxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMSksXG4gICAgICAgLyogMHhGMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDIpLFxuICAgICAgIC8qIDB4RjMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAzKSxcbiAgICAgICAvKiAweEY0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMCksXG4gICAgICAgLyogMHhGNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDEpLFxuICAgICAgIC8qIDB4RjYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAyKSxcbiAgICAgICAvKiAweEY3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMyksXG4gICAgICAgLyogMHhGOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDApLFxuICAgICAgIC8qIDB4RjkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAxKSxcbiAgICAgICAvKiAweEZBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMiksXG4gICAgICAgLyogMHhGQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDMpLFxuICAgICAgIC8qIDB4RkMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAwKSxcbiAgICAgICAvKiAweEZEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMSksXG4gICAgICAgLyogMHhGRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDIpLFxuICAgICAgIC8qIDB4RkYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAzKVxuICAgXTtcblxuICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIE1hdGhlbWF0aWNhbCBDb25zaWRlcmF0aW9uc1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgIGZ2IC4uLiByZWZlcnMgdG8gZnJlZWRvbSB2ZWN0b3JcbiAgIHB2IC4uLiByZWZlcnMgdG8gcHJvamVjdGlvbiB2ZWN0b3JcbiAgIHJwIC4uLiByZWZlcnMgdG8gcmVmZXJlbmNlIHBvaW50XG4gICBwICAuLi4gcmVmZXJzIHRvIHRvIHBvaW50IGJlaW5nIG9wZXJhdGVkIG9uXG4gICBkICAuLi4gcmVmZXJzIHRvIGRpc3RhbmNlXG5cbiAgIFNFVFJFTEFUSVZFOlxuICAgPT09PT09PT09PT09XG5cbiAgIGNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geC1heGlzOlxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChwdilcbiAgICAgICAgICAgICAgICAgICAgICAgIC4tJ1xuICAgICAgICAgICAgICAgICBycGQgLi0nXG4gICAgICAgICAgICAgICAgICAuLSpcbiAgICAgICAgICAgICBkIC4tJzkwwrAnXG4gICAgICAgICAgICAuLScgICAgICAgJ1xuICAgICAgICAgLi0nICAgICAgICAgICAnXG4gICAgICAqLScgICAgICAgICAgICAgICAnIGJcbiAgICAgcnAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgIHAgKi0tLS0tLS0tLS0qLS0tLS0tLS0tLS0tLS0gKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbVxuXG4gICAgIHJwZHggPSBycHggKyBkICogcHYueFxuICAgICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICAgICBlcXVhdGlvbiBvZiBsaW5lIGJcblxuICAgICAgeSAtIHJwZHkgPSBwdm5zICogKHgtIHJwZHgpXG5cbiAgICAgIHkgPSBwLnlcblxuICAgICAgeCA9IHJwZHggKyAoIHAueSAtIHJwZHkgKSAvIHB2bnNcblxuXG4gICBjYXNlIGZyZWVkb20gdmVjdG9yID09IHktYXhpczpcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgKiBwbVxuICAgICAgIHxcXFxuICAgICAgIHwgXFxcbiAgICAgICB8ICBcXFxuICAgICAgIHwgICBcXFxuICAgICAgIHwgICAgXFxcbiAgICAgICB8ICAgICBcXFxuICAgICAgIHwgICAgICBcXFxuICAgICAgIHwgICAgICAgXFxcbiAgICAgICB8ICAgICAgICBcXFxuICAgICAgIHwgICAgICAgICBcXCBiXG4gICAgICAgfCAgICAgICAgICBcXFxuICAgICAgIHwgICAgICAgICAgIFxcXG4gICAgICAgfCAgICAgICAgICAgIFxcICAgIC4tJyAocHYpXG4gICAgICAgfCAgICAgICAgIDkwwrAgXFwuLSdcbiAgICAgICB8ICAgICAgICAgICAuLScqIHJwZFxuICAgICAgIHwgICAgICAgIC4tJ1xuICAgICAgICogICAgICotJyAgZFxuICAgICAgIHAgICAgIHJwXG5cbiAgICAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gICAgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gICAgIGVxdWF0aW9uIG9mIGxpbmUgYjpcbiAgICAgICAgICAgICAgcHZucyAuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgICAgeCA9IHAueFxuXG4gICAgICB5ID0gcnBkeSArICBwdm5zICogKHAueCAtIHJwZHgpXG5cblxuXG4gICBnZW5lcmljIGNhc2U6XG4gICAtLS0tLS0tLS0tLS0tXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLicoZnYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLiogcG1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAuJyAgICAuXG4gICAgICAgICAgICAgICAgICAgICAgIC4nICAgICAgIVxuICAgICAgICAgICAgICAgICAgICAgLicgICAgICAgICAuIGJcbiAgICAgICAgICAgICAgICAgICAuJyAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICBwICAgICAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDkwwrAgICAuICAgIC4uLiAocHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4tKi0nJydcbiAgICAgICAgICAgICAgICAgICAgIC4uLi0tLScnJyAgICBycGRcbiAgICAgICAgICAgIC4uLi0tLScnJyAgIGRcbiAgICAgICotLScnJ1xuICAgICBycFxuXG4gICAgICAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gICAgICAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiAgICBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgICAgcHZucy4uLiBub3JtYWwgc2xvcGUgdG8gcHZcblxuICAgICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgIGVxdWF0aW9uIG9mIGZyZWVkb20gdmVjdG9yIGxpbmU6XG4gICAgICAgZnZzIC4uLiBzbG9wZSBvZiBmcmVlZG9tIHZlY3RvciAoPWZ5L2Z4KVxuXG4gICAgICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuXG4gICAgIG9uIHBtIGJvdGggZXF1YXRpb25zIGFyZSB0cnVlIGZvciBzYW1lIHgveVxuXG4gICAgICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG4gICAgICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuICAgICBmb3JtIHRvIHkgYW5kIHNldCBlcXVhbDpcblxuICAgICAgIHB2bnMgKiAoeCAtIHJwZHgpICsgcnBkeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuICAgICBleHBhbmQ6XG5cbiAgICAgICBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeSA9IGZ2cyAqIHggLSBmdnMgKiBweCArIHB5XG5cbiAgICAgc3dpdGNoOlxuXG4gICAgICAgZnZzICogeCAtIGZ2cyAqIHB4ICsgcHkgPSBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeVxuXG4gICAgIHNvbHZlIGZvciB4OlxuXG4gICAgICAgZnZzICogeCAtIHB2bnMgKiB4ID0gZnZzICogcHggLSBwdm5zICogcnBkeCAtIHB5ICsgcnBkeVxuXG5cblxuICAgICAgICAgICAgIGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHlcbiAgICAgICB4ID0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgIGZ2cyAtIHB2bnNcblxuICAgICBhbmQ6XG5cbiAgICAgICB5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG5cblxuICAgSU5URVJQT0xBVEU6XG4gICA9PT09PT09PT09PT1cblxuICAgRXhhbXBsZXMgb2YgcG9pbnQgaW50ZXJwb2xhdGlvbi5cblxuICAgVGhlIHdlaWdodCBvZiB0aGUgbW92ZW1lbnQgb2YgdGhlIHJlZmVyZW5jZSBwb2ludCBnZXRzIGJpZ2dlclxuICAgdGhlIGZ1cnRoZXIgdGhlIG90aGVyIHJlZmVyZW5jZSBwb2ludCBpcyBhd2F5LCB0aHVzIHRoZSBzYWZlc3RcbiAgIG9wdGlvbiAodGhhdCBpcyBhdm9pZGluZyAwLzAgZGl2aXNpb25zKSBpcyB0byB3ZWlnaHQgdGhlXG4gICBvcmlnaW5hbCBkaXN0YW5jZSBvZiB0aGUgb3RoZXIgcG9pbnQgYnkgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcy5cblxuICAgSWYgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcyBpcyAwLCB0aGVuIG1vdmUgdGhlIHBvaW50IGJ5IHRoZVxuICAgYXJpdGhtZXRpYyBhdmVyYWdlIG9mIHRoZSBtb3ZlbWVudCBvZiBib3RoIHJlZmVyZW5jZSBwb2ludHMuXG5cblxuXG5cbiAgICAgICAgICAgICAgKCs2KVxuICAgICAgIHJwMW8gKi0tLS0+KnJwMVxuICAgICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMilcbiAgICAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICBycDJvICotLS0tLS0tLS0tPiogcnAyXG4gICAgICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAgICAuICAgIDEwICAgICAgICAgIDIwICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi58ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAuICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAuICAgLiAoKzgpICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLT4qcCAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAuICAgIDEyICAgICAuICAgICAgICAgIDI0ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICB8Li4uLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzZcblxuXG4gICAtLS0tLS0tXG5cblxuXG4gICAgICAgICAgICAgICgrMTApXG4gICAgICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgICAgKC0xMClcbiAgICAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICBycDIgKjwtLS0tLS0tLS0qIHJwbzJcbiAgICAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgICAgLiAgICAxMCAgIC4gICAgICAgICAgMzAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgICAgLiAoKzUpICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgcG8gKi0tLT4qIHAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgICAgLiAgICAuICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgICAgLiAgICAuICAgMjAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgICAgfC4uLi58Li4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICAgICA1ICAgICAgICAxNVxuXG5cbiAgIC0tLS0tLS1cblxuXG4gICAgICAgICAgICAgICgrMTApXG4gICAgICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgcnAybyAqLS0tLS0tLS0+KnJwMlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbyAqLS0tLS0tLS0+KiBwXG5cbiAgIC0tLS0tLS1cblxuXG4gICAgICAgICAgICAgICgrMTApXG4gICAgICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgICAgIC4gICAgICAgICAuKCszMClcbiAgICAgICBycDJvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsyNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPiogcFxuXG5cblxuICAgdmltOiBzZXQgdHM9NCBzdz00IGV4cGFuZHRhYjpcbiAgICoqKioqL1xuXG4gICAvKipcbiAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBsaXN0IG9mIHRva2Vucy5cbiAgICAqL1xuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIG5ldyB0b2tlblxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgYSBzaW5nbGUgY2hhclxuICAgICovXG4gICBmdW5jdGlvbiBUb2tlbihjaGFyKSB7XG4gICAgICAgdGhpcy5jaGFyID0gY2hhcjtcbiAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgdGhpcy5hY3RpdmVTdGF0ZSA9IG51bGw7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IGNvbnRleHQgcmFuZ2VcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IHJhbmdlIGVuZCBpbmRleCBvZmZzZXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBvd25lciBjb250ZXh0IG5hbWVcbiAgICAqL1xuICAgZnVuY3Rpb24gQ29udGV4dFJhbmdlKHN0YXJ0SW5kZXgsIGVuZE9mZnNldCwgY29udGV4dE5hbWUpIHtcbiAgICAgICB0aGlzLmNvbnRleHROYW1lID0gY29udGV4dE5hbWU7XG4gICAgICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICB0aGlzLmVuZE9mZnNldCA9IGVuZE9mZnNldDtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVjayBjb250ZXh0IHN0YXJ0IGFuZCBlbmRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBhIHVuaXF1ZSBjb250ZXh0IG5hbWVcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNoZWNrU3RhcnQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBzdGFydFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2hlY2tFbmQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBlbmRcbiAgICAqL1xuICAgZnVuY3Rpb24gQ29udGV4dENoZWNrZXIoY29udGV4dE5hbWUsIGNoZWNrU3RhcnQsIGNoZWNrRW5kKSB7XG4gICAgICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgICAgIHRoaXMub3BlblJhbmdlID0gbnVsbDtcbiAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgIHRoaXMuY2hlY2tTdGFydCA9IGNoZWNrU3RhcnQ7XG4gICAgICAgdGhpcy5jaGVja0VuZCA9IGNoZWNrRW5kO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEB0eXBlZGVmIENvbnRleHRQYXJhbXNcbiAgICAqIEB0eXBlIE9iamVjdFxuICAgICogQHByb3BlcnR5IHthcnJheX0gY29udGV4dCBjb250ZXh0IGl0ZW1zXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICAgICovXG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgY29udGV4dCBwYXJhbXNcbiAgICAqIEBwYXJhbSB7YXJyYXl9IGNvbnRleHQgYSBsaXN0IG9mIGl0ZW1zXG4gICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICAgICovXG4gICBmdW5jdGlvbiBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGN1cnJlbnRJbmRleCkge1xuICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgdGhpcy5pbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICB0aGlzLmxlbmd0aCA9IGNvbnRleHQubGVuZ3RoO1xuICAgICAgIHRoaXMuY3VycmVudCA9IGNvbnRleHRbY3VycmVudEluZGV4XTtcbiAgICAgICB0aGlzLmJhY2t0cmFjayA9IGNvbnRleHQuc2xpY2UoMCwgY3VycmVudEluZGV4KTtcbiAgICAgICB0aGlzLmxvb2thaGVhZCA9IGNvbnRleHQuc2xpY2UoY3VycmVudEluZGV4ICsgMSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGFuIGV2ZW50IGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRJZCBldmVudCB1bmlxdWUgaWRcbiAgICAqL1xuICAgZnVuY3Rpb24gRXZlbnQoZXZlbnRJZCkge1xuICAgICAgIHRoaXMuZXZlbnRJZCA9IGV2ZW50SWQ7XG4gICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IFtdO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEluaXRpYWxpemUgYSBjb3JlIGV2ZW50cyBhbmQgYXV0byBzdWJzY3JpYmUgcmVxdWlyZWQgZXZlbnQgaGFuZGxlcnNcbiAgICAqIEBwYXJhbSB7YW55fSBldmVudHMgYW4gb2JqZWN0IHRoYXQgZW5saXN0cyBjb3JlIGV2ZW50cyBoYW5kbGVyc1xuICAgICovXG4gICBmdW5jdGlvbiBpbml0aWFsaXplQ29yZUV2ZW50cyhldmVudHMpIHtcbiAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgIHZhciBjb3JlRXZlbnRzID0gW1xuICAgICAgICAgICAnc3RhcnQnLCAnZW5kJywgJ25leHQnLCAnbmV3VG9rZW4nLCAnY29udGV4dFN0YXJ0JyxcbiAgICAgICAgICAgJ2NvbnRleHRFbmQnLCAnaW5zZXJ0VG9rZW4nLCAncmVtb3ZlVG9rZW4nLCAncmVtb3ZlUmFuZ2UnLFxuICAgICAgICAgICAncmVwbGFjZVRva2VuJywgJ3JlcGxhY2VSYW5nZScsICdjb21wb3NlUlVEJywgJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJ1xuICAgICAgIF07XG5cbiAgICAgICBjb3JlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SWQpIHtcbiAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMkMS5ldmVudHMsIGV2ZW50SWQsIHtcbiAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRXZlbnQoZXZlbnRJZClcbiAgICAgICAgICAgfSk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpZiAoISFldmVudHMpIHtcbiAgICAgICAgICAgY29yZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbZXZlbnRJZF07XG4gICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgdGhpcyQxLmV2ZW50c1tldmVudElkXS5zdWJzY3JpYmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgICAgdmFyIHJlcXVpcmVzQ29udGV4dFVwZGF0ZSA9IFtcbiAgICAgICAgICAgJ2luc2VydFRva2VuJywgJ3JlbW92ZVRva2VuJywgJ3JlbW92ZVJhbmdlJyxcbiAgICAgICAgICAgJ3JlcGxhY2VUb2tlbicsICdyZXBsYWNlUmFuZ2UnLCAnY29tcG9zZVJVRCdcbiAgICAgICBdO1xuICAgICAgIHJlcXVpcmVzQ29udGV4dFVwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgICAgIHRoaXMkMS5ldmVudHNbZXZlbnRJZF0uc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgdGhpcyQxLnVwZGF0ZUNvbnRleHRzUmFuZ2VzXG4gICAgICAgICAgICk7XG4gICAgICAgfSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge2FueX0gZXZlbnRzIHRva2VuaXplciBjb3JlIGV2ZW50c1xuICAgICovXG4gICBmdW5jdGlvbiBUb2tlbml6ZXIoZXZlbnRzKSB7XG4gICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0cyA9IHt9O1xuICAgICAgIHRoaXMuY29udGV4dENoZWNrZXJzID0gW107XG4gICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMgPSBbXTtcblxuICAgICAgIGluaXRpYWxpemVDb3JlRXZlbnRzLmNhbGwodGhpcywgZXZlbnRzKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiBhIHRva2VuLCB1c3VhbGx5IGNhbGxlZCBieSBhIHN0YXRlIG1vZGlmaWVyLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdGF0ZSBpdGVtIGtleVxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIHN0YXRlIGl0ZW0gdmFsdWVcbiAgICAqL1xuICAgVG9rZW4ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgIHRoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgIHRoaXMuYWN0aXZlU3RhdGUgPSB7IGtleToga2V5LCB2YWx1ZTogdGhpcy5zdGF0ZVtrZXldIH07XG4gICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGU7XG4gICB9O1xuXG4gICBUb2tlbi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVJZCkge1xuICAgICAgIHJldHVybiB0aGlzLnN0YXRlW3N0YXRlSWRdIHx8IG51bGw7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENoZWNrcyBpZiBhbiBpbmRleCBleGlzdHMgaW4gdGhlIHRva2VucyBsaXN0LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUuaW5ib3VuZEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQ29tcG9zZSBhbmQgYXBwbHkgYSBsaXN0IG9mIG9wZXJhdGlvbnMgKHJlcGxhY2UsIHVwZGF0ZSwgZGVsZXRlKVxuICAgICogQHBhcmFtIHthcnJheX0gUlVEcyByZXBsYWNlLCB1cGRhdGUgYW5kIGRlbGV0ZSBvcGVyYXRpb25zXG4gICAgKiBUT0RPOiBQZXJmLiBPcHRpbWl6YXRpb24gKGxlbmd0aEJlZm9yZSA9PT0gbGVuZ3RoQWZ0ZXIgPyBkaXNwYXRjaCBvbmNlKVxuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLmNvbXBvc2VSVUQgPSBmdW5jdGlvbiAoUlVEcykge1xuICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgdmFyIHNpbGVudCA9IHRydWU7XG4gICAgICAgdmFyIHN0YXRlID0gUlVEcy5tYXAoZnVuY3Rpb24gKFJVRCkgeyByZXR1cm4gKFxuICAgICAgICAgICB0aGlzJDFbUlVEWzBdXS5hcHBseSh0aGlzJDEsIFJVRC5zbGljZSgxKS5jb25jYXQoc2lsZW50KSlcbiAgICAgICApOyB9KTtcbiAgICAgICB2YXIgaGFzRkFJTE9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KCdGQUlMJylcbiAgICAgICApOyB9O1xuICAgICAgIGlmIChzdGF0ZS5ldmVyeShoYXNGQUlMT2JqZWN0KSkge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgRkFJTDogXCJjb21wb3NlUlVEOiBvbmUgb3IgbW9yZSBvcGVyYXRpb25zIGhhc24ndCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgICAgICAgICByZXBvcnQ6IHN0YXRlLmZpbHRlcihoYXNGQUlMT2JqZWN0KVxuICAgICAgICAgICB9O1xuICAgICAgIH1cbiAgICAgICB0aGlzLmRpc3BhdGNoKCdjb21wb3NlUlVEJywgW3N0YXRlLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuICFoYXNGQUlMT2JqZWN0KG9wKTsgfSldKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogUmVwbGFjZSBhIHJhbmdlIG9mIHRva2VucyB3aXRoIGEgbGlzdCBvZiB0b2tlbnNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIG9mZnNldFxuICAgICogQHBhcmFtIHt0b2tlbn0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gcmVwbGFjZVxuICAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAgICAqL1xuICAgVG9rZW5pemVyLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnMsIHNpbGVudCkge1xuICAgICAgIG9mZnNldCA9IG9mZnNldCAhPT0gbnVsbCA/IG9mZnNldCA6IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICAgICB2YXIgaXNUb2tlblR5cGUgPSB0b2tlbnMuZXZlcnkoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuOyB9KTtcbiAgICAgICBpZiAoIWlzTmFOKHN0YXJ0SW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KHN0YXJ0SW5kZXgpICYmIGlzVG9rZW5UeXBlKSB7XG4gICAgICAgICAgIHZhciByZXBsYWNlZCA9IHRoaXMudG9rZW5zLnNwbGljZS5hcHBseShcbiAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLCBbc3RhcnRJbmRleCwgb2Zmc2V0XS5jb25jYXQodG9rZW5zKVxuICAgICAgICAgICApO1xuICAgICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZXBsYWNlVG9rZW4nLCBbc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnNdKTsgfVxuICAgICAgICAgICByZXR1cm4gW3JlcGxhY2VkLCB0b2tlbnNdO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiB7IEZBSUw6ICdyZXBsYWNlUmFuZ2U6IGludmFsaWQgdG9rZW5zIG9yIHN0YXJ0SW5kZXguJyB9O1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogUmVwbGFjZSBhIHRva2VuIHdpdGggYW5vdGhlciB0b2tlblxuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gICAgKiBAcGFyYW0ge3Rva2VufSB0b2tlbiBhIHRva2VuIHRvIHJlcGxhY2VcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUucmVwbGFjZVRva2VuID0gZnVuY3Rpb24gKGluZGV4LCB0b2tlbiwgc2lsZW50KSB7XG4gICAgICAgaWYgKCFpc05hTihpbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoaW5kZXgpICYmIHRva2VuIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgdmFyIHJlcGxhY2VkID0gdGhpcy50b2tlbnMuc3BsaWNlKGluZGV4LCAxLCB0b2tlbik7XG4gICAgICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlcGxhY2VUb2tlbicsIFtpbmRleCwgdG9rZW5dKTsgfVxuICAgICAgICAgICByZXR1cm4gW3JlcGxhY2VkWzBdLCB0b2tlbl07XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlcGxhY2VUb2tlbjogaW52YWxpZCB0b2tlbiBvciBpbmRleC4nIH07XG4gICAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBSZW1vdmVzIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBvZmZzZXRcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihzdGFydEluZGV4LCBvZmZzZXQsIHNpbGVudCkge1xuICAgICAgIG9mZnNldCA9ICFpc05hTihvZmZzZXQpID8gb2Zmc2V0IDogdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vucy5zcGxpY2Uoc3RhcnRJbmRleCwgb2Zmc2V0KTtcbiAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZW1vdmVSYW5nZScsIFt0b2tlbnMsIHN0YXJ0SW5kZXgsIG9mZnNldF0pOyB9XG4gICAgICAgcmV0dXJuIHRva2VucztcbiAgIH07XG5cbiAgIC8qKlxuICAgICogUmVtb3ZlIGEgdG9rZW4gYXQgYSBjZXJ0YWluIGluZGV4XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlVG9rZW4gPSBmdW5jdGlvbihpbmRleCwgc2lsZW50KSB7XG4gICAgICAgaWYgKCFpc05hTihpbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlbW92ZVRva2VuJywgW3Rva2VuLCBpbmRleF0pOyB9XG4gICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4geyBGQUlMOiAncmVtb3ZlVG9rZW46IGludmFsaWQgdG9rZW4gaW5kZXguJyB9O1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogSW5zZXJ0IGEgbGlzdCBvZiB0b2tlbnMgYXQgYSBjZXJ0YWluIGluZGV4XG4gICAgKiBAcGFyYW0ge2FycmF5fSB0b2tlbnMgYSBsaXN0IG9mIHRva2VucyB0byBpbnNlcnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbnNlcnQgdGhlIGxpc3Qgb2YgdG9rZW5zIGF0IGluZGV4XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLmluc2VydFRva2VuID0gZnVuY3Rpb24gKHRva2VucywgaW5kZXgsIHNpbGVudCkge1xuICAgICAgIHZhciB0b2tlblR5cGUgPSB0b2tlbnMuZXZlcnkoXG4gICAgICAgICAgIGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gaW5zdGFuY2VvZiBUb2tlbjsgfVxuICAgICAgICk7XG4gICAgICAgaWYgKHRva2VuVHlwZSkge1xuICAgICAgICAgICB0aGlzLnRva2Vucy5zcGxpY2UuYXBwbHkoXG4gICAgICAgICAgICAgICB0aGlzLnRva2VucywgW2luZGV4LCAwXS5jb25jYXQodG9rZW5zKVxuICAgICAgICAgICApO1xuICAgICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdpbnNlcnRUb2tlbicsIFt0b2tlbnMsIGluZGV4XSk7IH1cbiAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4geyBGQUlMOiAnaW5zZXJ0VG9rZW46IGludmFsaWQgdG9rZW4ocykuJyB9O1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQSBzdGF0ZSBtb2RpZmllciB0aGF0IGlzIGNhbGxlZCBvbiAnbmV3VG9rZW4nIGV2ZW50XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kaWZpZXJJZCBzdGF0ZSBtb2RpZmllciBpZFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0b2tlbiBzdGF0ZVxuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLnJlZ2lzdGVyTW9kaWZpZXIgPSBmdW5jdGlvbihtb2RpZmllcklkLCBjb25kaXRpb24sIG1vZGlmaWVyKSB7XG4gICAgICAgdGhpcy5ldmVudHMubmV3VG9rZW4uc3Vic2NyaWJlKGZ1bmN0aW9uKHRva2VuLCBjb250ZXh0UGFyYW1zKSB7XG4gICAgICAgICAgIHZhciBjb25kaXRpb25QYXJhbXMgPSBbdG9rZW4sIGNvbnRleHRQYXJhbXNdO1xuICAgICAgICAgICB2YXIgY2FuQXBwbHlNb2RpZmllciA9IChcbiAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgY29uZGl0aW9uLmFwcGx5KHRoaXMsIGNvbmRpdGlvblBhcmFtcykgPT09IHRydWVcbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgdmFyIG1vZGlmaWVyUGFyYW1zID0gW3Rva2VuLCBjb250ZXh0UGFyYW1zXTtcbiAgICAgICAgICAgaWYgKGNhbkFwcGx5TW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZVZhbHVlID0gbW9kaWZpZXIuYXBwbHkodGhpcywgbW9kaWZpZXJQYXJhbXMpO1xuICAgICAgICAgICAgICAgdG9rZW4uc2V0U3RhdGUobW9kaWZpZXJJZCwgbmV3U3RhdGVWYWx1ZSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgICAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMucHVzaChtb2RpZmllcklkKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogU3Vic2NyaWJlIGEgaGFuZGxlciB0byBhbiBldmVudFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRIYW5kbGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAqL1xuICAgRXZlbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICAgICBpZiAodHlwZW9mIGV2ZW50SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICByZXR1cm4gKCh0aGlzLnN1YnNjcmliZXJzLnB1c2goZXZlbnRIYW5kbGVyKSkgLSAxKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4geyBGQUlMOiAoXCJpbnZhbGlkICdcIiArICh0aGlzLmV2ZW50SWQpICsgXCInIGV2ZW50IGhhbmRsZXJcIil9O1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YnNJZCBzdWJzY3JpcHRpb24gaWRcbiAgICAqL1xuICAgRXZlbnQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNJZCkge1xuICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKHN1YnNJZCwgMSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFNldHMgY29udGV4dCBwYXJhbXMgY3VycmVudCB2YWx1ZSBpbmRleFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGNvbnRleHQgcGFyYW1zIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAgICAqL1xuICAgQ29udGV4dFBhcmFtcy5wcm90b3R5cGUuc2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jb250ZXh0W2luZGV4XTtcbiAgICAgICB0aGlzLmJhY2t0cmFjayA9IHRoaXMuY29udGV4dC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgdGhpcy5sb29rYWhlYWQgPSB0aGlzLmNvbnRleHQuc2xpY2UoaW5kZXggKyAxKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0IGFuIGl0ZW0gYXQgYW4gb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAqIGV4YW1wbGUgKGN1cnJlbnQgdmFsdWUgaXMgMyk6XG4gICAgKiAgMSAgICAyICAgWzNdICAgNCAgICA1ICAgfCAgIGl0ZW1zIHZhbHVlc1xuICAgICogLTIgICAtMSAgICAwICAgIDEgICAgMiAgIHwgICBvZmZzZXQgdmFsdWVzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IGFuIG9mZnNldCBmcm9tIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAgICAqL1xuICAgQ29udGV4dFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICBjYXNlIChvZmZzZXQgPT09IDApOlxuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgY2FzZSAob2Zmc2V0IDwgMCAmJiBNYXRoLmFicyhvZmZzZXQpIDw9IHRoaXMuYmFja3RyYWNrLmxlbmd0aCk6XG4gICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrdHJhY2suc2xpY2Uob2Zmc2V0KVswXTtcbiAgICAgICAgICAgY2FzZSAob2Zmc2V0ID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5sb29rYWhlYWQubGVuZ3RoKTpcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZFtvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQ29udmVydHMgYSBjb250ZXh0IHJhbmdlIGludG8gYSBzdHJpbmcgdmFsdWVcbiAgICAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2VcbiAgICAqL1xuICAgVG9rZW5pemVyLnByb3RvdHlwZS5yYW5nZVRvVGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbnRleHRSYW5nZSkge1xuICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgdGhpcy5nZXRSYW5nZVRva2VucyhyYW5nZSlcbiAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSkuam9pbignJylcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENvbnZlcnRzIGFsbCB0b2tlbnMgaW50byBhIHN0cmluZ1xuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pLmpvaW4oJycpO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBHZXQgYSBjb250ZXh0IGJ5IG5hbWVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWUgdG8gZ2V0XG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0TmFtZSkge1xuICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdO1xuICAgICAgIHJldHVybiAhIWNvbnRleHQgPyBjb250ZXh0IDogbnVsbDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogU3Vic2NyaWJlcyBhIG5ldyBldmVudCBoYW5kbGVyIHRvIGFuIGV2ZW50XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlIHRvXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudEhhbmRsZXIgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIGV2ZW50XG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgaWYgKCEhZXZlbnQpIHtcbiAgICAgICAgICAgcmV0dXJuIGV2ZW50LnN1YnNjcmliZShldmVudEhhbmRsZXIpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogRGlzcGF0Y2hlcyBhbiBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgKiBAcGFyYW0ge2FueX0gYXJncyBldmVudCBoYW5kbGVyIGFyZ3VtZW50c1xuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYXBwbHkodGhpcyQxLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBSZWdpc3RlciBhIG5ldyBjb250ZXh0IGNoZWNrZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBhIHVuaXF1ZSBjb250ZXh0IG5hbWVcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRTdGFydENoZWNrIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9uIGNvbnRleHQgc3RhcnRcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRFbmRDaGVjayAgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb24gY29udGV4dCBlbmRcbiAgICAqIFRPRE86IGNhbGwgdG9rZW5pemUgb24gcmVnaXN0cmF0aW9uIHRvIHVwZGF0ZSBjb250ZXh0IHJhbmdlcyB3aXRoIHRoZSBuZXcgY29udGV4dC5cbiAgICAqL1xuICAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWdpc3RlckNvbnRleHRDaGVja2VyID0gZnVuY3Rpb24oY29udGV4dE5hbWUsIGNvbnRleHRTdGFydENoZWNrLCBjb250ZXh0RW5kQ2hlY2spIHtcbiAgICAgICBpZiAoISF0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpKSB7IHJldHVybiB7XG4gICAgICAgICAgIEZBSUw6XG4gICAgICAgICAgIChcImNvbnRleHQgbmFtZSAnXCIgKyBjb250ZXh0TmFtZSArIFwiJyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXCIpXG4gICAgICAgfTsgfVxuICAgICAgIGlmICh0eXBlb2YgY29udGV4dFN0YXJ0Q2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcbiAgICAgICAgICAgRkFJTDpcbiAgICAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgc3RhcnQgY2hlY2suXCJcbiAgICAgICB9OyB9XG4gICAgICAgaWYgKHR5cGVvZiBjb250ZXh0RW5kQ2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcbiAgICAgICAgICAgRkFJTDpcbiAgICAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgZW5kIGNoZWNrLlwiXG4gICAgICAgfTsgfVxuICAgICAgIHZhciBjb250ZXh0Q2hlY2tlcnMgPSBuZXcgQ29udGV4dENoZWNrZXIoXG4gICAgICAgICAgIGNvbnRleHROYW1lLCBjb250ZXh0U3RhcnRDaGVjaywgY29udGV4dEVuZENoZWNrXG4gICAgICAgKTtcbiAgICAgICB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV0gPSBjb250ZXh0Q2hlY2tlcnM7XG4gICAgICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMucHVzaChjb250ZXh0Q2hlY2tlcnMpO1xuICAgICAgIHJldHVybiBjb250ZXh0Q2hlY2tlcnM7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEdldHMgYSBjb250ZXh0IHJhbmdlIHRva2Vuc1xuICAgICogQHBhcmFtIHtjb250ZXh0UmFuZ2V9IHJhbmdlIGEgY29udGV4dCByYW5nZVxuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLmdldFJhbmdlVG9rZW5zID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICB2YXIgZW5kSW5kZXggPSByYW5nZS5zdGFydEluZGV4ICsgcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAgICAgIHRoaXMudG9rZW5zXG4gICAgICAgICAgICAgICAuc2xpY2UocmFuZ2Uuc3RhcnRJbmRleCwgZW5kSW5kZXgpXG4gICAgICAgKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0cyB0aGUgcmFuZ2VzIG9mIGEgY29udGV4dFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZVxuICAgICovXG4gICBUb2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHRSYW5nZXMgPSBmdW5jdGlvbihjb250ZXh0TmFtZSkge1xuICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKTtcbiAgICAgICBpZiAoISFjb250ZXh0KSB7XG4gICAgICAgICAgIHJldHVybiBjb250ZXh0LnJhbmdlcztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4geyBGQUlMOiAoXCJjb250ZXh0IGNoZWNrZXIgJ1wiICsgY29udGV4dE5hbWUgKyBcIicgaXMgbm90IHJlZ2lzdGVyZWQuXCIpIH07XG4gICAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBSZXNldHMgY29udGV4dCByYW5nZXMgdG8gcnVuIGNvbnRleHQgdXBkYXRlXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUucmVzZXRDb250ZXh0c1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICB2YXIgcmVnaXN0ZXJlZENvbnRleHRzID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHM7XG4gICAgICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gcmVnaXN0ZXJlZENvbnRleHRzKSB7XG4gICAgICAgICAgIGlmIChyZWdpc3RlcmVkQ29udGV4dHMuaGFzT3duUHJvcGVydHkoY29udGV4dE5hbWUpKSB7XG4gICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV07XG4gICAgICAgICAgICAgICBjb250ZXh0LnJhbmdlcyA9IFtdO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBVcGRhdGVzIGNvbnRleHQgcmFuZ2VzXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUudXBkYXRlQ29udGV4dHNSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG4gICAgICAgdmFyIGNoYXJzID0gdGhpcy50b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcbiAgICAgICAgICAgdGhpcy5ydW5Db250ZXh0Q2hlY2soY29udGV4dFBhcmFtcyk7XG4gICAgICAgfVxuICAgICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJywgW3RoaXMucmVnaXN0ZXJlZENvbnRleHRzXSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFNldHMgdGhlIGVuZCBvZmZzZXQgb2YgYW4gb3BlbiByYW5nZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBlbmQgb2Zmc2V0XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUuc2V0RW5kT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCwgY29udGV4dE5hbWUpIHtcbiAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgdmFyIHJhbmdlID0gbmV3IENvbnRleHRSYW5nZShzdGFydEluZGV4LCBvZmZzZXQsIGNvbnRleHROYW1lKTtcbiAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5yYW5nZXM7XG4gICAgICAgcmFuZ2UucmFuZ2VJZCA9IGNvbnRleHROYW1lICsgXCIuXCIgKyAocmFuZ2VzLmxlbmd0aCk7XG4gICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgIHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlID0gbnVsbDtcbiAgICAgICByZXR1cm4gcmFuZ2U7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFJ1bnMgYSBjb250ZXh0IGNoZWNrIG9uIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAqIEBwYXJhbSB7Y29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjdXJyZW50IGNvbnRleHQgcGFyYW1zXG4gICAgKi9cbiAgIFRva2VuaXplci5wcm90b3R5cGUucnVuQ29udGV4dENoZWNrID0gZnVuY3Rpb24oY29udGV4dFBhcmFtcykge1xuICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgdmFyIGluZGV4ID0gY29udGV4dFBhcmFtcy5pbmRleDtcbiAgICAgICB0aGlzLmNvbnRleHRDaGVja2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0Q2hlY2tlcikge1xuICAgICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBjb250ZXh0Q2hlY2tlci5jb250ZXh0TmFtZTtcbiAgICAgICAgICAgdmFyIG9wZW5SYW5nZSA9IHRoaXMkMS5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2U7XG4gICAgICAgICAgIGlmICghb3BlblJhbmdlICYmIGNvbnRleHRDaGVja2VyLmNoZWNrU3RhcnQoY29udGV4dFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgIG9wZW5SYW5nZSA9IG5ldyBDb250ZXh0UmFuZ2UoaW5kZXgsIG51bGwsIGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgICAgIHRoaXMkMS5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2UgPSBvcGVuUmFuZ2U7XG4gICAgICAgICAgICAgICB0aGlzJDEuZGlzcGF0Y2goJ2NvbnRleHRTdGFydCcsIFtjb250ZXh0TmFtZSwgaW5kZXhdKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoISFvcGVuUmFuZ2UgJiYgY29udGV4dENoZWNrZXIuY2hlY2tFbmQoY29udGV4dFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoaW5kZXggLSBvcGVuUmFuZ2Uuc3RhcnRJbmRleCkgKyAxO1xuICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcyQxLnNldEVuZE9mZnNldChvZmZzZXQsIGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgICAgIHRoaXMkMS5kaXNwYXRjaCgnY29udGV4dEVuZCcsIFtjb250ZXh0TmFtZSwgcmFuZ2VdKTtcbiAgICAgICAgICAgfVxuICAgICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBDb252ZXJ0cyBhIHRleHQgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhIHRleHQgdG8gdG9rZW5pemVcbiAgICAqL1xuICAgVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICB0aGlzLnJlc2V0Q29udGV4dHNSYW5nZXMoKTtcbiAgICAgICB2YXIgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuICAgICAgIHRoaXMuZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcbiAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnbmV4dCcsIFtjb250ZXh0UGFyYW1zXSk7XG4gICAgICAgICAgIHRoaXMucnVuQ29udGV4dENoZWNrKGNvbnRleHRQYXJhbXMpO1xuICAgICAgICAgICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oY2hhcik7XG4gICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCduZXdUb2tlbicsIFt0b2tlbiwgY29udGV4dFBhcmFtc10pO1xuICAgICAgIH1cbiAgICAgICB0aGlzLmRpc3BhdGNoKCdlbmQnLCBbdGhpcy50b2tlbnNdKTtcbiAgICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICB9O1xuXG4gICAvLyDila3ilIDilITilITilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDila5cbiAgIC8vIOKUiiBDaGFyYWN0ZXIgQ2xhc3MgQXNzZXJ0aW9ucyDilIogQ2hlY2tzIGlmIGEgY2hhciBiZWxvbmdzIHRvIGEgY2VydGFpbiBjbGFzcyDilIpcbiAgIC8vIOKVsOKUgOKVvuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUhOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKVr1xuICAgLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgY2hhciBpcyBBcmFiaWNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAgICAqL1xuICAgZnVuY3Rpb24gaXNBcmFiaWNDaGFyKGMpIHtcbiAgICAgICByZXR1cm4gL1tcXHUwNjAwLVxcdTA2NUZcXHUwNjZBLVxcdTA2RDJcXHUwNkZBLVxcdTA2RkZdLy50ZXN0KGMpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBpc29sYXRlZCBhcmFiaWMgY2hhclxuICAgICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICAgICovXG4gICBmdW5jdGlvbiBpc0lzb2xhdGVkQXJhYmljQ2hhcihjaGFyKSB7XG4gICAgICAgcmV0dXJuIC9bXFx1MDYzMFxcdTA2OTBcXHUwNjIxXFx1MDYzMVxcdTA2NjFcXHUwNjcxXFx1MDYyMlxcdTA2MzJcXHUwNjcyXFx1MDY5MlxcdTA2QzJcXHUwNjIzXFx1MDY3M1xcdTA2OTNcXHUwNkMzXFx1MDYyNFxcdTA2OTRcXHUwNkM0XFx1MDYyNVxcdTA2NzVcXHUwNjk1XFx1MDZDNVxcdTA2RTVcXHUwNjc2XFx1MDY5NlxcdTA2QzZcXHUwNjI3XFx1MDY3N1xcdTA2OTdcXHUwNkM3XFx1MDY0OFxcdTA2ODhcXHUwNjk4XFx1MDZDOFxcdTA2ODlcXHUwNjk5XFx1MDZDOVxcdTA2OEFcXHUwNkNBXFx1MDY2QlxcdTA2OEJcXHUwNkNCXFx1MDY4Q1xcdTA2OERcXHUwNkNEXFx1MDZGRFxcdTA2OEVcXHUwNkVFXFx1MDZGRVxcdTA2MkZcXHUwNjhGXFx1MDZDRlxcdTA2RUZdLy50ZXN0KGNoYXIpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBBcmFiaWMgVGFzaGtlZWwgY2hhclxuICAgICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICAgICovXG4gICBmdW5jdGlvbiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjaGFyKSB7XG4gICAgICAgcmV0dXJuIC9bXFx1MDYwMC1cXHUwNjA1XFx1MDYwQy1cXHUwNjBFXFx1MDYxMC1cXHUwNjFCXFx1MDYxRVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRF0vLnRlc3QoY2hhcik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSBjaGFyIGlzIExhdGluXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGlzTGF0aW5DaGFyKGMpIHtcbiAgICAgICByZXR1cm4gL1tBLXpdLy50ZXN0KGMpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgY2hhciBpcyB3aGl0ZXNwYWNlIGNoYXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAgICAqL1xuICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGMpIHtcbiAgICAgICByZXR1cm4gL1xccy8udGVzdChjKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBRdWVyeSBhIGZlYXR1cmUgYnkgc29tZSBvZiBpdCdzIHByb3BlcnRpZXMgdG8gbG9va3VwIGEgZ2x5cGggc3Vic3RpdHV0aW9uLlxuICAgICovXG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGZlYXR1cmUgcXVlcnkgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7Rm9udH0gZm9udCBvcGVudHlwZSBmb250IGluc3RhbmNlXG4gICAgKi9cbiAgIGZ1bmN0aW9uIEZlYXR1cmVRdWVyeShmb250KSB7XG4gICAgICAgdGhpcy5mb250ID0gZm9udDtcbiAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICB9XG5cbiAgIC8qKlxuICAgICogQHR5cGVkZWYgU3Vic3RpdHV0aW9uQWN0aW9uXG4gICAgKiBAdHlwZSBPYmplY3RcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBzdWJzdGl0dXRpb24gdHlwZVxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuICAgICogQHByb3BlcnR5IHthbnl9IHN1YnN0aXR1dGlvbiBzdWJzdGl0dXRpb24gdmFsdWUocylcbiAgICAqL1xuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhIHN1YnN0aXR1dGlvbiBhY3Rpb24gaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7U3Vic3RpdHV0aW9uQWN0aW9ufSBhY3Rpb25cbiAgICAqL1xuICAgZnVuY3Rpb24gU3Vic3RpdHV0aW9uQWN0aW9uKGFjdGlvbikge1xuICAgICAgIHRoaXMuaWQgPSBhY3Rpb24uaWQ7XG4gICAgICAgdGhpcy50YWcgPSBhY3Rpb24udGFnO1xuICAgICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMb29rdXAgYSBjb3ZlcmFnZSB0YWJsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggZ2x5cGggaW5kZXhcbiAgICAqIEBwYXJhbSB7Q292ZXJhZ2VUYWJsZX0gY292ZXJhZ2UgY292ZXJhZ2UgdGFibGVcbiAgICAqL1xuICAgZnVuY3Rpb24gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgY292ZXJhZ2UpIHtcbiAgICAgICBpZiAoIWdseXBoSW5kZXgpIHsgcmV0dXJuIC0xOyB9XG4gICAgICAgc3dpdGNoIChjb3ZlcmFnZS5mb3JtYXQpIHtcbiAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlLmdseXBocy5pbmRleE9mKGdseXBoSW5kZXgpO1xuXG4gICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgIHZhciByYW5nZXMgPSBjb3ZlcmFnZS5yYW5nZXM7XG4gICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCA+PSByYW5nZS5zdGFydCAmJiBnbHlwaEluZGV4IDw9IHJhbmdlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2x5cGhJbmRleCAtIHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICByZXR1cm4gLTE7IC8vIG5vdCBmb3VuZFxuICAgICAgIH1cbiAgICAgICByZXR1cm4gLTE7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGFuZGxlIGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gICAgKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gICAgKi9cbiAgIGZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgcmV0dXJuIGdseXBoSW5kZXggKyBzdWJ0YWJsZS5kZWx0YUdseXBoSWQ7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGFuZGxlIGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAyXG4gICAgKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gICAgKi9cbiAgIGZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgcmV0dXJuIHN1YnRhYmxlLnN1YnN0aXR1dGVbc3Vic3RpdHV0ZUluZGV4XTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMb29rdXAgYSBsaXN0IG9mIGNvdmVyYWdlIHRhYmxlc1xuICAgICogQHBhcmFtIHthbnl9IGNvdmVyYWdlTGlzdCBhIGxpc3Qgb2YgY292ZXJhZ2UgdGFibGVzXG4gICAgKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGxvb2t1cENvdmVyYWdlTGlzdChjb3ZlcmFnZUxpc3QsIGNvbnRleHRQYXJhbXMpIHtcbiAgICAgICB2YXIgbG9va3VwTGlzdCA9IFtdO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJhZ2VMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIHZhciBjb3ZlcmFnZSA9IGNvdmVyYWdlTGlzdFtpXTtcbiAgICAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgICAgICAgIGdseXBoSW5kZXggPSBBcnJheS5pc0FycmF5KGdseXBoSW5kZXgpID8gZ2x5cGhJbmRleFswXSA6IGdseXBoSW5kZXg7XG4gICAgICAgICAgIHZhciBsb29rdXBJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIGNvdmVyYWdlKTtcbiAgICAgICAgICAgaWYgKGxvb2t1cEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgbG9va3VwTGlzdC5wdXNoKGxvb2t1cEluZGV4KTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICBpZiAobG9va3VwTGlzdC5sZW5ndGggIT09IGNvdmVyYWdlTGlzdC5sZW5ndGgpIHsgcmV0dXJuIC0xOyB9XG4gICAgICAgcmV0dXJuIGxvb2t1cExpc3Q7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGFuZGxlIGNoYWluaW5nIGNvbnRleHQgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDNcbiAgICAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAgICAqL1xuICAgZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzKGNvbnRleHRQYXJhbXMsIHN1YnRhYmxlKSB7XG4gICAgICAgdmFyIGxvb2t1cHNDb3VudCA9IChcbiAgICAgICAgICAgc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggK1xuICAgICAgICAgICBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGggK1xuICAgICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcbiAgICAgICApO1xuICAgICAgIGlmIChjb250ZXh0UGFyYW1zLmNvbnRleHQubGVuZ3RoIDwgbG9va3Vwc0NvdW50KSB7IHJldHVybiBbXTsgfVxuICAgICAgIC8vIElOUFVUIExPT0tVUCAvL1xuICAgICAgIHZhciBpbnB1dExvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG4gICAgICAgICAgIHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UsIGNvbnRleHRQYXJhbXNcbiAgICAgICApO1xuICAgICAgIGlmIChpbnB1dExvb2t1cHMgPT09IC0xKSB7IHJldHVybiBbXTsgfVxuICAgICAgIC8vIExPT0tBSEVBRCBMT09LVVAgLy9cbiAgICAgICB2YXIgbG9va2FoZWFkT2Zmc2V0ID0gc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggLSAxO1xuICAgICAgIGlmIChjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5sZW5ndGggPCBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGgpIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgdmFyIGxvb2thaGVhZENvbnRleHQgPSBjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5zbGljZShsb29rYWhlYWRPZmZzZXQpO1xuICAgICAgIHdoaWxlIChsb29rYWhlYWRDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihsb29rYWhlYWRDb250ZXh0WzBdLmNoYXIpKSB7XG4gICAgICAgICAgIGxvb2thaGVhZENvbnRleHQuc2hpZnQoKTtcbiAgICAgICB9XG4gICAgICAgdmFyIGxvb2thaGVhZFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGxvb2thaGVhZENvbnRleHQsIDApO1xuICAgICAgIHZhciBsb29rYWhlYWRMb29rdXBzID0gbG9va3VwQ292ZXJhZ2VMaXN0KFxuICAgICAgICAgICBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZSwgbG9va2FoZWFkUGFyYW1zXG4gICAgICAgKTtcbiAgICAgICAvLyBCQUNLVFJBQ0sgTE9PS1VQIC8vXG4gICAgICAgdmFyIGJhY2t0cmFja0NvbnRleHQgPSBbXS5jb25jYXQoY29udGV4dFBhcmFtcy5iYWNrdHJhY2spO1xuICAgICAgIGJhY2t0cmFja0NvbnRleHQucmV2ZXJzZSgpO1xuICAgICAgIHdoaWxlIChiYWNrdHJhY2tDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihiYWNrdHJhY2tDb250ZXh0WzBdLmNoYXIpKSB7XG4gICAgICAgICAgIGJhY2t0cmFja0NvbnRleHQuc2hpZnQoKTtcbiAgICAgICB9XG4gICAgICAgaWYgKGJhY2t0cmFja0NvbnRleHQubGVuZ3RoIDwgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxuICAgICAgIHZhciBiYWNrdHJhY2tQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhiYWNrdHJhY2tDb250ZXh0LCAwKTtcbiAgICAgICB2YXIgYmFja3RyYWNrTG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcbiAgICAgICAgICAgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UsIGJhY2t0cmFja1BhcmFtc1xuICAgICAgICk7XG4gICAgICAgdmFyIGNvbnRleHRSdWxlc01hdGNoID0gKFxuICAgICAgICAgICBpbnB1dExvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aCAmJlxuICAgICAgICAgICBsb29rYWhlYWRMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoICYmXG4gICAgICAgICAgIGJhY2t0cmFja0xvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcbiAgICAgICApO1xuICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgICAgaWYgKGNvbnRleHRSdWxlc01hdGNoKSB7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGUubG9va3VwUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgdmFyIGxvb2t1cFJlY29yZCA9IHN1YnRhYmxlLmxvb2t1cFJlY29yZHNbaV07XG4gICAgICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ID0gbG9va3VwUmVjb3JkLmxvb2t1cExpc3RJbmRleDtcbiAgICAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwQnlJbmRleChsb29rdXBMaXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgc3VidGFibGUkMSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1tzXTtcbiAgICAgICAgICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlJDEpO1xuICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb25UeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSQxKTtcbiAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uVHlwZSA9PT0gJzEyJykge1xuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGlucHV0TG9va3Vwcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmdldChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSBsb29rdXAoZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7IHN1YnN0aXR1dGlvbnMucHVzaChzdWJzdGl0dXRpb24pOyB9XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGFuZGxlIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gICAgKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MShjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZSkge1xuICAgICAgIC8vIENPVkVSQUdFIExPT0tVUCAvL1xuICAgICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgICAgIHZhciBsaWdTZXRJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICBpZiAobGlnU2V0SW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgLy8gQ09NUE9ORU5UUyBMT09LVVBcbiAgICAgICAvLyAoISkgbm90ZSwgY29tcG9uZW50cyBhcmUgb3JkZXJlZCBpbiB0aGUgd3JpdHRlbiBkaXJlY3Rpb24uXG4gICAgICAgdmFyIGxpZ2F0dXJlO1xuICAgICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1tsaWdTZXRJbmRleF07XG4gICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBsaWdhdHVyZVNldC5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICBsaWdhdHVyZSA9IGxpZ2F0dXJlU2V0W3NdO1xuICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgIHZhciBsb29rYWhlYWRJdGVtID0gY29udGV4dFBhcmFtcy5sb29rYWhlYWRbbF07XG4gICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gbGlnYXR1cmUuY29tcG9uZW50c1tsXTtcbiAgICAgICAgICAgICAgIGlmIChsb29rYWhlYWRJdGVtICE9PSBjb21wb25lbnQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgIGlmIChsID09PSBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aCAtIDEpIHsgcmV0dXJuIGxpZ2F0dXJlOyB9XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIG51bGw7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSGFuZGxlIGRlY29tcG9zaXRpb24gc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IGdseXBoIGluZGV4XG4gICAgKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAgICAqL1xuICAgZnVuY3Rpb24gZGVjb21wb3NpdGlvblN1YnN0aXR1dGlvbkZvcm1hdDEoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgcmV0dXJuIHN1YnRhYmxlLnNlcXVlbmNlc1tzdWJzdGl0dXRlSW5kZXhdO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBkZWZhdWx0IHNjcmlwdCBmZWF0dXJlcyBpbmRleGVzXG4gICAgKi9cbiAgIEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICB2YXIgc2NyaXB0cyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5zY3JpcHRzO1xuICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tzXTtcbiAgICAgICAgICAgaWYgKHNjcmlwdC50YWcgPT09ICdERkxUJykgeyByZXR1cm4gKFxuICAgICAgICAgICAgICAgc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlc1xuICAgICAgICAgICApOyB9XG4gICAgICAgfVxuICAgICAgIHJldHVybiBbXTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0IGZlYXR1cmUgaW5kZXhlcyBvZiBhIHNwZWNpZmljIHNjcmlwdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gICAgKi9cbiAgIEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U2NyaXB0RmVhdHVyZXNJbmRleGVzID0gZnVuY3Rpb24oc2NyaXB0VGFnKSB7XG4gICAgICAgdmFyIHRhYmxlcyA9IHRoaXMuZm9udC50YWJsZXM7XG4gICAgICAgaWYgKCF0YWJsZXMuZ3N1YikgeyByZXR1cm4gW107IH1cbiAgICAgICBpZiAoIXNjcmlwdFRhZykgeyByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7IH1cbiAgICAgICB2YXIgc2NyaXB0cyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5zY3JpcHRzO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcbiAgICAgICAgICAgaWYgKHNjcmlwdC50YWcgPT09IHNjcmlwdFRhZyAmJiBzY3JpcHQuc2NyaXB0LmRlZmF1bHRMYW5nU3lzKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkcyA9IHNjcmlwdC5sYW5nU3lzUmVjb3JkcztcbiAgICAgICAgICAgICAgIGlmICghIWxhbmdTeXNSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYW5nU3lzUmVjb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IGxhbmdTeXNSZWNvcmRzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ1N5c1JlY29yZC50YWcgPT09IHNjcmlwdFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5cy5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIE1hcCBhIGZlYXR1cmUgdGFnIHRvIGEgZ3N1YiBmZWF0dXJlXG4gICAgKiBAcGFyYW0ge2FueX0gZmVhdHVyZXMgZ3N1YiBmZWF0dXJlc1xuICAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gICAgKi9cbiAgIEZlYXR1cmVRdWVyeS5wcm90b3R5cGUubWFwVGFnc1RvRmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHNjcmlwdFRhZykge1xuICAgICAgIHZhciB0YWdzID0ge307XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgdGFnID0gZmVhdHVyZXNbaV0udGFnO1xuICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLmZlYXR1cmU7XG4gICAgICAgICAgIHRhZ3NbdGFnXSA9IGZlYXR1cmU7XG4gICAgICAgfVxuICAgICAgIHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXS50YWdzID0gdGFncztcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0IGZlYXR1cmVzIG9mIGEgc3BlY2lmaWMgc2NyaXB0XG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGFnIHNjcmlwdCB0YWdcbiAgICAqL1xuICAgRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTY3JpcHRGZWF0dXJlcyA9IGZ1bmN0aW9uIChzY3JpcHRUYWcpIHtcbiAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ107XG4gICAgICAgaWYgKHRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkoc2NyaXB0VGFnKSkgeyByZXR1cm4gZmVhdHVyZXM7IH1cbiAgICAgICB2YXIgZmVhdHVyZXNJbmRleGVzID0gdGhpcy5nZXRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoc2NyaXB0VGFnKTtcbiAgICAgICBpZiAoIWZlYXR1cmVzSW5kZXhlcykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgIHZhciBnc3ViID0gdGhpcy5mb250LnRhYmxlcy5nc3ViO1xuICAgICAgIGZlYXR1cmVzID0gZmVhdHVyZXNJbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGdzdWIuZmVhdHVyZXNbaW5kZXhdOyB9KTtcbiAgICAgICB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ10gPSBmZWF0dXJlcztcbiAgICAgICB0aGlzLm1hcFRhZ3NUb0ZlYXR1cmVzKGZlYXR1cmVzLCBzY3JpcHRUYWcpO1xuICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0IHN1YnN0aXR1dGlvbiB0eXBlXG4gICAgKiBAcGFyYW0ge2FueX0gbG9va3VwVGFibGUgbG9va3VwIHRhYmxlXG4gICAgKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAgICAqL1xuICAgRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTdWJzdGl0dXRpb25UeXBlID0gZnVuY3Rpb24obG9va3VwVGFibGUsIHN1YnRhYmxlKSB7XG4gICAgICAgdmFyIGxvb2t1cFR5cGUgPSBsb29rdXBUYWJsZS5sb29rdXBUeXBlLnRvU3RyaW5nKCk7XG4gICAgICAgdmFyIHN1YnN0Rm9ybWF0ID0gc3VidGFibGUuc3Vic3RGb3JtYXQudG9TdHJpbmcoKTtcbiAgICAgICByZXR1cm4gbG9va3VwVHlwZSArIHN1YnN0Rm9ybWF0O1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBHZXQgbG9va3VwIG1ldGhvZFxuICAgICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICAgICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gICAgKi9cbiAgIEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0TG9va3VwTWV0aG9kID0gZnVuY3Rpb24obG9va3VwVGFibGUsIHN1YnRhYmxlKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgc3Vic3RpdHV0aW9uVHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuICAgICAgIHN3aXRjaCAoc3Vic3RpdHV0aW9uVHlwZSkge1xuICAgICAgICAgICBjYXNlICcxMSc6XG4gICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICAgICApOyB9O1xuICAgICAgICAgICBjYXNlICcxMic6XG4gICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICAgICApOyB9O1xuICAgICAgICAgICBjYXNlICc2Myc6XG4gICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRQYXJhbXMpIHsgcmV0dXJuIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0My5hcHBseShcbiAgICAgICAgICAgICAgICAgICB0aGlzJDEsIFtjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICAgICk7IH07XG4gICAgICAgICAgIGNhc2UgJzQxJzpcbiAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFBhcmFtcykgeyByZXR1cm4gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgIHRoaXMkMSwgW2NvbnRleHRQYXJhbXMsIHN1YnRhYmxlXVxuICAgICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgICAgY2FzZSAnMjEnOlxuICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBkZWNvbXBvc2l0aW9uU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcbiAgICAgICAgICAgICAgICAgICB0aGlzJDEsIFtnbHlwaEluZGV4LCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICAgICk7IH07XG4gICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgXCJsb29rdXBUeXBlOiBcIiArIChsb29rdXBUYWJsZS5sb29rdXBUeXBlKSArIFwiIC0gXCIgK1xuICAgICAgICAgICAgICAgICAgIFwic3Vic3RGb3JtYXQ6IFwiICsgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0KSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICBcImlzIG5vdCB5ZXQgc3VwcG9ydGVkXCJcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBbIExPT0tVUCBUWVBFUyBdXG4gICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgKiBTaW5nbGUgICAgICAgICAgICAgICAgICAgICAgICAxO1xuICAgICogTXVsdGlwbGUgICAgICAgICAgICAgICAgICAgICAgMjtcbiAgICAqIEFsdGVybmF0ZSAgICAgICAgICAgICAgICAgICAgIDM7XG4gICAgKiBMaWdhdHVyZSAgICAgICAgICAgICAgICAgICAgICA0O1xuICAgICogQ29udGV4dCAgICAgICAgICAgICAgICAgICAgICAgNTtcbiAgICAqIENoYWluaW5nQ29udGV4dCAgICAgICAgICAgICAgIDY7XG4gICAgKiBFeHRlbnNpb25TdWJzdGl0dXRpb24gICAgICAgICA3O1xuICAgICogUmV2ZXJzZUNoYWluaW5nQ29udGV4dCAgICAgICAgODtcbiAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAqXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBAdHlwZWRlZiBGUXVlcnlcbiAgICAqIEB0eXBlIE9iamVjdFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuICAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCBmZWF0dXJlIHNjcmlwdFxuICAgICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBMb29rdXAgYSBmZWF0dXJlIHVzaW5nIGEgcXVlcnkgcGFyYW1ldGVyc1xuICAgICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnlcbiAgICAqL1xuICAgRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5sb29rdXBGZWF0dXJlID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBxdWVyeS5jb250ZXh0UGFyYW1zO1xuICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBjb250ZXh0UGFyYW1zLmluZGV4O1xuICAgICAgIHZhciBmZWF0dXJlID0gdGhpcy5nZXRGZWF0dXJlKHtcbiAgICAgICAgICAgdGFnOiBxdWVyeS50YWcsIHNjcmlwdDogcXVlcnkuc2NyaXB0XG4gICAgICAgfSk7XG4gICAgICAgaWYgKCFmZWF0dXJlKSB7IHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICAgIFwiZm9udCAnXCIgKyAodGhpcy5mb250Lm5hbWVzLmZ1bGxOYW1lLmVuKSArIFwiJyBcIiArXG4gICAgICAgICAgIFwiZG9lc24ndCBzdXBwb3J0IGZlYXR1cmUgJ1wiICsgKHF1ZXJ5LnRhZykgKyBcIicgXCIgK1xuICAgICAgICAgICBcImZvciBzY3JpcHQgJ1wiICsgKHF1ZXJ5LnNjcmlwdCkgKyBcIicuXCJcbiAgICAgICApOyB9XG4gICAgICAgdmFyIGxvb2t1cHMgPSB0aGlzLmdldEZlYXR1cmVMb29rdXBzKGZlYXR1cmUpO1xuICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gW10uY29uY2F0KGNvbnRleHRQYXJhbXMuY29udGV4dCk7XG4gICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsb29rdXBzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgIHZhciBsb29rdXBUYWJsZSA9IGxvb2t1cHNbbF07XG4gICAgICAgICAgIHZhciBzdWJ0YWJsZXMgPSB0aGlzLmdldExvb2t1cFN1YnRhYmxlcyhsb29rdXBUYWJsZSk7XG4gICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbc107XG4gICAgICAgICAgICAgICB2YXIgc3Vic3RUeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG4gICAgICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcbiAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgIHN3aXRjaCAoc3Vic3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAnMTEnOlxuICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogMTEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgJzEyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEyLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlICc2Myc6XG4gICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic3RpdHV0aW9uKSAmJiBzdWJzdGl0dXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA2MywgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAnNDEnOlxuICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDQxLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlICcyMSc6XG4gICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAyMSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoc3Vic3RpdHV0aW9ucywgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnN0aXR1dGlvbikgJiYgIXN1YnN0aXR1dGlvbi5sZW5ndGgpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IG51bGw7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbnMubGVuZ3RoID8gc3Vic3RpdHV0aW9ucyA6IG51bGw7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENoZWNrcyBpZiBhIGZvbnQgc3VwcG9ydHMgYSBzcGVjaWZpYyBmZWF0dXJlc1xuICAgICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnkgb2JqZWN0XG4gICAgKi9cbiAgIEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICBpZiAoIXF1ZXJ5LnNjcmlwdCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICB0aGlzLmdldFNjcmlwdEZlYXR1cmVzKHF1ZXJ5LnNjcmlwdCk7XG4gICAgICAgdmFyIHN1cHBvcnRlZFNjcmlwdCA9IHRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkocXVlcnkuc2NyaXB0KTtcbiAgICAgICBpZiAoIXF1ZXJ5LnRhZykgeyByZXR1cm4gc3VwcG9ydGVkU2NyaXB0OyB9XG4gICAgICAgdmFyIHN1cHBvcnRlZEZlYXR1cmUgPSAoXG4gICAgICAgICAgIHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XS5zb21lKGZ1bmN0aW9uIChmZWF0dXJlKSB7IHJldHVybiBmZWF0dXJlLnRhZyA9PT0gcXVlcnkudGFnOyB9KVxuICAgICAgICk7XG4gICAgICAgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdCAmJiBzdXBwb3J0ZWRGZWF0dXJlO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBHZXQgbG9va3VwIHRhYmxlIHN1YnRhYmxlc1xuICAgICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICAgICovXG4gICBGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cFN1YnRhYmxlcyA9IGZ1bmN0aW9uIChsb29rdXBUYWJsZSkge1xuICAgICAgIHJldHVybiBsb29rdXBUYWJsZS5zdWJ0YWJsZXMgfHwgbnVsbDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0IGxvb2t1cCB0YWJsZSBieSBpbmRleFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxvb2t1cCB0YWJsZSBpbmRleFxuICAgICovXG4gICBGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICB2YXIgbG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5sb29rdXBzO1xuICAgICAgIHJldHVybiBsb29rdXBzW2luZGV4XSB8fCBudWxsO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBHZXQgbG9va3VwIHRhYmxlcyBmb3IgYSBmZWF0dXJlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZVxuICAgICovXG4gICBGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmVMb29rdXBzID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAvLyBUT0RPOiBtZW1vaXplXG4gICAgICAgcmV0dXJuIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMubWFwKHRoaXMuZ2V0TG9va3VwQnlJbmRleC5iaW5kKHRoaXMpKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogUXVlcnkgYSBmZWF0dXJlIGJ5IGl0J3MgcHJvcGVydGllc1xuICAgICogQHBhcmFtIHthbnl9IHF1ZXJ5IGFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiBhIHF1ZXJ5XG4gICAgKi9cbiAgIEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uIGdldEZlYXR1cmUocXVlcnkpIHtcbiAgICAgICBpZiAoIXRoaXMuZm9udCkgeyByZXR1cm4geyBGQUlMOiBcIk5vIGZvbnQgd2FzIGZvdW5kXCJ9OyB9XG4gICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHF1ZXJ5LnNjcmlwdCkpIHtcbiAgICAgICAgICAgdGhpcy5nZXRTY3JpcHRGZWF0dXJlcyhxdWVyeS5zY3JpcHQpO1xuICAgICAgIH1cbiAgICAgICB2YXIgc2NyaXB0RmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzW3F1ZXJ5LnNjcmlwdF07XG4gICAgICAgaWYgKCFzY3JpcHRGZWF0dXJlcykgeyByZXR1cm4gKFxuICAgICAgICAgICB7IEZBSUw6IChcIk5vIGZlYXR1cmUgZm9yIHNjcmlwdCBcIiArIChxdWVyeS5zY3JpcHQpKX1cbiAgICAgICApOyB9XG4gICAgICAgaWYgKCFzY3JpcHRGZWF0dXJlcy50YWdzW3F1ZXJ5LnRhZ10pIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdLnRhZ3NbcXVlcnkudGFnXTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQXJhYmljIHdvcmQgY29udGV4dCBjaGVja2Vyc1xuICAgICovXG5cbiAgIGZ1bmN0aW9uIGFyYWJpY1dvcmRTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgLy8gPyBhcmFiaWMgZmlyc3QgY2hhclxuICAgICAgICAgICAocHJldkNoYXIgPT09IG51bGwgJiYgaXNBcmFiaWNDaGFyKGNoYXIpKSB8fFxuICAgICAgICAgICAvLyA/IGFyYWJpYyBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gYXJhYmljIGNoYXJcbiAgICAgICAgICAgKCFpc0FyYWJpY0NoYXIocHJldkNoYXIpICYmIGlzQXJhYmljQ2hhcihjaGFyKSlcbiAgICAgICApO1xuICAgfVxuXG4gICBmdW5jdGlvbiBhcmFiaWNXb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgICAgIHJldHVybiAoXG4gICAgICAgICAgIC8vID8gbGFzdCBhcmFiaWMgY2hhclxuICAgICAgICAgICAobmV4dENoYXIgPT09IG51bGwpIHx8XG4gICAgICAgICAgIC8vID8gbmV4dCBjaGFyIGlzIG5vdCBhcmFiaWNcbiAgICAgICAgICAgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpKVxuICAgICAgICk7XG4gICB9XG5cbiAgIHZhciBhcmFiaWNXb3JkQ2hlY2sgPSB7XG4gICAgICAgc3RhcnRDaGVjazogYXJhYmljV29yZFN0YXJ0Q2hlY2ssXG4gICAgICAgZW5kQ2hlY2s6IGFyYWJpY1dvcmRFbmRDaGVja1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBBcmFiaWMgc2VudGVuY2UgY29udGV4dCBjaGVja2Vyc1xuICAgICovXG5cbiAgIGZ1bmN0aW9uIGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgICAgIHJldHVybiAoXG4gICAgICAgICAgIC8vID8gYW4gYXJhYmljIGNoYXIgcHJlY2VkZWQgd2l0aCBhIG5vbiBhcmFiaWMgY2hhclxuICAgICAgICAgICAoaXNBcmFiaWNDaGFyKGNoYXIpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGNoYXIpKSAmJlxuICAgICAgICAgICAhaXNBcmFiaWNDaGFyKHByZXZDaGFyKVxuICAgICAgICk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGFyYWJpY1NlbnRlbmNlRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICBjYXNlIG5leHRDaGFyID09PSBudWxsOlxuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgIGNhc2UgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpICYmICFpc1Rhc2hrZWVsQXJhYmljQ2hhcihuZXh0Q2hhcikpOlxuICAgICAgICAgICAgICAgdmFyIG5leHRJc1doaXRlc3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuICAgICAgICAgICAgICAgaWYgKCFuZXh0SXNXaGl0ZXNwYWNlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICBpZiAobmV4dElzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgIHZhciBhcmFiaWNDaGFyQWhlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICBhcmFiaWNDaGFyQWhlYWQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMubG9va2FoZWFkLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYykgeyByZXR1cm4gaXNBcmFiaWNDaGFyKGMpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGMpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgIGlmICghYXJhYmljQ2hhckFoZWFkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICB9XG5cbiAgIHZhciBhcmFiaWNTZW50ZW5jZUNoZWNrID0ge1xuICAgICAgIHN0YXJ0Q2hlY2s6IGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayxcbiAgICAgICBlbmRDaGVjazogYXJhYmljU2VudGVuY2VFbmRDaGVja1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBBcHBseSBzaW5nbGUgc3Vic3RpdHV0aW9uIGZvcm1hdCAxXG4gICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAgICAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gICAgKi9cbiAgIGZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICAgICB0b2tlbnNbaW5kZXhdLnNldFN0YXRlKGFjdGlvbi50YWcsIGFjdGlvbi5zdWJzdGl0dXRpb24pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEFwcGx5IHNpbmdsZSBzdWJzdGl0dXRpb24gZm9ybWF0IDJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICAgICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAgICAqL1xuICAgZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MiQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgICAgIHRva2Vuc1tpbmRleF0uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQXBwbHkgY2hhaW5pbmcgY29udGV4dCBzdWJzdGl0dXRpb24gZm9ybWF0IDNcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICAgICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAgICAqL1xuICAgZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgICAgYWN0aW9uLnN1YnN0aXR1dGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzdCwgb2Zmc2V0KSB7XG4gICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpbmRleCArIG9mZnNldF07XG4gICAgICAgICAgIHRva2VuLnNldFN0YXRlKGFjdGlvbi50YWcsIHN1YnN0KTtcbiAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBcHBseSBsaWdhdHVyZSBzdWJzdGl0dXRpb24gZm9ybWF0IDFcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICAgICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAgICAqL1xuICAgZnVuY3Rpb24gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2luZGV4XTtcbiAgICAgICB0b2tlbi5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uLmxpZ0dseXBoKTtcbiAgICAgICB2YXIgY29tcHNDb3VudCA9IGFjdGlvbi5zdWJzdGl0dXRpb24uY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaW5kZXggKyBpICsgMV07XG4gICAgICAgICAgIHRva2VuLnNldFN0YXRlKCdkZWxldGVkJywgdHJ1ZSk7XG4gICAgICAgfVxuICAgfVxuXG4gICAvKipcbiAgICAqIFN1cHBvcnRlZCBzdWJzdGl0dXRpb25zXG4gICAgKi9cbiAgIHZhciBTVUJTVElUVVRJT05TID0ge1xuICAgICAgIDExOiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxJDEsXG4gICAgICAgMTI6IHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIkMSxcbiAgICAgICA2MzogY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEsXG4gICAgICAgNDE6IGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSQxXG4gICB9O1xuXG4gICAvKipcbiAgICAqIEFwcGx5IHN1YnN0aXR1dGlvbnMgdG8gYSBsaXN0IG9mIHRva2Vuc1xuICAgICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gICAgKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICAgICovXG4gICBmdW5jdGlvbiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uQWN0aW9uICYmIFNVQlNUSVRVVElPTlNbYWN0aW9uLmlkXSkge1xuICAgICAgICAgICBTVUJTVElUVVRJT05TW2FjdGlvbi5pZF0oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcbiAgICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogQXBwbHkgQXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIHJhbmdlIG9mIHRva2Vuc1xuICAgICovXG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcmVjZWRpbmcgY2hhclxuICAgICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjaGFyQ29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyBvZiBhIGNoYXJcbiAgICAqL1xuICAgZnVuY3Rpb24gd2lsbENvbm5lY3RQcmV2KGNoYXJDb250ZXh0UGFyYW1zKSB7XG4gICAgICAgdmFyIGJhY2t0cmFjayA9IFtdLmNvbmNhdChjaGFyQ29udGV4dFBhcmFtcy5iYWNrdHJhY2spO1xuICAgICAgIGZvciAodmFyIGkgPSBiYWNrdHJhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgdmFyIHByZXZDaGFyID0gYmFja3RyYWNrW2ldO1xuICAgICAgICAgICB2YXIgaXNvbGF0ZWQgPSBpc0lzb2xhdGVkQXJhYmljQ2hhcihwcmV2Q2hhcik7XG4gICAgICAgICAgIHZhciB0YXNoa2VlbCA9IGlzVGFzaGtlZWxBcmFiaWNDaGFyKHByZXZDaGFyKTtcbiAgICAgICAgICAgaWYgKCFpc29sYXRlZCAmJiAhdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgaWYgKGlzb2xhdGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcm9jZWVkaW5nIGNoYXJcbiAgICAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY2hhckNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgb2YgYSBjaGFyXG4gICAgKi9cbiAgIGZ1bmN0aW9uIHdpbGxDb25uZWN0TmV4dChjaGFyQ29udGV4dFBhcmFtcykge1xuICAgICAgIGlmIChpc0lzb2xhdGVkQXJhYmljQ2hhcihjaGFyQ29udGV4dFBhcmFtcy5jdXJyZW50KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb250ZXh0UGFyYW1zLmxvb2thaGVhZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWRbaV07XG4gICAgICAgICAgIHZhciB0YXNoa2VlbCA9IGlzVGFzaGtlZWxBcmFiaWNDaGFyKG5leHRDaGFyKTtcbiAgICAgICAgICAgaWYgKCF0YXNoa2VlbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQXBwbHkgYXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAgICAqL1xuICAgZnVuY3Rpb24gYXJhYmljUHJlc2VudGF0aW9uRm9ybXMocmFuZ2UpIHtcbiAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHsgcmV0dXJuOyB9XG4gICAgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhcbiAgICAgICAgICAgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmdldFN0YXRlKCdnbHlwaEluZGV4Jyk7IH1cbiAgICAgICApLCAwKTtcbiAgICAgICB2YXIgY2hhckNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhcbiAgICAgICAgICAgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH1cbiAgICAgICApLCAwKTtcbiAgICAgICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIGluZGV4KSB7XG4gICAgICAgICAgIGlmIChpc1Rhc2hrZWVsQXJhYmljQ2hhcih0b2tlbi5jaGFyKSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICBjaGFyQ29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICB2YXIgQ09OTkVDVCA9IDA7IC8vIDIgYml0cyAwMCAoMTA6IGNhbiBjb25uZWN0IG5leHQpICgwMTogY2FuIGNvbm5lY3QgcHJldilcbiAgICAgICAgICAgaWYgKHdpbGxDb25uZWN0UHJldihjaGFyQ29udGV4dFBhcmFtcykpIHsgQ09OTkVDVCB8PSAxOyB9XG4gICAgICAgICAgIGlmICh3aWxsQ29ubmVjdE5leHQoY2hhckNvbnRleHRQYXJhbXMpKSB7IENPTk5FQ1QgfD0gMjsgfVxuICAgICAgICAgICB2YXIgdGFnO1xuICAgICAgICAgICBzd2l0Y2ggKENPTk5FQ1QpIHtcbiAgICAgICAgICAgICAgIGNhc2UgMTogKHRhZyA9ICdmaW5hJyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSAyOiAodGFnID0gJ2luaXQnKTsgYnJlYWs7XG4gICAgICAgICAgICAgICBjYXNlIDM6ICh0YWcgPSAnbWVkaScpOyBicmVhaztcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAodGFncy5pbmRleE9mKHRhZykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgICAgIHRhZzogdGFnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMgaW5zdGFuY2VvZiBFcnJvcikgeyByZXR1cm4gY29uc29sZS5pbmZvKHN1YnN0aXR1dGlvbnMubWVzc2FnZSk7IH1cbiAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICBjb250ZXh0UGFyYW1zLmNvbnRleHRbaW5kZXhdID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG4gICAgICAgfSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyBmZWF0dXJlIHRvIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBVcGRhdGUgY29udGV4dCBwYXJhbXNcbiAgICAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICAgICovXG4gICBmdW5jdGlvbiBnZXRDb250ZXh0UGFyYW1zKHRva2VucywgaW5kZXgpIHtcbiAgICAgICB2YXIgY29udGV4dCA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTsgfSk7XG4gICAgICAgcmV0dXJuIG5ldyBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGluZGV4IHx8IDApO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgdG8gYSBjb250ZXh0IHJhbmdlXG4gICAgKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAgICAqL1xuICAgZnVuY3Rpb24gYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMocmFuZ2UpIHtcbiAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXModG9rZW5zKTtcbiAgICAgICBjb250ZXh0UGFyYW1zLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgICAgIHRhZzogJ3JsaWcnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTsgfVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG4gICAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBMYXRpbiB3b3JkIGNvbnRleHQgY2hlY2tlcnNcbiAgICAqL1xuXG4gICBmdW5jdGlvbiBsYXRpbldvcmRTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgLy8gPyBsYXRpbiBmaXJzdCBjaGFyXG4gICAgICAgICAgIChwcmV2Q2hhciA9PT0gbnVsbCAmJiBpc0xhdGluQ2hhcihjaGFyKSkgfHxcbiAgICAgICAgICAgLy8gPyBsYXRpbiBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gbGF0aW4gY2hhclxuICAgICAgICAgICAoIWlzTGF0aW5DaGFyKHByZXZDaGFyKSAmJiBpc0xhdGluQ2hhcihjaGFyKSlcbiAgICAgICApO1xuICAgfVxuXG4gICBmdW5jdGlvbiBsYXRpbldvcmRFbmRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG4gICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgLy8gPyBsYXN0IGxhdGluIGNoYXJcbiAgICAgICAgICAgKG5leHRDaGFyID09PSBudWxsKSB8fFxuICAgICAgICAgICAvLyA/IG5leHQgY2hhciBpcyBub3QgbGF0aW5cbiAgICAgICAgICAgKCFpc0xhdGluQ2hhcihuZXh0Q2hhcikpXG4gICAgICAgKTtcbiAgIH1cblxuICAgdmFyIGxhdGluV29yZENoZWNrID0ge1xuICAgICAgIHN0YXJ0Q2hlY2s6IGxhdGluV29yZFN0YXJ0Q2hlY2ssXG4gICAgICAgZW5kQ2hlY2s6IGxhdGluV29yZEVuZENoZWNrXG4gICB9O1xuXG4gICAvKipcbiAgICAqIEFwcGx5IExhdGluIGxpZ2F0dXJlIGZlYXR1cmUgdG8gYSByYW5nZSBvZiB0b2tlbnNcbiAgICAqL1xuXG4gICAvKipcbiAgICAqIFVwZGF0ZSBjb250ZXh0IHBhcmFtc1xuICAgICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY3VycmVudCBpdGVtIGluZGV4XG4gICAgKi9cbiAgIGZ1bmN0aW9uIGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMsIGluZGV4KSB7XG4gICAgICAgdmFyIGNvbnRleHQgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7IH0pO1xuICAgICAgIHJldHVybiBuZXcgQ29udGV4dFBhcmFtcyhjb250ZXh0LCBpbmRleCB8fCAwKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIHRvIGEgY29udGV4dCByYW5nZVxuICAgICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGxhdGluTGlnYXR1cmUocmFuZ2UpIHtcbiAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgIHZhciBzY3JpcHQgPSAnbGF0bic7XG4gICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuICAgICAgIGNvbnRleHRQYXJhbXMuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChnbHlwaEluZGV4LCBpbmRleCkge1xuICAgICAgICAgICBjb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gdGhpcyQxLnF1ZXJ5Lmxvb2t1cEZlYXR1cmUoe1xuICAgICAgICAgICAgICAgdGFnOiAnbGlnYScsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpOyB9XG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuICAgICAgICAgICB9XG4gICAgICAgfSk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogSW5mZXIgYmlkaXJlY3Rpb25hbCBwcm9wZXJ0aWVzIGZvciBhIGdpdmVuIHRleHQgYW5kIGFwcGx5XG4gICAgKiB0aGUgY29ycmVzcG9uZGluZyBsYXlvdXQgcnVsZXMuXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBDcmVhdGUgQmlkaS4gZmVhdHVyZXNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlRGlyIHRleHQgYmFzZSBkaXJlY3Rpb24uIHZhbHVlIGVpdGhlciAnbHRyJyBvciAncnRsJ1xuICAgICovXG4gICBmdW5jdGlvbiBCaWRpKGJhc2VEaXIpIHtcbiAgICAgICB0aGlzLmJhc2VEaXIgPSBiYXNlRGlyIHx8ICdsdHInO1xuICAgICAgIHRoaXMudG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzID0ge307XG4gICB9XG5cbiAgIC8qKlxuICAgICogU2V0cyBCaWRpIHRleHRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGEgdGV4dCBpbnB1dFxuICAgICovXG4gICBCaWRpLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBTdG9yZSBlc3NlbnRpYWwgY29udGV4dCBjaGVja3M6XG4gICAgKiBhcmFiaWMgd29yZCBjaGVjayBmb3IgYXBwbHlpbmcgZ3N1YiBmZWF0dXJlc1xuICAgICogYXJhYmljIHNlbnRlbmNlIGNoZWNrIGZvciBhZGp1c3RpbmcgYXJhYmljIGxheW91dFxuICAgICovXG4gICBCaWRpLnByb3RvdHlwZS5jb250ZXh0Q2hlY2tzID0gKHtcbiAgICAgICBsYXRpbldvcmRDaGVjazogbGF0aW5Xb3JkQ2hlY2ssXG4gICAgICAgYXJhYmljV29yZENoZWNrOiBhcmFiaWNXb3JkQ2hlY2ssXG4gICAgICAgYXJhYmljU2VudGVuY2VDaGVjazogYXJhYmljU2VudGVuY2VDaGVja1xuICAgfSk7XG5cbiAgIC8qKlxuICAgICogUmVnaXN0ZXIgYXJhYmljIHdvcmQgY2hlY2tcbiAgICAqL1xuICAgZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0Q2hlY2tlcihjaGVja0lkKSB7XG4gICAgICAgdmFyIGNoZWNrID0gdGhpcy5jb250ZXh0Q2hlY2tzWyhjaGVja0lkICsgXCJDaGVja1wiKV07XG4gICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyQ29udGV4dENoZWNrZXIoXG4gICAgICAgICAgIGNoZWNrSWQsIGNoZWNrLnN0YXJ0Q2hlY2ssIGNoZWNrLmVuZENoZWNrXG4gICAgICAgKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBQZXJmb3JtIHByZSB0b2tlbml6YXRpb24gcHJvY2VkdXJlIHRoZW5cbiAgICAqIHRva2VuaXplIHRleHQgaW5wdXRcbiAgICAqL1xuICAgZnVuY3Rpb24gdG9rZW5pemVUZXh0KCkge1xuICAgICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnbGF0aW5Xb3JkJyk7XG4gICAgICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdhcmFiaWNXb3JkJyk7XG4gICAgICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdhcmFiaWNTZW50ZW5jZScpO1xuICAgICAgIHJldHVybiB0aGlzLnRva2VuaXplci50b2tlbml6ZSh0aGlzLnRleHQpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFJldmVyc2UgYXJhYmljIHNlbnRlbmNlIGxheW91dFxuICAgICogVE9ETzogY2hlY2sgYmFzZSBkaXIgYmVmb3JlIGFwcGx5aW5nIGFkanVzdG1lbnRzIC0gcHJpb3JpdHkgbG93XG4gICAgKi9cbiAgIGZ1bmN0aW9uIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMoKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljU2VudGVuY2UnKTtcbiAgICAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgdmFyIHJhbmdlVG9rZW5zID0gdGhpcyQxLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgICAgICAgIHRoaXMkMS50b2tlbml6ZXIucmVwbGFjZVJhbmdlKFxuICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgIHJhbmdlLmVuZE9mZnNldCxcbiAgICAgICAgICAgICAgIHJhbmdlVG9rZW5zLnJldmVyc2UoKVxuICAgICAgICAgICApO1xuICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFJlZ2lzdGVyIHN1cHBvcnRlZCBmZWF0dXJlcyB0YWdzXG4gICAgKiBAcGFyYW0ge3NjcmlwdH0gc2NyaXB0IHNjcmlwdCB0YWdcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHRhZ3MgZmVhdHVyZXMgdGFncyBsaXN0XG4gICAgKi9cbiAgIEJpZGkucHJvdG90eXBlLnJlZ2lzdGVyRmVhdHVyZXMgPSBmdW5jdGlvbiAoc2NyaXB0LCB0YWdzKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgc3VwcG9ydGVkVGFncyA9IHRhZ3MuZmlsdGVyKFxuICAgICAgICAgICBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0aGlzJDEucXVlcnkuc3VwcG9ydHMoe3NjcmlwdDogc2NyaXB0LCB0YWc6IHRhZ30pOyB9XG4gICAgICAgKTtcbiAgICAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHtcbiAgICAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XSA9IHN1cHBvcnRlZFRhZ3M7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XSA9XG4gICAgICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0uY29uY2F0KHN1cHBvcnRlZFRhZ3MpO1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQXBwbHkgR1NVQiBmZWF0dXJlc1xuICAgICogQHBhcmFtIHtBcnJheX0gdGFnc0xpc3QgYSBsaXN0IG9mIGZlYXR1cmVzIHRhZ3NcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgYSBzY3JpcHQgdGFnXG4gICAgKiBAcGFyYW0ge0ZvbnR9IGZvbnQgb3BlbnR5cGUgZm9udCBpbnN0YW5jZVxuICAgICovXG4gICBCaWRpLnByb3RvdHlwZS5hcHBseUZlYXR1cmVzID0gZnVuY3Rpb24gKGZvbnQsIGZlYXR1cmVzKSB7XG4gICAgICAgaWYgKCFmb250KSB7IHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgJ05vIHZhbGlkIGZvbnQgd2FzIHByb3ZpZGVkIHRvIGFwcGx5IGZlYXR1cmVzJ1xuICAgICAgICk7IH1cbiAgICAgICBpZiAoIXRoaXMucXVlcnkpIHsgdGhpcy5xdWVyeSA9IG5ldyBGZWF0dXJlUXVlcnkoZm9udCk7IH1cbiAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IGZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbZl07XG4gICAgICAgICAgIGlmICghdGhpcy5xdWVyeS5zdXBwb3J0cyh7c2NyaXB0OiBmZWF0dXJlLnNjcmlwdH0pKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlcyhmZWF0dXJlLnNjcmlwdCwgZmVhdHVyZS50YWdzKTtcbiAgICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFJlZ2lzdGVyIGEgc3RhdGUgbW9kaWZpZXJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RpZmllcklkIHN0YXRlIG1vZGlmaWVyIGlkXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGlmaWVyIGEgbW9kaWZpZXIgZnVuY3Rpb24gdG8gc2V0IHRva2VuIHN0YXRlXG4gICAgKi9cbiAgIEJpZGkucHJvdG90eXBlLnJlZ2lzdGVyTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcikge1xuICAgICAgIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyTW9kaWZpZXIobW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcik7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENoZWNrIGlmICdnbHlwaEluZGV4JyBpcyByZWdpc3RlcmVkXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGNoZWNrR2x5cGhJbmRleFN0YXR1cygpIHtcbiAgICAgICBpZiAodGhpcy50b2tlbml6ZXIucmVnaXN0ZXJlZE1vZGlmaWVycy5pbmRleE9mKCdnbHlwaEluZGV4JykgPT09IC0xKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICdnbHlwaEluZGV4IG1vZGlmaWVyIGlzIHJlcXVpcmVkIHRvIGFwcGx5ICcgK1xuICAgICAgICAgICAgICAgJ2FyYWJpYyBwcmVzZW50YXRpb24gZmVhdHVyZXMuJ1xuICAgICAgICAgICApO1xuICAgICAgIH1cbiAgIH1cblxuICAgLyoqXG4gICAgKiBBcHBseSBhcmFiaWMgcHJlc2VudGF0aW9uIGZvcm1zIGZlYXR1cmVzXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMoKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljV29yZCcpO1xuICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICBhcmFiaWNQcmVzZW50YXRpb25Gb3Jtcy5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuICAgICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEFwcGx5IHJlcXVpcmVkIGFyYWJpYyBsaWdhdHVyZXNcbiAgICAqL1xuICAgZnVuY3Rpb24gYXBwbHlBcmFiaWNSZXF1aXJlTGlnYXR1cmVzKCkge1xuICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgICAgIGlmICh0YWdzLmluZGV4T2YoJ3JsaWcnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1dvcmQnKTtcbiAgICAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBBcHBseSByZXF1aXJlZCBhcmFiaWMgbGlnYXR1cmVzXG4gICAgKi9cbiAgIGZ1bmN0aW9uIGFwcGx5TGF0aW5MaWdhdHVyZXMoKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgc2NyaXB0ID0gJ2xhdG4nO1xuICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICAgICB2YXIgdGFncyA9IHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF07XG4gICAgICAgaWYgKHRhZ3MuaW5kZXhPZignbGlnYScpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnbGF0aW5Xb3JkJyk7XG4gICAgICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgIGxhdGluTGlnYXR1cmUuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVjayBpZiBhIGNvbnRleHQgaXMgcmVnaXN0ZXJlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCBjb250ZXh0IGlkXG4gICAgKi9cbiAgIEJpZGkucHJvdG90eXBlLmNoZWNrQ29udGV4dFJlYWR5ID0gZnVuY3Rpb24gKGNvbnRleHRJZCkge1xuICAgICAgIHJldHVybiAhIXRoaXMudG9rZW5pemVyLmdldENvbnRleHQoY29udGV4dElkKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQXBwbHkgZmVhdHVyZXMgdG8gcmVnaXN0ZXJlZCBjb250ZXh0c1xuICAgICovXG4gICBCaWRpLnByb3RvdHlwZS5hcHBseUZlYXR1cmVzVG9Db250ZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnYXJhYmljV29yZCcpKSB7XG4gICAgICAgICAgIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgYXBwbHlBcmFiaWNSZXF1aXJlTGlnYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgICAgfVxuICAgICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdsYXRpbldvcmQnKSkge1xuICAgICAgICAgICBhcHBseUxhdGluTGlnYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgICAgfVxuICAgICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdhcmFiaWNTZW50ZW5jZScpKSB7XG4gICAgICAgICAgIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMuY2FsbCh0aGlzKTtcbiAgICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIHByb2Nlc3MgdGV4dCBpbnB1dFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYW4gaW5wdXQgdGV4dFxuICAgICovXG4gICBCaWRpLnByb3RvdHlwZS5wcm9jZXNzVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICBpZiAoIXRoaXMudGV4dCB8fCB0aGlzLnRleHQgIT09IHRleHQpIHtcbiAgICAgICAgICAgdGhpcy5zZXRUZXh0KHRleHQpO1xuICAgICAgICAgICB0b2tlbml6ZVRleHQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgdGhpcy5hcHBseUZlYXR1cmVzVG9Db250ZXh0cygpO1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogUHJvY2VzcyBhIHN0cmluZyBvZiB0ZXh0IHRvIGlkZW50aWZ5IGFuZCBhZGp1c3RcbiAgICAqIGJpZGlyZWN0aW9uYWwgdGV4dCBlbnRpdGllcy5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGlucHV0IHRleHRcbiAgICAqL1xuICAgQmlkaS5wcm90b3R5cGUuZ2V0QmlkaVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG4gICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLmdldFRleHQoKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIGluZGV4IG9mIGVhY2ggdG9rZW5cbiAgICAqIEBwYXJhbSB7dGV4dH0gdGV4dCBhbiBpbnB1dCB0ZXh0XG4gICAgKi9cbiAgIEJpZGkucHJvdG90eXBlLmdldFRleHRHbHlwaHMgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG4gICAgICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG9rZW5pemVyLnRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuaXplci50b2tlbnNbaV07XG4gICAgICAgICAgIGlmICh0b2tlbi5zdGF0ZS5kZWxldGVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgIHZhciBpbmRleCA9IHRva2VuLmFjdGl2ZVN0YXRlLnZhbHVlO1xuICAgICAgICAgICBpbmRleGVzLnB1c2goQXJyYXkuaXNBcnJheShpbmRleCkgPyBpbmRleFswXSA6IGluZGV4KTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICB9O1xuXG4gICAvLyBUaGUgRm9udCBvYmplY3RcblxuICAgLyoqXG4gICAgKiBAdHlwZWRlZiBGb250T3B0aW9uc1xuICAgICogQHR5cGUgT2JqZWN0XG4gICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVtcHR5IC0gd2hldGhlciB0byBjcmVhdGUgYSBuZXcgZW1wdHkgZm9udFxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseU5hbWVcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZU5hbWVcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnVsbE5hbWVcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcG9zdFNjcmlwdE5hbWVcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJVUkxcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyXG4gICAgKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclVSTFxuICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlXG4gICAgKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VVUkxcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdmVyc2lvblxuICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNjcmlwdGlvblxuICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSBjb3B5cmlnaHRcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdHJhZGVtYXJrXG4gICAgKiBAcHJvcGVydHkge051bWJlcn0gdW5pdHNQZXJFbVxuICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzY2VuZGVyXG4gICAgKiBAcHJvcGVydHkge051bWJlcn0gZGVzY2VuZGVyXG4gICAgKiBAcHJvcGVydHkge051bWJlcn0gY3JlYXRlZFRpbWVzdGFtcFxuICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSB3ZWlnaHRDbGFzc1xuICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSB3aWR0aENsYXNzXG4gICAgKiBAcHJvcGVydHkge3N0cmluZz19IGZzU2VsZWN0aW9uXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4gICAgKiBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuICAgICogb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG4gICAgKiBAZXhwb3J0cyBvcGVudHlwZS5Gb250XG4gICAgKiBAY2xhc3NcbiAgICAqIEBwYXJhbSB7Rm9udE9wdGlvbnN9XG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG4gICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgb3B0aW9ucy50YWJsZXMgPSBvcHRpb25zLnRhYmxlcyB8fCB7fTtcblxuICAgICAgIGlmICghb3B0aW9ucy5lbXB0eSkge1xuICAgICAgICAgICAvLyBDaGVjayB0aGF0IHdlJ3ZlIHByb3ZpZGVkIHRoZSBtaW5pbXVtIHNldCBvZiBuYW1lcy5cbiAgICAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgICAgICAgICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBmYW1pbHlOYW1lIGlzIHJlcXVpcmVkLidcbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVOYW1lLFxuICAgICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHN0eWxlTmFtZSBpcyByZXF1aXJlZC4nXG4gICAgICAgICAgICk7XG4gICAgICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICAgICBvcHRpb25zLnVuaXRzUGVyRW0sXG4gICAgICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgdW5pdHNQZXJFbSBpcyByZXF1aXJlZC4nXG4gICAgICAgICAgICk7XG4gICAgICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICAgICBvcHRpb25zLmFzY2VuZGVyLFxuICAgICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGFzY2VuZGVyIGlzIHJlcXVpcmVkLidcbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVzY2VuZGVyIDw9IDAsXG4gICAgICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgbmVnYXRpdmUgZGVzY2VuZGVyIHZhbHVlIGlzIHJlcXVpcmVkLidcbiAgICAgICAgICAgKTtcblxuICAgICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICAgICAgICAgdGhpcy5hc2NlbmRlciA9IG9wdGlvbnMuYXNjZW5kZXI7XG4gICAgICAgICAgIHRoaXMuZGVzY2VuZGVyID0gb3B0aW9ucy5kZXNjZW5kZXI7XG4gICAgICAgICAgIHRoaXMuY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcDtcbiAgICAgICAgICAgdGhpcy50YWJsZXMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMudGFibGVzLCB7XG4gICAgICAgICAgICAgICBvczI6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICB1c1dlaWdodENsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53ZWlnaHRDbGFzcyB8fCB0aGlzLnVzV2VpZ2h0Q2xhc3Nlcy5NRURJVU0sXG4gICAgICAgICAgICAgICAgICAgICAgIHVzV2lkdGhDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2lkdGhDbGFzcyB8fCB0aGlzLnVzV2lkdGhDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgICAgICAgICAgICAgZnNTZWxlY3Rpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZzU2VsZWN0aW9uIHx8IHRoaXMuZnNTZWxlY3Rpb25WYWx1ZXMuUkVHVUxBUixcbiAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudGFibGVzLm9zMlxuICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlOyAvLyBEZXByZWNhdGVkOiBwYXJzZUJ1ZmZlciB3aWxsIHRocm93IGFuIGVycm9yIGlmIGZvbnQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICB0aGlzLmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldCh0aGlzLCBvcHRpb25zLmdseXBocyB8fCBbXSk7XG4gICAgICAgdGhpcy5lbmNvZGluZyA9IG5ldyBEZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBQb3NpdGlvbih0aGlzKTtcbiAgICAgICB0aGlzLnN1YnN0aXR1dGlvbiA9IG5ldyBTdWJzdGl0dXRpb24odGhpcyk7XG4gICAgICAgdGhpcy50YWJsZXMgPSB0aGlzLnRhYmxlcyB8fCB7fTtcblxuICAgICAgIC8vIG5lZWRlZCBmb3IgbG93IG1lbW9yeSBtb2RlIG9ubHkuXG4gICAgICAgdGhpcy5fcHVzaCA9IG51bGw7XG4gICAgICAgdGhpcy5faG10eFRhYmxlRGF0YSA9IHt9O1xuXG4gICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoaW50aW5nJywge1xuICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIGlmICh0aGlzLl9oaW50aW5nKSB7IHJldHVybiB0aGlzLl9oaW50aW5nOyB9XG4gICAgICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lc0Zvcm1hdCA9PT0gJ3RydWV0eXBlJykge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5faGludGluZyA9IG5ldyBIaW50aW5nKHRoaXMpKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVjayBpZiB0aGUgZm9udCBoYXMgYSBnbHlwaCBmb3IgdGhlIGdpdmVuIGNoYXJhY3Rlci5cbiAgICAqIEBwYXJhbSAge3N0cmluZ31cbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgKi9cbiAgIEZvbnQucHJvdG90eXBlLmhhc0NoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBnbHlwaCBpbmRleC5cbiAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gICAgKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICAgICogQHBhcmFtICB7c3RyaW5nfVxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICBGb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KHMpO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgR2x5cGggb2JqZWN0LlxuICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbiAgICAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG4gICAgKiBAcGFyYW0gIHtzdHJpbmd9XG4gICAgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAgICAqL1xuICAgRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGggPSBmdW5jdGlvbiAoYykge1xuICAgICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgICAgIC8vIC5ub3RkZWZcbiAgICAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGdseXBoO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBVcGRhdGUgZmVhdHVyZXNcbiAgICAqIEBwYXJhbSB7YW55fSBvcHRpb25zIGZlYXR1cmVzIG9wdGlvbnNcbiAgICAqL1xuICAgRm9udC5wcm90b3R5cGUudXBkYXRlRmVhdHVyZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgIC8vIFRPRE86IHVwZGF0ZSBhbGwgZmVhdHVyZXMgb3B0aW9ucyBub3Qgb25seSAnbGF0bicuXG4gICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMuZmVhdHVyZXMubWFwKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgIGlmIChmZWF0dXJlLnNjcmlwdCA9PT0gJ2xhdG4nKSB7XG4gICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgIHNjcmlwdDogJ2xhdG4nLFxuICAgICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncy5maWx0ZXIoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gb3B0aW9uc1t0YWddOyB9KSxcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICAgICAgICAgfVxuICAgICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBDb252ZXJ0IHRoZSBnaXZlbiB0ZXh0IHRvIGEgbGlzdCBvZiBHbHlwaCBvYmplY3RzLlxuICAgICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHN0cmljdCBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZFxuICAgICogZ2x5cGhzLCBzbyB0aGUgbGlzdCBvZiByZXR1cm5lZCBnbHlwaHMgY2FuIGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gdGhlXG4gICAgKiBsZW5ndGggb2YgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqIEBwYXJhbSAge3N0cmluZ31cbiAgICAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9uc30gW29wdGlvbnNdXG4gICAgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaFtdfVxuICAgICovXG4gICBGb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uIChzLCBvcHRpb25zKSB7XG4gICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICB2YXIgYmlkaSA9IG5ldyBCaWRpKCk7XG5cbiAgICAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyICdnbHlwaEluZGV4JyBzdGF0ZSBtb2RpZmllclxuICAgICAgIHZhciBjaGFyVG9HbHlwaEluZGV4TW9kID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0aGlzJDEuY2hhclRvR2x5cGhJbmRleCh0b2tlbi5jaGFyKTsgfTtcbiAgICAgICBiaWRpLnJlZ2lzdGVyTW9kaWZpZXIoJ2dseXBoSW5kZXgnLCBudWxsLCBjaGFyVG9HbHlwaEluZGV4TW9kKTtcblxuICAgICAgIC8vIHJvbGwtYmFjayB0byBkZWZhdWx0IGZlYXR1cmVzXG4gICAgICAgdmFyIGZlYXR1cmVzID0gb3B0aW9uc1xuICAgICAgICAgICA/IHRoaXMudXBkYXRlRmVhdHVyZXMob3B0aW9ucy5mZWF0dXJlcylcbiAgICAgICAgICAgOiB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzO1xuXG4gICAgICAgYmlkaS5hcHBseUZlYXR1cmVzKHRoaXMsIGZlYXR1cmVzKTtcblxuICAgICAgIHZhciBpbmRleGVzID0gYmlkaS5nZXRUZXh0R2x5cGhzKHMpO1xuXG4gICAgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuXG4gICAgICAgLy8gY29udmVydCBnbHlwaCBpbmRleGVzIHRvIGdseXBoIG9iamVjdHNcbiAgICAgICB2YXIgZ2x5cGhzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgdmFyIG5vdGRlZiA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgIGdseXBoc1tpXSA9IHRoaXMuZ2x5cGhzLmdldChpbmRleGVzW2ldKSB8fCBub3RkZWY7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBnbHlwaHM7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcbiAgICAqIGFuZCB0aGUgcmlnaHQgZ2x5cGggKG9yIGl0cyBpbmRleCkuIElmIG5vIGtlcm5pbmcgcGFpciBpcyBmb3VuZCwgcmV0dXJuIDAuXG4gICAgKiBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcbiAgICAqIGJldHdlZW4gZ2x5cGhzLlxuICAgICogRm9yIEdQT1Mga2VybmluZywgdGhpcyBtZXRob2QgdXNlcyB0aGUgZGVmYXVsdCBzY3JpcHQgYW5kIGxhbmd1YWdlLCB3aGljaCBjb3ZlcnNcbiAgICAqIG1vc3QgdXNlIGNhc2VzLiBUbyBoYXZlIGdyZWF0ZXIgY29udHJvbCwgdXNlIGZvbnQucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlIC5cbiAgICAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSBsZWZ0R2x5cGhcbiAgICAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSByaWdodEdseXBoXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgIEZvbnQucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uIChsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICBsZWZ0R2x5cGggPSBsZWZ0R2x5cGguaW5kZXggfHwgbGVmdEdseXBoO1xuICAgICAgIHJpZ2h0R2x5cGggPSByaWdodEdseXBoLmluZGV4IHx8IHJpZ2h0R2x5cGg7XG4gICAgICAgdmFyIGdwb3NLZXJuaW5nID0gdGhpcy5wb3NpdGlvbi5kZWZhdWx0S2VybmluZ1RhYmxlcztcbiAgICAgICBpZiAoZ3Bvc0tlcm5pbmcpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlKFxuICAgICAgICAgICAgICAgZ3Bvc0tlcm5pbmcsXG4gICAgICAgICAgICAgICBsZWZ0R2x5cGgsXG4gICAgICAgICAgICAgICByaWdodEdseXBoXG4gICAgICAgICAgICk7XG4gICAgICAgfVxuICAgICAgIC8vIFwia2VyblwiIHRhYmxlXG4gICAgICAgcmV0dXJuIHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDA7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEB0eXBlZGVmIEdseXBoUmVuZGVyT3B0aW9uc1xuICAgICogQHR5cGUgT2JqZWN0XG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NjcmlwdF0gLSBzY3JpcHQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuIEJ5IGRlZmF1bHQsICdERkxUJyBvciAnbGF0bicgaXMgdXNlZC5cbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3NjcmlwdHRhZ3MuaHRtXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J10gLSBsYW5ndWFnZSBzeXN0ZW0gdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L2RldmVsb3BlcnMvb3BlbnR5cGUvbGFuZ3VhZ2V0YWdzLmFzcHhcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlcm5pbmc9dHJ1ZV0gLSB3aGV0aGVyIHRvIGluY2x1ZGUga2VybmluZyB2YWx1ZXNcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZmVhdHVyZXNdIC0gT3BlblR5cGUgTGF5b3V0IGZlYXR1cmUgdGFncy4gVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZmVhdHVyZXMgb2YgdGhlIGdpdmVuIHNjcmlwdC9sYW5ndWFnZSBzeXN0ZW0uXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2ZlYXR1cmV0YWdzLmh0bVxuICAgICovXG4gICBGb250LnByb3RvdHlwZS5kZWZhdWx0UmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgICBrZXJuaW5nOiB0cnVlLFxuICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiB0aGVzZSA0IGZlYXR1cmVzIGFyZSByZXF1aXJlZCB0byByZW5kZXIgQXJhYmljIHRleHQgcHJvcGVybHlcbiAgICAgICAgICAgICogYW5kIHNob3VsZG4ndCBiZSB0dXJuZWQgb2ZmIHdoZW4gcmVuZGVyaW5nIGFyYWJpYyB0ZXh0LlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgeyBzY3JpcHQ6ICdhcmFiJywgdGFnczogWydpbml0JywgJ21lZGknLCAnZmluYScsICdybGlnJ10gfSxcbiAgICAgICAgICAgeyBzY3JpcHQ6ICdsYXRuJywgdGFnczogWydsaWdhJywgJ3JsaWcnXSB9IF0sXG4gICB9O1xuXG4gICAvKipcbiAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGdseXBoIGluIHRoZSBnaXZlbiB0ZXh0LlxuICAgICogVGhlIGNhbGxiYWNrIGdldHMgYChnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpYC4qIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBhcHBseS5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICAgICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgKi9cbiAgIEZvbnQucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uIChcbiAgICAgICB0ZXh0LFxuICAgICAgIHgsXG4gICAgICAgeSxcbiAgICAgICBmb250U2l6ZSxcbiAgICAgICBvcHRpb25zLFxuICAgICAgIGNhbGxiYWNrXG4gICApIHtcbiAgICAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgIHZhciBmb250U2NhbGUgPSAoMSAvIHRoaXMudW5pdHNQZXJFbSkgKiBmb250U2l6ZTtcbiAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5zdHJpbmdUb0dseXBocyh0ZXh0LCBvcHRpb25zKTtcbiAgICAgICB2YXIga2VybmluZ0xvb2t1cHM7XG4gICAgICAgaWYgKG9wdGlvbnMua2VybmluZykge1xuICAgICAgICAgICB2YXIgc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQgfHwgdGhpcy5wb3NpdGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICAgICBrZXJuaW5nTG9va3VwcyA9IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1RhYmxlcyhcbiAgICAgICAgICAgICAgIHNjcmlwdCxcbiAgICAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2VcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZVdpZHRoICogZm9udFNjYWxlO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKG9wdGlvbnMua2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhcHBseSBwb3NpdGlvbiBhZGp1c3RtZW50IGxvb2t1cHMgaW4gYSBtb3JlIGdlbmVyaWMgd2F5LlxuICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBvbmx5IHVzZSB0aGUgeEFkdmFuY2UgdmFsdWUuXG4gICAgICAgICAgICAgICB2YXIga2VybmluZ1ZhbHVlID0ga2VybmluZ0xvb2t1cHNcbiAgICAgICAgICAgICAgICAgICA/IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5pbmdMb29rdXBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGdseXBoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGdseXBoc1tpICsgMV0uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICAgeCArPSBvcHRpb25zLmxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4geDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gICAgKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICAgICovXG4gICBGb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgICAgdmFyIGZ1bGxQYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgICB0aGlzLmZvckVhY2hHbHlwaChcbiAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgeCxcbiAgICAgICAgICAgeSxcbiAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgIGZ1bmN0aW9uIChnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgICAgIGZ1bGxQYXRoLmV4dGVuZChnbHlwaFBhdGgpO1xuICAgICAgICAgICB9XG4gICAgICAgKTtcbiAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIENyZWF0ZSBhbiBhcnJheSBvZiBQYXRoIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGdseXBocyBvZiBhIGdpdmVuIHRleHQuXG4gICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAgICAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge29wZW50eXBlLlBhdGhbXX1cbiAgICAqL1xuICAgRm9udC5wcm90b3R5cGUuZ2V0UGF0aHMgPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICAgICB2YXIgZ2x5cGhQYXRocyA9IFtdO1xuICAgICAgIHRoaXMuZm9yRWFjaEdseXBoKFxuICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICB4LFxuICAgICAgICAgICB5LFxuICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgZnVuY3Rpb24gKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICAgICAgICAgdmFyIGdseXBoUGF0aCA9IGdseXBoLmdldFBhdGgoZ1gsIGdZLCBnRm9udFNpemUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAgICAgICAgZ2x5cGhQYXRocy5wdXNoKGdseXBoUGF0aCk7XG4gICAgICAgICAgIH1cbiAgICAgICApO1xuXG4gICAgICAgcmV0dXJuIGdseXBoUGF0aHM7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFJldHVybnMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgYSB0ZXh0LlxuICAgICpcbiAgICAqIFRoaXMgaXMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIFBhdGguZ2V0Qm91bmRpbmdCb3goKSBhcyBmb3IgZXhhbXBsZSBhXG4gICAgKiBzdWZmaXhlZCB3aGl0ZXNwYWNlIGluY3JlYXNlcyB0aGUgYWR2YW5jZVdpZHRoIGJ1dCBub3QgdGhlIGJvdW5kaW5nIGJveFxuICAgICogb3IgYW4gb3ZlcmhhbmdpbmcgbGV0dGVyIGxpa2UgYSBjYWxsaWdyYXBoaWMgJ2YnIG1pZ2h0IGhhdmUgYSBxdWl0ZSBsYXJnZXJcbiAgICAqIGJvdW5kaW5nIGJveCB0aGFuIGl0cyBhZHZhbmNlIHdpZHRoLlxuICAgICpcbiAgICAqIFRoaXMgY29ycmVzcG9uZHMgdG8gY2FudmFzMmRDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoXG4gICAgKlxuICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAgICAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAgICAqIEByZXR1cm4gYWR2YW5jZSB3aWR0aFxuICAgICovXG4gICBGb250LnByb3RvdHlwZS5nZXRBZHZhbmNlV2lkdGggPSBmdW5jdGlvbiAodGV4dCwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgMCwgMCwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHt9KTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgRm9udC5wcm90b3R5cGUuZnNTZWxlY3Rpb25WYWx1ZXMgPSB7XG4gICAgICAgSVRBTElDOiAweDAwMSwgLy8xXG4gICAgICAgVU5ERVJTQ09SRTogMHgwMDIsIC8vMlxuICAgICAgIE5FR0FUSVZFOiAweDAwNCwgLy80XG4gICAgICAgT1VUTElORUQ6IDB4MDA4LCAvLzhcbiAgICAgICBTVFJJS0VPVVQ6IDB4MDEwLCAvLzE2XG4gICAgICAgQk9MRDogMHgwMjAsIC8vMzJcbiAgICAgICBSRUdVTEFSOiAweDA0MCwgLy82NFxuICAgICAgIFVTRVJfVFlQT19NRVRSSUNTOiAweDA4MCwgLy8xMjhcbiAgICAgICBXV1M6IDB4MTAwLCAvLzI1NlxuICAgICAgIE9CTElRVUU6IDB4MjAwLCAvLzUxMlxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICBGb250LnByb3RvdHlwZS51c1dpZHRoQ2xhc3NlcyA9IHtcbiAgICAgICBVTFRSQV9DT05ERU5TRUQ6IDEsXG4gICAgICAgRVhUUkFfQ09OREVOU0VEOiAyLFxuICAgICAgIENPTkRFTlNFRDogMyxcbiAgICAgICBTRU1JX0NPTkRFTlNFRDogNCxcbiAgICAgICBNRURJVU06IDUsXG4gICAgICAgU0VNSV9FWFBBTkRFRDogNixcbiAgICAgICBFWFBBTkRFRDogNyxcbiAgICAgICBFWFRSQV9FWFBBTkRFRDogOCxcbiAgICAgICBVTFRSQV9FWFBBTkRFRDogOSxcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgRm9udC5wcm90b3R5cGUudXNXZWlnaHRDbGFzc2VzID0ge1xuICAgICAgIFRISU46IDEwMCxcbiAgICAgICBFWFRSQV9MSUdIVDogMjAwLFxuICAgICAgIExJR0hUOiAzMDAsXG4gICAgICAgTk9STUFMOiA0MDAsXG4gICAgICAgTUVESVVNOiA1MDAsXG4gICAgICAgU0VNSV9CT0xEOiA2MDAsXG4gICAgICAgQk9MRDogNzAwLFxuICAgICAgIEVYVFJBX0JPTEQ6IDgwMCxcbiAgICAgICBCTEFDSzogOTAwLFxuICAgfTtcblxuICAgLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG5cbiAgIGZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCkge1xuICAgICAgIC8vU2tpcCByZXNlcnZlZC5cbiAgICAgICBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICAgICB2YXIgZ3JvdXBDb3VudDtcbiAgICAgICBjbWFwLmdyb3VwQ291bnQgPSBncm91cENvdW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgc3RhcnRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICAgICB2YXIgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgICAgdmFyIHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgICAgIGZvciAodmFyIGMgPSBzdGFydENoYXJDb2RlOyBjIDw9IGVuZENoYXJDb2RlOyBjICs9IDEpIHtcbiAgICAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcbiAgICAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCkge1xuICAgICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICAgICB2YXIgc2VnQ291bnQ7XG4gICAgICAgY21hcC5zZWdDb3VudCA9IHNlZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpID4+IDE7XG5cbiAgICAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcbiAgICAgICB2YXIgZW5kQ291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTQpO1xuICAgICAgIHZhciBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihcbiAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogMlxuICAgICAgICk7XG4gICAgICAgdmFyIGlkRGVsdGFQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKFxuICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0XG4gICAgICAgKTtcbiAgICAgICB2YXIgaWRSYW5nZU9mZnNldFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoXG4gICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDZcbiAgICAgICApO1xuICAgICAgIHZhciBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ0NvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgICAgIHZhciBnbHlwaEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICAgICAgIHZhciBlbmRDb3VudCA9IGVuZENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIHZhciBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICB2YXIgaWREZWx0YSA9IGlkRGVsdGFQYXJzZXIucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICB2YXIgaWRSYW5nZU9mZnNldCA9IGlkUmFuZ2VPZmZzZXRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgK1xuICAgICAgICAgICAgICAgICAgICAgICBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgMjtcblxuICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRoZSBjaGFyYWN0ZXIgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2VnbWVudCwgbXVsdGlwbGllZCBieSAyIGZvciBVU0hPUlRzLlxuICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gKGMgLSBzdGFydENvdW50KSAqIDI7XG4gICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBnbHlwaEluZGV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGdseXBoSW5kZXggKyBpZERlbHRhKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoYyArIGlkRGVsdGEpICYgMHhmZmZmO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBnbHlwaEluZGV4O1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgfVxuXG4gICAvLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbiAgIC8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0IGFuZCAxMi5cbiAgIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGBDbWFwRW5jb2RpbmdgIG9iamVjdCBvciBudWxsIGlmIG5vIHN1cHBvcnRlZCBmb3JtYXQgY291bGQgYmUgZm91bmQuXG4gICBmdW5jdGlvbiBwYXJzZUNtYXBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgICAgIHZhciBjbWFwID0ge307XG4gICAgICAgY21hcC52ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICAgICBjaGVjay5hcmd1bWVudChjbWFwLnZlcnNpb24gPT09IDAsICdjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuJyk7XG5cbiAgICAgICAvLyBUaGUgY21hcCB0YWJsZSBjYW4gY29udGFpbiBtYW55IHN1Yi10YWJsZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gZm9ybWF0LlxuICAgICAgIC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBhIFwicGxhdGZvcm0gMFwiIChVbmljb2RlIGZvcm1hdCkgYW5kIFwicGxhdGZvcm0gM1wiIChXaW5kb3dzIGZvcm1hdCkgdGFibGUuXG4gICAgICAgY21hcC5udW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICB2YXIgb2Zmc2V0ID0gLTE7XG4gICAgICAgZm9yICh2YXIgaSA9IGNtYXAubnVtVGFibGVzIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgdmFyIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgaSAqIDgpO1xuICAgICAgICAgICB2YXIgZW5jb2RpbmdJZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyBpICogOCArIDIpO1xuICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAocGxhdGZvcm1JZCA9PT0gMyAmJlxuICAgICAgICAgICAgICAgICAgIChlbmNvZGluZ0lkID09PSAwIHx8IGVuY29kaW5nSWQgPT09IDEgfHwgZW5jb2RpbmdJZCA9PT0gMTApKSB8fFxuICAgICAgICAgICAgICAgKHBsYXRmb3JtSWQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAoZW5jb2RpbmdJZCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0lkID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nSWQgPT09IDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdJZCA9PT0gMyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0lkID09PSA0KSlcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyBpICogOCArIDQpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjbWFwIHRhYmxlIGluIHRoZSBmb250IHRoYXQgd2Ugc3VwcG9ydC5cbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBjbWFwIHN1Yi10YWJsZXMgZm91bmQuJyk7XG4gICAgICAgfVxuXG4gICAgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICBjbWFwLmZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgICAgIGlmIChjbWFwLmZvcm1hdCA9PT0gMTIpIHtcbiAgICAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKTtcbiAgICAgICB9IGVsc2UgaWYgKGNtYXAuZm9ybWF0ID09PSA0KSB7XG4gICAgICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAnT25seSBmb3JtYXQgNCBhbmQgMTIgY21hcCB0YWJsZXMgYXJlIHN1cHBvcnRlZCAoZm91bmQgZm9ybWF0ICcgK1xuICAgICAgICAgICAgICAgICAgIGNtYXAuZm9ybWF0ICtcbiAgICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGNtYXA7XG4gICB9XG5cbiAgIHZhciBjbWFwID0geyBwYXJzZTogcGFyc2VDbWFwVGFibGUgfTtcblxuICAgLy8gVGhlIGBDRkZgIHRhYmxlIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cblxuICAgLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbiAgIC8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuICAgZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgICAgdmFyIGJpYXM7XG4gICAgICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgICAgYmlhcyA9IDEwNztcbiAgICAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgICAgIGJpYXMgPSAxMTMxO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gYmlhcztcbiAgIH1cblxuICAgLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbiAgIC8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG4gICBmdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgIHZhciBvYmplY3RzID0gW107XG4gICAgICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuICAgICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArIChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSArIDI7XG4gICAgICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBpbmRleCBhcnJheSBpcyA0IGhlYWRlciBieXRlcyArIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBvZmZzZXQuXG4gICAgICAgICAgIGVuZE9mZnNldCA9IG9iamVjdE9mZnNldCArIG9mZnNldHNbY291bnRdO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0ICsgMjtcbiAgICAgICB9XG5cbiAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkkMSArPSAxKSB7XG4gICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKFxuICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxXSxcbiAgICAgICAgICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxICsgMV1cbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgb2JqZWN0cy5wdXNoKHZhbHVlKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4geyBvYmplY3RzOiBvYmplY3RzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGSW5kZXhMb3dNZW1vcnkoZGF0YSwgc3RhcnQpIHtcbiAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgICAgdmFyIG9iamVjdE9mZnNldDtcbiAgICAgICB2YXIgZW5kT2Zmc2V0O1xuICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoY291bnQgKyAxKSAqIG9mZnNldFNpemUgKyAyO1xuICAgICAgICAgICB2YXIgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gocGFyc2UuZ2V0T2Zmc2V0KGRhdGEsIHBvcywgb2Zmc2V0U2l6ZSkpO1xuICAgICAgICAgICAgICAgcG9zICs9IG9mZnNldFNpemU7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHsgb2Zmc2V0czogb2Zmc2V0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xuICAgfVxuICAgZnVuY3Rpb24gZ2V0Q2ZmSW5kZXhPYmplY3QoaSwgb2Zmc2V0cywgZGF0YSwgc3RhcnQsIGNvbnZlcnNpb25Gbikge1xuICAgICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgICAgdmFyIG9iamVjdE9mZnNldCA9IDA7XG4gICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArIChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSArIDI7XG4gICAgICAgfVxuXG4gICAgICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoXG4gICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sXG4gICAgICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdXG4gICAgICAgKTtcbiAgICAgICBpZiAoY29udmVyc2lvbkZuKSB7XG4gICAgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHZhbHVlO1xuICAgfVxuXG4gICAvLyBQYXJzZSBhIGBDRkZgIERJQ1QgcmVhbCB2YWx1ZS5cbiAgIGZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcikge1xuICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgdmFyIGVvZiA9IDE1O1xuICAgICAgIHZhciBsb29rdXAgPSBbXG4gICAgICAgICAgICcwJyxcbiAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAnMicsXG4gICAgICAgICAgICczJyxcbiAgICAgICAgICAgJzQnLFxuICAgICAgICAgICAnNScsXG4gICAgICAgICAgICc2JyxcbiAgICAgICAgICAgJzcnLFxuICAgICAgICAgICAnOCcsXG4gICAgICAgICAgICc5JyxcbiAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAnRScsXG4gICAgICAgICAgICdFLScsXG4gICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICctJyBdO1xuICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgIHZhciBiID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICB2YXIgbjEgPSBiID4+IDQ7XG4gICAgICAgICAgIHZhciBuMiA9IGIgJiAxNTtcblxuICAgICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBzICs9IGxvb2t1cFtuMV07XG5cbiAgICAgICAgICAgaWYgKG4yID09PSBlb2YpIHtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcyArPSBsb29rdXBbbjJdO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xuICAgfVxuXG4gICAvLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbiAgIGZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgICAgdmFyIGIxO1xuICAgICAgIHZhciBiMjtcbiAgICAgICB2YXIgYjM7XG4gICAgICAgdmFyIGI0O1xuICAgICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICByZXR1cm4gKGIxIDw8IDgpIHwgYjI7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGIwID09PSAyOSkge1xuICAgICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgICAgIGIzID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICBiNCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgcmV0dXJuIChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQ7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoYjAgPj0gMzIgJiYgYjAgPD0gMjQ2KSB7XG4gICAgICAgICAgIHJldHVybiBiMCAtIDEzOTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoYjAgPj0gMjQ3ICYmIGIwIDw9IDI1MCkge1xuICAgICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgcmV0dXJuIChiMCAtIDI0NykgKiAyNTYgKyBiMSArIDEwODtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgICAgfVxuXG4gICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGIwICcgKyBiMCk7XG4gICB9XG5cbiAgIC8vIENvbnZlcnQgdGhlIGVudHJpZXMgcmV0dXJuZWQgYnkgYHBhcnNlRGljdGAgdG8gYSBwcm9wZXIgZGljdGlvbmFyeS5cbiAgIC8vIElmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIG9uZSwgaXQgaXMgdW5wYWNrZWQuXG4gICBmdW5jdGlvbiBlbnRyaWVzVG9PYmplY3QoZW50cmllcykge1xuICAgICAgIHZhciBvID0ge307XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICAgICB2YXIgdmFsdWVzID0gZW50cmllc1tpXVsxXTtcbiAgICAgICAgICAgdmFyIHZhbHVlID0gKHZvaWQgMCk7XG4gICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhaXNOYU4ob1trZXldKSkge1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgJyArIG8gKyAnIGFscmVhZHkgaGFzIGtleSAnICsga2V5KTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBvO1xuICAgfVxuXG4gICAvLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb2JqZWN0LlxuICAgLy8gQSBkaWN0aW9uYXJ5IGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBpbiBhIGNvbXBhY3QgdG9rZW5pemVkIGZvcm1hdC5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSkge1xuICAgICAgIHN0YXJ0ID0gc3RhcnQgIT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogMDtcbiAgICAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICB2YXIgb3BlcmFuZHMgPSBbXTtcbiAgICAgICBzaXplID0gc2l6ZSAhPT0gdW5kZWZpbmVkID8gc2l6ZSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgd2hpbGUgKHBhcnNlci5yZWxhdGl2ZU9mZnNldCA8IHNpemUpIHtcbiAgICAgICAgICAgdmFyIG9wID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXG4gICAgICAgICAgIC8vIFRoZSBmaXJzdCBieXRlIGZvciBlYWNoIGRpY3QgaXRlbSBkaXN0aW5ndWlzaGVzIGJldHdlZW4gb3BlcmF0b3IgKGtleSkgYW5kIG9wZXJhbmQgKHZhbHVlKS5cbiAgICAgICAgICAgLy8gVmFsdWVzIDw9IDIxIGFyZSBvcGVyYXRvcnMuXG4gICAgICAgICAgIGlmIChvcCA8PSAyMSkge1xuICAgICAgICAgICAgICAgLy8gVHdvLWJ5dGUgb3BlcmF0b3JzIGhhdmUgYW4gaW5pdGlhbCBlc2NhcGUgYnl0ZSBvZiAxMi5cbiAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICBvcCA9IDEyMDAgKyBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG4gICAgICAgICAgICAgICBvcGVyYW5kcyA9IFtdO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG4gICAgICAgICAgICAgICAvLyB1bnRpbCB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0b3IuXG4gICAgICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpO1xuICAgfVxuXG4gICAvLyBHaXZlbiBhIFN0cmluZyBJbmRleCAoU0lEKSwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgc3RyaW5nLlxuICAgLy8gU3RyaW5ncyBiZWxvdyBpbmRleCAzOTIgYXJlIHN0YW5kYXJkIENGRiBzdHJpbmdzIGFuZCBhcmUgbm90IGVuY29kZWQgaW4gdGhlIGZvbnQuXG4gICBmdW5jdGlvbiBnZXRDRkZTdHJpbmcoc3RyaW5ncywgaW5kZXgpIHtcbiAgICAgICBpZiAoaW5kZXggPD0gMzkwKSB7XG4gICAgICAgICAgIGluZGV4ID0gY2ZmU3RhbmRhcmRTdHJpbmdzW2luZGV4XTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBpbmRleCA9IHN0cmluZ3NbaW5kZXggLSAzOTFdO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBpbmRleDtcbiAgIH1cblxuICAgLy8gSW50ZXJwcmV0IGEgZGljdGlvbmFyeSBhbmQgcmV0dXJuIGEgbmV3IGRpY3Rpb25hcnkgd2l0aCByZWFkYWJsZSBrZXlzIGFuZCB2YWx1ZXMgZm9yIG1pc3NpbmcgZW50cmllcy5cbiAgIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYG1ldGFgIHdoaWNoIGlzIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYG9wZXJhbmRgLCBgbmFtZWAgYW5kIGBkZWZhdWx0YC5cbiAgIGZ1bmN0aW9uIGludGVycHJldERpY3QoZGljdCwgbWV0YSwgc3RyaW5ncykge1xuICAgICAgIHZhciBuZXdEaWN0ID0ge307XG4gICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgLy8gQmVjYXVzZSB3ZSBhbHNvIHdhbnQgdG8gaW5jbHVkZSBtaXNzaW5nIHZhbHVlcywgd2Ugc3RhcnQgb3V0IGZyb20gdGhlIG1ldGEgbGlzdFxuICAgICAgIC8vIGFuZCBsb29rdXAgdmFsdWVzIGluIHRoZSBkaWN0LlxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgbSA9IG1ldGFbaV07XG5cbiAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobS50eXBlKSkge1xuICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCA9IG0udHlwZS5sZW5ndGg7XG4gICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG0udHlwZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGljdFttLm9wXSAhPT0gdW5kZWZpbmVkID8gZGljdFttLm9wXVtqXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgbS52YWx1ZVtqXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtLnZhbHVlW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBpZiAobS50eXBlW2pdID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldENGRlN0cmluZyhzdHJpbmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHZhbHVlc1tqXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWVzO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdO1xuICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBpZiAobS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIG5ld0RpY3Q7XG4gICB9XG5cbiAgIC8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuICAgZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICAgICB2YXIgaGVhZGVyID0ge307XG4gICAgICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgICAgIHJldHVybiBoZWFkZXI7XG4gICB9XG5cbiAgIHZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgICAgIHsgbmFtZTogJ3ZlcnNpb24nLCBvcDogMCwgdHlwZTogJ1NJRCcgfSxcbiAgICAgICB7IG5hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCcgfSxcbiAgICAgICB7IG5hbWU6ICdjb3B5cmlnaHQnLCBvcDogMTIwMCwgdHlwZTogJ1NJRCcgfSxcbiAgICAgICB7IG5hbWU6ICdmdWxsTmFtZScsIG9wOiAyLCB0eXBlOiAnU0lEJyB9LFxuICAgICAgIHsgbmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCcgfSxcbiAgICAgICB7IG5hbWU6ICd3ZWlnaHQnLCBvcDogNCwgdHlwZTogJ1NJRCcgfSxcbiAgICAgICB7IG5hbWU6ICdpc0ZpeGVkUGl0Y2gnLCBvcDogMTIwMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgICAgeyBuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgICAgeyBuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCBvcDogMTIwMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAtMTAwIH0sXG4gICAgICAgeyBuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgb3A6IDEyMDQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogNTAgfSxcbiAgICAgICB7IG5hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgICAgeyBuYW1lOiAnY2hhcnN0cmluZ1R5cGUnLCBvcDogMTIwNiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAyIH0sXG4gICAgICAge1xuICAgICAgICAgICBuYW1lOiAnZm9udE1hdHJpeCcsXG4gICAgICAgICAgIG9wOiAxMjA3LFxuICAgICAgICAgICB0eXBlOiBbJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJ10sXG4gICAgICAgICAgIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXSxcbiAgICAgICB9LFxuICAgICAgIHsgbmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgIHtcbiAgICAgICAgICAgbmFtZTogJ2ZvbnRCQm94JyxcbiAgICAgICAgICAgb3A6IDUsXG4gICAgICAgICAgIHR5cGU6IFsnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJ10sXG4gICAgICAgICAgIHZhbHVlOiBbMCwgMCwgMCwgMF0sXG4gICAgICAgfSxcbiAgICAgICB7IG5hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICAgICB7IG5hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGwgfSxcbiAgICAgICB7IG5hbWU6ICdjaGFyc2V0Jywgb3A6IDE1LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDAgfSxcbiAgICAgICB7IG5hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwIH0sXG4gICAgICAgeyBuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMCB9LFxuICAgICAgIHsgbmFtZTogJ3ByaXZhdGUnLCBvcDogMTgsIHR5cGU6IFsnbnVtYmVyJywgJ29mZnNldCddLCB2YWx1ZTogWzAsIDBdIH0sXG4gICAgICAgeyBuYW1lOiAncm9zJywgb3A6IDEyMzAsIHR5cGU6IFsnU0lEJywgJ1NJRCcsICdudW1iZXInXSB9LFxuICAgICAgIHsgbmFtZTogJ2NpZEZvbnRWZXJzaW9uJywgb3A6IDEyMzEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgICAgIHsgbmFtZTogJ2NpZEZvbnRSZXZpc2lvbicsIG9wOiAxMjMyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICAgICB7IG5hbWU6ICdjaWRGb250VHlwZScsIG9wOiAxMjMzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICAgICB7IG5hbWU6ICdjaWRDb3VudCcsIG9wOiAxMjM0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDg3MjAgfSxcbiAgICAgICB7IG5hbWU6ICd1aWRCYXNlJywgb3A6IDEyMzUsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgeyBuYW1lOiAnZmRBcnJheScsIG9wOiAxMjM2LCB0eXBlOiAnb2Zmc2V0JyB9LFxuICAgICAgIHsgbmFtZTogJ2ZkU2VsZWN0Jywgb3A6IDEyMzcsIHR5cGU6ICdvZmZzZXQnIH0sXG4gICAgICAgeyBuYW1lOiAnZm9udE5hbWUnLCBvcDogMTIzOCwgdHlwZTogJ1NJRCcgfSBdO1xuXG4gICB2YXIgUFJJVkFURV9ESUNUX01FVEEgPSBbXG4gICAgICAgeyBuYW1lOiAnc3VicnMnLCBvcDogMTksIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMCB9LFxuICAgICAgIHsgbmFtZTogJ2RlZmF1bHRXaWR0aFgnLCBvcDogMjAsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgICAgIHsgbmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9IF07XG5cbiAgIC8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuICAgLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG4gICBmdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgVE9QX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG4gICB9XG5cbiAgIC8vIFBhcnNlIHRoZSBDRkYgcHJpdmF0ZSBkaWN0aW9uYXJ5LiBXZSBkb24ndCBmdWxseSBwYXJzZSBvdXQgYWxsIHRoZSB2YWx1ZXMsIG9ubHkgdGhlIG9uZXMgd2UgbmVlZC5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgc3RhcnQsIHNpemUsIHN0cmluZ3MpIHtcbiAgICAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSk7XG4gICAgICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgUFJJVkFURV9ESUNUX01FVEEsIHN0cmluZ3MpO1xuICAgfVxuXG4gICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBcIlRvcCBESUNUXCJzIGZvdW5kIHVzaW5nIGFuIElOREVYIGxpc3QuXG4gICAvLyBVc2VkIHRvIHJlYWQgYm90aCB0aGUgdXN1YWwgaGlnaC1sZXZlbCBUb3AgRElDVHMgYW5kIGFsc28gdGhlIEZEQXJyYXlcbiAgIC8vIGRpc2NvdmVyZWQgaW5zaWRlIENJRC1rZXllZCBmb250cy4gIFdoZW4gYSBUb3AgRElDVCBoYXMgYSByZWZlcmVuY2UgdG9cbiAgIC8vIGEgUHJpdmF0ZSBESUNUIHRoYXQgaXMgcmVhZCBhbmQgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG4gICAvL1xuICAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGV4cGVjdGVkL29wdGlvbmFsIHZhbHVlcyBhcyBvdXRsaW5lZCBpbiBUT1BfRElDVF9NRVRBXG4gICAvLyB0aGUgZm9sbG93aW5nIHZhbHVlcyBtaWdodCBiZSBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbiAgIC8vXG4gICAvLyAgICBfc3VicnMgW10gICAgICAgIGFycmF5IG9mIGxvY2FsIENGRiBzdWJyb3V0aW5lcyBmcm9tIFByaXZhdGUgRElDVFxuICAgLy8gICAgX3N1YnJzQmlhcyAgICAgICBiaWFzIHZhbHVlIGNvbXB1dGVkIGZyb20gbnVtYmVyIG9mIHN1YnJvdXRpbmVzXG4gICAvLyAgICAgICAgICAgICAgICAgICAgICAoc2VlIGNhbGNDRkZTdWJyb3V0aW5lQmlhcygpIGFuZCBwYXJzZUNGRkNoYXJzdHJpbmcoKSlcbiAgIC8vICAgIF9kZWZhdWx0V2lkdGhYICAgZGVmYXVsdCB3aWR0aHMgZm9yIENGRiBjaGFyYWN0ZXJzXG4gICAvLyAgICBfbm9taW5hbFdpZHRoWCAgIGJpYXMgYWRkZWQgdG8gd2lkdGggZW1iZWRkZWQgd2l0aGluIGdseXBoIGRlc2NyaXB0aW9uXG4gICAvL1xuICAgLy8gICAgX3ByaXZhdGVEaWN0ICAgICBzYXZlZCBjb3B5IG9mIHBhcnNlZCBQcml2YXRlIERJQ1QgZnJvbSBUb3AgRElDVFxuICAgZnVuY3Rpb24gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGNmZkluZGV4LCBzdHJpbmdzKSB7XG4gICAgICAgdmFyIHRvcERpY3RBcnJheSA9IFtdO1xuICAgICAgIGZvciAodmFyIGlUb3BEaWN0ID0gMDsgaVRvcERpY3QgPCBjZmZJbmRleC5sZW5ndGg7IGlUb3BEaWN0ICs9IDEpIHtcbiAgICAgICAgICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY2ZmSW5kZXhbaVRvcERpY3RdKS5idWZmZXJcbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgdmFyIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ3MpO1xuICAgICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IFtdO1xuICAgICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSAwO1xuICAgICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gMDtcbiAgICAgICAgICAgdG9wRGljdC5fbm9taW5hbFdpZHRoWCA9IDA7XG4gICAgICAgICAgIHZhciBwcml2YXRlU2l6ZSA9IHRvcERpY3QucHJpdmF0ZVswXTtcbiAgICAgICAgICAgdmFyIHByaXZhdGVPZmZzZXQgPSB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgICAgICAgIGlmIChwcml2YXRlU2l6ZSAhPT0gMCAmJiBwcml2YXRlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KFxuICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgcHJpdmF0ZU9mZnNldCArIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgIHByaXZhdGVTaXplLFxuICAgICAgICAgICAgICAgICAgIHN0cmluZ3NcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgICAgICAgIHRvcERpY3QuX25vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlT2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG4gICAgICAgICAgICAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCArIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyh0b3BEaWN0Ll9zdWJycyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB0b3BEaWN0Ll9wcml2YXRlRGljdCA9IHByaXZhdGVEaWN0O1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHRvcERpY3RBcnJheS5wdXNoKHRvcERpY3QpO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gdG9wRGljdEFycmF5O1xuICAgfVxuXG4gICAvLyBQYXJzZSB0aGUgQ0ZGIGNoYXJzZXQgdGFibGUsIHdoaWNoIGNvbnRhaW5zIGludGVybmFsIG5hbWVzIGZvciBhbGwgdGhlIGdseXBocy5cbiAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBsaXN0IG9mIGdseXBoIG5hbWVzLlxuICAgLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTMsIFwiQ2hhcnNldHNcIi5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCwgbkdseXBocywgc3RyaW5ncykge1xuICAgICAgIHZhciBzaWQ7XG4gICAgICAgdmFyIGNvdW50O1xuICAgICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblxuICAgICAgIC8vIFRoZSAubm90ZGVmIGdseXBoIGlzIG5vdCBpbmNsdWRlZCwgc28gc3VidHJhY3QgMS5cbiAgICAgICBuR2x5cGhzIC09IDE7XG4gICAgICAgdmFyIGNoYXJzZXQgPSBbJy5ub3RkZWYnXTtcblxuICAgICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgfVxuICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8PSBjb3VudDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8PSBjb3VudDsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBjaGFyc2V0O1xuICAgfVxuXG4gICAvLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4gICAvLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICAgICB2YXIgY29kZTtcbiAgICAgICB2YXIgZW5jID0ge307XG4gICAgICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgdmFyIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkNvZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcbiAgICAgICAgICAgfVxuICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgY29kZSA9IDE7XG4gICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG5SYW5nZXM7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgICAgdmFyIG5MZWZ0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIG5ldyBDZmZFbmNvZGluZyhlbmMsIGNoYXJzZXQpO1xuICAgfVxuXG4gICAvLyBUYWtlIGluIGNoYXJzdHJpbmcgY29kZSBhbmQgcmV0dXJuIGEgR2x5cGggb2JqZWN0LlxuICAgLy8gVGhlIGVuY29kaW5nIGlzIGRlc2NyaWJlZCBpbiB0aGUgVHlwZSAyIENoYXJzdHJpbmcgRm9ybWF0XG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXJzdHIyLmh0bVxuICAgZnVuY3Rpb24gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjb2RlKSB7XG4gICAgICAgdmFyIGMxeDtcbiAgICAgICB2YXIgYzF5O1xuICAgICAgIHZhciBjMng7XG4gICAgICAgdmFyIGMyeTtcbiAgICAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgdmFyIG5TdGVtcyA9IDA7XG4gICAgICAgdmFyIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgICAgdmFyIHggPSAwO1xuICAgICAgIHZhciB5ID0gMDtcbiAgICAgICB2YXIgc3VicnM7XG4gICAgICAgdmFyIHN1YnJzQmlhcztcbiAgICAgICB2YXIgZGVmYXVsdFdpZHRoWDtcbiAgICAgICB2YXIgbm9taW5hbFdpZHRoWDtcbiAgICAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgICAgdmFyIGZkSW5kZXggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRTZWxlY3RbZ2x5cGguaW5kZXhdO1xuICAgICAgICAgICB2YXIgZmREaWN0ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkQXJyYXlbZmRJbmRleF07XG4gICAgICAgICAgIHN1YnJzID0gZmREaWN0Ll9zdWJycztcbiAgICAgICAgICAgc3VicnNCaWFzID0gZmREaWN0Ll9zdWJyc0JpYXM7XG4gICAgICAgICAgIGRlZmF1bHRXaWR0aFggPSBmZERpY3QuX2RlZmF1bHRXaWR0aFg7XG4gICAgICAgICAgIG5vbWluYWxXaWR0aFggPSBmZERpY3QuX25vbWluYWxXaWR0aFg7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgc3VicnMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnM7XG4gICAgICAgICAgIHN1YnJzQmlhcyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJyc0JpYXM7XG4gICAgICAgICAgIGRlZmF1bHRXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9ub21pbmFsV2lkdGhYO1xuICAgICAgIH1cbiAgICAgICB2YXIgd2lkdGggPSBkZWZhdWx0V2lkdGhYO1xuXG4gICAgICAgZnVuY3Rpb24gbmV3Q29udG91cih4LCB5KSB7XG4gICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgIH1cblxuICAgICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgICAgIHZhciBoYXNXaWR0aEFyZztcblxuICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cbiAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHVuZXZlbiwgdGhhdCBtZWFucyBhIHdpZHRoIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgaGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuICAgICAgICAgICBpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIG5TdGVtcyArPSBzdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICB9XG5cbiAgICAgICBmdW5jdGlvbiBwYXJzZShjb2RlKSB7XG4gICAgICAgICAgIHZhciBiMTtcbiAgICAgICAgICAgdmFyIGIyO1xuICAgICAgICAgICB2YXIgYjM7XG4gICAgICAgICAgIHZhciBiNDtcbiAgICAgICAgICAgdmFyIGNvZGVJbmRleDtcbiAgICAgICAgICAgdmFyIHN1YnJDb2RlO1xuICAgICAgICAgICB2YXIganB4O1xuICAgICAgICAgICB2YXIganB5O1xuICAgICAgICAgICB2YXIgYzN4O1xuICAgICAgICAgICB2YXIgYzN5O1xuICAgICAgICAgICB2YXIgYzR4O1xuICAgICAgICAgICB2YXIgYzR5O1xuXG4gICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgd2hpbGUgKGkgPCBjb2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgdmFyIHYgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHJsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSA2OiAvLyBobGluZXRvXG4gICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDc6IC8vIHZsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgODogLy8gcnJjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiAvLyBjYWxsc3ViclxuICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIHN1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBzdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IC8vIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgY2FzZSAxMjogLy8gZmxleCBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM1OiAvLyBmbGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGR4NiBkeTYgZmQgZmxleCAoMTIgMzUpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7IC8vIGZsZXggZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OiAvLyBoZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR4NiBoZmxleCAoMTIgMzQpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7IC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSB5OyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNjogLy8gaGZsZXgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR5NSBkeDYgaGZsZXgxICgxMiAzNikgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZDYgZmxleDEgKDEyIDM3KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGM0eCAtIHgpID4gTWF0aC5hYnMoYzR5IC0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0dseXBoICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGguaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogdW5rbm93biBvcGVyYXRvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyMDAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiAvLyBlbmRjaGFyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiAvLyBoc3RlbWhtXG4gICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAxOTogLy8gaGludG1hc2tcbiAgICAgICAgICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGkgKz0gKG5TdGVtcyArIDcpID4+IDM7XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6IC8vIHJtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDIgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAyMzogLy8gdnN0ZW1obVxuICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6IC8vIHJjdXJ2ZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAyNTogLy8gcmxpbmVjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuZ3N1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBmb250LmdzdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgY2FzZSAzMTogLy8gaHZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjQ3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHYgLSAxMzkpO1xuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goLSh2IC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiMyA9IGNvZGVbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQpIC8gNjU1MzZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIHBhcnNlKGNvZGUpO1xuXG4gICAgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gd2lkdGg7XG4gICAgICAgcmV0dXJuIHA7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIGZkQXJyYXlDb3VudCkge1xuICAgICAgIHZhciBmZFNlbGVjdCA9IFtdO1xuICAgICAgIHZhciBmZEluZGV4O1xuICAgICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgICAgIC8vIFNpbXBsZSBsaXN0IG9mIG5HbHlwaHMgZWxlbWVudHNcbiAgICAgICAgICAgZm9yICh2YXIgaUdpZCA9IDA7IGlHaWQgPCBuR2x5cGhzOyBpR2lkKyspIHtcbiAgICAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAnQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmZEluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICcgKEZEIGNvdW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZmRBcnJheUNvdW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICAgICB9XG4gICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMpIHtcbiAgICAgICAgICAgLy8gUmFuZ2VzXG4gICAgICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICBpZiAoZmlyc3QgIT09IDApIHtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAnQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgaW5pdGlhbCBHSUQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGZpcnN0XG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHZhciBuZXh0O1xuICAgICAgICAgICBmb3IgKHZhciBpUmFuZ2UgPSAwOyBpUmFuZ2UgPCBuUmFuZ2VzOyBpUmFuZ2UrKykge1xuICAgICAgICAgICAgICAgZmRJbmRleCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICAgICBuZXh0ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICdDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZkSW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAoRkQgY291bnQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmZEFycmF5Q291bnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChuZXh0ID4gbkdseXBocykge1xuICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIEdJRCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZm9yICg7IGZpcnN0IDwgbmV4dDsgZmlyc3QrKykge1xuICAgICAgICAgICAgICAgICAgIGZkU2VsZWN0LnB1c2goZmRJbmRleCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBmaXJzdCA9IG5leHQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgaWYgKG5leHQgIT09IG5HbHlwaHMpIHtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAnQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgZmluYWwgR0lEICcgK1xuICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICB9XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCB0YWJsZSBoYXMgdW5zdXBwb3J0ZWQgZm9ybWF0ICcgKyBmb3JtYXRcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGZkU2VsZWN0O1xuICAgfVxuXG4gICAvLyBQYXJzZSB0aGUgYENGRmAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cbiAgIGZ1bmN0aW9uIHBhcnNlQ0ZGVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQsIG9wdCkge1xuICAgICAgIGZvbnQudGFibGVzLmNmZiA9IHt9O1xuICAgICAgIHZhciBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgICAgdmFyIG5hbWVJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoXG4gICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgIGhlYWRlci5lbmRPZmZzZXQsXG4gICAgICAgICAgIHBhcnNlLmJ5dGVzVG9TdHJpbmdcbiAgICAgICApO1xuICAgICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgICAgIHZhciBzdHJpbmdJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoXG4gICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgIHRvcERpY3RJbmRleC5lbmRPZmZzZXQsXG4gICAgICAgICAgIHBhcnNlLmJ5dGVzVG9TdHJpbmdcbiAgICAgICApO1xuICAgICAgIHZhciBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgICAgdmFyIHRvcERpY3RBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKFxuICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgdG9wRGljdEluZGV4Lm9iamVjdHMsXG4gICAgICAgICAgIHN0cmluZ0luZGV4Lm9iamVjdHNcbiAgICAgICApO1xuICAgICAgIGlmICh0b3BEaWN0QXJyYXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgIFwiQ0ZGIHRhYmxlIGhhcyB0b28gbWFueSBmb250cyBpbiAnRm9udFNldCcgLSBjb3VudCBvZiBmb250cyBOYW1lSW5kZXgubGVuZ3RoID0gXCIgK1xuICAgICAgICAgICAgICAgICAgIHRvcERpY3RBcnJheS5sZW5ndGhcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgdG9wRGljdCA9IHRvcERpY3RBcnJheVswXTtcbiAgICAgICBmb250LnRhYmxlcy5jZmYudG9wRGljdCA9IHRvcERpY3Q7XG5cbiAgICAgICBpZiAodG9wRGljdC5fcHJpdmF0ZURpY3QpIHtcbiAgICAgICAgICAgZm9udC5kZWZhdWx0V2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgICAgZm9udC5ub21pbmFsV2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcbiAgICAgICB9XG5cbiAgICAgICBpZiAodG9wRGljdC5yb3NbMF0gIT09IHVuZGVmaW5lZCAmJiB0b3BEaWN0LnJvc1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgIGZvbnQuaXNDSURGb250ID0gdHJ1ZTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgICAgdmFyIGZkQXJyYXlPZmZzZXQgPSB0b3BEaWN0LmZkQXJyYXk7XG4gICAgICAgICAgIHZhciBmZFNlbGVjdE9mZnNldCA9IHRvcERpY3QuZmRTZWxlY3Q7XG4gICAgICAgICAgIGlmIChmZEFycmF5T2Zmc2V0ID09PSAwIHx8IGZkU2VsZWN0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgJ0ZvbnQgaXMgbWFya2VkIGFzIGEgQ0lEIGZvbnQsIGJ1dCBGREFycmF5IGFuZC9vciBGRFNlbGVjdCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nJ1xuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBmZEFycmF5T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICAgICB2YXIgZmRBcnJheUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBmZEFycmF5T2Zmc2V0KTtcbiAgICAgICAgICAgdmFyIGZkQXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhcbiAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgIGZkQXJyYXlJbmRleC5vYmplY3RzLFxuICAgICAgICAgICAgICAgc3RyaW5nSW5kZXgub2JqZWN0c1xuICAgICAgICAgICApO1xuICAgICAgICAgICB0b3BEaWN0Ll9mZEFycmF5ID0gZmRBcnJheTtcbiAgICAgICAgICAgZmRTZWxlY3RPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgICAgIHRvcERpY3QuX2ZkU2VsZWN0ID0gcGFyc2VDRkZGRFNlbGVjdChcbiAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICBmZFNlbGVjdE9mZnNldCxcbiAgICAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzLFxuICAgICAgICAgICAgICAgZmRBcnJheS5sZW5ndGhcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgcHJpdmF0ZURpY3RPZmZzZXQgPSBzdGFydCArIHRvcERpY3QucHJpdmF0ZVsxXTtcbiAgICAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KFxuICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICBwcml2YXRlRGljdE9mZnNldCxcbiAgICAgICAgICAgdG9wRGljdC5wcml2YXRlWzBdLFxuICAgICAgICAgICBzdHJpbmdJbmRleC5vYmplY3RzXG4gICAgICAgKTtcbiAgICAgICBmb250LmRlZmF1bHRXaWR0aFggPSBwcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG5cbiAgICAgICBpZiAocHJpdmF0ZURpY3Quc3VicnMgIT09IDApIHtcbiAgICAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlRGljdE9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICAgICB9XG5cbiAgICAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICAgICB2YXIgY2hhclN0cmluZ3NJbmRleDtcbiAgICAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuICAgICAgICAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleExvd01lbW9yeShcbiAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3NcbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgICAgICAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHMubGVuZ3RoO1xuICAgICAgIH1cblxuICAgICAgIHZhciBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KFxuICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICBzdGFydCArIHRvcERpY3QuY2hhcnNldCxcbiAgICAgICAgICAgZm9udC5uR2x5cGhzLFxuICAgICAgICAgICBzdHJpbmdJbmRleC5vYmplY3RzXG4gICAgICAgKTtcbiAgICAgICBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgICAvLyBTdGFuZGFyZCBlbmNvZGluZ1xuICAgICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZlN0YW5kYXJkRW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgICAgIH0gZWxzZSBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgICAvLyBFeHBlcnQgZW5jb2RpbmdcbiAgICAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZFeHBlcnRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IHBhcnNlQ0ZGRW5jb2RpbmcoXG4gICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgc3RhcnQgKyB0b3BEaWN0LmVuY29kaW5nLFxuICAgICAgICAgICAgICAgY2hhcnNldFxuICAgICAgICAgICApO1xuICAgICAgIH1cblxuICAgICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuICAgICAgIGZvbnQuZW5jb2RpbmcgPSBmb250LmVuY29kaW5nIHx8IGZvbnQuY2ZmRW5jb2Rpbmc7XG5cbiAgICAgICBmb250LmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcbiAgICAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuICAgICAgICAgICBmb250Ll9wdXNoID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgIHZhciBjaGFyU3RyaW5nID0gZ2V0Q2ZmSW5kZXhPYmplY3QoXG4gICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICBjaGFyU3RyaW5nc0luZGV4Lm9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3NcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICBmb250LmdseXBocy5wdXNoKFxuICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgZ2x5cGhzZXQuY2ZmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyU3RyaW5nKVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgfTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICB2YXIgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgICAgICAgIGZvbnQuZ2x5cGhzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgfVxuXG4gICB2YXIgY2ZmID0geyBwYXJzZTogcGFyc2VDRkZUYWJsZSB9O1xuXG4gICAvLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG5cbiAgIGZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgICAgdmFyIGF4aXMgPSB7fTtcbiAgICAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuICAgICAgIGF4aXMubWluVmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICAgICBheGlzLmRlZmF1bHRWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG4gICAgICAgYXhpcy5uYW1lID0gbmFtZXNbcC5wYXJzZVVTaG9ydCgpXSB8fCB7fTtcbiAgICAgICByZXR1cm4gYXhpcztcbiAgIH1cblxuICAgZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG4gICAgICAgdmFyIGluc3QgPSB7fTtcbiAgICAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuXG4gICAgICAgaW5zdC5jb29yZGluYXRlcyA9IHt9O1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICBpbnN0LmNvb3JkaW5hdGVzW2F4ZXNbaV0udGFnXSA9IHAucGFyc2VGaXhlZCgpO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBpbnN0O1xuICAgfVxuXG4gICBmdW5jdGlvbiBwYXJzZUZ2YXJUYWJsZShkYXRhLCBzdGFydCwgbmFtZXMpIHtcbiAgICAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgICAgdGFibGVWZXJzaW9uID09PSAweDAwMDEwMDAwLFxuICAgICAgICAgICAnVW5zdXBwb3J0ZWQgZnZhciB0YWJsZSB2ZXJzaW9uLidcbiAgICAgICApO1xuICAgICAgIHZhciBvZmZzZXRUb0RhdGEgPSBwLnBhcnNlT2Zmc2V0MTYoKTtcbiAgICAgICAvLyBTa2lwIGNvdW50U2l6ZVBhaXJzLlxuICAgICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgICAgdmFyIGF4aXNDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICB2YXIgYXhpc1NpemUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgdmFyIGluc3RhbmNlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgdmFyIGluc3RhbmNlU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgICAgIHZhciBheGVzID0gW107XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGlzQ291bnQ7IGkrKykge1xuICAgICAgICAgICBheGVzLnB1c2goXG4gICAgICAgICAgICAgICBwYXJzZUZ2YXJBeGlzKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0VG9EYXRhICsgaSAqIGF4aXNTaXplLCBuYW1lcylcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgICAgdmFyIGluc3RhbmNlU3RhcnQgPSBzdGFydCArIG9mZnNldFRvRGF0YSArIGF4aXNDb3VudCAqIGF4aXNTaXplO1xuICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5zdGFuY2VDb3VudDsgaisrKSB7XG4gICAgICAgICAgIGluc3RhbmNlcy5wdXNoKFxuICAgICAgICAgICAgICAgcGFyc2VGdmFySW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICBheGVzLFxuICAgICAgICAgICAgICAgICAgIG5hbWVzXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHsgYXhlczogYXhlcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcbiAgIH1cblxuICAgdmFyIGZ2YXIgPSB7IHBhcnNlOiBwYXJzZUZ2YXJUYWJsZSB9O1xuXG4gICAvLyBUaGUgYEdERUZgIHRhYmxlIGNvbnRhaW5zIHZhcmlvdXMgZ2x5cGggcHJvcGVydGllc1xuXG4gICB2YXIgYXR0YWNoTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHJldHVybiB7XG4gICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICBhdHRhY2hQb2ludHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci51U2hvcnRMaXN0KSlcbiAgICAgICB9O1xuICAgfTtcblxuICAgdmFyIGNhcmV0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGNoZWNrLmFyZ3VtZW50KGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIgfHwgZm9ybWF0ID09PSAzLFxuICAgICAgICAgICAnVW5zdXBwb3J0ZWQgQ2FyZXRWYWx1ZSB0YWJsZSB2ZXJzaW9uLicpO1xuICAgICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZTogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICAgICByZXR1cm4geyBwb2ludGluZGV4OiB0aGlzLnBhcnNlU2hvcnQoKSB9O1xuICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG4gICAgICAgICAgIC8vIERldmljZSAvIFZhcmlhdGlvbiBJbmRleCB0YWJsZXMgdW5zdXBwb3J0ZWRcbiAgICAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZTogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICAgICB9XG4gICB9O1xuXG4gICB2YXIgbGlnR2x5cGggPSBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoY2FyZXRWYWx1ZSkpO1xuICAgfTtcblxuICAgdmFyIGxpZ0NhcmV0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHJldHVybiB7XG4gICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICBsaWdHbHlwaHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxpZ0dseXBoKSlcbiAgICAgICB9O1xuICAgfTtcblxuICAgdmFyIG1hcmtHbHlwaFNldHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICB0aGlzLnBhcnNlVVNob3J0KCk7IC8vIFZlcnNpb25cbiAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSk7XG4gICB9O1xuXG4gICBmdW5jdGlvbiBwYXJzZUdERUZUYWJsZShkYXRhLCBzdGFydCkge1xuICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjIgfHwgdGFibGVWZXJzaW9uID09PSAxLjMsXG4gICAgICAgICAgICdVbnN1cHBvcnRlZCBHREVGIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgICAgdmFyIGdkZWYgPSB7XG4gICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgY2xhc3NEZWY6IHAucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgIGF0dGFjaExpc3Q6IHAucGFyc2VQb2ludGVyKGF0dGFjaExpc3QpLFxuICAgICAgICAgICBsaWdDYXJldExpc3Q6IHAucGFyc2VQb2ludGVyKGxpZ0NhcmV0TGlzdCksXG4gICAgICAgICAgIG1hcmtBdHRhY2hDbGFzc0RlZjogcC5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKVxuICAgICAgIH07XG4gICAgICAgaWYgKHRhYmxlVmVyc2lvbiA+PSAxLjIpIHtcbiAgICAgICAgICAgZ2RlZi5tYXJrR2x5cGhTZXRzID0gcC5wYXJzZVBvaW50ZXIobWFya0dseXBoU2V0cyk7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBnZGVmO1xuICAgfVxuICAgdmFyIGdkZWYgPSB7IHBhcnNlOiBwYXJzZUdERUZUYWJsZSB9O1xuXG4gICAvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxuICAgdmFyIHN1YnRhYmxlUGFyc2VycyA9IG5ldyBBcnJheSgxMCk7IC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjbG9va3VwLXR5cGUtMS1zaW5nbGUtYWRqdXN0bWVudC1wb3NpdGlvbmluZy1zdWJ0YWJsZVxuICAgLy8gdGhpcyA9IFBhcnNlciBpbnN0YW5jZVxuICAgc3VidGFibGVQYXJzZXJzWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICAgICB2YXIgcG9zZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGlmIChwb3Nmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHBvc0Zvcm1hdDogMSxcbiAgICAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCgpLFxuICAgICAgICAgICB9O1xuICAgICAgIH0gZWxzZSBpZiAocG9zZm9ybWF0ID09PSAyKSB7XG4gICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICBwb3NGb3JtYXQ6IDIsXG4gICAgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgICAgIHZhbHVlczogdGhpcy5wYXJzZVZhbHVlUmVjb3JkTGlzdCgpLFxuICAgICAgICAgICB9O1xuICAgICAgIH1cbiAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAnMHgnICtcbiAgICAgICAgICAgICAgIHN0YXJ0LnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAnOiBHUE9TIGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLidcbiAgICAgICApO1xuICAgfTtcblxuICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjbG9va3VwLXR5cGUtMi1wYWlyLWFkanVzdG1lbnQtcG9zaXRpb25pbmctc3VidGFibGVcbiAgIHN1YnRhYmxlUGFyc2Vyc1syXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcbiAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgICAgdmFyIHBvc0Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgIHBvc0Zvcm1hdCA9PT0gMSB8fCBwb3NGb3JtYXQgPT09IDIsXG4gICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgc3RhcnQudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICc6IEdQT1MgbG9va3VwIHR5cGUgMiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJ1xuICAgICAgICk7XG4gICAgICAgdmFyIGNvdmVyYWdlID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKTtcbiAgICAgICB2YXIgdmFsdWVGb3JtYXQxID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIHZhciB2YWx1ZUZvcm1hdDIgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgaWYgKHBvc0Zvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAvLyBBZGp1c3RtZW50cyBmb3IgR2x5cGggUGFpcnNcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgICAgIHBhaXJTZXRzOiB0aGlzLnBhcnNlTGlzdChcbiAgICAgICAgICAgICAgICAgICBQYXJzZXIucG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgUGFyc2VyLmxpc3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWlyVmFsdWVSZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgfTtcbiAgICAgICB9IGVsc2UgaWYgKHBvc0Zvcm1hdCA9PT0gMikge1xuICAgICAgICAgICB2YXIgY2xhc3NEZWYxID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKTtcbiAgICAgICAgICAgdmFyIGNsYXNzRGVmMiA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG4gICAgICAgICAgIHZhciBjbGFzczFDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgdmFyIGNsYXNzMkNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgLy8gQ2xhc3MgUGFpciBBZGp1c3RtZW50XG4gICAgICAgICAgICAgICBwb3NGb3JtYXQ6IHBvc0Zvcm1hdCxcbiAgICAgICAgICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuICAgICAgICAgICAgICAgdmFsdWVGb3JtYXQyOiB2YWx1ZUZvcm1hdDIsXG4gICAgICAgICAgICAgICBjbGFzc0RlZjE6IGNsYXNzRGVmMSxcbiAgICAgICAgICAgICAgIGNsYXNzRGVmMjogY2xhc3NEZWYyLFxuICAgICAgICAgICAgICAgY2xhc3MxQ291bnQ6IGNsYXNzMUNvdW50LFxuICAgICAgICAgICAgICAgY2xhc3MyQ291bnQ6IGNsYXNzMkNvdW50LFxuICAgICAgICAgICAgICAgY2xhc3NSZWNvcmRzOiB0aGlzLnBhcnNlTGlzdChcbiAgICAgICAgICAgICAgICAgICBjbGFzczFDb3VudCxcbiAgICAgICAgICAgICAgICAgICBQYXJzZXIubGlzdChjbGFzczJDb3VudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MiksXG4gICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICksXG4gICAgICAgICAgIH07XG4gICAgICAgfVxuICAgfTtcblxuICAgc3VidGFibGVQYXJzZXJzWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuICAgICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgMyBub3Qgc3VwcG9ydGVkJyB9O1xuICAgfTtcbiAgIHN1YnRhYmxlUGFyc2Vyc1s0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHtcbiAgICAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDQgbm90IHN1cHBvcnRlZCcgfTtcbiAgIH07XG4gICBzdWJ0YWJsZVBhcnNlcnNbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA1IG5vdCBzdXBwb3J0ZWQnIH07XG4gICB9O1xuICAgc3VidGFibGVQYXJzZXJzWzZdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA2KCkge1xuICAgICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgfTtcbiAgIHN1YnRhYmxlUGFyc2Vyc1s3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHtcbiAgICAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDcgbm90IHN1cHBvcnRlZCcgfTtcbiAgIH07XG4gICBzdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA4IG5vdCBzdXBwb3J0ZWQnIH07XG4gICB9O1xuICAgc3VidGFibGVQYXJzZXJzWzldID0gZnVuY3Rpb24gcGFyc2VMb29rdXA5KCkge1xuICAgICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOSBub3Qgc3VwcG9ydGVkJyB9O1xuICAgfTtcblxuICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3NcbiAgIGZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuICAgICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICAgICB0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsXG4gICAgICAgICAgICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24gJyArIHRhYmxlVmVyc2lvblxuICAgICAgICk7XG5cbiAgICAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzKSxcbiAgICAgICAgICAgfTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyksXG4gICAgICAgICAgICAgICB2YXJpYXRpb25zOiBwLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0KCksXG4gICAgICAgICAgIH07XG4gICAgICAgfVxuICAgfVxuXG4gICB2YXIgZ3BvcyA9IHsgcGFyc2U6IHBhcnNlR3Bvc1RhYmxlIH07XG5cbiAgIC8vIFRoZSBgR1NVQmAgdGFibGUgY29udGFpbnMgbGlnYXR1cmVzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbiAgIHZhciBzdWJ0YWJsZVBhcnNlcnMkMSA9IG5ldyBBcnJheSg5KTsgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxuXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1NTXG4gICBzdWJ0YWJsZVBhcnNlcnMkMVsxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgICAgIGRlbHRhR2x5cGhJZDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICB9O1xuICAgICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICAgICBzdWJzdGl0dXRlOiB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCksXG4gICAgICAgICAgIH07XG4gICAgICAgfVxuICAgICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nXG4gICAgICAgKTtcbiAgIH07XG5cbiAgIC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTVNcbiAgIHN1YnRhYmxlUGFyc2VycyQxWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuICAgICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgICAgc3Vic3RGb3JtYXQgPT09IDEsXG4gICAgICAgICAgICdHU1VCIE11bHRpcGxlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgICAgKTtcbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICBzZXF1ZW5jZXM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpLFxuICAgICAgIH07XG4gICB9O1xuXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0FTXG4gICBzdWJ0YWJsZVBhcnNlcnMkMVszXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHtcbiAgICAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAgICAnR1NVQiBBbHRlcm5hdGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMSdcbiAgICAgICApO1xuICAgICAgIHJldHVybiB7XG4gICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgIGFsdGVybmF0ZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpLFxuICAgICAgIH07XG4gICB9O1xuXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG4gICBzdWJ0YWJsZVBhcnNlcnMkMVs0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHtcbiAgICAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAgICAnR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgICAgKTtcbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICBsaWdhdHVyZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgIGxpZ0dseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVVTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9KSxcbiAgICAgICB9O1xuICAgfTtcblxuICAgdmFyIGxvb2t1cFJlY29yZERlc2MgPSB7XG4gICAgICAgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICB9O1xuXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NTRlxuICAgc3VidGFibGVQYXJzZXJzJDFbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblxuICAgICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICAgICBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmREZXNjXG4gICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICB9O1xuICAgICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgICAgY2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICAgICBjbGFzc1NldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmREZXNjXG4gICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICB9O1xuICAgICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDMpIHtcbiAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgICAgY292ZXJhZ2VzOiB0aGlzLnBhcnNlTGlzdChcbiAgICAgICAgICAgICAgICAgICBnbHlwaENvdW50LFxuICAgICAgICAgICAgICAgICAgIFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSlcbiAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKSxcbiAgICAgICAgICAgfTtcbiAgICAgICB9XG4gICAgICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDUgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLidcbiAgICAgICApO1xuICAgfTtcblxuICAgLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDQ1xuICAgc3VidGFibGVQYXJzZXJzJDFbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7XG4gICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICAgICBjaGFpblJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYyksXG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICB9O1xuICAgICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICAgICBiYWNrdHJhY2tDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgICAgIGlucHV0Q2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICAgICBsb29rYWhlYWRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgICAgIGNoYWluQ2xhc3NTZXQ6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVNob3J0KCkgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKSxcbiAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgIH07XG4gICAgICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDMsXG4gICAgICAgICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICAgICBpbnB1dENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpLFxuICAgICAgICAgICB9O1xuICAgICAgIH1cbiAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJ1xuICAgICAgICk7XG4gICB9O1xuXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG4gICBzdWJ0YWJsZVBhcnNlcnMkMVs3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHtcbiAgICAgICAvLyBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlXG4gICAgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgICAgJ0dTVUIgRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgICAgKTtcbiAgICAgICB2YXIgZXh0ZW5zaW9uTG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICB2YXIgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcihcbiAgICAgICAgICAgdGhpcy5kYXRhLFxuICAgICAgICAgICB0aGlzLm9mZnNldCArIHRoaXMucGFyc2VVTG9uZygpXG4gICAgICAgKTtcbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgbG9va3VwVHlwZTogZXh0ZW5zaW9uTG9va3VwVHlwZSxcbiAgICAgICAgICAgZXh0ZW5zaW9uOiBzdWJ0YWJsZVBhcnNlcnMkMVtleHRlbnNpb25Mb29rdXBUeXBlXS5jYWxsKGV4dGVuc2lvblBhcnNlciksXG4gICAgICAgfTtcbiAgIH07XG5cbiAgIC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jUkNDU1xuICAgc3VidGFibGVQYXJzZXJzJDFbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgICAgJ0dTVUIgUmV2ZXJzZSBDaGFpbmluZyBDb250ZXh0dWFsIFNpbmdsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJ1xuICAgICAgICk7XG4gICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICBsb29rYWhlYWRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgIHN1YnN0aXR1dGVzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgIH07XG4gICB9O1xuXG4gICAvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dzdWIuaHRtXG4gICBmdW5jdGlvbiBwYXJzZUdzdWJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgICAgdGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLFxuICAgICAgICAgICAnVW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSB2ZXJzaW9uLidcbiAgICAgICApO1xuICAgICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSksXG4gICAgICAgICAgIH07XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSksXG4gICAgICAgICAgICAgICB2YXJpYXRpb25zOiBwLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0KCksXG4gICAgICAgICAgIH07XG4gICAgICAgfVxuICAgfVxuXG4gICB2YXIgZ3N1YiA9IHsgcGFyc2U6IHBhcnNlR3N1YlRhYmxlIH07XG5cbiAgIC8vIFRoZSBgaGVhZGAgdGFibGUgY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb250LlxuXG4gICAvLyBQYXJzZSB0aGUgaGVhZGVyIGBoZWFkYCB0YWJsZVxuICAgZnVuY3Rpb24gcGFyc2VIZWFkVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICAgICB2YXIgaGVhZCA9IHt9O1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgaGVhZC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICAgICBoZWFkLmZvbnRSZXZpc2lvbiA9IE1hdGgucm91bmQocC5wYXJzZUZpeGVkKCkgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgaGVhZC5jaGVja1N1bUFkanVzdG1lbnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBoZWFkLm1hZ2ljTnVtYmVyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgICAgIGhlYWQubWFnaWNOdW1iZXIgPT09IDB4NWYwZjNjZjUsXG4gICAgICAgICAgICdGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLidcbiAgICAgICApO1xuICAgICAgIGhlYWQuZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgaGVhZC51bml0c1BlckVtID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGhlYWQuY3JlYXRlZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICAgICBoZWFkLm1vZGlmaWVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgICAgIGhlYWQueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhlYWQueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhlYWQueE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhlYWQueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhlYWQubWFjU3R5bGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgaGVhZC5sb3dlc3RSZWNQUEVNID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGhlYWQuZm9udERpcmVjdGlvbkhpbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBoZWFkLmluZGV4VG9Mb2NGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBoZWFkLmdseXBoRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIHJldHVybiBoZWFkO1xuICAgfVxuXG4gICB2YXIgaGVhZCA9IHsgcGFyc2U6IHBhcnNlSGVhZFRhYmxlIH07XG5cbiAgIC8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuXG4gICAvLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG4gICBmdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgICAgIHZhciBoaGVhID0ge307XG4gICAgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIHJldHVybiBoaGVhO1xuICAgfVxuXG4gICB2YXIgaGhlYSA9IHsgcGFyc2U6IHBhcnNlSGhlYVRhYmxlIH07XG5cbiAgIC8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cblxuICAgZnVuY3Rpb24gcGFyc2VIbXR4VGFibGVBbGwoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKSB7XG4gICAgICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgICAgIH1cbiAgIH1cblxuICAgZnVuY3Rpb24gcGFyc2VIbXR4VGFibGVPbkxvd01lbW9yeShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzKSB7XG4gICAgICAgZm9udC5faG10eFRhYmxlRGF0YSA9IHt9O1xuXG4gICAgICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGZvbnQuX2htdHhUYWJsZURhdGFbaV0gPSB7XG4gICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IGFkdmFuY2VXaWR0aCxcbiAgICAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZzogbGVmdFNpZGVCZWFyaW5nLFxuICAgICAgICAgICB9O1xuICAgICAgIH1cbiAgIH1cblxuICAgLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbiAgIC8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG4gICBmdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMsIG9wdCkge1xuICAgICAgIGlmIChvcHQubG93TWVtb3J5KVxuICAgICAgICAgICB7IHBhcnNlSG10eFRhYmxlT25Mb3dNZW1vcnkoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocyk7IH1cbiAgICAgICBlbHNlIHsgcGFyc2VIbXR4VGFibGVBbGwoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKTsgfVxuICAgfVxuXG4gICB2YXIgaG10eCA9IHsgcGFyc2U6IHBhcnNlSG10eFRhYmxlIH07XG5cbiAgIC8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cblxuICAgZnVuY3Rpb24gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApIHtcbiAgICAgICB2YXIgcGFpcnMgPSB7fTtcbiAgICAgICAvLyBTa2lwIG5UYWJsZXMuXG4gICAgICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGNoZWNrLmFyZ3VtZW50KHN1YnRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgICAgLy8gU2tpcCBzdWJ0YWJsZUxlbmd0aCwgc3VidGFibGVDb3ZlcmFnZVxuICAgICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBwYWlycztcbiAgIH1cblxuICAgZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuICAgICAgIHZhciBwYWlycyA9IHt9O1xuICAgICAgIC8vIFRoZSBNYWMga2VybiB0YWJsZSBzdG9yZXMgdGhlIHZlcnNpb24gYXMgYSBmaXhlZCAoMzIgYml0cykgYnV0IHdlIG9ubHkgbG9hZGVkIHRoZSBmaXJzdCAxNiBiaXRzLlxuICAgICAgIC8vIFNraXAgdGhlIHJlc3QuXG4gICAgICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICAgICB2YXIgblRhYmxlcyA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgIC8vY2hlY2suYXJndW1lbnQoblRhYmxlcyA9PT0gMSwgJ09ubHkgMSBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQgKGdvdCAnICsgblRhYmxlcyArICcpLicpO1xuICAgICAgIGlmIChuVGFibGVzID4gMSkge1xuICAgICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgdGhlIGZpcnN0IGtlcm4gc3VidGFibGUgaXMgc3VwcG9ydGVkLicpO1xuICAgICAgIH1cbiAgICAgICBwLnNraXAoJ3VMb25nJyk7XG4gICAgICAgdmFyIGNvdmVyYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBjb3ZlcmFnZSAmIDB4RkY7XG4gICAgICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICAgICBpZiAoc3VidGFibGVWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gcGFpcnM7XG4gICB9XG5cbiAgIC8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbiAgIGZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgcmV0dXJuIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKTtcbiAgICAgICB9IGVsc2UgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICByZXR1cm4gcGFyc2VNYWNLZXJuVGFibGUocCk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24gKCcgKyB0YWJsZVZlcnNpb24gKyAnKS4nKTtcbiAgICAgICB9XG4gICB9XG5cbiAgIHZhciBrZXJuID0geyBwYXJzZTogcGFyc2VLZXJuVGFibGUgfTtcblxuICAgLy8gVGhlIGBsdGFnYCB0YWJsZSBzdG9yZXMgSUVURiBCQ1AtNDcgbGFuZ3VhZ2UgdGFncy4gSXQgYWxsb3dzIHN1cHBvcnRpbmdcblxuICAgZnVuY3Rpb24gcGFyc2VMdGFnVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBsdGFnIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgICAgLy8gVGhlICdsdGFnJyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGRlZmluZSBhbnkgZmxhZ3M7IHNraXAgdGhlIGZpZWxkLlxuICAgICAgIHAuc2tpcCgndUxvbmcnLCAxKTtcbiAgICAgICB2YXIgbnVtVGFncyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgdmFyIHRhZ3MgPSBbXTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhZ3M7IGkrKykge1xuICAgICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgdmFyIGxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IG9mZnNldCArIGxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmdldEludDgoaikpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHRhZ3M7XG4gICB9XG5cbiAgIHZhciBsdGFnID0geyBwYXJzZTogcGFyc2VMdGFnVGFibGUgfTtcblxuICAgLy8gVGhlIGBsb2NhYCB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LlxuXG4gICAvLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4gICAvLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4gICAvLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuICAgLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4gICAvLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4gICAvLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG4gICBmdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgICAgIHZhciBwYXJzZUZuID0gc2hvcnRWZXJzaW9uID8gcC5wYXJzZVVTaG9ydCA6IHAucGFyc2VVTG9uZztcbiAgICAgICAvLyBUaGVyZSBpcyBhbiBleHRyYSBlbnRyeSBhZnRlciB0aGUgbGFzdCBpbmRleCBlbGVtZW50IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgbGFzdCBnbHlwaC5cbiAgICAgICAvLyBUaGF0J3Mgd2h5IHdlIHVzZSBudW1HbHlwaHMgKyAxLlxuICAgICAgIHZhciBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBocyArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgZ2x5cGhPZmZzZXQgPSBwYXJzZUZuLmNhbGwocCk7XG4gICAgICAgICAgIGlmIChzaG9ydFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgIC8vIFRoZSBzaG9ydCB0YWJsZSB2ZXJzaW9uIHN0b3JlcyB0aGUgYWN0dWFsIG9mZnNldCBkaXZpZGVkIGJ5IDIuXG4gICAgICAgICAgICAgICBnbHlwaE9mZnNldCAqPSAyO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgZ2x5cGhPZmZzZXRzLnB1c2goZ2x5cGhPZmZzZXQpO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG4gICB9XG5cbiAgIHZhciBsb2NhID0geyBwYXJzZTogcGFyc2VMb2NhVGFibGUgfTtcblxuICAgLy8gVGhlIGBtYXhwYCB0YWJsZSBlc3RhYmxpc2hlcyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgdGhlIGZvbnQuXG5cbiAgIC8vIFBhcnNlIHRoZSBtYXhpbXVtIHByb2ZpbGUgYG1heHBgIHRhYmxlLlxuICAgZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICAgICB2YXIgbWF4cCA9IHt9O1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgbWF4cC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICAgICBtYXhwLm51bUdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICBpZiAobWF4cC52ZXJzaW9uID09PSAxLjApIHtcbiAgICAgICAgICAgbWF4cC5tYXhQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIG1heHAubWF4Q29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIG1heHAubWF4Q29tcG9zaXRlUG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICBtYXhwLm1heENvbXBvc2l0ZUNvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICBtYXhwLm1heFpvbmVzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICBtYXhwLm1heFR3aWxpZ2h0UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICBtYXhwLm1heFN0b3JhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIG1heHAubWF4RnVuY3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICBtYXhwLm1heEluc3RydWN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgbWF4cC5tYXhTdGFja0VsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICBtYXhwLm1heFNpemVPZkluc3RydWN0aW9ucyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgbWF4cC5tYXhDb21wb25lbnRFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgbWF4cC5tYXhDb21wb25lbnREZXB0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gbWF4cDtcbiAgIH1cblxuICAgdmFyIG1heHAgPSB7IHBhcnNlOiBwYXJzZU1heHBUYWJsZSB9O1xuXG4gICAvLyBUaGUgYE9TLzJgIHRhYmxlIGNvbnRhaW5zIG1ldHJpY3MgcmVxdWlyZWQgaW4gT3BlblR5cGUgZm9udHMuXG5cbiAgIC8vIFBhcnNlIHRoZSBPUy8yIGFuZCBXaW5kb3dzIG1ldHJpY3MgYE9TLzJgIHRhYmxlXG4gICBmdW5jdGlvbiBwYXJzZU9TMlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgICAgdmFyIG9zMiA9IHt9O1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgb3MyLnZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgb3MyLnhBdmdDaGFyV2lkdGggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIudXNXZWlnaHRDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICBvczIudXNXaWR0aENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIG9zMi5mc1R5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgb3MyLnlTdWJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIG9zMi55U3Vic2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIueVN1YnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIueVN1YnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIueVN1cGVyc2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIueVN1cGVyc2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIueVN1cGVyc2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIG9zMi55U3VwZXJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgb3MyLnlTdHJpa2VvdXRTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgb3MyLnlTdHJpa2VvdXRQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIG9zMi5zRmFtaWx5Q2xhc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIucGFub3NlID0gW107XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgIG9zMi5wYW5vc2VbaV0gPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgIH1cblxuICAgICAgIG9zMi51bFVuaWNvZGVSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBvczIudWxVbmljb2RlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgb3MyLnVsVW5pY29kZVJhbmdlMyA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgIG9zMi51bFVuaWNvZGVSYW5nZTQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBvczIuYWNoVmVuZElEID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgcC5wYXJzZUJ5dGUoKSxcbiAgICAgICAgICAgcC5wYXJzZUJ5dGUoKSxcbiAgICAgICAgICAgcC5wYXJzZUJ5dGUoKSxcbiAgICAgICAgICAgcC5wYXJzZUJ5dGUoKVxuICAgICAgICk7XG4gICAgICAgb3MyLmZzU2VsZWN0aW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIG9zMi51c0ZpcnN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIG9zMi51c0xhc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgb3MyLnNUeXBvQXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIuc1R5cG9EZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICBvczIuc1R5cG9MaW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgb3MyLnVzV2luQXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgIG9zMi51c1dpbkRlc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgaWYgKG9zMi52ZXJzaW9uID49IDEpIHtcbiAgICAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAob3MyLnZlcnNpb24gPj0gMikge1xuICAgICAgICAgICBvczIuc3hIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgb3MyLnNDYXBIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgb3MyLnVzRGVmYXVsdENoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgIG9zMi51c0JyZWFrQ2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgb3MyLnVzTWF4Q29udGVudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gb3MyO1xuICAgfVxuXG4gICB2YXIgb3MyID0geyBwYXJzZTogcGFyc2VPUzJUYWJsZSB9O1xuXG4gICAvLyBUaGUgYHBvc3RgIHRhYmxlIHN0b3JlcyBhZGRpdGlvbmFsIFBvc3RTY3JpcHQgaW5mb3JtYXRpb24sIHN1Y2ggYXMgZ2x5cGggbmFtZXMuXG5cbiAgIC8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuICAgZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICAgICB2YXIgcG9zdCA9IHt9O1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICBwb3N0Lm5hbWVzID0gW107XG4gICAgICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgMi41OlxuICAgICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICAgICBwb3N0Lm9mZnNldFtpJDFdID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gcG9zdDtcbiAgIH1cblxuICAgdmFyIHBvc3QgPSB7IHBhcnNlOiBwYXJzZVBvc3RUYWJsZSB9O1xuXG4gICAvLyBEYXRhIHR5cGVzIHVzZWQgaW4gdGhlIE9wZW5UeXBlIGZvbnQgZmlsZS5cblxuICAgLyoqXG4gICAgKiBAZXhwb3J0cyBvcGVudHlwZS5kZWNvZGVcbiAgICAqIEBjbGFzc1xuICAgICovXG4gICB2YXIgZGVjb2RlID0ge307XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICovXG4gICBkZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzO1xuICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDEpIHtcbiAgICAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDgob2Zmc2V0KTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICovXG4gICBkZWNvZGUuVVRGMTYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcyAvIDI7XG4gICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMikge1xuICAgICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbiAgIH07XG5cbiAgIC8vIERhdGEgZm9yIGNvbnZlcnRpbmcgb2xkIGVpZ2h0LWJpdCBNYWNpbnRvc2ggZW5jb2RpbmdzIHRvIFVuaWNvZGUuXG4gICAvLyBUaGlzIHJlcHJlc2VudGF0aW9uIGlzIG9wdGltaXplZCBmb3IgZGVjb2Rpbmc7IGVuY29kaW5nIGlzIHNsb3dlclxuICAgLy8gYW5kIG5lZWRzIG1vcmUgbWVtb3J5LiBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IGFsbCBvcGVudHlwZS5qcyB1c2Vyc1xuICAgLy8gd2FudCB0byBvcGVuIGZvbnRzLCBidXQgc2F2aW5nIGEgZm9udCB3aWxsIGJlIGNvbXBhcmF0aXZlbHkgcmFyZVxuICAgLy8gc28gaXQgY2FuIGJlIG1vcmUgZXhwZW5zaXZlLiBLZXllZCBieSBJQU5BIGNoYXJhY3RlciBzZXQgbmFtZS5cbiAgIC8vXG4gICAvLyBQeXRob24gc2NyaXB0IGZvciBnZW5lcmF0aW5nIHRoZXNlIHN0cmluZ3M6XG4gICAvL1xuICAgLy8gICAgIHMgPSB1Jycuam9pbihbY2hyKGMpLmRlY29kZSgnbWFjX2dyZWVrJykgZm9yIGMgaW4gcmFuZ2UoMTI4LCAyNTYpXSlcbiAgIC8vICAgICBwcmludChzLmVuY29kZSgndXRmLTgnKSlcbiAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgdmFyIGVpZ2h0Qml0TWFjRW5jb2RpbmdzID0ge1xuICAgICAgICd4LW1hYy1jcm9hdGlhbic6ICAvLyBQeXRob246ICdtYWNfY3JvYXRpYW4nXG4gICAgICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsWg4oSiwrTCqOKJoMW9w5jiiJ7CseKJpOKJpeKIhsK14oiC4oiR4oiPxaHiiKvCqsK6zqnFvsO4JyArXG4gICAgICAgJ8K/wqHCrOKImsaS4omIxIbCq8SM4oCmwqDDgMODw5XFksWTxJDigJTigJzigJ3igJjigJnDt+KXiu+jv8Kp4oGE4oKs4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHJyxcbiAgICAgICAneC1tYWMtY3lyaWxsaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2N5cmlsbGljJ1xuICAgICAgICfQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZonICtcbiAgICAgICAn0ZjQhcKs4oiaxpLiiYjiiIbCq8K74oCmwqDQi9Gb0IzRnNGV4oCT4oCU4oCc4oCd4oCY4oCZw7figJ7QjtGe0I/Rn+KEltCB0ZHRj9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGOJyxcbiAgICAgICAneC1tYWMtZ2FlbGljJzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0dBRUxJQy5UWFRcbiAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO4JyArXG4gICAgICAgJ+G5geG5luG5l8m8xpLFv+G5oMKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnhuaHhupvDv8W44bmq4oKs4oC54oC6xbbFt+G5q8K34buy4buz4oGKw4LDisOBw4vDiMONw47Dj8OMw5PDlOKZo8OSw5rDm8OZxLHDncO9xbTFteG6hOG6heG6gOG6geG6guG6gycsXG4gICAgICAgJ3gtbWFjLWdyZWVrJzogIC8vIFB5dGhvbjogJ21hY19ncmVlaydcbiAgICAgICAnw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbigqzDucO7w7zigKDOk86UzpjOm86ezqDDn8KuwqnOo86qwqfiiaDCsMK3zpHCseKJpOKJpcKlzpLOlc6WzpfOmc6azpzOps6rzqjOqScgK1xuICAgICAgICfOrM6dwqzOn86h4omIzqTCq8K74oCmwqDOpc6nzobOiMWT4oCT4oCV4oCc4oCd4oCY4oCZw7fOic6KzozOjs6tzq7Or8+Mzo/Pjc6xzrLPiM60zrXPhs6zzrfOuc6+zrrOu868zr3Ov8+Az47Pgc+Dz4TOuM+Jz4LPh8+FzrbPis+LzpDOsFxcdTAwQUQnLFxuICAgICAgICd4LW1hYy1pY2VsYW5kaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2ljZWxhbmQnXG4gICAgICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzDkMOww57DvsO9wrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAgICAneC1tYWMtaW51aXQnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvSU5VSVQuVFhUXG4gICAgICAgJ+GQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOXJyArXG4gICAgICAgJ+GTmOGTmuGTm+GTquGUqOGUqeGUquGUq+GUreKApsKg4ZSu4ZS+4ZWV4ZWW4ZWX4oCT4oCU4oCc4oCd4oCY4oCZ4ZWY4ZWZ4ZWa4ZWd4ZWG4ZWH4ZWI4ZWJ4ZWL4ZWM4ZWQ4ZW/4ZaA4ZaB4ZaC4ZaD4ZaE4ZaF4ZaP4ZaQ4ZaR4ZaS4ZaT4ZaU4ZaV4Zmx4Zmy4Zmz4Zm04Zm14Zm24ZaW4Zag4Zah4Zai4Zaj4Zak4Zal4Zam4ZW8xYHFgicsXG4gICAgICAgJ3gtbWFjLWNlJzogIC8vIFB5dGhvbjogJ21hY19sYXRpbjInXG4gICAgICAgJ8OExIDEgcOJxITDlsOcw6HEhcSMw6TEjcSGxIfDqcW5xbrEjsOtxI/EksSTxJbDs8SXw7TDtsO1w7rEmsSbw7zigKDCsMSYwqPCp+KAosK2w5/CrsKp4oSixJnCqOKJoMSjxK7Er8Sq4omk4omlxKvEtuKIguKIkcWCxLvEvMS9xL7EucS6xYUnICtcbiAgICAgICAnxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLhycsXG4gICAgICAgbWFjaW50b3NoOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuJ1xuICAgICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAuu+sge+sguKAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgICAgJ3gtbWFjLXJvbWFuaWFuJzogIC8vIFB5dGhvbjogJ21hY19yb21hbmlhbidcbiAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImScgK1xuICAgICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrImsib4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAgICAneC1tYWMtdHVya2lzaCc6ICAvLyBQeXRob246ICdtYWNfdHVya2lzaCdcbiAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDme+ioMuGy5zCr8uYy5nLmsK4y53Lm8uHJ1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBEZWNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGVpdGhlciBhIFVuaWNvZGUgSmF2YVNjcmlwdFxuICAgICogc3RyaW5nLCBvciAndW5kZWZpbmVkJyBpZiB0aGUgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQuIEZvciBleGFtcGxlLCB3ZSBkb1xuICAgICogbm90IHN1cHBvcnQgQ2hpbmVzZSwgSmFwYW5lc2Ugb3IgS29yZWFuIGJlY2F1c2UgdGhlc2Ugd291bGQgbmVlZCBsYXJnZVxuICAgICogbWFwcGluZyB0YWJsZXMuXG4gICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFMZW5ndGhcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAqL1xuICAgZGVjb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIGRhdGFMZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgICAgdmFyIHRhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuICAgICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgfVxuXG4gICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIHZhciBjID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgICAgICAgIC8vIEluIGFsbCBlaWdodC1iaXQgTWFjIGVuY29kaW5ncywgdGhlIGNoYXJhY3RlcnMgMHgwMC4uMHg3RiBhcmVcbiAgICAgICAgICAgLy8gbWFwcGVkIHRvIFUrMDAwMC4uVSswMDdGOyB3ZSBvbmx5IG5lZWQgdG8gbG9vayB1cCB0aGUgb3RoZXJzLlxuICAgICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHJlc3VsdCArPSB0YWJsZVtjICYgMHg3Rl07XG4gICAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgfTtcblxuICAgLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbiAgIC8vIFBhcnNlIHRoZSBtZXRhZGF0YSBgbWV0YWAgdGFibGUuXG4gICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2bWV0YS5odG1sXG4gICBmdW5jdGlvbiBwYXJzZU1ldGFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIE1FVEEgdGFibGUgdmVyc2lvbi4nKTtcbiAgICAgICBwLnBhcnNlVUxvbmcoKTsgLy8gZmxhZ3MgLSBjdXJyZW50bHkgdW51c2VkIGFuZCBzZXQgdG8gMFxuICAgICAgIHAucGFyc2VVTG9uZygpOyAvLyB0YWJsZU9mZnNldFxuICAgICAgIHZhciBudW1EYXRhTWFwcyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgdmFyIHRhZ3MgPSB7fTtcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFNYXBzOyBpKyspIHtcbiAgICAgICAgICAgdmFyIHRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICAgICAgICAgdmFyIGRhdGFPZmZzZXQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgICAgdmFyIHRleHQgPSBkZWNvZGUuVVRGOChkYXRhLCBzdGFydCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuXG4gICAgICAgICAgIHRhZ3NbdGFnXSA9IHRleHQ7XG4gICAgICAgfVxuICAgICAgIHJldHVybiB0YWdzO1xuICAgfVxuXG4gICB2YXIgbWV0YSA9IHsgcGFyc2U6IHBhcnNlTWV0YVRhYmxlIH07XG5cbiAgIC8vIG9wZW50eXBlLmpzXG5cbiAgIC8qKlxuICAgICogVGhlIG9wZW50eXBlIGxpYnJhcnkuXG4gICAgKiBAbmFtZXNwYWNlIG9wZW50eXBlXG4gICAgKi9cblxuICAgLy8gVGFibGUgRGlyZWN0b3J5IEVudHJpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgLyoqXG4gICAgKiBQYXJzZXMgT3BlblR5cGUgdGFibGUgZW50cmllcy5cbiAgICAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICAgICogQHBhcmFtICB7TnVtYmVyfVxuICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgKi9cbiAgIGZ1bmN0aW9uIHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgICAgIHZhciBwID0gMTI7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bSxcbiAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICAgICBjb21wcmVzc2lvbjogZmFsc2UsXG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBwICs9IDE2O1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG4gICB9XG5cbiAgIC8qKlxuICAgICogUGFyc2VzIFdPRkYgdGFibGUgZW50cmllcy5cbiAgICAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICAgICogQHBhcmFtICB7TnVtYmVyfVxuICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgKi9cbiAgIGZ1bmN0aW9uIHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcbiAgICAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgICAgdmFyIHAgPSA0NDsgLy8gb2Zmc2V0IHRvIHRoZSBmaXJzdCB0YWJsZSBkaXJlY3RvcnkgZW50cnkuXG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICAgICB2YXIgY29tcExlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgICAgdmFyIG9yaWdMZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICAgICB2YXIgY29tcHJlc3Npb24gPSAodm9pZCAwKTtcbiAgICAgICAgICAgaWYgKGNvbXBMZW5ndGggPCBvcmlnTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICBjb21wcmVzc2lvbiA9ICdXT0ZGJztcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uLFxuICAgICAgICAgICAgICAgY29tcHJlc3NlZExlbmd0aDogY29tcExlbmd0aCxcbiAgICAgICAgICAgICAgIGxlbmd0aDogb3JpZ0xlbmd0aCxcbiAgICAgICAgICAgfSk7XG4gICAgICAgICAgIHAgKz0gMjA7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHRhYmxlRW50cmllcztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBAdHlwZWRlZiBUYWJsZURhdGFcbiAgICAqIEB0eXBlIE9iamVjdFxuICAgICogQHByb3BlcnR5IHtEYXRhVmlld30gZGF0YSAtIFRoZSBEYXRhVmlld1xuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCAtIFRoZSBkYXRhIG9mZnNldC5cbiAgICAqL1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICAgICogQHBhcmFtICB7T2JqZWN0fVxuICAgICogQHJldHVybiB7VGFibGVEYXRhfVxuICAgICovXG4gICBmdW5jdGlvbiB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSkge1xuICAgICAgIGlmICh0YWJsZUVudHJ5LmNvbXByZXNzaW9uID09PSAnV09GRicpIHtcbiAgICAgICAgICAgdmFyIGluQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICAgICAgIHRhYmxlRW50cnkub2Zmc2V0ICsgMixcbiAgICAgICAgICAgICAgIHRhYmxlRW50cnkuY29tcHJlc3NlZExlbmd0aCAtIDJcbiAgICAgICAgICAgKTtcbiAgICAgICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgaW5mbGF0ZVN5bmMoaW5CdWZmZXIsIG91dEJ1ZmZlcik7XG4gICAgICAgICAgIGlmIChvdXRCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gdGFibGVFbnRyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAnRGVjb21wcmVzc2lvbiBlcnJvcjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgIHRhYmxlRW50cnkudGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgXCIgZGVjb21wcmVzc2VkIGxlbmd0aCBkb2Vzbid0IG1hdGNoIHJlY29yZGVkIGxlbmd0aFwiXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlciwgMCk7XG4gICAgICAgICAgIHJldHVybiB7IGRhdGE6IHZpZXcsIG9mZnNldDogMCB9O1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIG9mZnNldDogdGFibGVFbnRyeS5vZmZzZXQgfTtcbiAgICAgICB9XG4gICB9XG5cbiAgIC8vIFB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgLyoqXG4gICAgKiBQYXJzZSB0aGUgT3BlblR5cGUgZmlsZSBkYXRhIChhcyBhbiBBcnJheUJ1ZmZlcikgYW5kIHJldHVybiBhIEZvbnQgb2JqZWN0LlxuICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBmb250IGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn1cbiAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0IC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICogQHJldHVybiB7b3BlbnR5cGUuRm9udH1cbiAgICAqL1xuICAgZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyLCBvcHQpIHtcbiAgICAgICBvcHQgPSBvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQgPT09IG51bGwgPyB7fSA6IG9wdDtcblxuICAgICAgIHZhciBpbmRleFRvTG9jRm9ybWF0O1xuXG4gICAgICAgLy8gU2luY2UgdGhlIGNvbnN0cnVjdG9yIGNhbiBhbHNvIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IGZvbnRzIGZyb20gc2NyYXRjaCwgd2UgaW5kaWNhdGUgdGhpc1xuICAgICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cbiAgICAgICB2YXIgZm9udCA9IG5ldyBGb250KHsgZW1wdHk6IHRydWUgfSk7XG5cbiAgICAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cbiAgICAgICB2YXIgZGF0YSA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDApO1xuICAgICAgIHZhciBudW1UYWJsZXM7XG4gICAgICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgICAgIHZhciBzaWduYXR1cmUgPSBwYXJzZS5nZXRUYWcoZGF0YSwgMCk7XG4gICAgICAgaWYgKFxuICAgICAgICAgICBzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkgfHxcbiAgICAgICAgICAgc2lnbmF0dXJlID09PSAndHJ1ZScgfHxcbiAgICAgICAgICAgc2lnbmF0dXJlID09PSAndHlwMSdcbiAgICAgICApIHtcbiAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ3dPRkYnKSB7XG4gICAgICAgICAgIHZhciBmbGF2b3IgPSBwYXJzZS5nZXRUYWcoZGF0YSwgNCk7XG4gICAgICAgICAgIGlmIChmbGF2b3IgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkpIHtcbiAgICAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICAgICB9IGVsc2UgaWYgKGZsYXZvciA9PT0gJ09UVE8nKSB7XG4gICAgICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIGZsYXZvciAnICsgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCAxMik7XG4gICAgICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgc2lnbmF0dXJlICcgKyBzaWduYXR1cmUpO1xuICAgICAgIH1cblxuICAgICAgIHZhciBjZmZUYWJsZUVudHJ5O1xuICAgICAgIHZhciBmdmFyVGFibGVFbnRyeTtcbiAgICAgICB2YXIgZ2x5ZlRhYmxlRW50cnk7XG4gICAgICAgdmFyIGdkZWZUYWJsZUVudHJ5O1xuICAgICAgIHZhciBncG9zVGFibGVFbnRyeTtcbiAgICAgICB2YXIgZ3N1YlRhYmxlRW50cnk7XG4gICAgICAgdmFyIGhtdHhUYWJsZUVudHJ5O1xuICAgICAgIHZhciBrZXJuVGFibGVFbnRyeTtcbiAgICAgICB2YXIgbG9jYVRhYmxlRW50cnk7XG4gICAgICAgdmFyIG1ldGFUYWJsZUVudHJ5O1xuICAgICAgIHZhciBwO1xuXG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICAgICB2YXIgdGFibGVFbnRyeSA9IHRhYmxlRW50cmllc1tpXTtcbiAgICAgICAgICAgdmFyIHRhYmxlID0gKHZvaWQgMCk7XG4gICAgICAgICAgIHN3aXRjaCAodGFibGVFbnRyeS50YWcpIHtcbiAgICAgICAgICAgICAgIGNhc2UgJ2NtYXAnOlxuICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgZm9udC5lbmNvZGluZyA9IG5ldyBDbWFwRW5jb2RpbmcoZm9udC50YWJsZXMuY21hcCk7XG4gICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICBjYXNlICdjdnQgJzpcbiAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmN2dCA9IHAucGFyc2VTaG9ydExpc3QodGFibGVFbnRyeS5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ2Z2YXInOlxuICAgICAgICAgICAgICAgICAgIGZ2YXJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ2ZwZ20nOlxuICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgZm9udC50YWJsZXMuZnBnbSA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oZWFkID0gaGVhZC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgIGZvbnQudW5pdHNQZXJFbSA9IGZvbnQudGFibGVzLmhlYWQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICAgICBpbmRleFRvTG9jRm9ybWF0ID0gZm9udC50YWJsZXMuaGVhZC5pbmRleFRvTG9jRm9ybWF0O1xuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSAnaGhlYSc6XG4gICAgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGhlYSA9IGhoZWEucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICBmb250LmFzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5hc2NlbmRlcjtcbiAgICAgICAgICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuICAgICAgICAgICAgICAgICAgIGZvbnQubnVtYmVyT2ZITWV0cmljcyA9IGZvbnQudGFibGVzLmhoZWEubnVtYmVyT2ZITWV0cmljcztcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ2htdHgnOlxuICAgICAgICAgICAgICAgICAgIGhtdHhUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ2x0YWcnOlxuICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgIGx0YWdUYWJsZSA9IGx0YWcucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ21heHAnOlxuICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgZm9udC5udW1HbHlwaHMgPSBmb250LnRhYmxlcy5tYXhwLm51bUdseXBocztcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ09TLzInOlxuICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm9zMiA9IG9zMi5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ3ByZXAnOlxuICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgZm9udC50YWJsZXMucHJlcCA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICBjYXNlICdnbHlmJzpcbiAgICAgICAgICAgICAgICAgICBnbHlmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgICAgICAgICBsb2NhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgICAgICAgICBjZmZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ2tlcm4nOlxuICAgICAgICAgICAgICAgICAgIGtlcm5UYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ0dERUYnOlxuICAgICAgICAgICAgICAgICAgIGdkZWZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgICAgICAgIGdwb3NUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ0dTVUInOlxuICAgICAgICAgICAgICAgICAgIGdzdWJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgICAgICAgICAgIG1ldGFUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuICAgICAgICAgICB2YXIgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgICAgdmFyIGxvY2FUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBsb2NhVGFibGVFbnRyeSk7XG4gICAgICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UoXG4gICAgICAgICAgICAgICBsb2NhVGFibGUuZGF0YSxcbiAgICAgICAgICAgICAgIGxvY2FUYWJsZS5vZmZzZXQsXG4gICAgICAgICAgICAgICBmb250Lm51bUdseXBocyxcbiAgICAgICAgICAgICAgIHNob3J0VmVyc2lvblxuICAgICAgICAgICApO1xuICAgICAgICAgICB2YXIgZ2x5ZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdseWZUYWJsZUVudHJ5KTtcbiAgICAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKFxuICAgICAgICAgICAgICAgZ2x5ZlRhYmxlLmRhdGEsXG4gICAgICAgICAgICAgICBnbHlmVGFibGUub2Zmc2V0LFxuICAgICAgICAgICAgICAgbG9jYU9mZnNldHMsXG4gICAgICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgICAgb3B0XG4gICAgICAgICAgICk7XG4gICAgICAgfSBlbHNlIGlmIChjZmZUYWJsZUVudHJ5KSB7XG4gICAgICAgICAgIHZhciBjZmZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBjZmZUYWJsZUVudHJ5KTtcbiAgICAgICAgICAgY2ZmLnBhcnNlKGNmZlRhYmxlLmRhdGEsIGNmZlRhYmxlLm9mZnNldCwgZm9udCwgb3B0KTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGRvZXNuJ3QgY29udGFpbiBUcnVlVHlwZSBvciBDRkYgb3V0bGluZXMuXCIpO1xuICAgICAgIH1cblxuICAgICAgIHZhciBobXR4VGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgaG10eFRhYmxlRW50cnkpO1xuICAgICAgIGhtdHgucGFyc2UoXG4gICAgICAgICAgIGZvbnQsXG4gICAgICAgICAgIGhtdHhUYWJsZS5kYXRhLFxuICAgICAgICAgICBobXR4VGFibGUub2Zmc2V0LFxuICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MsXG4gICAgICAgICAgIGZvbnQubnVtR2x5cGhzLFxuICAgICAgICAgICBmb250LmdseXBocyxcbiAgICAgICAgICAgb3B0XG4gICAgICAgKTtcbiAgICAgICBhZGRHbHlwaE5hbWVzKGZvbnQsIG9wdCk7XG5cbiAgICAgICBpZiAoa2VyblRhYmxlRW50cnkpIHtcbiAgICAgICAgICAgdmFyIGtlcm5UYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBrZXJuVGFibGVFbnRyeSk7XG4gICAgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShrZXJuVGFibGUuZGF0YSwga2VyblRhYmxlLm9mZnNldCk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSB7fTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoZ2RlZlRhYmxlRW50cnkpIHtcbiAgICAgICAgICAgdmFyIGdkZWZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnZGVmVGFibGVFbnRyeSk7XG4gICAgICAgICAgIGZvbnQudGFibGVzLmdkZWYgPSBnZGVmLnBhcnNlKGdkZWZUYWJsZS5kYXRhLCBnZGVmVGFibGUub2Zmc2V0KTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoZ3Bvc1RhYmxlRW50cnkpIHtcbiAgICAgICAgICAgdmFyIGdwb3NUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBncG9zVGFibGVFbnRyeSk7XG4gICAgICAgICAgIGZvbnQudGFibGVzLmdwb3MgPSBncG9zLnBhcnNlKGdwb3NUYWJsZS5kYXRhLCBncG9zVGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgZm9udC5wb3NpdGlvbi5pbml0KCk7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGdzdWJUYWJsZUVudHJ5KSB7XG4gICAgICAgICAgIHZhciBnc3ViVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3N1YlRhYmxlRW50cnkpO1xuICAgICAgICAgICBmb250LnRhYmxlcy5nc3ViID0gZ3N1Yi5wYXJzZShnc3ViVGFibGUuZGF0YSwgZ3N1YlRhYmxlLm9mZnNldCk7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGZ2YXJUYWJsZUVudHJ5KSB7XG4gICAgICAgICAgIHZhciBmdmFyVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZnZhclRhYmxlRW50cnkpO1xuICAgICAgICAgICBmb250LnRhYmxlcy5mdmFyID0gZnZhci5wYXJzZShcbiAgICAgICAgICAgICAgIGZ2YXJUYWJsZS5kYXRhLFxuICAgICAgICAgICAgICAgZnZhclRhYmxlLm9mZnNldCxcbiAgICAgICAgICAgICAgIGZvbnQubmFtZXNcbiAgICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAobWV0YVRhYmxlRW50cnkpIHtcbiAgICAgICAgICAgdmFyIG1ldGFUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBtZXRhVGFibGVFbnRyeSk7XG4gICAgICAgICAgIGZvbnQudGFibGVzLm1ldGEgPSBtZXRhLnBhcnNlKG1ldGFUYWJsZS5kYXRhLCBtZXRhVGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgZm9udC5tZXRhcyA9IGZvbnQudGFibGVzLm1ldGE7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGZvbnQ7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGxvYWQoKSB7fVxuICAgZnVuY3Rpb24gbG9hZFN5bmMoKSB7fVxuXG4gICB2YXIgb3BlbnR5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICBGb250OiBGb250LFxuICAgICAgR2x5cGg6IEdseXBoLFxuICAgICAgUGF0aDogUGF0aCxcbiAgICAgIF9wYXJzZTogcGFyc2UsXG4gICAgICBwYXJzZTogcGFyc2VCdWZmZXIsXG4gICAgICBsb2FkOiBsb2FkLFxuICAgICAgbG9hZFN5bmM6IGxvYWRTeW5jXG4gICB9KTtcblxuICAgZXhwb3J0cy5Gb250ID0gRm9udDtcbiAgIGV4cG9ydHMuR2x5cGggPSBHbHlwaDtcbiAgIGV4cG9ydHMuUGF0aCA9IFBhdGg7XG4gICBleHBvcnRzLl9wYXJzZSA9IHBhcnNlO1xuICAgZXhwb3J0cy5kZWZhdWx0ID0gb3BlbnR5cGU7XG4gICBleHBvcnRzLmxvYWQgPSBsb2FkO1xuICAgZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuICAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlQnVmZmVyO1xuXG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbnR5cGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@shuding/opentype.js/dist/opentype.js\n");

/***/ })

};
;