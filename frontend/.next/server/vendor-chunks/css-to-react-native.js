"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/css-to-react-native";
exports.ids = ["vendor-chunks/css-to-react-native"];
exports.modules = {

/***/ "(ssr)/./node_modules/css-to-react-native/index.js":
/*!***************************************************!*\
  !*** ./node_modules/css-to-react-native/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar parse = __webpack_require__(/*! postcss-value-parser */ \"(ssr)/./node_modules/postcss-value-parser/lib/index.js\");\n\nvar parse__default = _interopDefault(parse);\n\nvar camelizeStyleName = _interopDefault(__webpack_require__(/*! camelize */ \"(ssr)/./node_modules/camelize/index.js\"));\n\nvar cssColorKeywords = _interopDefault(__webpack_require__(/*! css-color-keywords */ \"(ssr)/./node_modules/css-color-keywords/index.js\"));\n\nvar matchString = function matchString(node) {\n  if (node.type !== 'string') return null;\n  return node.value.replace(/\\\\([0-9a-f]{1,6})(?:\\s|$)/gi, function (match, charCode) {\n    return String.fromCharCode(parseInt(charCode, 16));\n  }).replace(/\\\\/g, '');\n};\n\nvar hexColorRe = /^(#(?:[0-9a-f]{3,4}){1,2})$/i;\nvar cssFunctionNameRe = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/;\n\nvar matchColor = function matchColor(node) {\n  if (node.type === 'word' && (hexColorRe.test(node.value) || node.value in cssColorKeywords || node.value === 'transparent')) {\n    return node.value;\n  } else if (node.type === 'function' && cssFunctionNameRe.test(node.value)) {\n    return parse.stringify(node);\n  }\n\n  return null;\n};\n\nvar noneRe = /^(none)$/i;\nvar autoRe = /^(auto)$/i;\nvar identRe = /(^-?[_a-z][_a-z0-9-]*$)/i; // Note if these are wrong, you'll need to change index.js too\n\nvar numberRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)$/i; // Note lengthRe is sneaky: you can omit units for 0\n\nvar lengthRe = /^(0$|(?:[+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?=px$))/i;\nvar unsupportedUnitRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/i;\nvar angleRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(?:deg|rad))$/i;\nvar percentRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?%)$/i;\n\nvar noopToken = function noopToken(predicate) {\n  return function (node) {\n    return predicate(node) ? '<token>' : null;\n  };\n};\n\nvar valueForTypeToken = function valueForTypeToken(type) {\n  return function (node) {\n    return node.type === type ? node.value : null;\n  };\n};\n\nvar regExpToken = function regExpToken(regExp, transform) {\n  if (transform === void 0) {\n    transform = String;\n  }\n\n  return function (node) {\n    if (node.type !== 'word') return null;\n    var match = node.value.match(regExp);\n    if (match === null) return null;\n    var value = transform(match[1]);\n    return value;\n  };\n};\n\nvar SPACE = noopToken(function (node) {\n  return node.type === 'space';\n});\nvar SLASH = noopToken(function (node) {\n  return node.type === 'div' && node.value === '/';\n});\nvar COMMA = noopToken(function (node) {\n  return node.type === 'div' && node.value === ',';\n});\nvar WORD = valueForTypeToken('word');\nvar NONE = regExpToken(noneRe);\nvar AUTO = regExpToken(autoRe);\nvar NUMBER = regExpToken(numberRe, Number);\nvar LENGTH = regExpToken(lengthRe, Number);\nvar UNSUPPORTED_LENGTH_UNIT = regExpToken(unsupportedUnitRe);\nvar ANGLE = regExpToken(angleRe, function (angle) {\n  return angle.toLowerCase();\n});\nvar PERCENT = regExpToken(percentRe);\nvar IDENT = regExpToken(identRe);\nvar STRING = matchString;\nvar COLOR = matchColor;\nvar LINE = regExpToken(/^(none|underline|line-through)$/i);\n\nvar aspectRatio = function aspectRatio(tokenStream) {\n  var aspectRatio = tokenStream.expect(NUMBER);\n\n  if (tokenStream.hasTokens()) {\n    tokenStream.expect(SLASH);\n    aspectRatio /= tokenStream.expect(NUMBER);\n  }\n\n  return {\n    aspectRatio: aspectRatio\n  };\n};\n\nvar BORDER_STYLE = regExpToken(/^(solid|dashed|dotted)$/);\nvar defaultBorderWidth = 1;\nvar defaultBorderColor = 'black';\nvar defaultBorderStyle = 'solid';\n\nvar border = function border(tokenStream) {\n  var borderWidth;\n  var borderColor;\n  var borderStyle;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      borderWidth: 0,\n      borderColor: 'black',\n      borderStyle: 'solid'\n    };\n  }\n\n  var partsParsed = 0;\n\n  while (partsParsed < 3 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (borderWidth === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      borderWidth = tokenStream.lastValue;\n    } else if (borderColor === undefined && tokenStream.matches(COLOR)) {\n      borderColor = tokenStream.lastValue;\n    } else if (borderStyle === undefined && tokenStream.matches(BORDER_STYLE)) {\n      borderStyle = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (borderWidth === undefined) borderWidth = defaultBorderWidth;\n  if (borderColor === undefined) borderColor = defaultBorderColor;\n  if (borderStyle === undefined) borderStyle = defaultBorderStyle;\n  return {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    borderStyle: borderStyle\n  };\n};\n\nvar directionFactory = function directionFactory(_ref) {\n  var _ref$types = _ref.types,\n      types = _ref$types === void 0 ? [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT] : _ref$types,\n      _ref$directions = _ref.directions,\n      directions = _ref$directions === void 0 ? ['Top', 'Right', 'Bottom', 'Left'] : _ref$directions,\n      _ref$prefix = _ref.prefix,\n      prefix = _ref$prefix === void 0 ? '' : _ref$prefix,\n      _ref$suffix = _ref.suffix,\n      suffix = _ref$suffix === void 0 ? '' : _ref$suffix;\n  return function (tokenStream) {\n    var _ref2;\n\n    var values = []; // borderWidth doesn't currently allow a percent value, but may do in the future\n\n    values.push(tokenStream.expect.apply(tokenStream, types));\n\n    while (values.length < 4 && tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      values.push(tokenStream.expect.apply(tokenStream, types));\n    }\n\n    tokenStream.expectEmpty();\n    var top = values[0],\n        _values$ = values[1],\n        right = _values$ === void 0 ? top : _values$,\n        _values$2 = values[2],\n        bottom = _values$2 === void 0 ? top : _values$2,\n        _values$3 = values[3],\n        left = _values$3 === void 0 ? right : _values$3;\n\n    var keyFor = function keyFor(n) {\n      return \"\" + prefix + directions[n] + suffix;\n    };\n\n    return _ref2 = {}, _ref2[keyFor(0)] = top, _ref2[keyFor(1)] = right, _ref2[keyFor(2)] = bottom, _ref2[keyFor(3)] = left, _ref2;\n  };\n};\n\nvar parseShadowOffset = function parseShadowOffset(tokenStream) {\n  var width = tokenStream.expect(LENGTH);\n  var height = tokenStream.matches(SPACE) ? tokenStream.expect(LENGTH) : width;\n  tokenStream.expectEmpty();\n  return {\n    width: width,\n    height: height\n  };\n};\n\nvar parseShadow = function parseShadow(tokenStream) {\n  var offsetX;\n  var offsetY;\n  var radius;\n  var color;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      offset: {\n        width: 0,\n        height: 0\n      },\n      radius: 0,\n      color: 'black'\n    };\n  }\n\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (offsetX === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      offsetX = tokenStream.lastValue;\n      tokenStream.expect(SPACE);\n      offsetY = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n        radius = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  if (offsetX === undefined) tokenStream[\"throw\"]();\n  return {\n    offset: {\n      width: offsetX,\n      height: offsetY\n    },\n    radius: radius !== undefined ? radius : 0,\n    color: color !== undefined ? color : 'black'\n  };\n};\n\nvar boxShadow = function boxShadow(tokenStream) {\n  var _parseShadow = parseShadow(tokenStream),\n      offset = _parseShadow.offset,\n      radius = _parseShadow.radius,\n      color = _parseShadow.color;\n\n  return {\n    shadowOffset: offset,\n    shadowRadius: radius,\n    shadowColor: color,\n    shadowOpacity: 1\n  };\n};\n\nvar defaultFlexGrow = 1;\nvar defaultFlexShrink = 1;\nvar defaultFlexBasis = 0;\n\nvar flex = function flex(tokenStream) {\n  var flexGrow;\n  var flexShrink;\n  var flexBasis;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      flexGrow: 0,\n      flexShrink: 0,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.saveRewindPoint();\n\n  if (tokenStream.matches(AUTO) && !tokenStream.hasTokens()) {\n    return {\n      flexGrow: 1,\n      flexShrink: 1,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.rewind();\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexGrow === undefined && tokenStream.matches(NUMBER)) {\n      flexGrow = tokenStream.lastValue;\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(NUMBER)) {\n        flexShrink = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (flexBasis === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT)) {\n      flexBasis = tokenStream.lastValue;\n    } else if (flexBasis === undefined && tokenStream.matches(AUTO)) {\n      flexBasis = 'auto';\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexGrow === undefined) flexGrow = defaultFlexGrow;\n  if (flexShrink === undefined) flexShrink = defaultFlexShrink;\n  if (flexBasis === undefined) flexBasis = defaultFlexBasis;\n  return {\n    flexGrow: flexGrow,\n    flexShrink: flexShrink,\n    flexBasis: flexBasis\n  };\n};\n\nvar FLEX_WRAP = regExpToken(/(nowrap|wrap|wrap-reverse)/);\nvar FLEX_DIRECTION = regExpToken(/(row|row-reverse|column|column-reverse)/);\nvar defaultFlexWrap = 'nowrap';\nvar defaultFlexDirection = 'row';\n\nvar flexFlow = function flexFlow(tokenStream) {\n  var flexWrap;\n  var flexDirection;\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexWrap === undefined && tokenStream.matches(FLEX_WRAP)) {\n      flexWrap = tokenStream.lastValue;\n    } else if (flexDirection === undefined && tokenStream.matches(FLEX_DIRECTION)) {\n      flexDirection = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexWrap === undefined) flexWrap = defaultFlexWrap;\n  if (flexDirection === undefined) flexDirection = defaultFlexDirection;\n  return {\n    flexWrap: flexWrap,\n    flexDirection: flexDirection\n  };\n};\n\nvar fontFamily = function fontFamily(tokenStream) {\n  var fontFamily;\n\n  if (tokenStream.matches(STRING)) {\n    fontFamily = tokenStream.lastValue;\n  } else {\n    fontFamily = tokenStream.expect(IDENT);\n\n    while (tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      var nextIdent = tokenStream.expect(IDENT);\n      fontFamily += \" \" + nextIdent;\n    }\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    fontFamily: fontFamily\n  };\n};\n\nvar NORMAL = regExpToken(/^(normal)$/);\nvar STYLE = regExpToken(/^(italic)$/);\nvar WEIGHT = regExpToken(/^([1-9]00|bold)$/);\nvar VARIANT = regExpToken(/^(small-caps)$/);\nvar defaultFontStyle = 'normal';\nvar defaultFontWeight = 'normal';\nvar defaultFontVariant = [];\n\nvar font = function font(tokenStream) {\n  var fontStyle;\n  var fontWeight;\n  var fontVariant; // let fontSize;\n\n  var lineHeight; // let fontFamily;\n\n  var numStyleWeightVariantMatched = 0;\n\n  while (numStyleWeightVariantMatched < 3 && tokenStream.hasTokens()) {\n    if (tokenStream.matches(NORMAL)) ;else if (fontStyle === undefined && tokenStream.matches(STYLE)) {\n      fontStyle = tokenStream.lastValue;\n    } else if (fontWeight === undefined && tokenStream.matches(WEIGHT)) {\n      fontWeight = tokenStream.lastValue;\n    } else if (fontVariant === undefined && tokenStream.matches(VARIANT)) {\n      fontVariant = [tokenStream.lastValue];\n    } else {\n      break;\n    }\n    tokenStream.expect(SPACE);\n    numStyleWeightVariantMatched += 1;\n  }\n\n  var fontSize = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n\n  if (tokenStream.matches(SLASH)) {\n    lineHeight = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n  }\n\n  tokenStream.expect(SPACE);\n\n  var _fontFamily = fontFamily(tokenStream),\n      fontFamily$1 = _fontFamily.fontFamily;\n\n  if (fontStyle === undefined) fontStyle = defaultFontStyle;\n  if (fontWeight === undefined) fontWeight = defaultFontWeight;\n  if (fontVariant === undefined) fontVariant = defaultFontVariant;\n  var out = {\n    fontStyle: fontStyle,\n    fontWeight: fontWeight,\n    fontVariant: fontVariant,\n    fontSize: fontSize,\n    fontFamily: fontFamily$1\n  };\n  if (lineHeight !== undefined) out.lineHeight = lineHeight;\n  return out;\n};\n\nvar fontVariant = function fontVariant(tokenStream) {\n  var values = [tokenStream.expect(IDENT)];\n\n  while (tokenStream.hasTokens()) {\n    tokenStream.expect(SPACE);\n    values.push(tokenStream.expect(IDENT));\n  }\n\n  return {\n    fontVariant: values\n  };\n};\n\nvar ALIGN_CONTENT = regExpToken(/(flex-(?:start|end)|center|stretch|space-(?:between|around))/);\nvar JUSTIFY_CONTENT = regExpToken(/(flex-(?:start|end)|center|space-(?:between|around|evenly))/);\n\nvar placeContent = function placeContent(tokenStream) {\n  var alignContent = tokenStream.expect(ALIGN_CONTENT);\n  var justifyContent;\n\n  if (tokenStream.hasTokens()) {\n    tokenStream.expect(SPACE);\n    justifyContent = tokenStream.expect(JUSTIFY_CONTENT);\n  } else {\n    justifyContent = 'stretch';\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    alignContent: alignContent,\n    justifyContent: justifyContent\n  };\n};\n\nvar STYLE$1 = regExpToken(/^(solid|double|dotted|dashed)$/);\nvar defaultTextDecorationLine = 'none';\nvar defaultTextDecorationStyle = 'solid';\nvar defaultTextDecorationColor = 'black';\n\nvar textDecoration = function textDecoration(tokenStream) {\n  var line;\n  var style;\n  var color;\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (line === undefined && tokenStream.matches(LINE)) {\n      var lines = [tokenStream.lastValue.toLowerCase()];\n      tokenStream.saveRewindPoint();\n\n      if (lines[0] !== 'none' && tokenStream.matches(SPACE) && tokenStream.matches(LINE)) {\n        lines.push(tokenStream.lastValue.toLowerCase()); // Underline comes before line-through\n\n        lines.sort().reverse();\n      } else {\n        tokenStream.rewind();\n      }\n\n      line = lines.join(' ');\n    } else if (style === undefined && tokenStream.matches(STYLE$1)) {\n      style = tokenStream.lastValue;\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  return {\n    textDecorationLine: line !== undefined ? line : defaultTextDecorationLine,\n    textDecorationColor: color !== undefined ? color : defaultTextDecorationColor,\n    textDecorationStyle: style !== undefined ? style : defaultTextDecorationStyle\n  };\n};\n\nvar textDecorationLine = function textDecorationLine(tokenStream) {\n  var lines = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    lines.push(tokenStream.expect(LINE).toLowerCase());\n    didParseFirst = true;\n  }\n\n  lines.sort().reverse();\n  return {\n    textDecorationLine: lines.join(' ')\n  };\n};\n\nvar textShadow = function textShadow(tokenStream) {\n  var _parseShadow2 = parseShadow(tokenStream),\n      offset = _parseShadow2.offset,\n      radius = _parseShadow2.radius,\n      color = _parseShadow2.color;\n\n  return {\n    textShadowOffset: offset,\n    textShadowRadius: radius,\n    textShadowColor: color\n  };\n};\n\nvar oneOfType = function oneOfType(tokenType) {\n  return function (functionStream) {\n    var value = functionStream.expect(tokenType);\n    functionStream.expectEmpty();\n    return value;\n  };\n};\n\nvar singleNumber = oneOfType(NUMBER);\nvar singleLength = oneOfType(LENGTH);\nvar singleAngle = oneOfType(ANGLE);\n\nvar xyTransformFactory = function xyTransformFactory(tokenType) {\n  return function (key, valueIfOmitted) {\n    return function (functionStream) {\n      var _ref3, _ref4;\n\n      var x = functionStream.expect(tokenType);\n      var y;\n\n      if (functionStream.hasTokens()) {\n        functionStream.expect(COMMA);\n        y = functionStream.expect(tokenType);\n      } else if (valueIfOmitted !== undefined) {\n        y = valueIfOmitted;\n      } else {\n        // Assumption, if x === y, then we can omit XY\n        // I.e. scale(5) => [{ scale: 5 }] rather than [{ scaleX: 5 }, { scaleY: 5 }]\n        return x;\n      }\n\n      functionStream.expectEmpty();\n      return [(_ref3 = {}, _ref3[key + \"Y\"] = y, _ref3), (_ref4 = {}, _ref4[key + \"X\"] = x, _ref4)];\n    };\n  };\n};\n\nvar xyNumber = xyTransformFactory(NUMBER);\nvar xyLength = xyTransformFactory(LENGTH);\nvar xyAngle = xyTransformFactory(ANGLE);\nvar partTransforms = {\n  perspective: singleNumber,\n  scale: xyNumber('scale'),\n  scaleX: singleNumber,\n  scaleY: singleNumber,\n  translate: xyLength('translate', 0),\n  translateX: singleLength,\n  translateY: singleLength,\n  rotate: singleAngle,\n  rotateX: singleAngle,\n  rotateY: singleAngle,\n  rotateZ: singleAngle,\n  skewX: singleAngle,\n  skewY: singleAngle,\n  skew: xyAngle('skew', '0deg')\n};\n\nvar transform = function transform(tokenStream) {\n  var transforms = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    var functionStream = tokenStream.expectFunction();\n    var functionName = functionStream.functionName;\n    var transformedValues = partTransforms[functionName](functionStream);\n\n    if (!Array.isArray(transformedValues)) {\n      var _ref5;\n\n      transformedValues = [(_ref5 = {}, _ref5[functionName] = transformedValues, _ref5)];\n    }\n\n    transforms = transformedValues.concat(transforms);\n    didParseFirst = true;\n  }\n\n  return {\n    transform: transforms\n  };\n};\n\nvar background = function background(tokenStream) {\n  return {\n    backgroundColor: tokenStream.expect(COLOR)\n  };\n};\n\nvar borderColor = directionFactory({\n  types: [COLOR],\n  prefix: 'border',\n  suffix: 'Color'\n});\nvar borderRadius = directionFactory({\n  directions: ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'],\n  prefix: 'border',\n  suffix: 'Radius'\n});\nvar borderWidth = directionFactory({\n  prefix: 'border',\n  suffix: 'Width'\n});\nvar margin = directionFactory({\n  types: [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT, AUTO],\n  prefix: 'margin'\n});\nvar padding = directionFactory({\n  prefix: 'padding'\n});\n\nvar fontWeight = function fontWeight(tokenStream) {\n  return {\n    fontWeight: tokenStream.expect(WORD) // Also match numbers as strings\n\n  };\n};\n\nvar shadowOffset = function shadowOffset(tokenStream) {\n  return {\n    shadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar textShadowOffset = function textShadowOffset(tokenStream) {\n  return {\n    textShadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar transforms = {\n  aspectRatio: aspectRatio,\n  background: background,\n  border: border,\n  borderColor: borderColor,\n  borderRadius: borderRadius,\n  borderWidth: borderWidth,\n  boxShadow: boxShadow,\n  flex: flex,\n  flexFlow: flexFlow,\n  font: font,\n  fontFamily: fontFamily,\n  fontVariant: fontVariant,\n  fontWeight: fontWeight,\n  margin: margin,\n  padding: padding,\n  placeContent: placeContent,\n  shadowOffset: shadowOffset,\n  textShadow: textShadow,\n  textShadowOffset: textShadowOffset,\n  textDecoration: textDecoration,\n  textDecorationLine: textDecorationLine,\n  transform: transform\n};\nvar propertiesWithoutUnits;\n\nif (true) {\n  propertiesWithoutUnits = ['aspectRatio', 'elevation', 'flexGrow', 'flexShrink', 'opacity', 'shadowOpacity', 'zIndex'];\n}\n\nvar devPropertiesWithUnitsRegExp = propertiesWithoutUnits != null ? new RegExp(propertiesWithoutUnits.join('|')) : null;\nvar SYMBOL_MATCH = 'SYMBOL_MATCH';\n\nvar TokenStream =\n/*#__PURE__*/\nfunction () {\n  function TokenStream(nodes, parent) {\n    this.index = 0;\n    this.nodes = nodes;\n    this.functionName = parent != null ? parent.value : null;\n    this.lastValue = null;\n    this.rewindIndex = -1;\n  }\n\n  var _proto = TokenStream.prototype;\n\n  _proto.hasTokens = function hasTokens() {\n    return this.index <= this.nodes.length - 1;\n  };\n\n  _proto[SYMBOL_MATCH] = function () {\n    if (!this.hasTokens()) return null;\n    var node = this.nodes[this.index];\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      var tokenDescriptor = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      var value = tokenDescriptor(node);\n\n      if (value !== null) {\n        this.index += 1;\n        this.lastValue = value;\n        return value;\n      }\n    }\n\n    return null;\n  };\n\n  _proto.matches = function matches() {\n    return this[SYMBOL_MATCH].apply(this, arguments) !== null;\n  };\n\n  _proto.expect = function expect() {\n    var value = this[SYMBOL_MATCH].apply(this, arguments);\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.matchesFunction = function matchesFunction() {\n    var node = this.nodes[this.index];\n    if (node.type !== 'function') return null;\n    var value = new TokenStream(node.nodes, node);\n    this.index += 1;\n    this.lastValue = null;\n    return value;\n  };\n\n  _proto.expectFunction = function expectFunction() {\n    var value = this.matchesFunction();\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.expectEmpty = function expectEmpty() {\n    if (this.hasTokens()) this[\"throw\"]();\n  };\n\n  _proto[\"throw\"] = function _throw() {\n    throw new Error(\"Unexpected token type: \" + this.nodes[this.index].type);\n  };\n\n  _proto.saveRewindPoint = function saveRewindPoint() {\n    this.rewindIndex = this.index;\n  };\n\n  _proto.rewind = function rewind() {\n    if (this.rewindIndex === -1) throw new Error('Internal error');\n    this.index = this.rewindIndex;\n    this.lastValue = null;\n  };\n\n  return TokenStream;\n}();\n/* eslint-disable no-param-reassign */\n// Note if this is wrong, you'll need to change tokenTypes.js too\n\n\nvar numberOrLengthRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?:px)?$/i;\nvar numberOnlyRe = /^[+-]?(?:\\d*\\.\\d*|[1-9]\\d*)(?:e[+-]?\\d+)?$/i;\nvar boolRe = /^true|false$/i;\nvar nullRe = /^null$/i;\nvar undefinedRe = /^undefined$/i; // Undocumented export\n\nvar transformRawValue = function transformRawValue(propName, value) {\n  if (true) {\n    var needsUnit = !devPropertiesWithUnitsRegExp.test(propName);\n    var isNumberWithoutUnit = numberOnlyRe.test(value);\n\n    if (needsUnit && isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to contain units\");\n    }\n\n    if (!needsUnit && value !== '0' && !isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to be unitless\");\n    }\n  }\n\n  var numberMatch = value.match(numberOrLengthRe);\n  if (numberMatch !== null) return Number(numberMatch[1]);\n  var boolMatch = value.match(boolRe);\n  if (boolMatch !== null) return boolMatch[0].toLowerCase() === 'true';\n  var nullMatch = value.match(nullRe);\n  if (nullMatch !== null) return null;\n  var undefinedMatch = value.match(undefinedRe);\n  if (undefinedMatch !== null) return undefined;\n  return value;\n};\n\nvar baseTransformShorthandValue = function baseTransformShorthandValue(propName, value) {\n  var ast = parse__default(value);\n  var tokenStream = new TokenStream(ast.nodes);\n  return transforms[propName](tokenStream);\n};\n\nvar transformShorthandValue =  false ? 0 : function (propName, value) {\n  try {\n    return baseTransformShorthandValue(propName, value);\n  } catch (e) {\n    throw new Error(\"Failed to parse declaration \\\"\" + propName + \": \" + value + \"\\\"\");\n  }\n};\n\nvar getStylesForProperty = function getStylesForProperty(propName, inputValue, allowShorthand) {\n  var _ref6;\n\n  var isRawValue = allowShorthand === false || !(propName in transforms);\n  var value = inputValue.trim();\n  var propValues = isRawValue ? (_ref6 = {}, _ref6[propName] = transformRawValue(propName, value), _ref6) : transformShorthandValue(propName, value);\n  return propValues;\n};\n\nvar getPropertyName = function getPropertyName(propName) {\n  var isCustomProp = /^--\\w+/.test(propName);\n\n  if (isCustomProp) {\n    return propName;\n  }\n\n  return camelizeStyleName(propName);\n};\n\nvar index = function index(rules, shorthandBlacklist) {\n  if (shorthandBlacklist === void 0) {\n    shorthandBlacklist = [];\n  }\n\n  return rules.reduce(function (accum, rule) {\n    var propertyName = getPropertyName(rule[0]);\n    var value = rule[1];\n    var allowShorthand = shorthandBlacklist.indexOf(propertyName) === -1;\n    return Object.assign(accum, getStylesForProperty(propertyName, value, allowShorthand));\n  }, {});\n};\n\nexports[\"default\"] = index;\nexports.getPropertyName = getPropertyName;\nexports.getStylesForProperty = getStylesForProperty;\nexports.transformRawValue = transformRawValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3NzLXRvLXJlYWN0LW5hdGl2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxvRkFBc0I7O0FBRTFDOztBQUVBLHdDQUF3QyxtQkFBTyxDQUFDLHdEQUFVOztBQUUxRCx1Q0FBdUMsbUJBQU8sQ0FBQyw0RUFBb0I7O0FBRW5FO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQ0FBaUMsSUFBSSxFQUFFLElBQUk7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQyx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSwrQkFBK0IsVUFBVSxpQkFBaUIsV0FBVyxJQUFJLFdBQVc7QUFDcEY7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QiwyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsTUFBcUMsR0FBRyxDQUEyQjtBQUNqRztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQSxrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1Qix5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmV5bWF0dGVyLXYyLy4vbm9kZV9tb2R1bGVzL2Nzcy10by1yZWFjdC1uYXRpdmUvaW5kZXguanM/YTk2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQoZXgpIHtcbiAgcmV0dXJuIGV4ICYmIHR5cGVvZiBleCA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGV4ID8gZXhbJ2RlZmF1bHQnXSA6IGV4O1xufVxuXG52YXIgcGFyc2UgPSByZXF1aXJlKCdwb3N0Y3NzLXZhbHVlLXBhcnNlcicpO1xuXG52YXIgcGFyc2VfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQocGFyc2UpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnY2FtZWxpemUnKSk7XG5cbnZhciBjc3NDb2xvcktleXdvcmRzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2Nzcy1jb2xvci1rZXl3b3JkcycpKTtcblxudmFyIG1hdGNoU3RyaW5nID0gZnVuY3Rpb24gbWF0Y2hTdHJpbmcobm9kZSkge1xuICBpZiAobm9kZS50eXBlICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBub2RlLnZhbHVlLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSkoPzpcXHN8JCkvZ2ksIGZ1bmN0aW9uIChtYXRjaCwgY2hhckNvZGUpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjaGFyQ29kZSwgMTYpKTtcbiAgfSkucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG59O1xuXG52YXIgaGV4Q29sb3JSZSA9IC9eKCMoPzpbMC05YS1mXXszLDR9KXsxLDJ9KSQvaTtcbnZhciBjc3NGdW5jdGlvbk5hbWVSZSA9IC9eKHJnYmE/fGhzbGE/fGh3YnxsYWJ8bGNofGdyYXl8Y29sb3IpJC87XG5cbnZhciBtYXRjaENvbG9yID0gZnVuY3Rpb24gbWF0Y2hDb2xvcihub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICd3b3JkJyAmJiAoaGV4Q29sb3JSZS50ZXN0KG5vZGUudmFsdWUpIHx8IG5vZGUudmFsdWUgaW4gY3NzQ29sb3JLZXl3b3JkcyB8fCBub2RlLnZhbHVlID09PSAndHJhbnNwYXJlbnQnKSkge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBjc3NGdW5jdGlvbk5hbWVSZS50ZXN0KG5vZGUudmFsdWUpKSB7XG4gICAgcmV0dXJuIHBhcnNlLnN0cmluZ2lmeShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIG5vbmVSZSA9IC9eKG5vbmUpJC9pO1xudmFyIGF1dG9SZSA9IC9eKGF1dG8pJC9pO1xudmFyIGlkZW50UmUgPSAvKF4tP1tfYS16XVtfYS16MC05LV0qJCkvaTsgLy8gTm90ZSBpZiB0aGVzZSBhcmUgd3JvbmcsIHlvdSdsbCBuZWVkIHRvIGNoYW5nZSBpbmRleC5qcyB0b29cblxudmFyIG51bWJlclJlID0gL14oWystXT8oPzpcXGQqXFwuKT9cXGQrKD86ZVsrLV0/XFxkKyk/KSQvaTsgLy8gTm90ZSBsZW5ndGhSZSBpcyBzbmVha3k6IHlvdSBjYW4gb21pdCB1bml0cyBmb3IgMFxuXG52YXIgbGVuZ3RoUmUgPSAvXigwJHwoPzpbKy1dPyg/OlxcZCpcXC4pP1xcZCsoPzplWystXT9cXGQrKT8pKD89cHgkKSkvaTtcbnZhciB1bnN1cHBvcnRlZFVuaXRSZSA9IC9eKFsrLV0/KD86XFxkKlxcLik/XFxkKyg/OmVbKy1dP1xcZCspPyhjaHxlbXxleHxyZW18dmh8dnd8dm1pbnx2bWF4fGNtfG1tfGlufHBjfHB0KSkkL2k7XG52YXIgYW5nbGVSZSA9IC9eKFsrLV0/KD86XFxkKlxcLik/XFxkKyg/OmVbKy1dP1xcZCspPyg/OmRlZ3xyYWQpKSQvaTtcbnZhciBwZXJjZW50UmUgPSAvXihbKy1dPyg/OlxcZCpcXC4pP1xcZCsoPzplWystXT9cXGQrKT8lKSQvaTtcblxudmFyIG5vb3BUb2tlbiA9IGZ1bmN0aW9uIG5vb3BUb2tlbihwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHByZWRpY2F0ZShub2RlKSA/ICc8dG9rZW4+JyA6IG51bGw7XG4gIH07XG59O1xuXG52YXIgdmFsdWVGb3JUeXBlVG9rZW4gPSBmdW5jdGlvbiB2YWx1ZUZvclR5cGVUb2tlbih0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IHR5cGUgPyBub2RlLnZhbHVlIDogbnVsbDtcbiAgfTtcbn07XG5cbnZhciByZWdFeHBUb2tlbiA9IGZ1bmN0aW9uIHJlZ0V4cFRva2VuKHJlZ0V4cCwgdHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT09IHZvaWQgMCkge1xuICAgIHRyYW5zZm9ybSA9IFN0cmluZztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09ICd3b3JkJykgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1hdGNoID0gbm9kZS52YWx1ZS5tYXRjaChyZWdFeHApO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtKG1hdGNoWzFdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuXG52YXIgU1BBQ0UgPSBub29wVG9rZW4oZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3NwYWNlJztcbn0pO1xudmFyIFNMQVNIID0gbm9vcFRva2VuKGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09ICdkaXYnICYmIG5vZGUudmFsdWUgPT09ICcvJztcbn0pO1xudmFyIENPTU1BID0gbm9vcFRva2VuKGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09ICdkaXYnICYmIG5vZGUudmFsdWUgPT09ICcsJztcbn0pO1xudmFyIFdPUkQgPSB2YWx1ZUZvclR5cGVUb2tlbignd29yZCcpO1xudmFyIE5PTkUgPSByZWdFeHBUb2tlbihub25lUmUpO1xudmFyIEFVVE8gPSByZWdFeHBUb2tlbihhdXRvUmUpO1xudmFyIE5VTUJFUiA9IHJlZ0V4cFRva2VuKG51bWJlclJlLCBOdW1iZXIpO1xudmFyIExFTkdUSCA9IHJlZ0V4cFRva2VuKGxlbmd0aFJlLCBOdW1iZXIpO1xudmFyIFVOU1VQUE9SVEVEX0xFTkdUSF9VTklUID0gcmVnRXhwVG9rZW4odW5zdXBwb3J0ZWRVbml0UmUpO1xudmFyIEFOR0xFID0gcmVnRXhwVG9rZW4oYW5nbGVSZSwgZnVuY3Rpb24gKGFuZ2xlKSB7XG4gIHJldHVybiBhbmdsZS50b0xvd2VyQ2FzZSgpO1xufSk7XG52YXIgUEVSQ0VOVCA9IHJlZ0V4cFRva2VuKHBlcmNlbnRSZSk7XG52YXIgSURFTlQgPSByZWdFeHBUb2tlbihpZGVudFJlKTtcbnZhciBTVFJJTkcgPSBtYXRjaFN0cmluZztcbnZhciBDT0xPUiA9IG1hdGNoQ29sb3I7XG52YXIgTElORSA9IHJlZ0V4cFRva2VuKC9eKG5vbmV8dW5kZXJsaW5lfGxpbmUtdGhyb3VnaCkkL2kpO1xuXG52YXIgYXNwZWN0UmF0aW8gPSBmdW5jdGlvbiBhc3BlY3RSYXRpbyh0b2tlblN0cmVhbSkge1xuICB2YXIgYXNwZWN0UmF0aW8gPSB0b2tlblN0cmVhbS5leHBlY3QoTlVNQkVSKTtcblxuICBpZiAodG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICB0b2tlblN0cmVhbS5leHBlY3QoU0xBU0gpO1xuICAgIGFzcGVjdFJhdGlvIC89IHRva2VuU3RyZWFtLmV4cGVjdChOVU1CRVIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW9cbiAgfTtcbn07XG5cbnZhciBCT1JERVJfU1RZTEUgPSByZWdFeHBUb2tlbigvXihzb2xpZHxkYXNoZWR8ZG90dGVkKSQvKTtcbnZhciBkZWZhdWx0Qm9yZGVyV2lkdGggPSAxO1xudmFyIGRlZmF1bHRCb3JkZXJDb2xvciA9ICdibGFjayc7XG52YXIgZGVmYXVsdEJvcmRlclN0eWxlID0gJ3NvbGlkJztcblxudmFyIGJvcmRlciA9IGZ1bmN0aW9uIGJvcmRlcih0b2tlblN0cmVhbSkge1xuICB2YXIgYm9yZGVyV2lkdGg7XG4gIHZhciBib3JkZXJDb2xvcjtcbiAgdmFyIGJvcmRlclN0eWxlO1xuXG4gIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKE5PTkUpKSB7XG4gICAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICBib3JkZXJDb2xvcjogJ2JsYWNrJyxcbiAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYXJ0c1BhcnNlZCA9IDA7XG5cbiAgd2hpbGUgKHBhcnRzUGFyc2VkIDwgMyAmJiB0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmIChwYXJ0c1BhcnNlZCAhPT0gMCkgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcblxuICAgIGlmIChib3JkZXJXaWR0aCA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoTEVOR1RILCBVTlNVUFBPUlRFRF9MRU5HVEhfVU5JVCkpIHtcbiAgICAgIGJvcmRlcldpZHRoID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoYm9yZGVyQ29sb3IgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKENPTE9SKSkge1xuICAgICAgYm9yZGVyQ29sb3IgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChib3JkZXJTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoQk9SREVSX1NUWUxFKSkge1xuICAgICAgYm9yZGVyU3R5bGUgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuU3RyZWFtW1widGhyb3dcIl0oKTtcbiAgICB9XG5cbiAgICBwYXJ0c1BhcnNlZCArPSAxO1xuICB9XG5cbiAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgaWYgKGJvcmRlcldpZHRoID09PSB1bmRlZmluZWQpIGJvcmRlcldpZHRoID0gZGVmYXVsdEJvcmRlcldpZHRoO1xuICBpZiAoYm9yZGVyQ29sb3IgPT09IHVuZGVmaW5lZCkgYm9yZGVyQ29sb3IgPSBkZWZhdWx0Qm9yZGVyQ29sb3I7XG4gIGlmIChib3JkZXJTdHlsZSA9PT0gdW5kZWZpbmVkKSBib3JkZXJTdHlsZSA9IGRlZmF1bHRCb3JkZXJTdHlsZTtcbiAgcmV0dXJuIHtcbiAgICBib3JkZXJXaWR0aDogYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgIGJvcmRlclN0eWxlOiBib3JkZXJTdHlsZVxuICB9O1xufTtcblxudmFyIGRpcmVjdGlvbkZhY3RvcnkgPSBmdW5jdGlvbiBkaXJlY3Rpb25GYWN0b3J5KF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZXMgPSBfcmVmLnR5cGVzLFxuICAgICAgdHlwZXMgPSBfcmVmJHR5cGVzID09PSB2b2lkIDAgPyBbTEVOR1RILCBVTlNVUFBPUlRFRF9MRU5HVEhfVU5JVCwgUEVSQ0VOVF0gOiBfcmVmJHR5cGVzLFxuICAgICAgX3JlZiRkaXJlY3Rpb25zID0gX3JlZi5kaXJlY3Rpb25zLFxuICAgICAgZGlyZWN0aW9ucyA9IF9yZWYkZGlyZWN0aW9ucyA9PT0gdm9pZCAwID8gWydUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0xlZnQnXSA6IF9yZWYkZGlyZWN0aW9ucyxcbiAgICAgIF9yZWYkcHJlZml4ID0gX3JlZi5wcmVmaXgsXG4gICAgICBwcmVmaXggPSBfcmVmJHByZWZpeCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHByZWZpeCxcbiAgICAgIF9yZWYkc3VmZml4ID0gX3JlZi5zdWZmaXgsXG4gICAgICBzdWZmaXggPSBfcmVmJHN1ZmZpeCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHN1ZmZpeDtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlblN0cmVhbSkge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHZhciB2YWx1ZXMgPSBbXTsgLy8gYm9yZGVyV2lkdGggZG9lc24ndCBjdXJyZW50bHkgYWxsb3cgYSBwZXJjZW50IHZhbHVlLCBidXQgbWF5IGRvIGluIHRoZSBmdXR1cmVcblxuICAgIHZhbHVlcy5wdXNoKHRva2VuU3RyZWFtLmV4cGVjdC5hcHBseSh0b2tlblN0cmVhbSwgdHlwZXMpKTtcblxuICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgNCAmJiB0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgICAgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcbiAgICAgIHZhbHVlcy5wdXNoKHRva2VuU3RyZWFtLmV4cGVjdC5hcHBseSh0b2tlblN0cmVhbSwgdHlwZXMpKTtcbiAgICB9XG5cbiAgICB0b2tlblN0cmVhbS5leHBlY3RFbXB0eSgpO1xuICAgIHZhciB0b3AgPSB2YWx1ZXNbMF0sXG4gICAgICAgIF92YWx1ZXMkID0gdmFsdWVzWzFdLFxuICAgICAgICByaWdodCA9IF92YWx1ZXMkID09PSB2b2lkIDAgPyB0b3AgOiBfdmFsdWVzJCxcbiAgICAgICAgX3ZhbHVlcyQyID0gdmFsdWVzWzJdLFxuICAgICAgICBib3R0b20gPSBfdmFsdWVzJDIgPT09IHZvaWQgMCA/IHRvcCA6IF92YWx1ZXMkMixcbiAgICAgICAgX3ZhbHVlcyQzID0gdmFsdWVzWzNdLFxuICAgICAgICBsZWZ0ID0gX3ZhbHVlcyQzID09PSB2b2lkIDAgPyByaWdodCA6IF92YWx1ZXMkMztcblxuICAgIHZhciBrZXlGb3IgPSBmdW5jdGlvbiBrZXlGb3Iobikge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyBkaXJlY3Rpb25zW25dICsgc3VmZml4O1xuICAgIH07XG5cbiAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJba2V5Rm9yKDApXSA9IHRvcCwgX3JlZjJba2V5Rm9yKDEpXSA9IHJpZ2h0LCBfcmVmMltrZXlGb3IoMildID0gYm90dG9tLCBfcmVmMltrZXlGb3IoMyldID0gbGVmdCwgX3JlZjI7XG4gIH07XG59O1xuXG52YXIgcGFyc2VTaGFkb3dPZmZzZXQgPSBmdW5jdGlvbiBwYXJzZVNoYWRvd09mZnNldCh0b2tlblN0cmVhbSkge1xuICB2YXIgd2lkdGggPSB0b2tlblN0cmVhbS5leHBlY3QoTEVOR1RIKTtcbiAgdmFyIGhlaWdodCA9IHRva2VuU3RyZWFtLm1hdGNoZXMoU1BBQ0UpID8gdG9rZW5TdHJlYW0uZXhwZWN0KExFTkdUSCkgOiB3aWR0aDtcbiAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn07XG5cbnZhciBwYXJzZVNoYWRvdyA9IGZ1bmN0aW9uIHBhcnNlU2hhZG93KHRva2VuU3RyZWFtKSB7XG4gIHZhciBvZmZzZXRYO1xuICB2YXIgb2Zmc2V0WTtcbiAgdmFyIHJhZGl1cztcbiAgdmFyIGNvbG9yO1xuXG4gIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKE5PTkUpKSB7XG4gICAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sXG4gICAgICByYWRpdXM6IDAsXG4gICAgICBjb2xvcjogJ2JsYWNrJ1xuICAgIH07XG4gIH1cblxuICB2YXIgZGlkUGFyc2VGaXJzdCA9IGZhbHNlO1xuXG4gIHdoaWxlICh0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmIChkaWRQYXJzZUZpcnN0KSB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQpKSB7XG4gICAgICBvZmZzZXRYID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgICAgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcbiAgICAgIG9mZnNldFkgPSB0b2tlblN0cmVhbS5leHBlY3QoTEVOR1RILCBVTlNVUFBPUlRFRF9MRU5HVEhfVU5JVCk7XG4gICAgICB0b2tlblN0cmVhbS5zYXZlUmV3aW5kUG9pbnQoKTtcblxuICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoZXMoU1BBQ0UpICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoTEVOR1RILCBVTlNVUFBPUlRFRF9MRU5HVEhfVU5JVCkpIHtcbiAgICAgICAgcmFkaXVzID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5TdHJlYW0ucmV3aW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoQ09MT1IpKSB7XG4gICAgICBjb2xvciA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5TdHJlYW1bXCJ0aHJvd1wiXSgpO1xuICAgIH1cblxuICAgIGRpZFBhcnNlRmlyc3QgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgdG9rZW5TdHJlYW1bXCJ0aHJvd1wiXSgpO1xuICByZXR1cm4ge1xuICAgIG9mZnNldDoge1xuICAgICAgd2lkdGg6IG9mZnNldFgsXG4gICAgICBoZWlnaHQ6IG9mZnNldFlcbiAgICB9LFxuICAgIHJhZGl1czogcmFkaXVzICE9PSB1bmRlZmluZWQgPyByYWRpdXMgOiAwLFxuICAgIGNvbG9yOiBjb2xvciAhPT0gdW5kZWZpbmVkID8gY29sb3IgOiAnYmxhY2snXG4gIH07XG59O1xuXG52YXIgYm94U2hhZG93ID0gZnVuY3Rpb24gYm94U2hhZG93KHRva2VuU3RyZWFtKSB7XG4gIHZhciBfcGFyc2VTaGFkb3cgPSBwYXJzZVNoYWRvdyh0b2tlblN0cmVhbSksXG4gICAgICBvZmZzZXQgPSBfcGFyc2VTaGFkb3cub2Zmc2V0LFxuICAgICAgcmFkaXVzID0gX3BhcnNlU2hhZG93LnJhZGl1cyxcbiAgICAgIGNvbG9yID0gX3BhcnNlU2hhZG93LmNvbG9yO1xuXG4gIHJldHVybiB7XG4gICAgc2hhZG93T2Zmc2V0OiBvZmZzZXQsXG4gICAgc2hhZG93UmFkaXVzOiByYWRpdXMsXG4gICAgc2hhZG93Q29sb3I6IGNvbG9yLFxuICAgIHNoYWRvd09wYWNpdHk6IDFcbiAgfTtcbn07XG5cbnZhciBkZWZhdWx0RmxleEdyb3cgPSAxO1xudmFyIGRlZmF1bHRGbGV4U2hyaW5rID0gMTtcbnZhciBkZWZhdWx0RmxleEJhc2lzID0gMDtcblxudmFyIGZsZXggPSBmdW5jdGlvbiBmbGV4KHRva2VuU3RyZWFtKSB7XG4gIHZhciBmbGV4R3JvdztcbiAgdmFyIGZsZXhTaHJpbms7XG4gIHZhciBmbGV4QmFzaXM7XG5cbiAgaWYgKHRva2VuU3RyZWFtLm1hdGNoZXMoTk9ORSkpIHtcbiAgICB0b2tlblN0cmVhbS5leHBlY3RFbXB0eSgpO1xuICAgIHJldHVybiB7XG4gICAgICBmbGV4R3JvdzogMCxcbiAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICBmbGV4QmFzaXM6ICdhdXRvJ1xuICAgIH07XG4gIH1cblxuICB0b2tlblN0cmVhbS5zYXZlUmV3aW5kUG9pbnQoKTtcblxuICBpZiAodG9rZW5TdHJlYW0ubWF0Y2hlcyhBVVRPKSAmJiAhdG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmxleEdyb3c6IDEsXG4gICAgICBmbGV4U2hyaW5rOiAxLFxuICAgICAgZmxleEJhc2lzOiAnYXV0bydcbiAgICB9O1xuICB9XG5cbiAgdG9rZW5TdHJlYW0ucmV3aW5kKCk7XG4gIHZhciBwYXJ0c1BhcnNlZCA9IDA7XG5cbiAgd2hpbGUgKHBhcnRzUGFyc2VkIDwgMiAmJiB0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmIChwYXJ0c1BhcnNlZCAhPT0gMCkgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcblxuICAgIGlmIChmbGV4R3JvdyA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoTlVNQkVSKSkge1xuICAgICAgZmxleEdyb3cgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgICB0b2tlblN0cmVhbS5zYXZlUmV3aW5kUG9pbnQoKTtcblxuICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoZXMoU1BBQ0UpICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoTlVNQkVSKSkge1xuICAgICAgICBmbGV4U2hyaW5rID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5TdHJlYW0ucmV3aW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmbGV4QmFzaXMgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQsIFBFUkNFTlQpKSB7XG4gICAgICBmbGV4QmFzaXMgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChmbGV4QmFzaXMgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKEFVVE8pKSB7XG4gICAgICBmbGV4QmFzaXMgPSAnYXV0byc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuU3RyZWFtW1widGhyb3dcIl0oKTtcbiAgICB9XG5cbiAgICBwYXJ0c1BhcnNlZCArPSAxO1xuICB9XG5cbiAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgaWYgKGZsZXhHcm93ID09PSB1bmRlZmluZWQpIGZsZXhHcm93ID0gZGVmYXVsdEZsZXhHcm93O1xuICBpZiAoZmxleFNocmluayA9PT0gdW5kZWZpbmVkKSBmbGV4U2hyaW5rID0gZGVmYXVsdEZsZXhTaHJpbms7XG4gIGlmIChmbGV4QmFzaXMgPT09IHVuZGVmaW5lZCkgZmxleEJhc2lzID0gZGVmYXVsdEZsZXhCYXNpcztcbiAgcmV0dXJuIHtcbiAgICBmbGV4R3JvdzogZmxleEdyb3csXG4gICAgZmxleFNocmluazogZmxleFNocmluayxcbiAgICBmbGV4QmFzaXM6IGZsZXhCYXNpc1xuICB9O1xufTtcblxudmFyIEZMRVhfV1JBUCA9IHJlZ0V4cFRva2VuKC8obm93cmFwfHdyYXB8d3JhcC1yZXZlcnNlKS8pO1xudmFyIEZMRVhfRElSRUNUSU9OID0gcmVnRXhwVG9rZW4oLyhyb3d8cm93LXJldmVyc2V8Y29sdW1ufGNvbHVtbi1yZXZlcnNlKS8pO1xudmFyIGRlZmF1bHRGbGV4V3JhcCA9ICdub3dyYXAnO1xudmFyIGRlZmF1bHRGbGV4RGlyZWN0aW9uID0gJ3Jvdyc7XG5cbnZhciBmbGV4RmxvdyA9IGZ1bmN0aW9uIGZsZXhGbG93KHRva2VuU3RyZWFtKSB7XG4gIHZhciBmbGV4V3JhcDtcbiAgdmFyIGZsZXhEaXJlY3Rpb247XG4gIHZhciBwYXJ0c1BhcnNlZCA9IDA7XG5cbiAgd2hpbGUgKHBhcnRzUGFyc2VkIDwgMiAmJiB0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmIChwYXJ0c1BhcnNlZCAhPT0gMCkgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcblxuICAgIGlmIChmbGV4V3JhcCA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoRkxFWF9XUkFQKSkge1xuICAgICAgZmxleFdyYXAgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChmbGV4RGlyZWN0aW9uID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhGTEVYX0RJUkVDVElPTikpIHtcbiAgICAgIGZsZXhEaXJlY3Rpb24gPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuU3RyZWFtW1widGhyb3dcIl0oKTtcbiAgICB9XG5cbiAgICBwYXJ0c1BhcnNlZCArPSAxO1xuICB9XG5cbiAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgaWYgKGZsZXhXcmFwID09PSB1bmRlZmluZWQpIGZsZXhXcmFwID0gZGVmYXVsdEZsZXhXcmFwO1xuICBpZiAoZmxleERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSBmbGV4RGlyZWN0aW9uID0gZGVmYXVsdEZsZXhEaXJlY3Rpb247XG4gIHJldHVybiB7XG4gICAgZmxleFdyYXA6IGZsZXhXcmFwLFxuICAgIGZsZXhEaXJlY3Rpb246IGZsZXhEaXJlY3Rpb25cbiAgfTtcbn07XG5cbnZhciBmb250RmFtaWx5ID0gZnVuY3Rpb24gZm9udEZhbWlseSh0b2tlblN0cmVhbSkge1xuICB2YXIgZm9udEZhbWlseTtcblxuICBpZiAodG9rZW5TdHJlYW0ubWF0Y2hlcyhTVFJJTkcpKSB7XG4gICAgZm9udEZhbWlseSA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBmb250RmFtaWx5ID0gdG9rZW5TdHJlYW0uZXhwZWN0KElERU5UKTtcblxuICAgIHdoaWxlICh0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgICAgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcbiAgICAgIHZhciBuZXh0SWRlbnQgPSB0b2tlblN0cmVhbS5leHBlY3QoSURFTlQpO1xuICAgICAgZm9udEZhbWlseSArPSBcIiBcIiArIG5leHRJZGVudDtcbiAgICB9XG4gIH1cblxuICB0b2tlblN0cmVhbS5leHBlY3RFbXB0eSgpO1xuICByZXR1cm4ge1xuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfTtcbn07XG5cbnZhciBOT1JNQUwgPSByZWdFeHBUb2tlbigvXihub3JtYWwpJC8pO1xudmFyIFNUWUxFID0gcmVnRXhwVG9rZW4oL14oaXRhbGljKSQvKTtcbnZhciBXRUlHSFQgPSByZWdFeHBUb2tlbigvXihbMS05XTAwfGJvbGQpJC8pO1xudmFyIFZBUklBTlQgPSByZWdFeHBUb2tlbigvXihzbWFsbC1jYXBzKSQvKTtcbnZhciBkZWZhdWx0Rm9udFN0eWxlID0gJ25vcm1hbCc7XG52YXIgZGVmYXVsdEZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbnZhciBkZWZhdWx0Rm9udFZhcmlhbnQgPSBbXTtcblxudmFyIGZvbnQgPSBmdW5jdGlvbiBmb250KHRva2VuU3RyZWFtKSB7XG4gIHZhciBmb250U3R5bGU7XG4gIHZhciBmb250V2VpZ2h0O1xuICB2YXIgZm9udFZhcmlhbnQ7IC8vIGxldCBmb250U2l6ZTtcblxuICB2YXIgbGluZUhlaWdodDsgLy8gbGV0IGZvbnRGYW1pbHk7XG5cbiAgdmFyIG51bVN0eWxlV2VpZ2h0VmFyaWFudE1hdGNoZWQgPSAwO1xuXG4gIHdoaWxlIChudW1TdHlsZVdlaWdodFZhcmlhbnRNYXRjaGVkIDwgMyAmJiB0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKE5PUk1BTCkpIDtlbHNlIGlmIChmb250U3R5bGUgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKFNUWUxFKSkge1xuICAgICAgZm9udFN0eWxlID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZm9udFdlaWdodCA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoV0VJR0hUKSkge1xuICAgICAgZm9udFdlaWdodCA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGZvbnRWYXJpYW50ID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhWQVJJQU5UKSkge1xuICAgICAgZm9udFZhcmlhbnQgPSBbdG9rZW5TdHJlYW0ubGFzdFZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG4gICAgbnVtU3R5bGVXZWlnaHRWYXJpYW50TWF0Y2hlZCArPSAxO1xuICB9XG5cbiAgdmFyIGZvbnRTaXplID0gdG9rZW5TdHJlYW0uZXhwZWN0KExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQpO1xuXG4gIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKFNMQVNIKSkge1xuICAgIGxpbmVIZWlnaHQgPSB0b2tlblN0cmVhbS5leHBlY3QoTEVOR1RILCBVTlNVUFBPUlRFRF9MRU5HVEhfVU5JVCk7XG4gIH1cblxuICB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuXG4gIHZhciBfZm9udEZhbWlseSA9IGZvbnRGYW1pbHkodG9rZW5TdHJlYW0pLFxuICAgICAgZm9udEZhbWlseSQxID0gX2ZvbnRGYW1pbHkuZm9udEZhbWlseTtcblxuICBpZiAoZm9udFN0eWxlID09PSB1bmRlZmluZWQpIGZvbnRTdHlsZSA9IGRlZmF1bHRGb250U3R5bGU7XG4gIGlmIChmb250V2VpZ2h0ID09PSB1bmRlZmluZWQpIGZvbnRXZWlnaHQgPSBkZWZhdWx0Rm9udFdlaWdodDtcbiAgaWYgKGZvbnRWYXJpYW50ID09PSB1bmRlZmluZWQpIGZvbnRWYXJpYW50ID0gZGVmYXVsdEZvbnRWYXJpYW50O1xuICB2YXIgb3V0ID0ge1xuICAgIGZvbnRTdHlsZTogZm9udFN0eWxlLFxuICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgZm9udFZhcmlhbnQ6IGZvbnRWYXJpYW50LFxuICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5JDFcbiAgfTtcbiAgaWYgKGxpbmVIZWlnaHQgIT09IHVuZGVmaW5lZCkgb3V0LmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICByZXR1cm4gb3V0O1xufTtcblxudmFyIGZvbnRWYXJpYW50ID0gZnVuY3Rpb24gZm9udFZhcmlhbnQodG9rZW5TdHJlYW0pIHtcbiAgdmFyIHZhbHVlcyA9IFt0b2tlblN0cmVhbS5leHBlY3QoSURFTlQpXTtcblxuICB3aGlsZSAodG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuICAgIHZhbHVlcy5wdXNoKHRva2VuU3RyZWFtLmV4cGVjdChJREVOVCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb250VmFyaWFudDogdmFsdWVzXG4gIH07XG59O1xuXG52YXIgQUxJR05fQ09OVEVOVCA9IHJlZ0V4cFRva2VuKC8oZmxleC0oPzpzdGFydHxlbmQpfGNlbnRlcnxzdHJldGNofHNwYWNlLSg/OmJldHdlZW58YXJvdW5kKSkvKTtcbnZhciBKVVNUSUZZX0NPTlRFTlQgPSByZWdFeHBUb2tlbigvKGZsZXgtKD86c3RhcnR8ZW5kKXxjZW50ZXJ8c3BhY2UtKD86YmV0d2Vlbnxhcm91bmR8ZXZlbmx5KSkvKTtcblxudmFyIHBsYWNlQ29udGVudCA9IGZ1bmN0aW9uIHBsYWNlQ29udGVudCh0b2tlblN0cmVhbSkge1xuICB2YXIgYWxpZ25Db250ZW50ID0gdG9rZW5TdHJlYW0uZXhwZWN0KEFMSUdOX0NPTlRFTlQpO1xuICB2YXIganVzdGlmeUNvbnRlbnQ7XG5cbiAgaWYgKHRva2VuU3RyZWFtLmhhc1Rva2VucygpKSB7XG4gICAgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcbiAgICBqdXN0aWZ5Q29udGVudCA9IHRva2VuU3RyZWFtLmV4cGVjdChKVVNUSUZZX0NPTlRFTlQpO1xuICB9IGVsc2Uge1xuICAgIGp1c3RpZnlDb250ZW50ID0gJ3N0cmV0Y2gnO1xuICB9XG5cbiAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgcmV0dXJuIHtcbiAgICBhbGlnbkNvbnRlbnQ6IGFsaWduQ29udGVudCxcbiAgICBqdXN0aWZ5Q29udGVudDoganVzdGlmeUNvbnRlbnRcbiAgfTtcbn07XG5cbnZhciBTVFlMRSQxID0gcmVnRXhwVG9rZW4oL14oc29saWR8ZG91YmxlfGRvdHRlZHxkYXNoZWQpJC8pO1xudmFyIGRlZmF1bHRUZXh0RGVjb3JhdGlvbkxpbmUgPSAnbm9uZSc7XG52YXIgZGVmYXVsdFRleHREZWNvcmF0aW9uU3R5bGUgPSAnc29saWQnO1xudmFyIGRlZmF1bHRUZXh0RGVjb3JhdGlvbkNvbG9yID0gJ2JsYWNrJztcblxudmFyIHRleHREZWNvcmF0aW9uID0gZnVuY3Rpb24gdGV4dERlY29yYXRpb24odG9rZW5TdHJlYW0pIHtcbiAgdmFyIGxpbmU7XG4gIHZhciBzdHlsZTtcbiAgdmFyIGNvbG9yO1xuICB2YXIgZGlkUGFyc2VGaXJzdCA9IGZhbHNlO1xuXG4gIHdoaWxlICh0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmIChkaWRQYXJzZUZpcnN0KSB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuXG4gICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKExJTkUpKSB7XG4gICAgICB2YXIgbGluZXMgPSBbdG9rZW5TdHJlYW0ubGFzdFZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgdG9rZW5TdHJlYW0uc2F2ZVJld2luZFBvaW50KCk7XG5cbiAgICAgIGlmIChsaW5lc1swXSAhPT0gJ25vbmUnICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoU1BBQ0UpICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoTElORSkpIHtcbiAgICAgICAgbGluZXMucHVzaCh0b2tlblN0cmVhbS5sYXN0VmFsdWUudG9Mb3dlckNhc2UoKSk7IC8vIFVuZGVybGluZSBjb21lcyBiZWZvcmUgbGluZS10aHJvdWdoXG5cbiAgICAgICAgbGluZXMuc29ydCgpLnJldmVyc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuU3RyZWFtLnJld2luZCgpO1xuICAgICAgfVxuXG4gICAgICBsaW5lID0gbGluZXMuam9pbignICcpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKFNUWUxFJDEpKSB7XG4gICAgICBzdHlsZSA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhDT0xPUikpIHtcbiAgICAgIGNvbG9yID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlblN0cmVhbVtcInRocm93XCJdKCk7XG4gICAgfVxuXG4gICAgZGlkUGFyc2VGaXJzdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRleHREZWNvcmF0aW9uTGluZTogbGluZSAhPT0gdW5kZWZpbmVkID8gbGluZSA6IGRlZmF1bHRUZXh0RGVjb3JhdGlvbkxpbmUsXG4gICAgdGV4dERlY29yYXRpb25Db2xvcjogY29sb3IgIT09IHVuZGVmaW5lZCA/IGNvbG9yIDogZGVmYXVsdFRleHREZWNvcmF0aW9uQ29sb3IsXG4gICAgdGV4dERlY29yYXRpb25TdHlsZTogc3R5bGUgIT09IHVuZGVmaW5lZCA/IHN0eWxlIDogZGVmYXVsdFRleHREZWNvcmF0aW9uU3R5bGVcbiAgfTtcbn07XG5cbnZhciB0ZXh0RGVjb3JhdGlvbkxpbmUgPSBmdW5jdGlvbiB0ZXh0RGVjb3JhdGlvbkxpbmUodG9rZW5TdHJlYW0pIHtcbiAgdmFyIGxpbmVzID0gW107XG4gIHZhciBkaWRQYXJzZUZpcnN0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRva2VuU3RyZWFtLmhhc1Rva2VucygpKSB7XG4gICAgaWYgKGRpZFBhcnNlRmlyc3QpIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG4gICAgbGluZXMucHVzaCh0b2tlblN0cmVhbS5leHBlY3QoTElORSkudG9Mb3dlckNhc2UoKSk7XG4gICAgZGlkUGFyc2VGaXJzdCA9IHRydWU7XG4gIH1cblxuICBsaW5lcy5zb3J0KCkucmV2ZXJzZSgpO1xuICByZXR1cm4ge1xuICAgIHRleHREZWNvcmF0aW9uTGluZTogbGluZXMuam9pbignICcpXG4gIH07XG59O1xuXG52YXIgdGV4dFNoYWRvdyA9IGZ1bmN0aW9uIHRleHRTaGFkb3codG9rZW5TdHJlYW0pIHtcbiAgdmFyIF9wYXJzZVNoYWRvdzIgPSBwYXJzZVNoYWRvdyh0b2tlblN0cmVhbSksXG4gICAgICBvZmZzZXQgPSBfcGFyc2VTaGFkb3cyLm9mZnNldCxcbiAgICAgIHJhZGl1cyA9IF9wYXJzZVNoYWRvdzIucmFkaXVzLFxuICAgICAgY29sb3IgPSBfcGFyc2VTaGFkb3cyLmNvbG9yO1xuXG4gIHJldHVybiB7XG4gICAgdGV4dFNoYWRvd09mZnNldDogb2Zmc2V0LFxuICAgIHRleHRTaGFkb3dSYWRpdXM6IHJhZGl1cyxcbiAgICB0ZXh0U2hhZG93Q29sb3I6IGNvbG9yXG4gIH07XG59O1xuXG52YXIgb25lT2ZUeXBlID0gZnVuY3Rpb24gb25lT2ZUeXBlKHRva2VuVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZ1bmN0aW9uU3RyZWFtKSB7XG4gICAgdmFyIHZhbHVlID0gZnVuY3Rpb25TdHJlYW0uZXhwZWN0KHRva2VuVHlwZSk7XG4gICAgZnVuY3Rpb25TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuXG52YXIgc2luZ2xlTnVtYmVyID0gb25lT2ZUeXBlKE5VTUJFUik7XG52YXIgc2luZ2xlTGVuZ3RoID0gb25lT2ZUeXBlKExFTkdUSCk7XG52YXIgc2luZ2xlQW5nbGUgPSBvbmVPZlR5cGUoQU5HTEUpO1xuXG52YXIgeHlUcmFuc2Zvcm1GYWN0b3J5ID0gZnVuY3Rpb24geHlUcmFuc2Zvcm1GYWN0b3J5KHRva2VuVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWVJZk9taXR0ZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZ1bmN0aW9uU3RyZWFtKSB7XG4gICAgICB2YXIgX3JlZjMsIF9yZWY0O1xuXG4gICAgICB2YXIgeCA9IGZ1bmN0aW9uU3RyZWFtLmV4cGVjdCh0b2tlblR5cGUpO1xuICAgICAgdmFyIHk7XG5cbiAgICAgIGlmIChmdW5jdGlvblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgICAgICBmdW5jdGlvblN0cmVhbS5leHBlY3QoQ09NTUEpO1xuICAgICAgICB5ID0gZnVuY3Rpb25TdHJlYW0uZXhwZWN0KHRva2VuVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlSWZPbWl0dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeSA9IHZhbHVlSWZPbWl0dGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXNzdW1wdGlvbiwgaWYgeCA9PT0geSwgdGhlbiB3ZSBjYW4gb21pdCBYWVxuICAgICAgICAvLyBJLmUuIHNjYWxlKDUpID0+IFt7IHNjYWxlOiA1IH1dIHJhdGhlciB0aGFuIFt7IHNjYWxlWDogNSB9LCB7IHNjYWxlWTogNSB9XVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb25TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgICAgIHJldHVybiBbKF9yZWYzID0ge30sIF9yZWYzW2tleSArIFwiWVwiXSA9IHksIF9yZWYzKSwgKF9yZWY0ID0ge30sIF9yZWY0W2tleSArIFwiWFwiXSA9IHgsIF9yZWY0KV07XG4gICAgfTtcbiAgfTtcbn07XG5cbnZhciB4eU51bWJlciA9IHh5VHJhbnNmb3JtRmFjdG9yeShOVU1CRVIpO1xudmFyIHh5TGVuZ3RoID0geHlUcmFuc2Zvcm1GYWN0b3J5KExFTkdUSCk7XG52YXIgeHlBbmdsZSA9IHh5VHJhbnNmb3JtRmFjdG9yeShBTkdMRSk7XG52YXIgcGFydFRyYW5zZm9ybXMgPSB7XG4gIHBlcnNwZWN0aXZlOiBzaW5nbGVOdW1iZXIsXG4gIHNjYWxlOiB4eU51bWJlcignc2NhbGUnKSxcbiAgc2NhbGVYOiBzaW5nbGVOdW1iZXIsXG4gIHNjYWxlWTogc2luZ2xlTnVtYmVyLFxuICB0cmFuc2xhdGU6IHh5TGVuZ3RoKCd0cmFuc2xhdGUnLCAwKSxcbiAgdHJhbnNsYXRlWDogc2luZ2xlTGVuZ3RoLFxuICB0cmFuc2xhdGVZOiBzaW5nbGVMZW5ndGgsXG4gIHJvdGF0ZTogc2luZ2xlQW5nbGUsXG4gIHJvdGF0ZVg6IHNpbmdsZUFuZ2xlLFxuICByb3RhdGVZOiBzaW5nbGVBbmdsZSxcbiAgcm90YXRlWjogc2luZ2xlQW5nbGUsXG4gIHNrZXdYOiBzaW5nbGVBbmdsZSxcbiAgc2tld1k6IHNpbmdsZUFuZ2xlLFxuICBza2V3OiB4eUFuZ2xlKCdza2V3JywgJzBkZWcnKVxufTtcblxudmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSh0b2tlblN0cmVhbSkge1xuICB2YXIgdHJhbnNmb3JtcyA9IFtdO1xuICB2YXIgZGlkUGFyc2VGaXJzdCA9IGZhbHNlO1xuXG4gIHdoaWxlICh0b2tlblN0cmVhbS5oYXNUb2tlbnMoKSkge1xuICAgIGlmIChkaWRQYXJzZUZpcnN0KSB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuICAgIHZhciBmdW5jdGlvblN0cmVhbSA9IHRva2VuU3RyZWFtLmV4cGVjdEZ1bmN0aW9uKCk7XG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uU3RyZWFtLmZ1bmN0aW9uTmFtZTtcbiAgICB2YXIgdHJhbnNmb3JtZWRWYWx1ZXMgPSBwYXJ0VHJhbnNmb3Jtc1tmdW5jdGlvbk5hbWVdKGZ1bmN0aW9uU3RyZWFtKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZFZhbHVlcykpIHtcbiAgICAgIHZhciBfcmVmNTtcblxuICAgICAgdHJhbnNmb3JtZWRWYWx1ZXMgPSBbKF9yZWY1ID0ge30sIF9yZWY1W2Z1bmN0aW9uTmFtZV0gPSB0cmFuc2Zvcm1lZFZhbHVlcywgX3JlZjUpXTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1zID0gdHJhbnNmb3JtZWRWYWx1ZXMuY29uY2F0KHRyYW5zZm9ybXMpO1xuICAgIGRpZFBhcnNlRmlyc3QgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXNcbiAgfTtcbn07XG5cbnZhciBiYWNrZ3JvdW5kID0gZnVuY3Rpb24gYmFja2dyb3VuZCh0b2tlblN0cmVhbSkge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogdG9rZW5TdHJlYW0uZXhwZWN0KENPTE9SKVxuICB9O1xufTtcblxudmFyIGJvcmRlckNvbG9yID0gZGlyZWN0aW9uRmFjdG9yeSh7XG4gIHR5cGVzOiBbQ09MT1JdLFxuICBwcmVmaXg6ICdib3JkZXInLFxuICBzdWZmaXg6ICdDb2xvcidcbn0pO1xudmFyIGJvcmRlclJhZGl1cyA9IGRpcmVjdGlvbkZhY3Rvcnkoe1xuICBkaXJlY3Rpb25zOiBbJ1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tUmlnaHQnLCAnQm90dG9tTGVmdCddLFxuICBwcmVmaXg6ICdib3JkZXInLFxuICBzdWZmaXg6ICdSYWRpdXMnXG59KTtcbnZhciBib3JkZXJXaWR0aCA9IGRpcmVjdGlvbkZhY3Rvcnkoe1xuICBwcmVmaXg6ICdib3JkZXInLFxuICBzdWZmaXg6ICdXaWR0aCdcbn0pO1xudmFyIG1hcmdpbiA9IGRpcmVjdGlvbkZhY3Rvcnkoe1xuICB0eXBlczogW0xFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQsIFBFUkNFTlQsIEFVVE9dLFxuICBwcmVmaXg6ICdtYXJnaW4nXG59KTtcbnZhciBwYWRkaW5nID0gZGlyZWN0aW9uRmFjdG9yeSh7XG4gIHByZWZpeDogJ3BhZGRpbmcnXG59KTtcblxudmFyIGZvbnRXZWlnaHQgPSBmdW5jdGlvbiBmb250V2VpZ2h0KHRva2VuU3RyZWFtKSB7XG4gIHJldHVybiB7XG4gICAgZm9udFdlaWdodDogdG9rZW5TdHJlYW0uZXhwZWN0KFdPUkQpIC8vIEFsc28gbWF0Y2ggbnVtYmVycyBhcyBzdHJpbmdzXG5cbiAgfTtcbn07XG5cbnZhciBzaGFkb3dPZmZzZXQgPSBmdW5jdGlvbiBzaGFkb3dPZmZzZXQodG9rZW5TdHJlYW0pIHtcbiAgcmV0dXJuIHtcbiAgICBzaGFkb3dPZmZzZXQ6IHBhcnNlU2hhZG93T2Zmc2V0KHRva2VuU3RyZWFtKVxuICB9O1xufTtcblxudmFyIHRleHRTaGFkb3dPZmZzZXQgPSBmdW5jdGlvbiB0ZXh0U2hhZG93T2Zmc2V0KHRva2VuU3RyZWFtKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dFNoYWRvd09mZnNldDogcGFyc2VTaGFkb3dPZmZzZXQodG9rZW5TdHJlYW0pXG4gIH07XG59O1xuXG52YXIgdHJhbnNmb3JtcyA9IHtcbiAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kLFxuICBib3JkZXI6IGJvcmRlcixcbiAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgYm9yZGVyV2lkdGg6IGJvcmRlcldpZHRoLFxuICBib3hTaGFkb3c6IGJveFNoYWRvdyxcbiAgZmxleDogZmxleCxcbiAgZmxleEZsb3c6IGZsZXhGbG93LFxuICBmb250OiBmb250LFxuICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICBmb250VmFyaWFudDogZm9udFZhcmlhbnQsXG4gIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gIG1hcmdpbjogbWFyZ2luLFxuICBwYWRkaW5nOiBwYWRkaW5nLFxuICBwbGFjZUNvbnRlbnQ6IHBsYWNlQ29udGVudCxcbiAgc2hhZG93T2Zmc2V0OiBzaGFkb3dPZmZzZXQsXG4gIHRleHRTaGFkb3c6IHRleHRTaGFkb3csXG4gIHRleHRTaGFkb3dPZmZzZXQ6IHRleHRTaGFkb3dPZmZzZXQsXG4gIHRleHREZWNvcmF0aW9uOiB0ZXh0RGVjb3JhdGlvbixcbiAgdGV4dERlY29yYXRpb25MaW5lOiB0ZXh0RGVjb3JhdGlvbkxpbmUsXG4gIHRyYW5zZm9ybTogdHJhbnNmb3JtXG59O1xudmFyIHByb3BlcnRpZXNXaXRob3V0VW5pdHM7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByb3BlcnRpZXNXaXRob3V0VW5pdHMgPSBbJ2FzcGVjdFJhdGlvJywgJ2VsZXZhdGlvbicsICdmbGV4R3JvdycsICdmbGV4U2hyaW5rJywgJ29wYWNpdHknLCAnc2hhZG93T3BhY2l0eScsICd6SW5kZXgnXTtcbn1cblxudmFyIGRldlByb3BlcnRpZXNXaXRoVW5pdHNSZWdFeHAgPSBwcm9wZXJ0aWVzV2l0aG91dFVuaXRzICE9IG51bGwgPyBuZXcgUmVnRXhwKHByb3BlcnRpZXNXaXRob3V0VW5pdHMuam9pbignfCcpKSA6IG51bGw7XG52YXIgU1lNQk9MX01BVENIID0gJ1NZTUJPTF9NQVRDSCc7XG5cbnZhciBUb2tlblN0cmVhbSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRva2VuU3RyZWFtKG5vZGVzLCBwYXJlbnQpIHtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgdGhpcy5mdW5jdGlvbk5hbWUgPSBwYXJlbnQgIT0gbnVsbCA/IHBhcmVudC52YWx1ZSA6IG51bGw7XG4gICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMucmV3aW5kSW5kZXggPSAtMTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb2tlblN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc1Rva2VucyA9IGZ1bmN0aW9uIGhhc1Rva2VucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA8PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gIH07XG5cbiAgX3Byb3RvW1NZTUJPTF9NQVRDSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1Rva2VucygpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbdGhpcy5pbmRleF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHRva2VuRGVzY3JpcHRvciA9IGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHRva2VuRGVzY3JpcHRvcihub2RlKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5tYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcygpIHtcbiAgICByZXR1cm4gdGhpc1tTWU1CT0xfTUFUQ0hdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgIT09IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmV4cGVjdCA9IGZ1bmN0aW9uIGV4cGVjdCgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzW1NZTUJPTF9NQVRDSF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6IHRoaXNbXCJ0aHJvd1wiXSgpO1xuICB9O1xuXG4gIF9wcm90by5tYXRjaGVzRnVuY3Rpb24gPSBmdW5jdGlvbiBtYXRjaGVzRnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW3RoaXMuaW5kZXhdO1xuICAgIGlmIChub2RlLnR5cGUgIT09ICdmdW5jdGlvbicpIHJldHVybiBudWxsO1xuICAgIHZhciB2YWx1ZSA9IG5ldyBUb2tlblN0cmVhbShub2RlLm5vZGVzLCBub2RlKTtcbiAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uZXhwZWN0RnVuY3Rpb24gPSBmdW5jdGlvbiBleHBlY3RGdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLm1hdGNoZXNGdW5jdGlvbigpO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlIDogdGhpc1tcInRocm93XCJdKCk7XG4gIH07XG5cbiAgX3Byb3RvLmV4cGVjdEVtcHR5ID0gZnVuY3Rpb24gZXhwZWN0RW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuaGFzVG9rZW5zKCkpIHRoaXNbXCJ0aHJvd1wiXSgpO1xuICB9O1xuXG4gIF9wcm90b1tcInRocm93XCJdID0gZnVuY3Rpb24gX3Rocm93KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0aGlzLm5vZGVzW3RoaXMuaW5kZXhdLnR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5zYXZlUmV3aW5kUG9pbnQgPSBmdW5jdGlvbiBzYXZlUmV3aW5kUG9pbnQoKSB7XG4gICAgdGhpcy5yZXdpbmRJbmRleCA9IHRoaXMuaW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLnJld2luZCA9IGZ1bmN0aW9uIHJld2luZCgpIHtcbiAgICBpZiAodGhpcy5yZXdpbmRJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3InKTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5yZXdpbmRJbmRleDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuU3RyZWFtO1xufSgpO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8vIE5vdGUgaWYgdGhpcyBpcyB3cm9uZywgeW91J2xsIG5lZWQgdG8gY2hhbmdlIHRva2VuVHlwZXMuanMgdG9vXG5cblxudmFyIG51bWJlck9yTGVuZ3RoUmUgPSAvXihbKy1dPyg/OlxcZCpcXC4pP1xcZCsoPzplWystXT9cXGQrKT8pKD86cHgpPyQvaTtcbnZhciBudW1iZXJPbmx5UmUgPSAvXlsrLV0/KD86XFxkKlxcLlxcZCp8WzEtOV1cXGQqKSg/OmVbKy1dP1xcZCspPyQvaTtcbnZhciBib29sUmUgPSAvXnRydWV8ZmFsc2UkL2k7XG52YXIgbnVsbFJlID0gL15udWxsJC9pO1xudmFyIHVuZGVmaW5lZFJlID0gL151bmRlZmluZWQkL2k7IC8vIFVuZG9jdW1lbnRlZCBleHBvcnRcblxudmFyIHRyYW5zZm9ybVJhd1ZhbHVlID0gZnVuY3Rpb24gdHJhbnNmb3JtUmF3VmFsdWUocHJvcE5hbWUsIHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG5lZWRzVW5pdCA9ICFkZXZQcm9wZXJ0aWVzV2l0aFVuaXRzUmVnRXhwLnRlc3QocHJvcE5hbWUpO1xuICAgIHZhciBpc051bWJlcldpdGhvdXRVbml0ID0gbnVtYmVyT25seVJlLnRlc3QodmFsdWUpO1xuXG4gICAgaWYgKG5lZWRzVW5pdCAmJiBpc051bWJlcldpdGhvdXRVbml0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiRXhwZWN0ZWQgc3R5bGUgXFxcIlwiICsgcHJvcE5hbWUgKyBcIjogXCIgKyB2YWx1ZSArIFwiXFxcIiB0byBjb250YWluIHVuaXRzXCIpO1xuICAgIH1cblxuICAgIGlmICghbmVlZHNVbml0ICYmIHZhbHVlICE9PSAnMCcgJiYgIWlzTnVtYmVyV2l0aG91dFVuaXQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJFeHBlY3RlZCBzdHlsZSBcXFwiXCIgKyBwcm9wTmFtZSArIFwiOiBcIiArIHZhbHVlICsgXCJcXFwiIHRvIGJlIHVuaXRsZXNzXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBudW1iZXJNYXRjaCA9IHZhbHVlLm1hdGNoKG51bWJlck9yTGVuZ3RoUmUpO1xuICBpZiAobnVtYmVyTWF0Y2ggIT09IG51bGwpIHJldHVybiBOdW1iZXIobnVtYmVyTWF0Y2hbMV0pO1xuICB2YXIgYm9vbE1hdGNoID0gdmFsdWUubWF0Y2goYm9vbFJlKTtcbiAgaWYgKGJvb2xNYXRjaCAhPT0gbnVsbCkgcmV0dXJuIGJvb2xNYXRjaFswXS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gIHZhciBudWxsTWF0Y2ggPSB2YWx1ZS5tYXRjaChudWxsUmUpO1xuICBpZiAobnVsbE1hdGNoICE9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIHVuZGVmaW5lZE1hdGNoID0gdmFsdWUubWF0Y2godW5kZWZpbmVkUmUpO1xuICBpZiAodW5kZWZpbmVkTWF0Y2ggIT09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBiYXNlVHJhbnNmb3JtU2hvcnRoYW5kVmFsdWUgPSBmdW5jdGlvbiBiYXNlVHJhbnNmb3JtU2hvcnRoYW5kVmFsdWUocHJvcE5hbWUsIHZhbHVlKSB7XG4gIHZhciBhc3QgPSBwYXJzZV9fZGVmYXVsdCh2YWx1ZSk7XG4gIHZhciB0b2tlblN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShhc3Qubm9kZXMpO1xuICByZXR1cm4gdHJhbnNmb3Jtc1twcm9wTmFtZV0odG9rZW5TdHJlYW0pO1xufTtcblxudmFyIHRyYW5zZm9ybVNob3J0aGFuZFZhbHVlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IGJhc2VUcmFuc2Zvcm1TaG9ydGhhbmRWYWx1ZSA6IGZ1bmN0aW9uIChwcm9wTmFtZSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYmFzZVRyYW5zZm9ybVNob3J0aGFuZFZhbHVlKHByb3BOYW1lLCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgZGVjbGFyYXRpb24gXFxcIlwiICsgcHJvcE5hbWUgKyBcIjogXCIgKyB2YWx1ZSArIFwiXFxcIlwiKTtcbiAgfVxufTtcblxudmFyIGdldFN0eWxlc0ZvclByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0U3R5bGVzRm9yUHJvcGVydHkocHJvcE5hbWUsIGlucHV0VmFsdWUsIGFsbG93U2hvcnRoYW5kKSB7XG4gIHZhciBfcmVmNjtcblxuICB2YXIgaXNSYXdWYWx1ZSA9IGFsbG93U2hvcnRoYW5kID09PSBmYWxzZSB8fCAhKHByb3BOYW1lIGluIHRyYW5zZm9ybXMpO1xuICB2YXIgdmFsdWUgPSBpbnB1dFZhbHVlLnRyaW0oKTtcbiAgdmFyIHByb3BWYWx1ZXMgPSBpc1Jhd1ZhbHVlID8gKF9yZWY2ID0ge30sIF9yZWY2W3Byb3BOYW1lXSA9IHRyYW5zZm9ybVJhd1ZhbHVlKHByb3BOYW1lLCB2YWx1ZSksIF9yZWY2KSA6IHRyYW5zZm9ybVNob3J0aGFuZFZhbHVlKHByb3BOYW1lLCB2YWx1ZSk7XG4gIHJldHVybiBwcm9wVmFsdWVzO1xufTtcblxudmFyIGdldFByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIGdldFByb3BlcnR5TmFtZShwcm9wTmFtZSkge1xuICB2YXIgaXNDdXN0b21Qcm9wID0gL14tLVxcdysvLnRlc3QocHJvcE5hbWUpO1xuXG4gIGlmIChpc0N1c3RvbVByb3ApIHtcbiAgICByZXR1cm4gcHJvcE5hbWU7XG4gIH1cblxuICByZXR1cm4gY2FtZWxpemVTdHlsZU5hbWUocHJvcE5hbWUpO1xufTtcblxudmFyIGluZGV4ID0gZnVuY3Rpb24gaW5kZXgocnVsZXMsIHNob3J0aGFuZEJsYWNrbGlzdCkge1xuICBpZiAoc2hvcnRoYW5kQmxhY2tsaXN0ID09PSB2b2lkIDApIHtcbiAgICBzaG9ydGhhbmRCbGFja2xpc3QgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBydWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBydWxlKSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IGdldFByb3BlcnR5TmFtZShydWxlWzBdKTtcbiAgICB2YXIgdmFsdWUgPSBydWxlWzFdO1xuICAgIHZhciBhbGxvd1Nob3J0aGFuZCA9IHNob3J0aGFuZEJsYWNrbGlzdC5pbmRleE9mKHByb3BlcnR5TmFtZSkgPT09IC0xO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjY3VtLCBnZXRTdHlsZXNGb3JQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlLCBhbGxvd1Nob3J0aGFuZCkpO1xuICB9LCB7fSk7XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGluZGV4O1xuZXhwb3J0cy5nZXRQcm9wZXJ0eU5hbWUgPSBnZXRQcm9wZXJ0eU5hbWU7XG5leHBvcnRzLmdldFN0eWxlc0ZvclByb3BlcnR5ID0gZ2V0U3R5bGVzRm9yUHJvcGVydHk7XG5leHBvcnRzLnRyYW5zZm9ybVJhd1ZhbHVlID0gdHJhbnNmb3JtUmF3VmFsdWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/css-to-react-native/index.js\n");

/***/ })

};
;