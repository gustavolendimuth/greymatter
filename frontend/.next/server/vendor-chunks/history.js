/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/history";
exports.ids = ["vendor-chunks/history"];
exports.modules = {

/***/ "(ssr)/./node_modules/history/main.js":
/*!**************************************!*\
  !*** ./node_modules/history/main.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-env node */\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./umd/history.development.js */ \"(ssr)/./node_modules/history/umd/history.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSUFBd0Q7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmV5bWF0dGVyLXYyLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvbWFpbi5qcz8zZWI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi91bWQvaGlzdG9yeS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3VtZC9oaXN0b3J5LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/history/main.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/history/umd/history.development.js":
/*!*********************************************************!*\
  !*** ./node_modules/history/umd/history.development.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) { 'use strict';\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  /**\r\n   * Actions represent the type of change to a location value.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n   */\n  exports.Action = void 0;\n\n  (function (Action) {\n    /**\r\n     * A POP indicates a change to an arbitrary index in the history stack, such\r\n     * as a back or forward navigation. It does not describe the direction of the\r\n     * navigation, only that the current index changed.\r\n     *\r\n     * Note: This is the default action for newly created history objects.\r\n     */\n    Action[\"Pop\"] = \"POP\";\n    /**\r\n     * A PUSH indicates a new entry being added to the history stack, such as when\r\n     * a link is clicked and a new page loads. When this happens, all subsequent\r\n     * entries in the stack are lost.\r\n     */\n\n    Action[\"Push\"] = \"PUSH\";\n    /**\r\n     * A REPLACE indicates the entry at the current index in the history stack\r\n     * being replaced by a new one.\r\n     */\n\n    Action[\"Replace\"] = \"REPLACE\";\n  })(exports.Action || (exports.Action = {}));\n\n  var readOnly = function (obj) {\n    return Object.freeze(obj);\n  } ;\n\n  function warning(cond, message) {\n    if (!cond) {\n      // eslint-disable-next-line no-console\n      if (typeof console !== 'undefined') console.warn(message);\n\n      try {\n        // Welcome to debugging history!\n        //\n        // This error is thrown as a convenience so you can more easily\n        // find the source for a warning that appears in the console by\n        // enabling \"pause on exceptions\" in your JavaScript debugger.\n        throw new Error(message); // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n  }\n\n  var BeforeUnloadEventType = 'beforeunload';\n  var HashChangeEventType = 'hashchange';\n  var PopStateEventType = 'popstate';\n  /**\r\n   * Browser history stores the location in regular URLs. This is the standard for\r\n   * most web apps, but it requires some configuration on the server to ensure you\r\n   * serve the same app at multiple URLs.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n   */\n\n  function createBrowserHistory(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$window = _options.window,\n        window = _options$window === void 0 ? document.defaultView : _options$window;\n    var globalHistory = window.history;\n\n    function getIndexAndLocation() {\n      var _window$location = window.location,\n          pathname = _window$location.pathname,\n          search = _window$location.search,\n          hash = _window$location.hash;\n      var state = globalHistory.state || {};\n      return [state.idx, readOnly({\n        pathname: pathname,\n        search: search,\n        hash: hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })];\n    }\n\n    var blockedPopTx = null;\n\n    function handlePop() {\n      if (blockedPopTx) {\n        blockers.call(blockedPopTx);\n        blockedPopTx = null;\n      } else {\n        var nextAction = exports.Action.Pop;\n\n        var _getIndexAndLocation = getIndexAndLocation(),\n            nextIndex = _getIndexAndLocation[0],\n            nextLocation = _getIndexAndLocation[1];\n\n        if (blockers.length) {\n          if (nextIndex != null) {\n            var delta = index - nextIndex;\n\n            if (delta) {\n              // Revert the POP\n              blockedPopTx = {\n                action: nextAction,\n                location: nextLocation,\n                retry: function retry() {\n                  go(delta * -1);\n                }\n              };\n              go(delta);\n            }\n          } else {\n            // Trying to POP to a location with no index. We did not create\n            // this location, so we can't effectively block the navigation.\n            warning(false, // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better what\n            // is going on and how to avoid it.\n            \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") ;\n          }\n        } else {\n          applyTx(nextAction);\n        }\n      }\n    }\n\n    window.addEventListener(PopStateEventType, handlePop);\n    var action = exports.Action.Pop;\n\n    var _getIndexAndLocation2 = getIndexAndLocation(),\n        index = _getIndexAndLocation2[0],\n        location = _getIndexAndLocation2[1];\n\n    var listeners = createEvents();\n    var blockers = createEvents();\n\n    if (index == null) {\n      index = 0;\n      globalHistory.replaceState(_extends({}, globalHistory.state, {\n        idx: index\n      }), '');\n    }\n\n    function createHref(to) {\n      return typeof to === 'string' ? to : createPath(to);\n    } // state defaults to `null` because `window.history.state` does\n\n\n    function getNextLocation(to, state) {\n      if (state === void 0) {\n        state = null;\n      }\n\n      return readOnly(_extends({\n        pathname: location.pathname,\n        hash: '',\n        search: ''\n      }, typeof to === 'string' ? parsePath(to) : to, {\n        state: state,\n        key: createKey()\n      }));\n    }\n\n    function getHistoryStateAndUrl(nextLocation, index) {\n      return [{\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      }, createHref(nextLocation)];\n    }\n\n    function allowTx(action, location, retry) {\n      return !blockers.length || (blockers.call({\n        action: action,\n        location: location,\n        retry: retry\n      }), false);\n    }\n\n    function applyTx(nextAction) {\n      action = nextAction;\n\n      var _getIndexAndLocation3 = getIndexAndLocation();\n\n      index = _getIndexAndLocation3[0];\n      location = _getIndexAndLocation3[1];\n      listeners.call({\n        action: action,\n        location: location\n      });\n    }\n\n    function push(to, state) {\n      var nextAction = exports.Action.Push;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        push(to, state);\n      }\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n            historyState = _getHistoryStateAndUr[0],\n            url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n        // try...catch because iOS limits us to 100 pushState calls :/\n\n\n        try {\n          globalHistory.pushState(historyState, '', url);\n        } catch (error) {\n          // They are going to lose state here, but there is no real\n          // way to warn them about it since the page will refresh...\n          window.location.assign(url);\n        }\n\n        applyTx(nextAction);\n      }\n    }\n\n    function replace(to, state) {\n      var nextAction = exports.Action.Replace;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        replace(to, state);\n      }\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n            historyState = _getHistoryStateAndUr2[0],\n            url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n        globalHistory.replaceState(historyState, '', url);\n        applyTx(nextAction);\n      }\n    }\n\n    function go(delta) {\n      globalHistory.go(delta);\n    }\n\n    var history = {\n      get action() {\n        return action;\n      },\n\n      get location() {\n        return location;\n      },\n\n      createHref: createHref,\n      push: push,\n      replace: replace,\n      go: go,\n      back: function back() {\n        go(-1);\n      },\n      forward: function forward() {\n        go(1);\n      },\n      listen: function listen(listener) {\n        return listeners.push(listener);\n      },\n      block: function block(blocker) {\n        var unblock = blockers.push(blocker);\n\n        if (blockers.length === 1) {\n          window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n\n        return function () {\n          unblock(); // Remove the beforeunload listener so the document may\n          // still be salvageable in the pagehide event.\n          // See https://html.spec.whatwg.org/#unloading-documents\n\n          if (!blockers.length) {\n            window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n          }\n        };\n      }\n    };\n    return history;\n  }\n  /**\r\n   * Hash history stores the location in window.location.hash. This makes it ideal\r\n   * for situations where you don't want to send the location to the server for\r\n   * some reason, either because you do cannot configure it or the URL space is\r\n   * reserved for something else.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n   */\n\n  function createHashHistory(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options2 = options,\n        _options2$window = _options2.window,\n        window = _options2$window === void 0 ? document.defaultView : _options2$window;\n    var globalHistory = window.history;\n\n    function getIndexAndLocation() {\n      var _parsePath = parsePath(window.location.hash.substr(1)),\n          _parsePath$pathname = _parsePath.pathname,\n          pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n          _parsePath$search = _parsePath.search,\n          search = _parsePath$search === void 0 ? '' : _parsePath$search,\n          _parsePath$hash = _parsePath.hash,\n          hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n      var state = globalHistory.state || {};\n      return [state.idx, readOnly({\n        pathname: pathname,\n        search: search,\n        hash: hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })];\n    }\n\n    var blockedPopTx = null;\n\n    function handlePop() {\n      if (blockedPopTx) {\n        blockers.call(blockedPopTx);\n        blockedPopTx = null;\n      } else {\n        var nextAction = exports.Action.Pop;\n\n        var _getIndexAndLocation4 = getIndexAndLocation(),\n            nextIndex = _getIndexAndLocation4[0],\n            nextLocation = _getIndexAndLocation4[1];\n\n        if (blockers.length) {\n          if (nextIndex != null) {\n            var delta = index - nextIndex;\n\n            if (delta) {\n              // Revert the POP\n              blockedPopTx = {\n                action: nextAction,\n                location: nextLocation,\n                retry: function retry() {\n                  go(delta * -1);\n                }\n              };\n              go(delta);\n            }\n          } else {\n            // Trying to POP to a location with no index. We did not create\n            // this location, so we can't effectively block the navigation.\n            warning(false, // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") ;\n          }\n        } else {\n          applyTx(nextAction);\n        }\n      }\n    }\n\n    window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n    window.addEventListener(HashChangeEventType, function () {\n      var _getIndexAndLocation5 = getIndexAndLocation(),\n          nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n      if (createPath(nextLocation) !== createPath(location)) {\n        handlePop();\n      }\n    });\n    var action = exports.Action.Pop;\n\n    var _getIndexAndLocation6 = getIndexAndLocation(),\n        index = _getIndexAndLocation6[0],\n        location = _getIndexAndLocation6[1];\n\n    var listeners = createEvents();\n    var blockers = createEvents();\n\n    if (index == null) {\n      index = 0;\n      globalHistory.replaceState(_extends({}, globalHistory.state, {\n        idx: index\n      }), '');\n    }\n\n    function getBaseHref() {\n      var base = document.querySelector('base');\n      var href = '';\n\n      if (base && base.getAttribute('href')) {\n        var url = window.location.href;\n        var hashIndex = url.indexOf('#');\n        href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n      }\n\n      return href;\n    }\n\n    function createHref(to) {\n      return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n    }\n\n    function getNextLocation(to, state) {\n      if (state === void 0) {\n        state = null;\n      }\n\n      return readOnly(_extends({\n        pathname: location.pathname,\n        hash: '',\n        search: ''\n      }, typeof to === 'string' ? parsePath(to) : to, {\n        state: state,\n        key: createKey()\n      }));\n    }\n\n    function getHistoryStateAndUrl(nextLocation, index) {\n      return [{\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      }, createHref(nextLocation)];\n    }\n\n    function allowTx(action, location, retry) {\n      return !blockers.length || (blockers.call({\n        action: action,\n        location: location,\n        retry: retry\n      }), false);\n    }\n\n    function applyTx(nextAction) {\n      action = nextAction;\n\n      var _getIndexAndLocation7 = getIndexAndLocation();\n\n      index = _getIndexAndLocation7[0];\n      location = _getIndexAndLocation7[1];\n      listeners.call({\n        action: action,\n        location: location\n      });\n    }\n\n    function push(to, state) {\n      var nextAction = exports.Action.Push;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        push(to, state);\n      }\n\n      warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n            historyState = _getHistoryStateAndUr3[0],\n            url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n        // try...catch because iOS limits us to 100 pushState calls :/\n\n\n        try {\n          globalHistory.pushState(historyState, '', url);\n        } catch (error) {\n          // They are going to lose state here, but there is no real\n          // way to warn them about it since the page will refresh...\n          window.location.assign(url);\n        }\n\n        applyTx(nextAction);\n      }\n    }\n\n    function replace(to, state) {\n      var nextAction = exports.Action.Replace;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        replace(to, state);\n      }\n\n      warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n            historyState = _getHistoryStateAndUr4[0],\n            url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n        globalHistory.replaceState(historyState, '', url);\n        applyTx(nextAction);\n      }\n    }\n\n    function go(delta) {\n      globalHistory.go(delta);\n    }\n\n    var history = {\n      get action() {\n        return action;\n      },\n\n      get location() {\n        return location;\n      },\n\n      createHref: createHref,\n      push: push,\n      replace: replace,\n      go: go,\n      back: function back() {\n        go(-1);\n      },\n      forward: function forward() {\n        go(1);\n      },\n      listen: function listen(listener) {\n        return listeners.push(listener);\n      },\n      block: function block(blocker) {\n        var unblock = blockers.push(blocker);\n\n        if (blockers.length === 1) {\n          window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n\n        return function () {\n          unblock(); // Remove the beforeunload listener so the document may\n          // still be salvageable in the pagehide event.\n          // See https://html.spec.whatwg.org/#unloading-documents\n\n          if (!blockers.length) {\n            window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n          }\n        };\n      }\n    };\n    return history;\n  }\n  /**\r\n   * Memory history stores the current location in memory. It is designed for use\r\n   * in stateful non-browser environments like tests and React Native.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n   */\n\n  function createMemoryHistory(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options3 = options,\n        _options3$initialEntr = _options3.initialEntries,\n        initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n        initialIndex = _options3.initialIndex;\n    var entries = initialEntries.map(function (entry) {\n      var location = readOnly(_extends({\n        pathname: '/',\n        search: '',\n        hash: '',\n        state: null,\n        key: createKey()\n      }, typeof entry === 'string' ? parsePath(entry) : entry));\n      warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") ;\n      return location;\n    });\n    var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n    var action = exports.Action.Pop;\n    var location = entries[index];\n    var listeners = createEvents();\n    var blockers = createEvents();\n\n    function createHref(to) {\n      return typeof to === 'string' ? to : createPath(to);\n    }\n\n    function getNextLocation(to, state) {\n      if (state === void 0) {\n        state = null;\n      }\n\n      return readOnly(_extends({\n        pathname: location.pathname,\n        search: '',\n        hash: ''\n      }, typeof to === 'string' ? parsePath(to) : to, {\n        state: state,\n        key: createKey()\n      }));\n    }\n\n    function allowTx(action, location, retry) {\n      return !blockers.length || (blockers.call({\n        action: action,\n        location: location,\n        retry: retry\n      }), false);\n    }\n\n    function applyTx(nextAction, nextLocation) {\n      action = nextAction;\n      location = nextLocation;\n      listeners.call({\n        action: action,\n        location: location\n      });\n    }\n\n    function push(to, state) {\n      var nextAction = exports.Action.Push;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        push(to, state);\n      }\n\n      warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        index += 1;\n        entries.splice(index, entries.length, nextLocation);\n        applyTx(nextAction, nextLocation);\n      }\n    }\n\n    function replace(to, state) {\n      var nextAction = exports.Action.Replace;\n      var nextLocation = getNextLocation(to, state);\n\n      function retry() {\n        replace(to, state);\n      }\n\n      warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") ;\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        entries[index] = nextLocation;\n        applyTx(nextAction, nextLocation);\n      }\n    }\n\n    function go(delta) {\n      var nextIndex = clamp(index + delta, 0, entries.length - 1);\n      var nextAction = exports.Action.Pop;\n      var nextLocation = entries[nextIndex];\n\n      function retry() {\n        go(delta);\n      }\n\n      if (allowTx(nextAction, nextLocation, retry)) {\n        index = nextIndex;\n        applyTx(nextAction, nextLocation);\n      }\n    }\n\n    var history = {\n      get index() {\n        return index;\n      },\n\n      get action() {\n        return action;\n      },\n\n      get location() {\n        return location;\n      },\n\n      createHref: createHref,\n      push: push,\n      replace: replace,\n      go: go,\n      back: function back() {\n        go(-1);\n      },\n      forward: function forward() {\n        go(1);\n      },\n      listen: function listen(listener) {\n        return listeners.push(listener);\n      },\n      block: function block(blocker) {\n        return blockers.push(blocker);\n      }\n    };\n    return history;\n  } ////////////////////////////////////////////////////////////////////////////////\n  // UTILS\n  ////////////////////////////////////////////////////////////////////////////////\n\n  function clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n  }\n\n  function promptBeforeUnload(event) {\n    // Cancel the event.\n    event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n    event.returnValue = '';\n  }\n\n  function createEvents() {\n    var handlers = [];\n    return {\n      get length() {\n        return handlers.length;\n      },\n\n      push: function push(fn) {\n        handlers.push(fn);\n        return function () {\n          handlers = handlers.filter(function (handler) {\n            return handler !== fn;\n          });\n        };\n      },\n      call: function call(arg) {\n        handlers.forEach(function (fn) {\n          return fn && fn(arg);\n        });\n      }\n    };\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, 8);\n  }\n  /**\r\n   * Creates a string URL path from the given pathname, search, and hash components.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n   */\n\n\n  function createPath(_ref) {\n    var _ref$pathname = _ref.pathname,\n        pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n        _ref$search = _ref.search,\n        search = _ref$search === void 0 ? '' : _ref$search,\n        _ref$hash = _ref.hash,\n        hash = _ref$hash === void 0 ? '' : _ref$hash;\n    if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n    if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n    return pathname;\n  }\n  /**\r\n   * Parses a string URL path into its separate pathname, search, and hash components.\r\n   *\r\n   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n   */\n\n  function parsePath(path) {\n    var parsedPath = {};\n\n    if (path) {\n      var hashIndex = path.indexOf('#');\n\n      if (hashIndex >= 0) {\n        parsedPath.hash = path.substr(hashIndex);\n        path = path.substr(0, hashIndex);\n      }\n\n      var searchIndex = path.indexOf('?');\n\n      if (searchIndex >= 0) {\n        parsedPath.search = path.substr(searchIndex);\n        path = path.substr(0, searchIndex);\n      }\n\n      if (path) {\n        parsedPath.pathname = path;\n      }\n    }\n\n    return parsedPath;\n  }\n\n  exports.createBrowserHistory = createBrowserHistory;\n  exports.createHashHistory = createHashHistory;\n  exports.createMemoryHistory = createMemoryHistory;\n  exports.createPath = createPath;\n  exports.parsePath = parsePath;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=history.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS91bWQvaGlzdG9yeS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUMrRztBQUNqSCxDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyx3Q0FBd0M7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7OztBQUc3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7OztBQUduRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOzs7QUFHN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrSEFBa0gsZ0JBQWdCO0FBQ2xJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyZXltYXR0ZXItdjIvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS91bWQvaGlzdG9yeS5kZXZlbG9wbWVudC5qcz84NzI3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuSGlzdG9yeUxpYnJhcnkgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcclxuICAgKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjYWN0aW9uXHJcbiAgICovXG4gIGV4cG9ydHMuQWN0aW9uID0gdm9pZCAwO1xuXG4gIChmdW5jdGlvbiAoQWN0aW9uKSB7XG4gICAgLyoqXHJcbiAgICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXHJcbiAgICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxyXG4gICAgICogbmF2aWdhdGlvbiwgb25seSB0aGF0IHRoZSBjdXJyZW50IGluZGV4IGNoYW5nZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxyXG4gICAgICovXG4gICAgQWN0aW9uW1wiUG9wXCJdID0gXCJQT1BcIjtcbiAgICAvKipcclxuICAgICAqIEEgUFVTSCBpbmRpY2F0ZXMgYSBuZXcgZW50cnkgYmVpbmcgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2ggYXMgd2hlblxyXG4gICAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxyXG4gICAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXHJcbiAgICAgKi9cblxuICAgIEFjdGlvbltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcbiAgICAvKipcclxuICAgICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXHJcbiAgICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXHJcbiAgICAgKi9cblxuICAgIEFjdGlvbltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbiAgfSkoZXhwb3J0cy5BY3Rpb24gfHwgKGV4cG9ydHMuQWN0aW9uID0ge30pKTtcblxuICB2YXIgcmVhZE9ubHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqKTtcbiAgfSA7XG5cbiAgZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG5cbiAgdmFyIEJlZm9yZVVubG9hZEV2ZW50VHlwZSA9ICdiZWZvcmV1bmxvYWQnO1xuICB2YXIgSGFzaENoYW5nZUV2ZW50VHlwZSA9ICdoYXNoY2hhbmdlJztcbiAgdmFyIFBvcFN0YXRlRXZlbnRUeXBlID0gJ3BvcHN0YXRlJztcbiAgLyoqXHJcbiAgICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcclxuICAgKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxyXG4gICAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxyXG4gICAqXHJcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgX29wdGlvbnMkd2luZG93ID0gX29wdGlvbnMud2luZG93LFxuICAgICAgICB3aW5kb3cgPSBfb3B0aW9ucyR3aW5kb3cgPT09IHZvaWQgMCA/IGRvY3VtZW50LmRlZmF1bHRWaWV3IDogX29wdGlvbnMkd2luZG93O1xuICAgIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG5cbiAgICBmdW5jdGlvbiBnZXRJbmRleEFuZExvY2F0aW9uKCkge1xuICAgICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG4gICAgICB2YXIgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgcmV0dXJuIFtzdGF0ZS5pZHgsIHJlYWRPbmx5KHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgc3RhdGU6IHN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgICBrZXk6IHN0YXRlLmtleSB8fCAnZGVmYXVsdCdcbiAgICAgIH0pXTtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tlZFBvcFR4ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICAgIGlmIChibG9ja2VkUG9wVHgpIHtcbiAgICAgICAgYmxvY2tlcnMuY2FsbChibG9ja2VkUG9wVHgpO1xuICAgICAgICBibG9ja2VkUG9wVHggPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRBY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5Qb3A7XG5cbiAgICAgICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICAgICAgbmV4dEluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb25bMF0sXG4gICAgICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvblsxXTtcblxuICAgICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBpbmRleCAtIG5leHRJbmRleDtcblxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgUE9QXG4gICAgICAgICAgICAgIGJsb2NrZWRQb3BUeCA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IG5leHRBY3Rpb24sXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICByZXRyeTogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgICAgICBnbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGdvKGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIFBPUCB0byBhIGxvY2F0aW9uIHdpdGggbm8gaW5kZXguIFdlIGRpZCBub3QgY3JlYXRlXG4gICAgICAgICAgICAvLyB0aGlzIGxvY2F0aW9uLCBzbyB3ZSBjYW4ndCBlZmZlY3RpdmVseSBibG9jayB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsIC8vIFRPRE86IFdyaXRlIHVwIGEgZG9jIHRoYXQgZXhwbGFpbnMgb3VyIGJsb2NraW5nIHN0cmF0ZWd5IGluXG4gICAgICAgICAgICAvLyBkZXRhaWwgYW5kIGxpbmsgdG8gaXQgaGVyZSBzbyBwZW9wbGUgY2FuIHVuZGVyc3RhbmQgYmV0dGVyIHdoYXRcbiAgICAgICAgICAgIC8vIGlzIGdvaW5nIG9uIGFuZCBob3cgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgXCIgKyBcImNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBcIiArIFwiaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgXCIgKyBcInRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKSA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICB2YXIgYWN0aW9uID0gZXhwb3J0cy5BY3Rpb24uUG9wO1xuXG4gICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uMiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjJbMF0sXG4gICAgICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb24yWzFdO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICAgIHZhciBibG9ja2VycyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBnbG9iYWxIaXN0b3J5LnN0YXRlLCB7XG4gICAgICAgIGlkeDogaW5kZXhcbiAgICAgIH0pLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICAgIH0gLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG5cblxuICAgIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBoYXNoOiAnJyxcbiAgICAgICAgc2VhcmNoOiAnJ1xuICAgICAgfSwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHVzcjogbmV4dExvY2F0aW9uLnN0YXRlLFxuICAgICAgICBrZXk6IG5leHRMb2NhdGlvbi5rZXksXG4gICAgICAgIGlkeDogaW5kZXhcbiAgICAgIH0sIGNyZWF0ZUhyZWYobmV4dExvY2F0aW9uKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsb3dUeChhY3Rpb24sIGxvY2F0aW9uLCByZXRyeSkge1xuICAgICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICByZXRyeTogcmV0cnlcbiAgICAgIH0pLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uKSB7XG4gICAgICBhY3Rpb24gPSBuZXh0QWN0aW9uO1xuXG4gICAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb24zID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpO1xuXG4gICAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uM1swXTtcbiAgICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb24zWzFdO1xuICAgICAgbGlzdGVuZXJzLmNhbGwoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5QdXNoO1xuICAgICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXggKyAxKSxcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVclswXSxcbiAgICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVclsxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG4gICAgICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5SZXBsYWNlO1xuICAgICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgICAgcmVwbGFjZSh0bywgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyMiA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSxcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjJbMF0sXG4gICAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcblxuXG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ28oZGVsdGEpIHtcbiAgICAgIGdsb2JhbEhpc3RvcnkuZ28oZGVsdGEpO1xuICAgIH1cblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgfSxcblxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgZ286IGdvLFxuICAgICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgICAgZ28oLTEpO1xuICAgICAgfSxcbiAgICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgICAgIGdvKDEpO1xuICAgICAgfSxcbiAgICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICB9LFxuICAgICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKGJsb2NrZXIpIHtcbiAgICAgICAgdmFyIHVuYmxvY2sgPSBibG9ja2Vycy5wdXNoKGJsb2NrZXIpO1xuXG4gICAgICAgIGlmIChibG9ja2Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVuYmxvY2soKTsgLy8gUmVtb3ZlIHRoZSBiZWZvcmV1bmxvYWQgbGlzdGVuZXIgc28gdGhlIGRvY3VtZW50IG1heVxuICAgICAgICAgIC8vIHN0aWxsIGJlIHNhbHZhZ2VhYmxlIGluIHRoZSBwYWdlaGlkZSBldmVudC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdW5sb2FkaW5nLWRvY3VtZW50c1xuXG4gICAgICAgICAgaWYgKCFibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxuICAvKipcclxuICAgKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxyXG4gICAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXHJcbiAgICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcclxuICAgKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XHJcbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMyID0gb3B0aW9ucyxcbiAgICAgICAgX29wdGlvbnMyJHdpbmRvdyA9IF9vcHRpb25zMi53aW5kb3csXG4gICAgICAgIHdpbmRvdyA9IF9vcHRpb25zMiR3aW5kb3cgPT09IHZvaWQgMCA/IGRvY3VtZW50LmRlZmF1bHRWaWV3IDogX29wdGlvbnMyJHdpbmRvdztcbiAgICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhBbmRMb2NhdGlvbigpIHtcbiAgICAgIHZhciBfcGFyc2VQYXRoID0gcGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSksXG4gICAgICAgICAgX3BhcnNlUGF0aCRwYXRobmFtZSA9IF9wYXJzZVBhdGgucGF0aG5hbWUsXG4gICAgICAgICAgcGF0aG5hbWUgPSBfcGFyc2VQYXRoJHBhdGhuYW1lID09PSB2b2lkIDAgPyAnLycgOiBfcGFyc2VQYXRoJHBhdGhuYW1lLFxuICAgICAgICAgIF9wYXJzZVBhdGgkc2VhcmNoID0gX3BhcnNlUGF0aC5zZWFyY2gsXG4gICAgICAgICAgc2VhcmNoID0gX3BhcnNlUGF0aCRzZWFyY2ggPT09IHZvaWQgMCA/ICcnIDogX3BhcnNlUGF0aCRzZWFyY2gsXG4gICAgICAgICAgX3BhcnNlUGF0aCRoYXNoID0gX3BhcnNlUGF0aC5oYXNoLFxuICAgICAgICAgIGhhc2ggPSBfcGFyc2VQYXRoJGhhc2ggPT09IHZvaWQgMCA/ICcnIDogX3BhcnNlUGF0aCRoYXNoO1xuXG4gICAgICB2YXIgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgcmV0dXJuIFtzdGF0ZS5pZHgsIHJlYWRPbmx5KHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgc3RhdGU6IHN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgICBrZXk6IHN0YXRlLmtleSB8fCAnZGVmYXVsdCdcbiAgICAgIH0pXTtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tlZFBvcFR4ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICAgIGlmIChibG9ja2VkUG9wVHgpIHtcbiAgICAgICAgYmxvY2tlcnMuY2FsbChibG9ja2VkUG9wVHgpO1xuICAgICAgICBibG9ja2VkUG9wVHggPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRBY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5Qb3A7XG5cbiAgICAgICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNCA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgICAgIG5leHRJbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uNFswXSxcbiAgICAgICAgICAgIG5leHRMb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNFsxXTtcblxuICAgICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBpbmRleCAtIG5leHRJbmRleDtcblxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgUE9QXG4gICAgICAgICAgICAgIGJsb2NrZWRQb3BUeCA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IG5leHRBY3Rpb24sXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICByZXRyeTogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgICAgICBnbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGdvKGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIFBPUCB0byBhIGxvY2F0aW9uIHdpdGggbm8gaW5kZXguIFdlIGRpZCBub3QgY3JlYXRlXG4gICAgICAgICAgICAvLyB0aGlzIGxvY2F0aW9uLCBzbyB3ZSBjYW4ndCBlZmZlY3RpdmVseSBibG9jayB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsIC8vIFRPRE86IFdyaXRlIHVwIGEgZG9jIHRoYXQgZXhwbGFpbnMgb3VyIGJsb2NraW5nIHN0cmF0ZWd5IGluXG4gICAgICAgICAgICAvLyBkZXRhaWwgYW5kIGxpbmsgdG8gaXQgaGVyZSBzbyBwZW9wbGUgY2FuIHVuZGVyc3RhbmQgYmV0dGVyXG4gICAgICAgICAgICAvLyB3aGF0IGlzIGdvaW5nIG9uIGFuZCBob3cgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgXCIgKyBcImNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBcIiArIFwiaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgXCIgKyBcInRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKSA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTsgLy8gcG9wc3RhdGUgZG9lcyBub3QgZmlyZSBvbiBoYXNoY2hhbmdlIGluIElFIDExIGFuZCBvbGQgKHRyaWRlbnQpIEVkZ2VcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9BUEkvV2luZG93L3BvcHN0YXRlX2V2ZW50XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnRUeXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb241ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICAgIG5leHRMb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNVsxXTsgLy8gSWdub3JlIGV4dHJhbmVvdXMgaGFzaGNoYW5nZSBldmVudHMuXG5cblxuICAgICAgaWYgKGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKSAhPT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHtcbiAgICAgICAgaGFuZGxlUG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGFjdGlvbiA9IGV4cG9ydHMuQWN0aW9uLlBvcDtcblxuICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjYgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb242WzBdLFxuICAgICAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNlsxXTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSwge1xuICAgICAgICBpZHg6IGluZGV4XG4gICAgICB9KSwgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJhc2VIcmVmKCkge1xuICAgICAgdmFyIGJhc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICB2YXIgaHJlZiA9ICcnO1xuXG4gICAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgdmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBocmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgICAgIHJldHVybiBnZXRCYXNlSHJlZigpICsgJyMnICsgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgaGFzaDogJycsXG4gICAgICAgIHNlYXJjaDogJydcbiAgICAgIH0sIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB1c3I6IG5leHRMb2NhdGlvbi5zdGF0ZSxcbiAgICAgICAga2V5OiBuZXh0TG9jYXRpb24ua2V5LFxuICAgICAgICBpZHg6IGluZGV4XG4gICAgICB9LCBjcmVhdGVIcmVmKG5leHRMb2NhdGlvbildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG93VHgoYWN0aW9uLCBsb2NhdGlvbiwgcmV0cnkpIHtcbiAgICAgIHJldHVybiAhYmxvY2tlcnMubGVuZ3RoIHx8IChibG9ja2Vycy5jYWxsKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgcmV0cnk6IHJldHJ5XG4gICAgICB9KSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VHgobmV4dEFjdGlvbikge1xuICAgICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcblxuICAgICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNyA9IGdldEluZGV4QW5kTG9jYXRpb24oKTtcblxuICAgICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjdbMF07XG4gICAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uN1sxXTtcbiAgICAgIGxpc3RlbmVycy5jYWxsKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIHZhciBuZXh0QWN0aW9uID0gZXhwb3J0cy5BY3Rpb24uUHVzaDtcbiAgICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgIHB1c2godG8sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZyhuZXh0TG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDtcblxuICAgICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjMgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCArIDEpLFxuICAgICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyM1swXSxcbiAgICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjNbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuICAgICAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIHZhciBuZXh0QWN0aW9uID0gZXhwb3J0cy5BY3Rpb24uUmVwbGFjZTtcbiAgICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZyhuZXh0TG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5yZXBsYWNlKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDtcblxuICAgICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjQgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCksXG4gICAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0WzBdLFxuICAgICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyNFsxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG5cblxuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvKGRlbHRhKSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LmdvKGRlbHRhKTtcbiAgICB9XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICB9LFxuXG4gICAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGdvOiBnbyxcbiAgICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICAgIGdvKC0xKTtcbiAgICAgIH0sXG4gICAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgICBnbygxKTtcbiAgICAgIH0sXG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSxcbiAgICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICAgIHZhciB1bmJsb2NrID0gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcblxuICAgICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1bmJsb2NrKCk7IC8vIFJlbW92ZSB0aGUgYmVmb3JldW5sb2FkIGxpc3RlbmVyIHNvIHRoZSBkb2N1bWVudCBtYXlcbiAgICAgICAgICAvLyBzdGlsbCBiZSBzYWx2YWdlYWJsZSBpbiB0aGUgcGFnZWhpZGUgZXZlbnQuXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3VubG9hZGluZy1kb2N1bWVudHNcblxuICAgICAgICAgIGlmICghYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH1cbiAgLyoqXHJcbiAgICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxyXG4gICAqIGluIHN0YXRlZnVsIG5vbi1icm93c2VyIGVudmlyb25tZW50cyBsaWtlIHRlc3RzIGFuZCBSZWFjdCBOYXRpdmUuXHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZW1lbW9yeWhpc3RvcnlcclxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zMyA9IG9wdGlvbnMsXG4gICAgICAgIF9vcHRpb25zMyRpbml0aWFsRW50ciA9IF9vcHRpb25zMy5pbml0aWFsRW50cmllcyxcbiAgICAgICAgaW5pdGlhbEVudHJpZXMgPSBfb3B0aW9uczMkaW5pdGlhbEVudHIgPT09IHZvaWQgMCA/IFsnLyddIDogX29wdGlvbnMzJGluaXRpYWxFbnRyLFxuICAgICAgICBpbml0aWFsSW5kZXggPSBfb3B0aW9uczMuaW5pdGlhbEluZGV4O1xuICAgIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgdmFyIGxvY2F0aW9uID0gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgICBwYXRobmFtZTogJy8nLFxuICAgICAgICBzZWFyY2g6ICcnLFxuICAgICAgICBoYXNoOiAnJyxcbiAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICAgIH0sIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgoZW50cnkpIDogZW50cnkpKTtcbiAgICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcyB9KSAoaW52YWxpZCBlbnRyeTogXCIgKyBKU09OLnN0cmluZ2lmeShlbnRyeSkgKyBcIilcIikgO1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0pO1xuICAgIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4LCAwLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBhY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5Qb3A7XG4gICAgdmFyIGxvY2F0aW9uID0gZW50cmllc1tpbmRleF07XG4gICAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICAgIHZhciBibG9ja2VycyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6ICcnLFxuICAgICAgICBoYXNoOiAnJ1xuICAgICAgfSwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgICByZXR1cm4gIWJsb2NrZXJzLmxlbmd0aCB8fCAoYmxvY2tlcnMuY2FsbCh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIHJldHJ5OiByZXRyeVxuICAgICAgfSksIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbikge1xuICAgICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcbiAgICAgIGxvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuICAgICAgbGlzdGVuZXJzLmNhbGwoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5QdXNoO1xuICAgICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeS5wdXNoKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDtcblxuICAgICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgICBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIHZhciBuZXh0QWN0aW9uID0gZXhwb3J0cy5BY3Rpb24uUmVwbGFjZTtcbiAgICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucmVwbGFjZShcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA7XG5cbiAgICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgICBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ28oZGVsdGEpIHtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChpbmRleCArIGRlbHRhLCAwLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBleHBvcnRzLkFjdGlvbi5Qb3A7XG4gICAgICB2YXIgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgICAgZ28oZGVsdGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9LFxuXG4gICAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgfSxcblxuICAgICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBnbzogZ28sXG4gICAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgICBnbygtMSk7XG4gICAgICB9LFxuICAgICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgICAgZ28oMSk7XG4gICAgICB9LFxuICAgICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH0sXG4gICAgICBibG9jazogZnVuY3Rpb24gYmxvY2soYmxvY2tlcikge1xuICAgICAgICByZXR1cm4gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFVUSUxTXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9tcHRCZWZvcmVVbmxvYWQoZXZlbnQpIHtcbiAgICAvLyBDYW5jZWwgdGhlIGV2ZW50LlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIENocm9tZSAoYW5kIGxlZ2FjeSBJRSkgcmVxdWlyZXMgcmV0dXJuVmFsdWUgdG8gYmUgc2V0LlxuXG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50cygpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgIH0sXG5cbiAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goZm4pIHtcbiAgICAgICAgaGFuZGxlcnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyICE9PSBmbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjYWxsOiBmdW5jdGlvbiBjYWxsKGFyZykge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHJldHVybiBmbiAmJiBmbihhcmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxyXG4gICAqXHJcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVwYXRoXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRoKF9yZWYpIHtcbiAgICB2YXIgX3JlZiRwYXRobmFtZSA9IF9yZWYucGF0aG5hbWUsXG4gICAgICAgIHBhdGhuYW1lID0gX3JlZiRwYXRobmFtZSA9PT0gdm9pZCAwID8gJy8nIDogX3JlZiRwYXRobmFtZSxcbiAgICAgICAgX3JlZiRzZWFyY2ggPSBfcmVmLnNlYXJjaCxcbiAgICAgICAgc2VhcmNoID0gX3JlZiRzZWFyY2ggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRzZWFyY2gsXG4gICAgICAgIF9yZWYkaGFzaCA9IF9yZWYuaGFzaCxcbiAgICAgICAgaGFzaCA9IF9yZWYkaGFzaCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGhhc2g7XG4gICAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuICAgIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aG5hbWUgKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuICAgIHJldHVybiBwYXRobmFtZTtcbiAgfVxuICAvKipcclxuICAgKiBQYXJzZXMgYSBzdHJpbmcgVVJMIHBhdGggaW50byBpdHMgc2VwYXJhdGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjcGFyc2VwYXRoXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgICB2YXIgcGFyc2VkUGF0aCA9IHt9O1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcblxuICAgICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcblxuICAgICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkUGF0aC5zZWFyY2ggPSBwYXRoLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRQYXRoO1xuICB9XG5cbiAgZXhwb3J0cy5jcmVhdGVCcm93c2VySGlzdG9yeSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xuICBleHBvcnRzLmNyZWF0ZUhhc2hIaXN0b3J5ID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG4gIGV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG4gIGV4cG9ydHMuY3JlYXRlUGF0aCA9IGNyZWF0ZVBhdGg7XG4gIGV4cG9ydHMucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaXN0b3J5LmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/history/umd/history.development.js\n");

/***/ })

};
;