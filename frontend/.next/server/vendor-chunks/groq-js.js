"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.js":
/*!****************************************!*\
  !*** ./node_modules/groq-js/dist/1.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => {\n  __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\")) {\n    if (part === \"*\") {\n      re.push(\"[^.]+\");\n    } else if (part === \"**\") {\n      re.push(\".*\");\n    } else {\n      re.push(escapeRegExp(part));\n    }\n  }\n  return new RegExp(\"^\".concat(re.join(\".\"), \"$\"));\n}\nclass Path {\n  constructor(pattern) {\n    __publicField$5(this, \"pattern\");\n    __publicField$5(this, \"patternRe\");\n    this.pattern = pattern;\n    this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$4 = (obj, key, value) => {\n  __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass StreamValue {\n  constructor(generator) {\n    __publicField$4(this, \"type\", \"stream\");\n    __publicField$4(this, \"generator\");\n    __publicField$4(this, \"ticker\");\n    __publicField$4(this, \"isDone\");\n    __publicField$4(this, \"data\");\n    this.generator = generator;\n    this.ticker = null;\n    this.isDone = false;\n    this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return true;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this) {\n      result.push(await value.get());\n    }\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i];\n      }\n      if (this.isDone) {\n        return;\n      }\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker) {\n      return this.ticker;\n    }\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise(resolve => {\n        currentResolver = resolve;\n      });\n    };\n    const tick = () => {\n      currentResolver();\n      setupTicker();\n    };\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value);\n        tick();\n      }\n      this.isDone = true;\n      tick();\n    };\n    setupTicker();\n    fetch();\n    return this.ticker;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str);\n  }\n  return null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4);\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n  const day = addLeadingZero(d.getUTCDate(), 2);\n  const hour = addLeadingZero(d.getUTCHours(), 2);\n  const minute = addLeadingZero(d.getUTCMinutes(), 2);\n  const second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  if (millis != 0) {\n    fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n  }\n  return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  while (str.length < targetLength) {\n    str = \"0\".concat(str);\n  }\n  return str;\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass StaticValue {\n  constructor(data, type) {\n    __publicField$3(this, \"data\");\n    __publicField$3(this, \"type\");\n    this.data = data;\n    this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data)) {\n      return function* (data) {\n        for (const element of data) {\n          yield fromJS(element);\n        }\n      }(this.data);\n    }\n    throw new Error(\"Cannot iterate over: \".concat(this.type));\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    __publicField$3(this, \"date\");\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    if (date) {\n      return new StaticValue(new DateTime(date), \"datetime\");\n    }\n    return NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    copy.setTime(copy.getTime() + secs * 1e3);\n    return new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, \"number\");\n  }\n  return NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value);\n      }\n    });\n  } else if (val === null || val === void 0) {\n    return NULL_VALUE;\n  }\n  return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  if (data === null || typeof data === \"undefined\") {\n    return \"null\";\n  }\n  if (Array.isArray(data)) {\n    return \"array\";\n  }\n  if (data instanceof Path) {\n    return \"path\";\n  }\n  if (data instanceof DateTime) {\n    return \"datetime\";\n  }\n  return typeof data;\n}\nfunction isEqual(a, b) {\n  if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n    return a.data === b.data;\n  }\n  if (a.type === \"datetime\" && b.type === \"datetime\") {\n    return a.data.equals(b.data);\n  }\n  return false;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false;\n  }\n  return patterns.every(pattern => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  const termsRe = matchPatternRegex(text);\n  return termsRe.map(re => tokens => tokens.some(token => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n  return terms.map(term => new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\"), \"$\"), \"i\"));\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\") {\n    cb(value.data);\n    return true;\n  }\n  if (value.isArray()) {\n    let success = true;\n    for await (const part of value) {\n      if (part.type === \"string\") {\n        cb(part.data);\n      } else {\n        success = false;\n      }\n    }\n    return success;\n  }\n  return false;\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  if (aType !== bType) {\n    return null;\n  }\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  const aTypeOrder = TYPE_ORDER[aType] || 100;\n  const bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder;\n  }\n  let result = partialCompare(a, b);\n  if (result === null) {\n    result = 0;\n  }\n  return result;\n}\nconst operators = {\n  \"==\": function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function gt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function gte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function lt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function lte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === \"path\") {\n      if (left.type !== \"string\") {\n        return NULL_VALUE;\n      }\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    }\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE;\n        }\n      }\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function match(left, right) {\n    let tokens = [];\n    let patterns = [];\n    await gatherText(left, part => {\n      tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(right, part => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    });\n    if (!didSucceed) {\n      return FALSE_VALUE;\n    }\n    const matched = matchText(tokens, patterns);\n    return matched ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function plus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data + right.data);\n    }\n    if (left.type === \"string\" && right.type === \"string\") {\n      return fromString(left.data + right.data);\n    }\n    if (left.type === \"object\" && right.type === \"object\") {\n      return fromJS({\n        ...left.data,\n        ...right.data\n      });\n    }\n    if (left.type === \"array\" && right.type === \"array\") {\n      return fromJS(left.data.concat(right.data));\n    }\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val;\n        }\n        for await (const val of right) {\n          yield val;\n        }\n      });\n    }\n    return NULL_VALUE;\n  },\n  \"-\": function minus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(-right.data));\n    }\n    if (left.type === \"datetime\" && right.type === \"datetime\") {\n      return fromNumber(left.data.difference(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data - right.data);\n    }\n    return NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function (left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Scope {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    __publicField$2(this, \"params\");\n    __publicField$2(this, \"source\");\n    __publicField$2(this, \"value\");\n    __publicField$2(this, \"parent\");\n    __publicField$2(this, \"context\");\n    __publicField$2(this, \"isHidden\", false);\n    this.params = params;\n    this.source = source;\n    this.value = value;\n    this.context = context;\n    this.parent = parent;\n  }\n  createNested(value) {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent);\n    }\n    return new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    result.isHidden = true;\n    return result;\n  }\n}\nfunction evaluate(node, scope) {\n  let execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : evaluate;\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  if (\"then\" in value) {\n    return value.then(cb);\n  }\n  return cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Selector() {\n    throw new Error(\"Selectors can not be evaluated\");\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter(_ref, scope) {\n    let {\n      name\n    } = _ref;\n    return fromJS(scope.params[name]);\n  },\n  Context(_ref2, scope) {\n    let {\n      key\n    } = _ref2;\n    if (key === \"before\" || key === \"after\") {\n      const value = scope.context[key];\n      return value || NULL_VALUE;\n    }\n    throw new Error(\"unknown context key: \".concat(key));\n  },\n  Parent(_ref3, scope) {\n    let {\n      n\n    } = _ref3;\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE;\n      }\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall(_ref4, scope, execute) {\n    let {\n      op,\n      left,\n      right\n    } = _ref4;\n    const func = operators[op];\n    if (!func) {\n      throw new Error(\"Unknown operator: \".concat(op));\n    }\n    const leftValue = execute(left, scope);\n    const rightValue = execute(right, scope);\n    if (\"then\" in leftValue || \"then\" in rightValue) {\n      return (async () => func(await leftValue, await rightValue))();\n    }\n    return func(leftValue, rightValue);\n  },\n  async Select(_ref5, scope, execute) {\n    let {\n      alternatives,\n      fallback\n    } = _ref5;\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === true) {\n        return execute(alt.value, scope);\n      }\n    }\n    if (fallback) {\n      return execute(fallback, scope);\n    }\n    return NULL_VALUE;\n  },\n  async InRange(_ref6, scope, execute) {\n    let {\n      base,\n      left,\n      right,\n      isInclusive\n    } = _ref6;\n    const value = await execute(base, scope);\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    const leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null) {\n      return NULL_VALUE;\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    if (rightCmp === null) {\n      return NULL_VALUE;\n    }\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter(_ref7, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref7;\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem);\n        const exprValue = await execute(expr, newScope);\n        if (exprValue.type === \"boolean\" && exprValue.data === true) {\n          yield elem;\n        }\n      }\n    });\n  },\n  async Projection(_ref8, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref8;\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall(_ref9, scope, execute) {\n    let {\n      func,\n      args\n    } = _ref9;\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall(_ref10, scope, execute) {\n    let {\n      func,\n      base,\n      args\n    } = _ref10;\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute(_ref11, scope, execute) {\n    let {\n      base,\n      name\n    } = _ref11;\n    let value = scope.value;\n    if (base) {\n      value = await execute(base, scope);\n    }\n    if (value.type === \"object\") {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name]);\n      }\n    }\n    return NULL_VALUE;\n  },\n  async AccessElement(_ref12, scope, execute) {\n    let {\n      base,\n      index\n    } = _ref12;\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const data = await baseValue.get();\n    const finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice(_ref13, scope, execute) {\n    let {\n      base,\n      left,\n      right,\n      isInclusive\n    } = _ref13;\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const array = await baseValue.get();\n    let leftIdx = left;\n    let rightIdx = right;\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx;\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx;\n    }\n    if (isInclusive) {\n      rightIdx++;\n    }\n    if (leftIdx < 0) {\n      leftIdx = 0;\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0;\n    }\n    return fromJS(array.slice(leftIdx, rightIdx));\n  },\n  async Deref(_ref14, scope, execute) {\n    let {\n      base\n    } = _ref14;\n    const value = await execute(base, scope);\n    if (!scope.source.isArray()) {\n      return NULL_VALUE;\n    }\n    if (value.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const id = value.data._ref;\n    if (typeof id !== \"string\") {\n      return NULL_VALUE;\n    }\n    if (scope.context.dereference) {\n      return fromJS(await scope.context.dereference({\n        _ref: id\n      }));\n    }\n    for await (const doc of scope.source) {\n      if (doc.type === \"object\" && id === doc.data._id) {\n        return doc;\n      }\n    }\n    return NULL_VALUE;\n  },\n  Value(_ref15) {\n    let {\n      value\n    } = _ref15;\n    return fromJS(value);\n  },\n  Group(_ref16, scope, execute) {\n    let {\n      base\n    } = _ref16;\n    return execute(base, scope);\n  },\n  async Object(_ref17, scope, execute) {\n    let {\n      attributes\n    } = _ref17;\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\":\n          {\n            const value = await execute(attr.value, scope);\n            result[attr.name] = await value.get();\n            break;\n          }\n        case \"ObjectConditionalSplat\":\n          {\n            const cond = await execute(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === false) {\n              continue;\n            }\n            const value = await execute(attr.value, scope);\n            if (value.type === \"object\") {\n              Object.assign(result, value.data);\n            }\n            break;\n          }\n        case \"ObjectSplat\":\n          {\n            const value = await execute(attr.value, scope);\n            if (value.type === \"object\") {\n              Object.assign(result, value.data);\n            }\n            break;\n          }\n        default:\n          throw new Error(\"Unknown node type: \".concat(attrType));\n      }\n    }\n    return fromJS(result);\n  },\n  Array(_ref18, scope, execute) {\n    let {\n      elements\n    } = _ref18;\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v;\n            }\n          }\n        } else {\n          yield value;\n        }\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or(_ref19, scope, execute) {\n    let {\n      left,\n      right\n    } = _ref19;\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return FALSE_VALUE;\n  },\n  async And(_ref20, scope, execute) {\n    let {\n      left,\n      right\n    } = _ref20;\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return TRUE_VALUE;\n  },\n  async Not(_ref21, scope, execute) {\n    let {\n      base\n    } = _ref21;\n    const value = await execute(base, scope);\n    if (value.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg(_ref22, scope, execute) {\n    let {\n      base\n    } = _ref22;\n    return promiselessApply(execute(base, scope), value => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(-value.data);\n    });\n  },\n  Pos(_ref23, scope, execute) {\n    let {\n      base\n    } = _ref23;\n    return promiselessApply(execute(base, scope), value => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(value.data);\n    });\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce(_ref24, scope, execute) {\n    let {\n      base\n    } = _ref24;\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map(_ref25, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref25;\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    });\n  },\n  async FlatMap(_ref26, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref26;\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        const innerValue = await execute(expr, newScope);\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner;\n          }\n        } else {\n          yield innerValue;\n        }\n      }\n    });\n  }\n};\nfunction evaluateQuery(tree) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const root = fromJS(options.root);\n  const dataset = fromJS(options.dataset);\n  const params = {\n    ...options.params\n  };\n  const scope = new Scope(params, dataset, root, {\n    timestamp: options.timestamp || /* @__PURE__ */new Date(),\n    identity: options.identity === void 0 ? \"me\" : options.identity,\n    sanity: options.sanity,\n    after: options.after ? fromJS(options.after) : null,\n    before: options.before ? fromJS(options.before) : null,\n    dereference: options.dereference\n  }, null);\n  return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return true;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return false;\n      }\n    default:\n      return false;\n  }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {\n  timestamp: /* @__PURE__ */new Date(0),\n  identity: \"me\",\n  before: null,\n  after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n  if (!canConstantEvaluate(node)) {\n    return null;\n  }\n  return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value) {\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  }\n  return value;\n}\nasync function portableTextContent(value) {\n  if (value.type === \"object\") {\n    return blockText(value.data);\n  } else if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0) {\n      return texts.join(\"\\n\\n\");\n    }\n  }\n  return null;\n}\nasync function arrayText(value) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  for await (const block of value) {\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      if (text !== null) result.push(text);\n    } else if (block.isArray()) {\n      await arrayText(block, result);\n    }\n  }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type !== \"string\") return null;\n  const children = obj.children;\n  if (!Array.isArray(children)) return null;\n  let result = \"\";\n  for (const child of children) {\n    if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n      result += child.text;\n    }\n  }\n  return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\") {\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  }\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute);\n    const boost = await execute(node.args[1], scope);\n    if (boost.type === \"number\" && innerScore > 0) {\n      return innerScore + boost.data;\n    }\n    return 0;\n  }\n  switch (node.type) {\n    case \"Or\":\n      {\n        const leftScore = await evaluateScore(node.left, scope, execute);\n        const rightScore = await evaluateScore(node.right, scope, execute);\n        return leftScore + rightScore;\n      }\n    case \"And\":\n      {\n        const leftScore = await evaluateScore(node.left, scope, execute);\n        const rightScore = await evaluateScore(node.right, scope, execute);\n        if (leftScore === 0 || rightScore === 0) return 0;\n        return leftScore + rightScore;\n      }\n    default:\n      {\n        const res = await execute(node, scope);\n        return res.type === \"boolean\" && res.data === true ? 1 : 0;\n      }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope);\n  const pattern = await execute(right, scope);\n  let tokens = [];\n  let terms = [];\n  await gatherText(text, part => {\n    tokens = tokens.concat(matchTokenize(part));\n  });\n  const didSucceed = await gatherText(pattern, part => {\n    terms = terms.concat(matchPatternRegex(part));\n  });\n  if (!didSucceed) {\n    return 0;\n  }\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0;\n  }\n  let score = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n    case \"object\":\n      if (value._ref) {\n        return pathSet.has(value._ref);\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n  }\n  return false;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    if (code >= 55296 && code <= 56319) {\n      continue;\n    }\n    count2++;\n  }\n  return count2;\n}\nconst _global = {};\n_global.anywhere = async function anywhere() {\n  throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\") {\n      return value;\n    }\n  }\n  return NULL_VALUE;\n};\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray()) {\n    return NULL_VALUE;\n  }\n  let num = 0;\n  for await (const _ of inner) {\n    num++;\n  }\n  return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  if (val.type === \"datetime\") {\n    return val;\n  }\n  if (val.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\") {\n    return fromNumber(countUTF8(inner.data));\n  }\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner) {\n      num++;\n    }\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(\"\".concat(value.data));\n    default:\n      return NULL_VALUE;\n  }\n};\n_global.string.arity = 1;\n_global.references = async function references(args, scope, execute) {\n  const pathSet = /* @__PURE__ */new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\") {\n      pathSet.add(path2.data);\n    } else if (path2.isArray()) {\n      for await (const elem of path2) {\n        if (elem.type === \"string\") {\n          pathSet.add(elem.data);\n        }\n      }\n    }\n  }\n  if (pathSet.size === 0) {\n    return FALSE_VALUE;\n  }\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = c => c >= 1;\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\") {\n    return NULL_VALUE;\n  }\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE;\n    }\n    prec = precValue.data;\n  }\n  if (prec === 0) {\n    if (num < 0) {\n      return fromNumber(-Math.round(-num));\n    }\n    return fromNumber(Math.round(num));\n  }\n  return fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = count2 => count2 >= 1 && count2 <= 2;\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function boost() {\n  throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  if (str.data.length === 0) {\n    return fromJS([]);\n  }\n  if (sep.data.length === 0) {\n    return fromJS(Array.from(str.data));\n  }\n  return fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  const prefix = await execute(args[1], scope);\n  if (prefix.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  let buf = \"\";\n  let needSep = false;\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data;\n    }\n    switch (elem.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        buf += \"\".concat(elem.data);\n        break;\n      default:\n        return NULL_VALUE;\n    }\n    needSep = true;\n  }\n  return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== \"null\") {\n        yield elem;\n      }\n    }\n  });\n};\narray.compact.arity = 1;\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (!value.isArray()) {\n    return NULL_VALUE;\n  }\n  return new StreamValue(async function* () {\n    const added = /* @__PURE__ */new Set();\n    for await (const iter of value) {\n      switch (iter.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          if (!added.has(iter.data)) {\n            added.add(iter.data);\n            yield iter;\n          }\n          break;\n        default:\n          yield iter;\n      }\n    }\n  });\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  const text = await portableTextContent(value);\n  if (text === null) {\n    return NULL_VALUE;\n  }\n  return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId);\n  }\n  return NULL_VALUE;\n};\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset);\n  }\n  return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n  await true;\n  if (!base.isArray()) {\n    return NULL_VALUE;\n  }\n  const mappers = [];\n  const directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    if (mapper.type === \"Desc\") {\n      direction = \"desc\";\n      mapper = mapper.base;\n    } else if (mapper.type === \"Asc\") {\n      mapper = mapper.base;\n    }\n    mappers.push(mapper);\n    directions.push(direction);\n    n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value);\n    const tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple);\n    idx++;\n  }\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\") {\n        c = -c;\n      }\n      if (c !== 0) {\n        return c;\n      }\n    }\n    return aTuple[1] - bTuple[1];\n  });\n  return fromJS(aux.map(v => v[0]));\n};\npipeFunctions.order.arity = count2 => count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE;\n  const unknown = [];\n  const scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute);\n    }\n    const newObject = Object.assign({}, value.data, {\n      _score: valueScore\n    });\n    scored.push(newObject);\n  }\n  scored.sort((a, b) => b._score - a._score);\n  return fromJS(scored);\n};\npipeFunctions.score.arity = count2 => count2 >= 1;\nconst delta = {};\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null;\n  const hasAfter = scope.context.after !== null;\n  if (hasBefore && hasAfter) {\n    return fromString(\"update\");\n  }\n  if (hasAfter) {\n    return fromString(\"create\");\n  }\n  if (hasBefore) {\n    return fromString(\"delete\");\n  }\n  return NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    if (n === void 0 || elem.data < n) {\n      n = elem.data;\n    }\n  }\n  return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    if (n === void 0 || elem.data > n) {\n      n = elem.data;\n    }\n  }\n  return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n = 0;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    n += elem.data;\n  }\n  return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n = 0;\n  let c = 0;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    n += elem.data;\n    c++;\n  }\n  if (c === 0) {\n    return NULL_VALUE;\n  }\n  return fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst namespaces = {\n  global: _global,\n  string: string2,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math\n};\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MarkProcessor {\n  constructor(string, marks, parseOptions) {\n    __publicField$1(this, \"string\");\n    __publicField$1(this, \"marks\");\n    __publicField$1(this, \"index\");\n    __publicField$1(this, \"parseOptions\");\n    __publicField$1(this, \"allowBoost\", false);\n    this.string = string;\n    this.marks = marks;\n    this.index = 0;\n    this.parseOptions = parseOptions;\n  }\n  hasMark() {\n    let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.index + pos < this.marks.length;\n  }\n  getMark() {\n    let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func) {\n      throw new Error(\"Unknown handler: \".concat(mark.name));\n    }\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    this.shift();\n    return this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1];\n    const curr = this.marks[this.index];\n    this.shift();\n    return this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === \"error\") return result;\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result;\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n  switch (token) {\n    case \"+\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n        if (rhs.type === \"error\") return rhs;\n        marks = [{\n          name: \"pos\",\n          position: startPos\n        }].concat(rhs.marks);\n        pos = rhs.position;\n        break;\n      }\n    case \"-\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n        if (rhs.type === \"error\") return rhs;\n        marks = [{\n          name: \"neg\",\n          position: startPos\n        }].concat(rhs.marks);\n        pos = rhs.position;\n        break;\n      }\n    case \"(\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n        if (rhs.type === \"error\") return rhs;\n        pos = skipWS(str, rhs.position);\n        switch (str[pos]) {\n          case \",\":\n            {\n              marks = [{\n                name: \"tuple\",\n                position: startPos\n              }].concat(rhs.marks);\n              pos = skipWS(str, pos + 1);\n              while (true) {\n                rhs = parseExpr(str, pos, 0);\n                if (rhs.type === \"error\") return rhs;\n                pos = skipWS(str, rhs.position);\n                if (str[pos] !== \",\") break;\n                pos = skipWS(str, pos + 1);\n              }\n              if (str[pos] !== \")\") return {\n                type: \"error\",\n                position: pos\n              };\n              pos++;\n              marks.push({\n                name: \"tuple_end\",\n                position: pos\n              });\n              break;\n            }\n          case \")\":\n            {\n              pos++;\n              marks = [{\n                name: \"group\",\n                position: startPos\n              }].concat(rhs.marks);\n              break;\n            }\n          default:\n            return {\n              type: \"error\",\n              position: pos\n            };\n        }\n        break;\n      }\n    case \"!\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n        if (rhs.type === \"error\") return rhs;\n        marks = [{\n          name: \"not\",\n          position: startPos\n        }].concat(rhs.marks);\n        pos = rhs.position;\n        break;\n      }\n    case \"{\":\n      {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\") return result;\n        marks = result.marks;\n        pos = result.position;\n        break;\n      }\n    case \"[\":\n      marks = [{\n        name: \"array\",\n        position: pos\n      }];\n      pos = skipWS(str, pos + 1);\n      if (str[pos] !== \"]\") {\n        while (true) {\n          if (str.slice(pos, pos + 3) === \"...\") {\n            marks.push({\n              name: \"array_splat\",\n              position: pos\n            });\n            pos = skipWS(str, pos + 3);\n          }\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\") return res;\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== \",\") break;\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === \"]\") break;\n        }\n      }\n      if (str[pos] === \"]\") {\n        pos++;\n        marks.push({\n          name: \"array_end\",\n          position: pos\n        });\n      } else {\n        return {\n          type: \"error\",\n          position: pos\n        };\n      }\n      break;\n    case \"'\":\n    case '\"':\n      {\n        let result = parseString(str, pos);\n        if (result.type === \"error\") return result;\n        marks = result.marks;\n        pos = result.position;\n        break;\n      }\n    case \"^\":\n      {\n        pos++;\n        marks = [];\n        while (str[pos] === \".\" && str[pos + 1] === \"^\") {\n          marks.push({\n            name: \"dblparent\",\n            position: startPos\n          });\n          pos += 2;\n        }\n        marks.push({\n          name: \"parent\",\n          position: startPos\n        });\n        break;\n      }\n    case \"@\":\n      marks = [{\n        name: \"this\",\n        position: startPos\n      }];\n      pos++;\n      break;\n    case \"*\":\n      marks = [{\n        name: \"everything\",\n        position: startPos\n      }];\n      pos++;\n      break;\n    case \"$\":\n      {\n        let identLen = parseRegex(str, pos + 1, IDENT);\n        if (identLen) {\n          pos += 1 + identLen;\n          marks = [{\n            name: \"param\",\n            position: startPos\n          }, {\n            name: \"ident\",\n            position: startPos + 1\n          }, {\n            name: \"ident_end\",\n            position: pos\n          }];\n        }\n        break;\n      }\n    default:\n      {\n        let numLen = parseRegex(str, pos, NUM);\n        if (numLen) {\n          pos += numLen;\n          let name = \"integer\";\n          if (str[pos] === \".\") {\n            let fracLen = parseRegex(str, pos + 1, NUM);\n            if (fracLen) {\n              name = \"float\";\n              pos += 1 + fracLen;\n            }\n          }\n          if (str[pos] === \"e\" || str[pos] === \"E\") {\n            name = \"sci\";\n            pos++;\n            if (str[pos] === \"+\" || str[pos] === \"-\") {\n              pos++;\n            }\n            let expLen = parseRegex(str, pos, NUM);\n            if (!expLen) return {\n              type: \"error\",\n              position: pos\n            };\n            pos += expLen;\n          }\n          marks = [{\n            name,\n            position: startPos\n          }, {\n            name: name + \"_end\",\n            position: pos\n          }];\n          break;\n        }\n        let identLen = parseRegex(str, pos, IDENT);\n        if (identLen) {\n          pos += identLen;\n          switch (str[pos]) {\n            case \":\":\n            case \"(\":\n              {\n                let result = parseFuncCall(str, startPos, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n              }\n            default:\n              {\n                marks = [{\n                  name: \"this_attr\",\n                  position: startPos\n                }, {\n                  name: \"ident\",\n                  position: startPos\n                }, {\n                  name: \"ident_end\",\n                  position: pos\n                }];\n              }\n          }\n          break;\n        }\n      }\n  }\n  if (!marks) {\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  let lhsLevel = 12;\n  let trav;\n  loop: while (true) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break;\n    }\n    trav = parseTraversal(str, innerPos);\n    if (trav.type === \"success\") {\n      marks.unshift({\n        name: \"traverse\",\n        position: startPos\n      });\n      while (trav.type === \"success\") {\n        marks = marks.concat(trav.marks);\n        pos = trav.position;\n        trav = parseTraversal(str, skipWS(str, pos));\n      }\n      marks.push({\n        name: \"traversal_end\",\n        position: pos\n      });\n      continue;\n    }\n    let token2 = str[innerPos];\n    switch (token2) {\n      case \"=\":\n        {\n          let nextToken = str[innerPos + 1];\n          switch (nextToken) {\n            case \">\":\n              {\n                if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop;\n                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n                if (rhs.type === \"error\") return rhs;\n                marks = marks.concat(rhs.marks);\n                marks.unshift({\n                  name: \"pair\",\n                  position: startPos\n                });\n                pos = rhs.position;\n                lhsLevel = PREC_PAIR;\n                break;\n              }\n            case \"=\":\n              {\n                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                if (rhs.type === \"error\") return rhs;\n                marks.unshift({\n                  name: \"comp\",\n                  position: startPos\n                });\n                marks.push({\n                  name: \"op\",\n                  position: innerPos\n                }, {\n                  name: \"op_end\",\n                  position: innerPos + 2\n                });\n                marks = marks.concat(rhs.marks);\n                pos = rhs.position;\n                lhsLevel = PREC_COMP;\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        }\n      case \"+\":\n        {\n          if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"add\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_ADD;\n          break;\n        }\n      case \"-\":\n        {\n          if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"sub\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_SUB;\n          break;\n        }\n      case \"*\":\n        {\n          if (str[innerPos + 1] === \"*\") {\n            if (level > PREC_POW || lhsLevel <= PREC_POW) break loop;\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n            if (rhs2.type === \"error\") return rhs2;\n            marks = marks.concat(rhs2.marks);\n            marks.unshift({\n              name: \"pow\",\n              position: startPos\n            });\n            pos = rhs2.position;\n            lhsLevel = PREC_POW;\n            break;\n          }\n          if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"mul\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_MUL;\n          break;\n        }\n      case \"/\":\n        {\n          if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"div\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_DIV;\n          break;\n        }\n      case \"%\":\n        {\n          if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"mod\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_MOD;\n          break;\n        }\n      case \"<\":\n      case \">\":\n        {\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n          let nextPos = innerPos + 1;\n          if (str[nextPos] === \"=\") {\n            nextPos++;\n          }\n          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks.unshift({\n            name: \"comp\",\n            position: startPos\n          });\n          marks.push({\n            name: \"op\",\n            position: innerPos\n          }, {\n            name: \"op_end\",\n            position: nextPos\n          });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n      case \"|\":\n        {\n          if (str[innerPos + 1] === \"|\") {\n            if (level > PREC_OR || lhsLevel < PREC_OR) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n            if (rhs.type === \"error\") return rhs;\n            marks = marks.concat(rhs.marks);\n            marks.unshift({\n              name: \"or\",\n              position: startPos\n            });\n            pos = rhs.position;\n            lhsLevel = PREC_OR;\n          } else {\n            if (level > 11 || lhsLevel < 11) break loop;\n            let identPos = skipWS(str, innerPos + 1);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (!identLen) return {\n              type: \"error\",\n              position: identPos\n            };\n            pos = identPos + identLen;\n            if (str[pos] === \"(\" || str[pos] === \":\") {\n              let result = parseFuncCall(str, identPos, pos);\n              if (result.type === \"error\") return result;\n              marks = marks.concat(result.marks);\n              marks.unshift({\n                name: \"pipecall\",\n                position: startPos\n              });\n              pos = result.position;\n              lhsLevel = 11;\n            }\n          }\n          break;\n        }\n      case \"&\":\n        {\n          if (str[innerPos + 1] != \"&\") break loop;\n          if (level > PREC_AND || lhsLevel < PREC_AND) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"and\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_AND;\n          break;\n        }\n      case \"!\":\n        {\n          if (str[innerPos + 1] !== \"=\") break loop;\n          if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks.unshift({\n            name: \"comp\",\n            position: startPos\n          });\n          marks.push({\n            name: \"op\",\n            position: innerPos\n          }, {\n            name: \"op_end\",\n            position: innerPos + 2\n          });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n      case \"d\":\n        {\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\") break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n          marks.unshift({\n            name: \"desc\",\n            position: startPos\n          });\n          pos = innerPos + 4;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n      case \"a\":\n        {\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\") break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n          marks.unshift({\n            name: \"asc\",\n            position: startPos\n          });\n          pos = innerPos + 3;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n      default:\n        {\n          let ident = parseRegexStr(str, innerPos, IDENT);\n          switch (ident) {\n            case \"in\":\n              {\n                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                pos = skipWS(str, innerPos + 2);\n                let isGroup = false;\n                if (str[pos] === \"(\") {\n                  isGroup = true;\n                  pos = skipWS(str, pos + 1);\n                }\n                let rangePos = pos;\n                let result = parseExpr(str, pos, PREC_COMP + 1);\n                if (result.type === \"error\") return result;\n                pos = skipWS(str, result.position);\n                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                  let type = \"inc_range\";\n                  if (str[pos + 2] === \".\") {\n                    type = \"exc_range\";\n                    pos = skipWS(str, pos + 3);\n                  } else {\n                    pos = skipWS(str, pos + 2);\n                  }\n                  let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                  if (rhs.type === \"error\") return rhs;\n                  marks.unshift({\n                    name: \"in_range\",\n                    position: startPos\n                  });\n                  marks = marks.concat({\n                    name: type,\n                    position: rangePos\n                  }, result.marks, rhs.marks);\n                  pos = rhs.position;\n                } else {\n                  marks.unshift({\n                    name: \"comp\",\n                    position: startPos\n                  });\n                  marks.push({\n                    name: \"op\",\n                    position: innerPos\n                  }, {\n                    name: \"op_end\",\n                    position: innerPos + 2\n                  });\n                  marks = marks.concat(result.marks);\n                }\n                if (isGroup) {\n                  pos = skipWS(str, pos);\n                  if (str[pos] !== \")\") return {\n                    type: \"error\",\n                    position: pos\n                  };\n                  pos++;\n                }\n                lhsLevel = PREC_COMP;\n                break;\n              }\n            case \"match\":\n              {\n                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n                if (rhs.type === \"error\") return rhs;\n                marks.unshift({\n                  name: \"comp\",\n                  position: startPos\n                });\n                marks.push({\n                  name: \"op\",\n                  position: innerPos\n                }, {\n                  name: \"op_end\",\n                  position: innerPos + 5\n                });\n                marks = marks.concat(rhs.marks);\n                pos = rhs.position;\n                lhsLevel = 4;\n                break;\n              }\n            default:\n              {\n                break loop;\n              }\n          }\n        }\n    }\n  }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return {\n    type: \"success\",\n    marks,\n    position: pos,\n    failPosition\n  };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\":\n      {\n        pos = skipWS(str, pos + 1);\n        let identStart = pos;\n        let identLen2 = parseRegex(str, pos, IDENT);\n        if (!identLen2) return {\n          type: \"error\",\n          position: pos\n        };\n        pos += identLen2;\n        return {\n          type: \"success\",\n          marks: [{\n            name: \"attr_access\",\n            position: startPos\n          }, {\n            name: \"ident\",\n            position: identStart\n          }, {\n            name: \"ident_end\",\n            position: pos\n          }],\n          position: pos\n        };\n      }\n    case \"-\":\n      if (str[pos + 1] !== \">\") return {\n        type: \"error\",\n        position: pos\n      };\n      let marks = [{\n        name: \"deref\",\n        position: startPos\n      }];\n      pos += 2;\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push({\n          name: \"deref_attr\",\n          position: identPos\n        }, {\n          name: \"ident\",\n          position: identPos\n        }, {\n          name: \"ident_end\",\n          position: pos\n        });\n      }\n      return {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\":\n      {\n        pos = skipWS(str, pos + 1);\n        if (str[pos] === \"]\") {\n          return {\n            type: \"success\",\n            marks: [{\n              name: \"array_postfix\",\n              position: startPos\n            }],\n            position: pos + 1\n          };\n        }\n        let rangePos = pos;\n        let result = parseExpr(str, pos, 0);\n        if (result.type === \"error\") return result;\n        pos = skipWS(str, result.position);\n        if (str[pos] === \".\" && str[pos + 1] === \".\") {\n          let type = \"inc_range\";\n          if (str[pos + 2] === \".\") {\n            type = \"exc_range\";\n            pos += 3;\n          } else {\n            pos += 2;\n          }\n          pos = skipWS(str, pos);\n          let rhs = parseExpr(str, pos, 0);\n          if (rhs.type === \"error\") return rhs;\n          pos = skipWS(str, rhs.position);\n          if (str[pos] !== \"]\") return {\n            type: \"error\",\n            position: pos\n          };\n          return {\n            type: \"success\",\n            marks: [{\n              name: \"slice\",\n              position: startPos\n            }, {\n              name: type,\n              position: rangePos\n            }].concat(result.marks, rhs.marks),\n            position: pos + 1\n          };\n        }\n        if (str[pos] !== \"]\") return {\n          type: \"error\",\n          position: pos\n        };\n        return {\n          type: \"success\",\n          marks: [{\n            name: \"square_bracket\",\n            position: startPos\n          }].concat(result.marks),\n          position: pos + 1\n        };\n      }\n    case \"|\":\n      {\n        pos = skipWS(str, pos + 1);\n        if (str[pos] === \"{\") {\n          let result = parseObject(str, pos);\n          if (result.type === \"error\") return result;\n          result.marks.unshift({\n            name: \"projection\",\n            position: startPos\n          });\n          return result;\n        }\n        break;\n      }\n    case \"{\":\n      {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\") return result;\n        result.marks.unshift({\n          name: \"projection\",\n          position: startPos\n        });\n        return result;\n      }\n  }\n  return {\n    type: \"error\",\n    position: pos\n  };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  marks.push({\n    name: \"func_call\",\n    position: startPos\n  });\n  if (str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({\n      name: \"namespace\",\n      position: startPos\n    });\n    marks.push({\n      name: \"ident\",\n      position: startPos\n    }, {\n      name: \"ident_end\",\n      position: pos\n    });\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return {\n      type: \"error\",\n      position: pos\n    };\n    marks.push({\n      name: \"ident\",\n      position: pos\n    }, {\n      name: \"ident_end\",\n      position: pos + nameLen\n    });\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== \"(\") return {\n      type: \"error\",\n      position: pos\n    };\n    pos++;\n    pos = skipWS(str, pos);\n  } else {\n    marks.push({\n      name: \"ident\",\n      position: startPos\n    }, {\n      name: \"ident_end\",\n      position: pos\n    });\n    pos = skipWS(str, pos + 1);\n  }\n  let lastPos = pos;\n  if (str[pos] !== \")\") {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== \",\") break;\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \")\") break;\n    }\n  }\n  if (str[pos] !== \")\") {\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  marks.push({\n    name: \"func_args_end\",\n    position: lastPos\n  });\n  return {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  };\n}\nfunction parseObject(str, pos) {\n  let marks = [{\n    name: \"object\",\n    position: pos\n  }];\n  pos = skipWS(str, pos + 1);\n  while (str[pos] !== \"}\") {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\") {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\") return expr;\n        marks.push({\n          name: \"object_splat\",\n          position: pairPos\n        });\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({\n          name: \"object_splat_this\",\n          position: pairPos\n        });\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\") return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\") return value;\n        marks.push({\n          name: \"object_pair\",\n          position: pairPos\n        });\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({\n          name: \"object_expr\",\n          position: pos\n        }, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== \",\") break;\n    pos = skipWS(str, pos + 1);\n  }\n  if (str[pos] !== \"}\") {\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  pos++;\n  marks.push({\n    name: \"object_end\",\n    position: pos\n  });\n  return {\n    type: \"success\",\n    marks,\n    position: pos\n  };\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{\n    name: \"str\",\n    position: pos\n  }];\n  str: for (;; pos++) {\n    if (pos > str.length) return {\n      type: \"error\",\n      position: pos\n    };\n    switch (str[pos]) {\n      case token:\n        {\n          marks.push({\n            name: \"str_end\",\n            position: pos\n          });\n          pos++;\n          break str;\n        }\n      case \"\\\\\":\n        {\n          marks.push({\n            name: \"str_pause\",\n            position: pos\n          });\n          if (str[pos + 1] === \"u\") {\n            if (str[pos + 2] === \"{\") {\n              marks.push({\n                name: \"unicode_hex\",\n                position: pos + 3\n              });\n              pos = str.indexOf(\"}\", pos + 3);\n              marks.push({\n                name: \"unicode_hex_end\",\n                position: pos\n              });\n            } else {\n              marks.push({\n                name: \"unicode_hex\",\n                position: pos + 2\n              });\n              marks.push({\n                name: \"unicode_hex_end\",\n                position: pos + 6\n              });\n              pos += 5;\n            }\n          } else {\n            marks.push({\n              name: \"single_escape\",\n              position: pos + 1\n            });\n            pos += 1;\n          }\n          marks.push({\n            name: \"str_start\",\n            position: pos + 1\n          });\n        }\n    }\n  }\n  return {\n    type: \"success\",\n    marks,\n    position: pos\n  };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return base => b(a(base));\n}\nfunction map(inner) {\n  return base => ({\n    type: \"Map\",\n    base,\n    expr: inner({\n      type: \"This\"\n    })\n  });\n}\nfunction flatMap(inner) {\n  return base => ({\n    type: \"FlatMap\",\n    base,\n    expr: inner({\n      type: \"This\"\n    })\n  });\n}\nfunction traverseArray(build, right) {\n  if (!right) {\n    return {\n      type: \"a-a\",\n      build\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right) {\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"GroqQueryError\");\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER);\n    return {\n      type: \"Group\",\n      base: inner\n    };\n  },\n  everything() {\n    return {\n      type: \"Everything\"\n    };\n  },\n  this() {\n    return {\n      type: \"This\"\n    };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER);\n    return {\n      type: \"Parent\",\n      n: next.n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER);\n    const traversalList = [];\n    while (p.getMark().name !== \"traversal_end\") {\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    }\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal);\n    }\n    if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n      traversal = traverseArray(val => val, traversal);\n    }\n    if (traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    if (name === \"null\") {\n      return {\n        type: \"Value\",\n        value: null\n      };\n    }\n    if (name === \"true\") {\n      return {\n        type: \"Value\",\n        value: true\n      };\n    }\n    if (name === \"false\") {\n      return {\n        type: \"Value\",\n        value: false\n      };\n    }\n    return {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Neg\",\n      base\n    };\n  },\n  pos(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Pos\",\n      base\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER);\n    const op = p.processString();\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER);\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop: while (p.hasMark()) {\n      const mark = p.getMark();\n      switch (mark.name) {\n        case \"str_end\":\n          value += p.processStringEnd();\n          break loop;\n        case \"str_pause\":\n          value += p.processStringEnd();\n          break;\n        case \"str_start\":\n          p.shift();\n          break;\n        case \"single_escape\":\n          {\n            const char = p.slice(1);\n            p.shift();\n            value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n        case \"unicode_hex\":\n          p.shift();\n          value += expandHex(p.processStringEnd());\n          break;\n        default:\n          throw new Error(\"unexpected mark: \".concat(mark.name));\n      }\n    }\n    return {\n      type: \"Value\",\n      value\n    };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    while (p.getMark().name !== \"object_end\") {\n      attributes.push(p.process(OBJECT_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    while (p.getMark().name !== \"array_end\") {\n      let isSplat = false;\n      if (p.getMark().name === \"array_splat\") {\n        isSplat = true;\n        p.shift();\n      }\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    p.shift();\n    return {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    while (p.getMark().name !== \"tuple_end\") {\n      members.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      while (p.getMark().name !== \"func_args_end\") {\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER);\n          const value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      }\n      p.shift();\n      return result;\n    }\n    const args = [];\n    while (p.getMark().name !== \"func_args_end\") {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        p.process(SELECTOR_BUILDER);\n        args.push({\n          type: \"Selector\"\n        });\n      } else {\n        args.push(p.process(EXPR_BUILDER));\n      }\n    }\n    p.shift();\n    if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n      if (p.parseOptions.mode === \"delta\") {\n        return {\n          type: \"Context\",\n          key: name\n        };\n      }\n    }\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs) {\n      throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n    }\n    const func = funcs[name];\n    if (!func) {\n      throw new GroqQueryError(\"Undefined function: \".concat(name));\n    }\n    if (func.arity !== void 0) {\n      validateArity(name, func.arity, args.length);\n    }\n    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(\"Undefined function: \".concat(name));\n    }\n    return {\n      type: \"FuncCall\",\n      func,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    if (namespace !== \"global\") {\n      throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n    }\n    const name = p.processString();\n    const args = [];\n    const oldAllowBoost = p.allowBoost;\n    if (name === \"score\") {\n      p.allowBoost = true;\n    }\n    for (;;) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\") {\n        break;\n      }\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift();\n          args.push({\n            type: \"Asc\",\n            base: p.process(EXPR_BUILDER)\n          });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift();\n          args.push({\n            type: \"Desc\",\n            base: p.process(EXPR_BUILDER)\n          });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func) {\n      throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length);\n    }\n    return {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair(p) {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Not\",\n      base\n    };\n  },\n  asc(p) {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc(p) {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: \"Value\",\n        value: p.parseOptions.params[name]\n      };\n    }\n    return {\n      type: \"Parameter\",\n      name\n    };\n  }\n};\nconst OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER);\n      const value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\") throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectSplat\",\n      value\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: {\n        type: \"This\"\n      }\n    };\n  }\n};\nconst TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER);\n    const value = tryConstantEvaluate(expr);\n    if (value && value.type === \"number\") {\n      return right => traverseElement(base => ({\n        type: \"AccessElement\",\n        base,\n        index: value.data\n      }), right);\n    }\n    if (value && value.type === \"string\") {\n      return right => traversePlain(base => ({\n        type: \"AccessAttribute\",\n        base,\n        name: value.data\n      }), right);\n    }\n    return right => traverseArray(base => ({\n      type: \"Filter\",\n      base,\n      expr\n    }), right);\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    const leftValue = tryConstantEvaluate(left);\n    const rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    }\n    return rhs => traverseArray(base => ({\n      type: \"Slice\",\n      base,\n      left: leftValue.data,\n      right: rightValue.data,\n      isInclusive\n    }), rhs);\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return right => traverseProjection(base => ({\n      type: \"Projection\",\n      base,\n      expr: obj\n    }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return right => traversePlain(base => ({\n      type: \"AccessAttribute\",\n      base,\n      name\n    }), right);\n  },\n  deref(p) {\n    let attr = null;\n    if (p.getMark().name === \"deref_attr\") {\n      p.shift();\n      attr = p.processString();\n    }\n    const wrap = base => attr ? {\n      type: \"AccessAttribute\",\n      base,\n      name: attr\n    } : base;\n    return right => traversePlain(base => wrap({\n      type: \"Deref\",\n      base\n    }), right);\n  },\n  array_postfix(p) {\n    return right => traverseArray(base => ({\n      type: \"ArrayCoerce\",\n      base\n    }), right);\n  }\n};\nconst SELECTOR_BUILDER = {\n  group(p) {\n    p.process(SELECTOR_BUILDER);\n    return null;\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    p.process(SELECTOR_BUILDER);\n    while (p.getMark().name !== \"traversal_end\") {\n      p.process(TRAVERSE_BUILDER);\n    }\n    p.shift();\n    return null;\n  },\n  this_attr(p) {\n    p.processString();\n    return null;\n  },\n  neg(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1) return null;\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param(p) {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base) {\n    return node.name;\n  }\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n    return extractPropertyKey(node.base);\n  }\n  throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity === \"number\") {\n    if (count !== arity) {\n      throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n    }\n  }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(\"Syntax error in GROQ query at position \".concat(position));\n    __publicField(this, \"position\");\n    __publicField(this, \"name\", \"GroqSyntaxError\");\n    this.position = position;\n  }\n}\nfunction parse(input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = parse$1(input);\n  if (result.type === \"error\") {\n    throw new GroqSyntaxError(result.position);\n  }\n  const processor = new MarkProcessor(input, result.marks, options);\n  return processor.process(EXPR_BUILDER);\n}\nexports.evaluate = evaluateQuery;\nexports.parse = parse;\n//# sourceMappingURL=1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEMsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmV5bWF0dGVyLXYyLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLmpzP2MwZjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfX2RlZlByb3AkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNShvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpIHtcbiAgICBpZiAocGFydCA9PT0gXCIqXCIpIHtcbiAgICAgIHJlLnB1c2goXCJbXi5dK1wiKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiKipcIikge1xuICAgICAgcmUucHVzaChcIi4qXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChyZS5qb2luKFwiLlwiKSwgXCIkXCIpKTtcbn1cbmNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ1KHRoaXMsIFwicGF0dGVyblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuUmVcIik7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG52YXIgX19kZWZQcm9wJDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDQob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQ0KG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidHlwZVwiLCBcInN0cmVhbVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJnZW5lcmF0b3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidGlja2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImlzRG9uZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJkYXRhXCIpO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcykge1xuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQgdGhpcy5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHRpY2soKTtcbiAgICB9O1xuICAgIHNldHVwVGlja2VyKCk7XG4gICAgZmV0Y2goKTtcbiAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNvbnN0IFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gIGlmIChSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xuICBjb25zdCBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpO1xuICBjb25zdCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMik7XG4gIGNvbnN0IGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpO1xuICBjb25zdCBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBjb25zdCBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICBpZiAobWlsbGlzICE9IDApIHtcbiAgICBmcmFjdGlvbmFsU2Vjb25kID0gXCIuXCIuY29uY2F0KGFkZExlYWRpbmdaZXJvKG1pbGxpcywgMykpO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdCh5ZWFyLCBcIi1cIikuY29uY2F0KG1vbnRoLCBcIi1cIikuY29uY2F0KGRheSwgXCJUXCIpLmNvbmNhdChob3VyLCBcIjpcIikuY29uY2F0KG1pbnV0ZSwgXCI6XCIpLmNvbmNhdChzZWNvbmQpLmNvbmNhdChmcmFjdGlvbmFsU2Vjb25kLCBcIlpcIik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgc3RyID0gXCIwXCIuY29uY2F0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDMob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU3RhdGljVmFsdWUge1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGF0YVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJ0eXBlXCIpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb3ZlcjogXCIuY29uY2F0KHRoaXMudHlwZSkpO1xuICB9XG59XG5jb25zdCBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsIFwibnVsbFwiKTtcbmNvbnN0IFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUodHJ1ZSwgXCJib29sZWFuXCIpO1xuY29uc3QgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGVcIik7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gIGlmIChpc0l0ZXJhdG9yKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHZhbCkge1xuICAgICAgICB5aWVsZCBmcm9tSlModmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICByZXR1cm4gXCJwYXRoXCI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSkge1xuICAgIHJldHVybiBcImRhdGV0aW1lXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBkYXRhO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgfVxuICBpZiAoYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG5jb25zdCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmNvbnN0IE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5zLmV2ZXJ5KHBhdHRlcm4gPT4gcGF0dGVybih0b2tlbnMpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICBjb25zdCB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XG4gIHJldHVybiB0ZXJtc1JlLm1hcChyZSA9PiB0b2tlbnMgPT4gdG9rZW5zLnNvbWUodG9rZW4gPT4gcmUudGVzdCh0b2tlbikpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgY29uc3QgdGVybXMgPSB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XG4gIHJldHVybiB0ZXJtcy5tYXAodGVybSA9PiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdCh0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIiksIFwiJFwiKSwgXCJpXCIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2IodmFsdWUuZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpIHtcbiAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2IocGFydC5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgVFlQRV9PUkRFUiA9IHtcbiAgZGF0ZXRpbWU6IDEsXG4gIG51bWJlcjogMixcbiAgc3RyaW5nOiAzLFxuICBib29sZWFuOiA0XG59O1xuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvdGFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBjb25zdCBhVHlwZU9yZGVyID0gVFlQRV9PUkRFUlthVHlwZV0gfHwgMTAwO1xuICBjb25zdCBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xuICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcikge1xuICAgIHJldHVybiBhVHlwZU9yZGVyIC0gYlR5cGVPcmRlcjtcbiAgfVxuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIj49XCI6IGZ1bmN0aW9uIGd0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjxcIjogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBhc3luYyBmdW5jdGlvbiBpbm9wKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwicGF0aFwiKSB7XG4gICAgICBpZiAobGVmdC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0LmRhdGEubWF0Y2hlcyhsZWZ0LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAocmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgcmlnaHQpIHtcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpIHtcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgbWF0Y2g6IGFzeW5jIGZ1bmN0aW9uIG1hdGNoKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGxldCBwYXR0ZXJucyA9IFtdO1xuICAgIGF3YWl0IGdhdGhlclRleHQobGVmdCwgcGFydCA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCBwYXJ0ID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pO1xuICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgIHJldHVybiBtYXRjaGVkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIitcIjogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMoe1xuICAgICAgICAuLi5sZWZ0LmRhdGEsXG4gICAgICAgIC4uLnJpZ2h0LmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICByZXR1cm4gZnJvbUpTKGxlZnQuZGF0YS5jb25jYXQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCItXCI6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXG4gIFwiL1wiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgLyBiKSxcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQyKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFNjb3BlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwYXJhbXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwic291cmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInZhbHVlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJjb250ZXh0XCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImlzSGlkZGVuXCIsIGZhbHNlKTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMucGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZUhpZGRlbih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICByZXN1bHQuaXNIaWRkZW4gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlKSB7XG4gIGxldCBleGVjdXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBldmFsdWF0ZTtcbiAgY29uc3QgZnVuYyA9IEVYRUNVVE9SU1tub2RlLnR5cGVdO1xuICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG5mdW5jdGlvbiBwcm9taXNlbGVzc0FwcGx5KHZhbHVlLCBjYikge1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudGhlbihjYik7XG4gIH1cbiAgcmV0dXJuIGNiKHZhbHVlKTtcbn1cbmNvbnN0IEVYRUNVVE9SUyA9IHtcbiAgVGhpcyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgfSxcbiAgU2VsZWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgfSxcbiAgUGFyYW1ldGVyKF9yZWYsIHNjb3BlKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gIH0sXG4gIENvbnRleHQoX3JlZjIsIHNjb3BlKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleVxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAoa2V5ID09PSBcImJlZm9yZVwiIHx8IGtleSA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNjb3BlLmNvbnRleHRba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRleHQga2V5OiBcIi5jb25jYXQoa2V5KSk7XG4gIH0sXG4gIFBhcmVudChfcmVmMywgc2NvcGUpIHtcbiAgICBsZXQge1xuICAgICAgblxuICAgIH0gPSBfcmVmMztcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgfSxcbiAgT3BDYWxsKF9yZWY0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBvcCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmNDtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3I6IFwiLmNvbmNhdChvcCkpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChcInRoZW5cIiBpbiBsZWZ0VmFsdWUgfHwgXCJ0aGVuXCIgaW4gcmlnaHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiBmdW5jKGF3YWl0IGxlZnRWYWx1ZSwgYXdhaXQgcmlnaHRWYWx1ZSkpKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gIH0sXG4gIGFzeW5jIFNlbGVjdChfcmVmNSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYWx0ZXJuYXRpdmVzLFxuICAgICAgZmFsbGJhY2tcbiAgICB9ID0gX3JlZjU7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoX3JlZjYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0gPSBfcmVmNjtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoX3JlZjcsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWY3O1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoZXhwclZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhc3luYyBQcm9qZWN0aW9uKF9yZWY4LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgZXhwclxuICAgIH0gPSBfcmVmODtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgIHJldHVybiBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgfSxcbiAgRnVuY0NhbGwoX3JlZjksIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGZ1bmMsXG4gICAgICBhcmdzXG4gICAgfSA9IF9yZWY5O1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKF9yZWYxMCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBhcmdzXG4gICAgfSA9IF9yZWYxMDtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzQXR0cmlidXRlKF9yZWYxMSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjExO1xuICAgIGxldCB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgIGlmIChiYXNlKSB7XG4gICAgICB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0VsZW1lbnQoX3JlZjEyLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgaW5kZXhcbiAgICB9ID0gX3JlZjEyO1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgY29uc3QgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICB9LFxuICBhc3luYyBTbGljZShfcmVmMTMsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0gPSBfcmVmMTM7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmlnaHRJZHgrKztcbiAgICB9XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKGFycmF5LnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKF9yZWYxNCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMTQ7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHtcbiAgICAgICAgX3JlZjogaWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoX3JlZjE1KSB7XG4gICAgbGV0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWYxNTtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoX3JlZjE2LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYxNjtcbiAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gIH0sXG4gIGFzeW5jIE9iamVjdChfcmVmMTcsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gX3JlZjE3O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIuY29uY2F0KGF0dHJUeXBlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcbiAgfSxcbiAgQXJyYXkoX3JlZjE4LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBfcmVmMTg7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcihfcmVmMTksIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmMTk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFuZChfcmVmMjAsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmMjA7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE5vdChfcmVmMjEsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjIxO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyhfcmVmMjIsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjIyO1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCB2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgUG9zKF9yZWYyMywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMjM7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIHZhbHVlID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgfSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoX3JlZjI0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYyNDtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE1hcChfcmVmMjUsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWYyNTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcChfcmVmMjYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWYyNjtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5uZXIgb2YgaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgY29uc3QgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgLi4ub3B0aW9ucy5wYXJhbXNcbiAgfTtcbiAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUocGFyYW1zLCBkYXRhc2V0LCByb290LCB7XG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCAvKiBAX19QVVJFX18gKi9uZXcgRGF0ZSgpLFxuICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbCxcbiAgICBkZXJlZmVyZW5jZTogb3B0aW9ucy5kZXJlZmVyZW5jZVxuICB9LCBudWxsKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5sZWZ0KSAmJiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBEVU1NWV9TQ09QRSA9IG5ldyBTY29wZSh7fSwgTlVMTF9WQUxVRSwgTlVMTF9WQUxVRSwge1xuICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqL25ldyBEYXRlKDApLFxuICBpZGVudGl0eTogXCJtZVwiLFxuICBiZWZvcmU6IG51bGwsXG4gIGFmdGVyOiBudWxsXG59LCBudWxsKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBpZiAoIWNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY29uc3RhbnRFdmFsdWF0ZShub2RlKTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5hc3luYyBmdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBjb25zdCB0ZXh0cyA9IGF3YWl0IGFycmF5VGV4dCh2YWx1ZSk7XG4gICAgaWYgKHRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSkge1xuICBsZXQgcmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSkge1xuICAgIGlmIChibG9jay50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYmxvY2tUZXh0KGJsb2NrLmRhdGEpO1xuICAgICAgaWYgKHRleHQgIT09IG51bGwpIHJlc3VsdC5wdXNoKHRleHQpO1xuICAgIH0gZWxzZSBpZiAoYmxvY2suaXNBcnJheSgpKSB7XG4gICAgICBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHJldHVybiBudWxsO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNoaWxkLl90eXBlID09PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0ICs9IGNoaWxkLnRleHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBub2RlLm5hbWUgPT09IFwiYm9vc3RcIikge1xuICAgIGNvbnN0IGlubmVyU2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgIGNvbnN0IGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAoYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCkge1xuICAgICAgcmV0dXJuIGlubmVyU2NvcmUgKyBib29zdC5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOlxuICAgICAge1xuICAgICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgICAgfVxuICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBpZiAobGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDApIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlKG5vZGUsIHNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgY29uc3QgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgdGVybXMgPSBbXTtcbiAgYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCBwYXJ0ID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KTtcbiAgY29uc3QgZGlkU3VjY2VlZCA9IGF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgcGFydCA9PiB7XG4gICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xuICB9KTtcbiAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IHNjb3JlID0gMDtcbiAgZm9yIChjb25zdCByZSBvZiB0ZXJtcykge1xuICAgIGNvbnN0IGZyZXEgPSB0b2tlbnMucmVkdWNlKChjLCB0b2tlbikgPT4gYyArIChyZS50ZXN0KHRva2VuKSA/IDEgOiAwKSwgMCk7XG4gICAgc2NvcmUgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XG4gIH1cbiAgcmV0dXJuIHNjb3JlO1xufVxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XG4gIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50VVRGOChzdHIpIHtcbiAgbGV0IGNvdW50MiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb3VudDIrKztcbiAgfVxuICByZXR1cm4gY291bnQyO1xufVxuY29uc3QgX2dsb2JhbCA9IHt9O1xuX2dsb2JhbC5hbnl3aGVyZSA9IGFzeW5jIGZ1bmN0aW9uIGFueXdoZXJlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuX2dsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgIG51bSsrO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIH1cbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgICAgbnVtKys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gYXN5bmMgZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XG59O1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24gc3RyaW5nKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiXCIuY29uY2F0KHZhbHVlLmRhdGEpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5fZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbiByZWZlcmVuY2VzKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHBhdGhTZXQgPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCBwYXRoMiA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHBhdGgyLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhdGhTZXQuYWRkKHBhdGgyLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGF0aDIuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgcGF0aDIpIHtcbiAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfVxuICBjb25zdCBzY29wZVZhbHVlID0gYXdhaXQgc2NvcGUudmFsdWUuZ2V0KCk7XG4gIHJldHVybiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG59O1xuX2dsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gYyA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24gcm91bmQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICB9XG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKTtcbiAgfVxuICByZXR1cm4gZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcbn07XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gY291bnQyID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xuX2dsb2JhbC5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XG59O1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uIGJvb3N0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59O1xuX2dsb2JhbC5ib29zdC5hcml0eSA9IDI7XG5jb25zdCBzdHJpbmcyID0ge307XG5zdHJpbmcyLmxvd2VyID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChzZXAudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGlmIChzdHIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbUpTKFtdKTtcbiAgfVxuICBpZiAoc2VwLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhzdHIuZGF0YS5zcGxpdChzZXAuZGF0YSkpO1xufTtcbnN0cmluZzIuc3BsaXQuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZzIubG93ZXI7XG5fZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbnN0cmluZzIuc3RhcnRzV2l0aCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChwcmVmaXgudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBzdHIuZGF0YS5zdGFydHNXaXRoKHByZWZpeC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5zdHJpbmcyLnN0YXJ0c1dpdGguYXJpdHkgPSAyO1xuY29uc3QgYXJyYXkgPSB7fTtcbmFycmF5LmpvaW4gPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgYnVmID0gXCJcIjtcbiAgbGV0IG5lZWRTZXAgPSBmYWxzZTtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChuZWVkU2VwKSB7XG4gICAgICBidWYgKz0gc2VwLmRhdGE7XG4gICAgfVxuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGJ1ZiArPSBcIlwiLmNvbmNhdChlbGVtLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuZWVkU2VwID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LmNvbXBhY3QuYXJpdHkgPSAxO1xuYXJyYXkudW5pcXVlID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChpdGVyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGlmICghYWRkZWQuaGFzKGl0ZXIuZGF0YSkpIHtcbiAgICAgICAgICAgIGFkZGVkLmFkZChpdGVyLmRhdGEpO1xuICAgICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSk7XG4gIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodGV4dCk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24gb3JkZXIoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgYXdhaXQgdHJ1ZTtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG1hcHBlcnMgPSBbXTtcbiAgY29uc3QgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgaWYgKG1hcHBlci50eXBlID09PSBcIkRlc2NcIikge1xuICAgICAgZGlyZWN0aW9uID0gXCJkZXNjXCI7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlci50eXBlID09PSBcIkFzY1wiKSB7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9XG4gICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG4gICAgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIGNvbnN0IHR1cGxlID0gW2F3YWl0IHZhbHVlLmdldCgpLCBpZHhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICB9XG4gICAgYXV4LnB1c2godHVwbGUpO1xuICAgIGlkeCsrO1xuICB9XG4gIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIikge1xuICAgICAgICBjID0gLWM7XG4gICAgICB9XG4gICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSk7XG4gIHJldHVybiBmcm9tSlMoYXV4Lm1hcCh2ID0+IHZbMF0pKTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gY291bnQyID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCB1bmtub3duID0gW107XG4gIGNvbnN0IHNjb3JlZCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7XG4gICAgICBfc2NvcmU6IHZhbHVlU2NvcmVcbiAgICB9KTtcbiAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICB9XG4gIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKTtcbiAgcmV0dXJuIGZyb21KUyhzY29yZWQpO1xufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSBjb3VudDIgPT4gY291bnQyID49IDE7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbiA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAoZWxlbS50eXBlID09PSBcIm51bGxcIikgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG4gKz0gZWxlbS5kYXRhO1xuICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5zdW0uYXJpdHkgPSAxO1xubWF0aC5hdmcgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuID0gMDtcbiAgbGV0IGMgPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuICs9IGVsZW0uZGF0YTtcbiAgICBjKys7XG4gIH1cbiAgaWYgKGMgPT09IDApIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKG4gLyBjKTtcbn07XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoXG59O1xudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3RyaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hcmtzXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImluZGV4XCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInBhcnNlT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhbGxvd0Jvb3N0XCIsIGZhbHNlKTtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gIH1cbiAgaGFzTWFyaygpIHtcbiAgICBsZXQgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyaygpIHtcbiAgICBsZXQgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFuZGxlcjogXCIuY29uY2F0KG1hcmsubmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nRW5kKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuY29uc3QgV1MgPSAvXihbXFx0XFxuXFx2XFxmXFxyIFxcdTAwODVcXHUwMEEwXXwoXFwvXFwvW15cXG5dKlxcbikpKy87XG5jb25zdCBOVU0gPSAvXlxcZCsvO1xuY29uc3QgSURFTlQgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSovO1xuY29uc3QgUFJFQ19QQUlSID0gMTtcbmNvbnN0IFBSRUNfT1IgPSAyO1xuY29uc3QgUFJFQ19BTkQgPSAzO1xuY29uc3QgUFJFQ19DT01QID0gNDtcbmNvbnN0IFBSRUNfT1JERVIgPSA0O1xuY29uc3QgUFJFQ19BREQgPSA2O1xuY29uc3QgUFJFQ19TVUIgPSA2O1xuY29uc3QgUFJFQ19NVUwgPSA3O1xuY29uc3QgUFJFQ19ESVYgPSA3O1xuY29uc3QgUFJFQ19NT0QgPSA3O1xuY29uc3QgUFJFQ19QT1cgPSA4O1xuY29uc3QgUFJFQ19QT1MgPSAxMDtcbmNvbnN0IFBSRUNfTk9UID0gMTA7XG5jb25zdCBQUkVDX05FRyA9IDg7XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwicG9zXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwibmVnXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCIoXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInR1cGxlX2VuZFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJncm91cFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiIVwiOlxuICAgICAge1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgICBuYW1lOiBcIm5vdFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwie1wiOlxuICAgICAge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgbmFtZTogXCJhcnJheVwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9XTtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYXJyYXlfc3BsYXRcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByZXMucG9zaXRpb247XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJhcnJheV9lbmRcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6XG4gICAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiXlwiOlxuICAgICAge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImRibHBhcmVudFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJwYXJlbnRcIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7XG4gICAgICAgIG5hbWU6IFwidGhpc1wiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgbWFya3MgPSBbe1xuICAgICAgICBuYW1lOiBcImV2ZXJ5dGhpbmdcIixcbiAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICB9XTtcbiAgICAgIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICBuYW1lOiBcInBhcmFtXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3MgKyAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgaWYgKG51bUxlbikge1xuICAgICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgICAgaWYgKGZyYWNMZW4pIHtcbiAgICAgICAgICAgICAgbmFtZSA9IFwiZmxvYXRcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDEgKyBmcmFjTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgICAgbmFtZSA9IFwic2NpXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgKyBcIl9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJ0aGlzX2F0dHJcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIGxldCBsaHNMZXZlbCA9IDEyO1xuICBsZXQgdHJhdjtcbiAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgcG9zID0gaW5uZXJQb3M7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpO1xuICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgbmFtZTogXCJ0cmF2ZXJzZVwiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH0pO1xuICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHRyYXYucG9zaXRpb247XG4gICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgIG5hbWU6IFwidHJhdmVyc2FsX2VuZFwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgdG9rZW4yID0gc3RyW2lubmVyUG9zXTtcbiAgICBzd2l0Y2ggKHRva2VuMikge1xuICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCBuZXh0VG9rZW4gPSBzdHJbaW5uZXJQb3MgKyAxXTtcbiAgICAgICAgICBzd2l0Y2ggKG5leHRUb2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfUEFJUik7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGFpclwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvcyArIDJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImFkZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcInN1YlwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVykgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzMjtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwicG93XCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMyLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BPVztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01VTCB8fCBsaHNMZXZlbCA8IFBSRUNfTVVMKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01VTCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcIm11bFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NVUw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0RJViB8fCBsaHNMZXZlbCA8IFBSRUNfRElWKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0RJViArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19ESVY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01PRCB8fCBsaHNMZXZlbCA8IFBSRUNfTU9EKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01PRCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcIm1vZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NT0Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgICBpZiAoc3RyW25leHRQb3NdID09PSBcIj1cIikge1xuICAgICAgICAgICAgbmV4dFBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BfZW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogbmV4dFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwifFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1IpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19PUiArIDEpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwib3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBpcGVjYWxsXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiJlwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQU5EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiYW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FORDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDwgUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiY29tcFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgMlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImRlc2NcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgNDtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKSBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJhc2NcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgMztcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgaWRlbnQgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKTtcbiAgICAgICAgICBzd2l0Y2ggKGlkZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcbiAgICAgICAgICAgICAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW5fcmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJhbmdlUG9zXG4gICAgICAgICAgICAgICAgICB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3MgKyAyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3BcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3BfZW5kXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3MgKyA1XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZmFpbFBvc2l0aW9uID0gKHRyYXYgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYXYudHlwZSkgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgZmFpbFBvc2l0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOlxuICAgICAge1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3M7XG4gICAgICAgIGxldCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICAgIGlmICghaWRlbnRMZW4yKSByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH07XG4gICAgICAgIHBvcyArPSBpZGVudExlbjI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImF0dHJfYWNjZXNzXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogaWRlbnRTdGFydFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIikgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgICAgbGV0IG1hcmtzID0gW3tcbiAgICAgICAgbmFtZTogXCJkZXJlZlwiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJkZXJlZl9hdHRyXCIsXG4gICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIHtcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBtYXJrczogW3tcbiAgICAgICAgICAgICAgbmFtZTogXCJhcnJheV9wb3N0Zml4XCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlUG9zID0gcG9zO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSBcIi5cIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwic2xpY2VcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG5hbWU6IHR5cGUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByYW5nZVBvc1xuICAgICAgICAgICAgfV0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJ8XCI6XG4gICAgICB7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcInByb2plY3Rpb25cIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIntcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICBuYW1lOiBcInByb2plY3Rpb25cIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW107XG4gIG1hcmtzLnB1c2goe1xuICAgIG5hbWU6IFwiZnVuY19jYWxsXCIsXG4gICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gIH0pO1xuICBpZiAoc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHtcbiAgICAgIG5hbWU6IFwibmFtZXNwYWNlXCIsXG4gICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICB9KTtcbiAgICBtYXJrcy5wdXNoKHtcbiAgICAgIG5hbWU6IFwiaWRlbnRcIixcbiAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuXG4gICAgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgbmFtZUxlbik7XG4gICAgaWYgKHN0cltwb3NdICE9PSBcIihcIikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICAgIHBvcysrO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIH0gZWxzZSB7XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIilcIikgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gIH1cbiAgbWFya3MucHVzaCh7XG4gICAgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsXG4gICAgcG9zaXRpb246IGxhc3RQb3NcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7XG4gICAgbmFtZTogXCJvYmplY3RcIixcbiAgICBwb3NpdGlvbjogcG9zXG4gIH1dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgd2hpbGUgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGV4cHI7XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsXG4gICAgICAgICAgcG9zaXRpb246IHBhaXJQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpO1xuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwYWlyUG9zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwib2JqZWN0X3BhaXJcIixcbiAgICAgICAgICBwb3NpdGlvbjogcGFpclBvc1xuICAgICAgICB9KTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcywgdmFsdWUubWFya3MpO1xuICAgICAgICBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHtcbiAgICAgICAgICBuYW1lOiBcIm9iamVjdF9leHByXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9LCBleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICBpZiAoc3RyW3Bvc10gIT09IFwifVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIHBvcysrO1xuICBtYXJrcy5wdXNoKHtcbiAgICBuYW1lOiBcIm9iamVjdF9lbmRcIixcbiAgICBwb3NpdGlvbjogcG9zXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7XG4gICAgbmFtZTogXCJzdHJcIixcbiAgICBwb3NpdGlvbjogcG9zXG4gIH1dO1xuICBzdHI6IGZvciAoOzsgcG9zKyspIHtcbiAgICBpZiAocG9zID4gc3RyLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgIGNhc2UgdG9rZW46XG4gICAgICAgIHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyX2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGJyZWFrIHN0cjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAge1xuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJzdHJfcGF1c2VcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSBcInVcIikge1xuICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ1bmljb2RlX2hleFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgNlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJzdHJfc3RhcnRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zXG4gIH07XG59XG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gYmFzZSA9PiBiKGEoYmFzZSkpO1xufVxuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gIHJldHVybiBiYXNlID0+ICh7XG4gICAgdHlwZTogXCJNYXBcIixcbiAgICBiYXNlLFxuICAgIGV4cHI6IGlubmVyKHtcbiAgICAgIHR5cGU6IFwiVGhpc1wiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiBiYXNlID0+ICh7XG4gICAgdHlwZTogXCJGbGF0TWFwXCIsXG4gICAgYmFzZSxcbiAgICBleHByOiBpbm5lcih7XG4gICAgICB0eXBlOiBcIlRoaXNcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQobWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xuICBcIidcIjogXCInXCIsXG4gICdcIic6ICdcIicsXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgXCIvXCI6IFwiL1wiLFxuICBiOiBcIlxcYlwiLFxuICBmOiBcIlxcZlwiLFxuICBuOiBcIlxcblwiLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlx0XCJcbn07XG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVF1ZXJ5RXJyb3JcIik7XG4gIH1cbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIGNvbnN0IGlubmVyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgIGJhc2U6IGlubmVyXG4gICAgfTtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJFdmVyeXRoaW5nXCJcbiAgICB9O1xuICB9LFxuICB0aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlRoaXNcIlxuICAgIH07XG4gIH0sXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IDFcbiAgICB9O1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIGNvbnN0IG5leHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IG5leHQubiArIDFcbiAgICB9O1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHRyYXZlcnNhbExpc3QgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCIpIHtcbiAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IHRyYXZlcnNhbCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IHRyYXZlcnNhbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNhbExpc3RbaV0odHJhdmVyc2FsKTtcbiAgICB9XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJFdmVyeXRoaW5nXCIgfHwgYmFzZS50eXBlID09PSBcIkFycmF5XCIgfHwgYmFzZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiKSB7XG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KHZhbCA9PiB2YWwsIHRyYXZlcnNhbCk7XG4gICAgfVxuICAgIGlmICh0cmF2ZXJzYWwgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkJVRzogdW5leHBlY3RlZCBlbXB0eSB0cmF2ZXJzYWxcIik7XG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWUgPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOZWdcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb3NcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiK1wiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgc3ViKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi1cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG11bChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiL1wiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbW9kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIiVcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IG9wID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkluUmFuZ2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH07XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBsb29wOiB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgdmFsdWUgKz0gRVNDQVBFX1NFUVVFTkNFW2NoYXJdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwidW5pY29kZV9oZXhcIjpcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG1hcms6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBzY2kocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIikge1xuICAgICAgbGV0IGlzU3BsYXQgPSBmYWxzZTtcbiAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIpIHtcbiAgICAgICAgaXNTcGxhdCA9IHRydWU7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXJyYXlcIixcbiAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0dXBsZV9lbmRcIikge1xuICAgICAgbWVtYmVycy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlR1cGxlXCIsXG4gICAgICBtZW1iZXJzXG4gICAgfTtcbiAgfSxcbiAgZnVuY19jYWxsKHApIHtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgfTtcbiAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgaWYgKGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIG5hbWUsIGFyZ3MubGVuZ3RoKSkge1xuICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgIGFyZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJTZWxlY3RvclwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSkge1xuICAgICAgaWYgKHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICAgIGtleTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0XCIpO1xuICAgIGNvbnN0IGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xuICAgIGlmICghZnVuY3MpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlICE9PSBcImdsb2JhbFwiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgY29uc3Qgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICBpZiAobmFtZSA9PT0gXCJzY29yZVwiKSB7XG4gICAgICBwLmFsbG93Qm9vc3QgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICBpZiAobWFya05hbWUgPT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwib3JkZXJcIikge1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgYXJncy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiQXNjXCIsXG4gICAgICAgICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBhcmdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJEZXNjXCIsXG4gICAgICAgICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgPT5cIik7XG4gIH0sXG4gIGFuZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQW5kXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBvcihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3JcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5vdFwiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIGFzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhc2NcIik7XG4gIH0sXG4gIGRlc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgZGVzY1wiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAocC5wYXJzZU9wdGlvbnMucGFyYW1zICYmIHAucGFyc2VPcHRpb25zLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJhbWV0ZXJcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9XG59O1xuY29uc3QgT0JKRUNUX0JVSUxERVIgPSB7XG4gIG9iamVjdF9leHByKHApIHtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgY29uc3QgdmFsdWUyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcbiAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBleHRyYWN0UHJvcGVydHlLZXkodmFsdWUpLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3RfcGFpcihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGlmIChuYW1lLnR5cGUgIT09IFwiVmFsdWVcIikgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXQocCkge1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwiVGhpc1wiXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IFRSQVZFUlNFX0JVSUxERVIgPSB7XG4gIHNxdWFyZV9icmFja2V0KHApIHtcbiAgICBjb25zdCBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VFbGVtZW50KGJhc2UgPT4gKHtcbiAgICAgICAgdHlwZTogXCJBY2Nlc3NFbGVtZW50XCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGluZGV4OiB2YWx1ZS5kYXRhXG4gICAgICB9KSwgcmlnaHQpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlUGxhaW4oYmFzZSA9PiAoe1xuICAgICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBuYW1lOiB2YWx1ZS5kYXRhXG4gICAgICB9KSwgcmlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VBcnJheShiYXNlID0+ICh7XG4gICAgICB0eXBlOiBcIkZpbHRlclwiLFxuICAgICAgYmFzZSxcbiAgICAgIGV4cHJcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBzbGljZShwKSB7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcbiAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInNsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJocyA9PiB0cmF2ZXJzZUFycmF5KGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0pLCByaHMpO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgYmFzZSxcbiAgICAgIGV4cHI6IG9ialxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIGF0dHJfYWNjZXNzKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlUGxhaW4oYmFzZSA9PiAoe1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgZGVyZWYocCkge1xuICAgIGxldCBhdHRyID0gbnVsbDtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJkZXJlZl9hdHRyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGF0dHIgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcCA9IGJhc2UgPT4gYXR0ciA/IHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZTogYXR0clxuICAgIH0gOiBiYXNlO1xuICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZVBsYWluKGJhc2UgPT4gd3JhcCh7XG4gICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICBiYXNlXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXJyYXlfcG9zdGZpeChwKSB7XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlQXJyYXkoYmFzZSA9PiAoe1xuICAgICAgdHlwZTogXCJBcnJheUNvZXJjZVwiLFxuICAgICAgYmFzZVxuICAgIH0pLCByaWdodCk7XG4gIH1cbn07XG5jb25zdCBTRUxFQ1RPUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0aGlzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiKSB7XG4gICAgICBwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUik7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3ViKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbW9kKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGluX3JhbmdlKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZ1bmNfY2FsbChwLCBtYXJrKSB7XG4gICAgY29uc3QgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgaWYgKGZ1bmMubmFtZSA9PT0gXCJhbnl3aGVyZVwiICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRlc2MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIkFjY2Vzc0F0dHJpYnV0ZVwiICYmICFub2RlLmJhc2UpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIikge1xuICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgfVxuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHByb3BlcnR5IGtleSBmb3IgdHlwZTogXCIuY29uY2F0KG5vZGUudHlwZSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChjb3VudCAhPT0gYXJpdHkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLiBFeHBlY3RlZCBcIikuY29uY2F0KGFyaXR5LCBcIiwgZ290IFwiKS5jb25jYXQoY291bnQsIFwiLlwiKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyaXR5KSB7XG4gICAgaWYgKCFhcml0eShjb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLlwiKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gIGNvbnN0IGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFtcImNoYW5nZWRBbnlcIiwgXCJjaGFuZ2VkT25seVwiXTtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PSBcImRpZmZcIiAmJiBhcmdDb3VudCA9PSAyICYmIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycy5pbmNsdWRlcyhmdW5jdGlvbk5hbWUpO1xufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKFwiU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gXCIuY29uY2F0KHBvc2l0aW9uKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVN5bnRheEVycm9yXCIpO1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IoaW5wdXQsIHJlc3VsdC5tYXJrcywgb3B0aW9ucyk7XG4gIHJldHVybiBwcm9jZXNzb3IucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xufVxuZXhwb3J0cy5ldmFsdWF0ZSA9IGV2YWx1YXRlUXVlcnk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD0xLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/groq-js/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/groq-js/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _1 = __webpack_require__(/*! ./1.js */ \"(ssr)/./node_modules/groq-js/dist/1.js\");\nexports.evaluate = _1.evaluate;\nexports.parse = _1.parse;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLFNBQVMsbUJBQU8sQ0FBQyxzREFBUTtBQUN6QixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvaW5kZXguanM/M2FjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF8xID0gcmVxdWlyZSgnLi8xLmpzJyk7XG5leHBvcnRzLmV2YWx1YXRlID0gXzEuZXZhbHVhdGU7XG5leHBvcnRzLnBhcnNlID0gXzEucGFyc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/index.js\n");

/***/ })

};
;