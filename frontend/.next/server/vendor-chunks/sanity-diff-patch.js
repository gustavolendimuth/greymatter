"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar diffMatchPatch = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.cjs\");\nfunction pathToString(path) {\n  return path.reduce((target, segment, i) => {\n    if (Array.isArray(segment)) {\n      return \"\".concat(target, \"[\").concat(segment.join(\":\"), \"]\");\n    }\n    if (isKeyedObject(segment)) {\n      return \"\".concat(target, \"[_key==\\\"\").concat(segment._key, \"\\\"]\");\n    }\n    if (typeof segment === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    } else if (typeof segment === \"string\" && /^\\d+$/.test(segment)) {\n      return \"\".concat(target, \"[\\\"\").concat(segment, \"\\\"]\");\n    }\n    if (typeof segment === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    throw new Error(\"Unsupported path segment \\\"\".concat(segment, \"\\\"\"));\n  }, \"\");\n}\nfunction isKeyedObject(obj) {\n  return typeof obj === \"object\" && typeof obj._key === \"string\";\n}\nclass DiffError extends Error {\n  constructor(message, path, value) {\n    const serializedPath = pathToString(path);\n    super(\"\".concat(message, \" (at '\").concat(serializedPath, \"')\"));\n    this.path = path;\n    this.serializedPath = serializedPath;\n    this.value = value;\n  }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;\nconst propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n  if (!propStartPattern.test(property)) {\n    throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n  }\n  if (!propPattern.test(property)) {\n    throw new DiffError(\"Keys can only contain letters, numbers and underscores\", path.concat(property), value);\n  }\n  if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n    if (typeof value !== \"string\") {\n      throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n    }\n    if (!idPattern.test(value)) {\n      throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n    }\n  }\n  return property;\n}\nconst ignoredKeys = [\"_id\", \"_type\", \"_createdAt\", \"_updatedAt\", \"_rev\"];\nconst defaultOptions = {\n  hideWarnings: false,\n  diffMatchPatch: {\n    enabled: true,\n    // Only use diff-match-patch if target string is longer than this threshold\n    lengthThresholdAbsolute: 30,\n    // Only use generated diff-match-patch if the patch length is less than or equal to\n    // (targetString * relative). Example: A 100 character target with a relative factor\n    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n    // it will fall back to a regular `set` patch.\n    lengthThresholdRelative: 1.2\n  }\n};\nfunction mergeOptions(options) {\n  return {\n    ...defaultOptions,\n    ...options,\n    diffMatchPatch: {\n      ...defaultOptions.diffMatchPatch,\n      ...(options.diffMatchPatch || {})\n    }\n  };\n}\nfunction diffPatch(itemA, itemB, opts) {\n  const options = mergeOptions(opts || {});\n  const id = options.id || itemA._id === itemB._id && itemA._id;\n  const revisionLocked = options.ifRevisionID;\n  const ifRevisionID = typeof revisionLocked === \"boolean\" ? itemA._rev : revisionLocked;\n  const basePath = options.basePath || [];\n  if (!id) {\n    throw new Error(\"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\");\n  }\n  if (revisionLocked === true && !ifRevisionID) {\n    throw new Error(\"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\");\n  }\n  if (basePath.length === 0 && itemA._type !== itemB._type) {\n    throw new Error(\"_type is immutable and cannot be changed (\".concat(itemA._type, \" => \").concat(itemB._type, \")\"));\n  }\n  const operations = diffItem(itemA, itemB, options, basePath, []);\n  return serializePatches(operations, {\n    id,\n    ifRevisionID: revisionLocked ? ifRevisionID : void 0\n  });\n}\nfunction diffItem(itemA, itemB) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let patches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  if (itemA === itemB) {\n    return patches;\n  }\n  const aType = Array.isArray(itemA) ? \"array\" : typeof itemA;\n  const bType = Array.isArray(itemB) ? \"array\" : typeof itemB;\n  const aIsUndefined = aType === \"undefined\";\n  const bIsUndefined = bType === \"undefined\";\n  if (aIsUndefined && !bIsUndefined) {\n    patches.push({\n      op: \"set\",\n      path,\n      value: itemB\n    });\n    return patches;\n  }\n  if (!aIsUndefined && bIsUndefined) {\n    patches.push({\n      op: \"unset\",\n      path\n    });\n    return patches;\n  }\n  const options = mergeOptions(opts);\n  const dataType = aIsUndefined ? bType : aType;\n  const isContainer = dataType === \"object\" || dataType === \"array\";\n  if (!isContainer) {\n    return diffPrimitive(itemA, itemB, options, path, patches);\n  }\n  if (aType !== bType) {\n    patches.push({\n      op: \"set\",\n      path,\n      value: itemB\n    });\n    return patches;\n  }\n  return dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n  const atRoot = path.length === 0;\n  const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemA[key], path));\n  const aKeysLength = aKeys.length;\n  const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemB[key], path));\n  const bKeysLength = bKeys.length;\n  for (let i = 0; i < aKeysLength; i++) {\n    const key = aKeys[i];\n    if (!(key in itemB)) {\n      patches.push({\n        op: \"unset\",\n        path: path.concat(key)\n      });\n    }\n  }\n  for (let i = 0; i < bKeysLength; i++) {\n    const key = bKeys[i];\n    diffItem(itemA[key], itemB[key], options, path.concat([key]), patches);\n  }\n  return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n  if (itemB.length > itemA.length) {\n    patches.push({\n      op: \"insert\",\n      after: path.concat([-1]),\n      items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path, i, options))\n    });\n  }\n  if (itemB.length < itemA.length) {\n    const isSingle = itemA.length - itemB.length === 1;\n    const unsetItems = itemA.slice(itemB.length);\n    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {\n      patches.push({\n        op: \"unset\",\n        path: path.concat([isSingle ? itemB.length : [itemB.length, \"\"]])\n      });\n    } else {\n      patches.push(...unsetItems.map(item => ({\n        op: \"unset\",\n        path: path.concat({\n          _key: item._key\n        })\n      })));\n    }\n  }\n  for (let i = 0; i < itemB.length; i++) {\n    if (Array.isArray(itemB[i])) {\n      throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n    }\n  }\n  const overlapping = Math.min(itemA.length, itemB.length);\n  const segmentA = itemA.slice(0, overlapping);\n  const segmentB = itemB.slice(0, overlapping);\n  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n  for (let i = 0; i < itemA.length; i++) {\n    diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);\n  }\n  return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n  const keyedA = indexByKey(itemA);\n  const keyedB = indexByKey(itemB);\n  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {\n    return diffArrayByIndex(itemA, itemB, options, path, patches);\n  }\n  for (let i = 0; i < keyedB.keys.length; i++) {\n    const key = keyedB.keys[i];\n    const valueA = keyedA.index[key];\n    const valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n    diffItem(valueA, valueB, options, path.concat({\n      _key: key\n    }), patches);\n  }\n  return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n  const {\n    enabled,\n    lengthThresholdRelative,\n    lengthThresholdAbsolute\n  } = options.diffMatchPatch;\n  const segment = path[path.length - 1];\n  if (!enabled ||\n  // Don't use for anything but strings\n  typeof itemA !== \"string\" || typeof itemB !== \"string\" ||\n  // Don't use for `_key`, `_ref` etc\n  typeof segment === \"string\" && segment[0] === \"_\" ||\n  // Don't use on short strings\n  itemB.length < lengthThresholdAbsolute) {\n    return void 0;\n  }\n  let strPatch = \"\";\n  try {\n    const patch = diffMatchPatch.makeDiff(itemA, itemB);\n    const diff = diffMatchPatch.cleanupEfficiency(patch);\n    strPatch = diffMatchPatch.stringifyPatches(diffMatchPatch.makePatches(diff));\n  } catch (err) {\n    return void 0;\n  }\n  return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {\n    op: \"diffMatchPatch\",\n    path,\n    value: strPatch\n  };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n  const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n  patches.push(dmp || {\n    op: \"set\",\n    path,\n    value: itemB\n  });\n  return patches;\n}\nfunction isNotIgnoredKey(key) {\n  return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n  if (patches.length === 0) {\n    return [];\n  }\n  const {\n    id,\n    ifRevisionID\n  } = options;\n  const set = patches.filter(patch => patch.op === \"set\");\n  const unset = patches.filter(patch => patch.op === \"unset\");\n  const insert = patches.filter(patch => patch.op === \"insert\");\n  const dmp = patches.filter(patch => patch.op === \"diffMatchPatch\");\n  const withSet = set.length > 0 && set.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.set[path] = item.value;\n    return patch;\n  }, {\n    id,\n    set: {}\n  });\n  const withUnset = unset.length > 0 && unset.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.unset.push(path);\n    return patch;\n  }, {\n    id,\n    unset: []\n  });\n  const withInsert = insert.reduce((acc, item) => {\n    const after = pathToString(item.after);\n    return acc.concat({\n      id,\n      insert: {\n        after,\n        items: item.items\n      }\n    });\n  }, []);\n  const withDmp = dmp.length > 0 && dmp.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.diffMatchPatch[path] = item.value;\n    return patch;\n  }, {\n    id,\n    diffMatchPatch: {}\n  });\n  const patchSet = [withSet, withUnset, withDmp, ...withInsert].filter(item => item !== false);\n  return patchSet.map((patch, i) => ({\n    patch: ifRevisionID && i === 0 ? {\n      ...patch,\n      ifRevisionID\n    } : patch\n  }));\n}\nfunction isUniquelyKeyed(arr) {\n  const keys = [];\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i]);\n    if (!key || keys.indexOf(key) !== -1) {\n      return false;\n    }\n    keys.push(key);\n  }\n  return true;\n}\nfunction getKey(obj) {\n  return typeof obj === \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n  return arr.reduce((acc, item) => {\n    acc.keys.push(item._key);\n    acc.index[item._key] = item;\n    return acc;\n  }, {\n    keys: [],\n    index: {}\n  });\n}\nfunction arrayIsEqual(itemA, itemB) {\n  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n  if (typeof item !== \"undefined\") {\n    return item;\n  }\n  if (!options.hideWarnings) {\n    const serializedPath = pathToString(path.concat(index));\n    console.warn(\"undefined value in array converted to null (at '\".concat(serializedPath, \"')\"));\n  }\n  return null;\n}\nfunction isRevisionLocked(options) {\n  return Boolean(options.ifRevisionID);\n}\nfunction yes(_) {\n  return true;\n}\nexports.DiffError = DiffError;\nexports.diffItem = diffItem;\nexports.diffPatch = diffPatch;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCLG1CQUFPLENBQUMsOEZBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9zYW5pdHktZGlmZi1wYXRjaC9kaXN0L2luZGV4LmNqcz82NmNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZGlmZk1hdGNoUGF0Y2ggPSByZXF1aXJlKCdAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2gnKTtcbmZ1bmN0aW9uIHBhdGhUb1N0cmluZyhwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodGFyZ2V0LCBzZWdtZW50LCBpKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQsIFwiW1wiKS5jb25jYXQoc2VnbWVudC5qb2luKFwiOlwiKSwgXCJdXCIpO1xuICAgIH1cbiAgICBpZiAoaXNLZXllZE9iamVjdChzZWdtZW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbX2tleT09XFxcIlwiKS5jb25jYXQoc2VnbWVudC5fa2V5LCBcIlxcXCJdXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQsIFwiW1wiKS5jb25jYXQoc2VnbWVudCwgXCJdXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIgJiYgL15cXGQrJC8udGVzdChzZWdtZW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbXFxcIlwiKS5jb25jYXQoc2VnbWVudCwgXCJcXFwiXVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBzZXBhcmF0b3IgPSBpID09PSAwID8gXCJcIiA6IFwiLlwiO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCkuY29uY2F0KHNlcGFyYXRvcikuY29uY2F0KHNlZ21lbnQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXRoIHNlZ21lbnQgXFxcIlwiLmNvbmNhdChzZWdtZW50LCBcIlxcXCJcIikpO1xuICB9LCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzS2V5ZWRPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmouX2tleSA9PT0gXCJzdHJpbmdcIjtcbn1cbmNsYXNzIERpZmZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgdmFsdWUpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF0aCA9IHBhdGhUb1N0cmluZyhwYXRoKTtcbiAgICBzdXBlcihcIlwiLmNvbmNhdChtZXNzYWdlLCBcIiAoYXQgJ1wiKS5jb25jYXQoc2VyaWFsaXplZFBhdGgsIFwiJylcIikpO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zZXJpYWxpemVkUGF0aCA9IHNlcmlhbGl6ZWRQYXRoO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuY29uc3QgaWRQYXR0ZXJuID0gL15bYS16MC05XVthLXowLTlfLi1dKyQvaTtcbmNvbnN0IHByb3BQYXR0ZXJuID0gL15bYS16QS1aX11bYS16QS1aMC05X10qJC87XG5jb25zdCBwcm9wU3RhcnRQYXR0ZXJuID0gL15bYS16X10vaTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBwYXRoKSB7XG4gIGlmICghcHJvcFN0YXJ0UGF0dGVybi50ZXN0KHByb3BlcnR5KSkge1xuICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJLZXlzIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciAoYS16KVwiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgfVxuICBpZiAoIXByb3BQYXR0ZXJuLnRlc3QocHJvcGVydHkpKSB7XG4gICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIktleXMgY2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzIGFuZCB1bmRlcnNjb3Jlc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgfVxuICBpZiAocHJvcGVydHkgPT09IFwiX2tleVwiIHx8IHByb3BlcnR5ID09PSBcIl9yZWZcIiB8fCBwcm9wZXJ0eSA9PT0gXCJfdHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIktleXMgbXVzdCBiZSBzdHJpbmdzXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWlkUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIkludmFsaWQga2V5IC0gdXNlIGxlc3MgZXhvdGljIGNoYXJhY3RlcnNcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wZXJ0eTtcbn1cbmNvbnN0IGlnbm9yZWRLZXlzID0gW1wiX2lkXCIsIFwiX3R5cGVcIiwgXCJfY3JlYXRlZEF0XCIsIFwiX3VwZGF0ZWRBdFwiLCBcIl9yZXZcIl07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGlkZVdhcm5pbmdzOiBmYWxzZSxcbiAgZGlmZk1hdGNoUGF0Y2g6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8vIE9ubHkgdXNlIGRpZmYtbWF0Y2gtcGF0Y2ggaWYgdGFyZ2V0IHN0cmluZyBpcyBsb25nZXIgdGhhbiB0aGlzIHRocmVzaG9sZFxuICAgIGxlbmd0aFRocmVzaG9sZEFic29sdXRlOiAzMCxcbiAgICAvLyBPbmx5IHVzZSBnZW5lcmF0ZWQgZGlmZi1tYXRjaC1wYXRjaCBpZiB0aGUgcGF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgIC8vICh0YXJnZXRTdHJpbmcgKiByZWxhdGl2ZSkuIEV4YW1wbGU6IEEgMTAwIGNoYXJhY3RlciB0YXJnZXQgd2l0aCBhIHJlbGF0aXZlIGZhY3RvclxuICAgIC8vIG9mIDEuMiB3aWxsIGFsbG93IGEgMTIwIGNoYXJhY3RlciBkaWZmLW1hdGNoLXBhdGNoLiBJZiBsYXJnZXIgdGhhbiB0aGlzIG51bWJlcixcbiAgICAvLyBpdCB3aWxsIGZhbGwgYmFjayB0byBhIHJlZ3VsYXIgYHNldGAgcGF0Y2guXG4gICAgbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmU6IDEuMlxuICB9XG59O1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zLFxuICAgIGRpZmZNYXRjaFBhdGNoOiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucy5kaWZmTWF0Y2hQYXRjaCxcbiAgICAgIC4uLihvcHRpb25zLmRpZmZNYXRjaFBhdGNoIHx8IHt9KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZQYXRjaChpdGVtQSwgaXRlbUIsIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRzIHx8IHt9KTtcbiAgY29uc3QgaWQgPSBvcHRpb25zLmlkIHx8IGl0ZW1BLl9pZCA9PT0gaXRlbUIuX2lkICYmIGl0ZW1BLl9pZDtcbiAgY29uc3QgcmV2aXNpb25Mb2NrZWQgPSBvcHRpb25zLmlmUmV2aXNpb25JRDtcbiAgY29uc3QgaWZSZXZpc2lvbklEID0gdHlwZW9mIHJldmlzaW9uTG9ja2VkID09PSBcImJvb2xlYW5cIiA/IGl0ZW1BLl9yZXYgOiByZXZpc2lvbkxvY2tlZDtcbiAgY29uc3QgYmFzZVBhdGggPSBvcHRpb25zLmJhc2VQYXRoIHx8IFtdO1xuICBpZiAoIWlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiX2lkIG9uIGl0ZW1BIGFuZCBpdGVtQiBub3QgcHJlc2VudCBvciBkaWZmZXJzLCBzcGVjaWZ5IGRvY3VtZW50IGlkIHRoZSBtdXRhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgdG9cIik7XG4gIH1cbiAgaWYgKHJldmlzaW9uTG9ja2VkID09PSB0cnVlICYmICFpZlJldmlzaW9uSUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaWZSZXZpc2lvbklEYCBpcyBzZXQgdG8gYHRydWVgLCBidXQgbm8gYF9yZXZgIHdhcyBwYXNzZWQgaW4gaXRlbSBBLiBFaXRoZXIgZXhwbGljaXRseSBzZXQgYGlmUmV2aXNpb25JRGAgdG8gYSByZXZpc2lvbiwgb3IgcGFzcyBgX3JldmAgYXMgcGFydCBvZiBpdGVtIEEuXCIpO1xuICB9XG4gIGlmIChiYXNlUGF0aC5sZW5ndGggPT09IDAgJiYgaXRlbUEuX3R5cGUgIT09IGl0ZW1CLl90eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiX3R5cGUgaXMgaW1tdXRhYmxlIGFuZCBjYW5ub3QgYmUgY2hhbmdlZCAoXCIuY29uY2F0KGl0ZW1BLl90eXBlLCBcIiA9PiBcIikuY29uY2F0KGl0ZW1CLl90eXBlLCBcIilcIikpO1xuICB9XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBkaWZmSXRlbShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIGJhc2VQYXRoLCBbXSk7XG4gIHJldHVybiBzZXJpYWxpemVQYXRjaGVzKG9wZXJhdGlvbnMsIHtcbiAgICBpZCxcbiAgICBpZlJldmlzaW9uSUQ6IHJldmlzaW9uTG9ja2VkID8gaWZSZXZpc2lvbklEIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlmZkl0ZW0oaXRlbUEsIGl0ZW1CKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0T3B0aW9ucztcbiAgbGV0IHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICBsZXQgcGF0Y2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIGlmIChpdGVtQSA9PT0gaXRlbUIpIHtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBjb25zdCBhVHlwZSA9IEFycmF5LmlzQXJyYXkoaXRlbUEpID8gXCJhcnJheVwiIDogdHlwZW9mIGl0ZW1BO1xuICBjb25zdCBiVHlwZSA9IEFycmF5LmlzQXJyYXkoaXRlbUIpID8gXCJhcnJheVwiIDogdHlwZW9mIGl0ZW1CO1xuICBjb25zdCBhSXNVbmRlZmluZWQgPSBhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgYklzVW5kZWZpbmVkID0gYlR5cGUgPT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChhSXNVbmRlZmluZWQgJiYgIWJJc1VuZGVmaW5lZCkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJzZXRcIixcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogaXRlbUJcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBpZiAoIWFJc1VuZGVmaW5lZCAmJiBiSXNVbmRlZmluZWQpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdHMpO1xuICBjb25zdCBkYXRhVHlwZSA9IGFJc1VuZGVmaW5lZCA/IGJUeXBlIDogYVR5cGU7XG4gIGNvbnN0IGlzQ29udGFpbmVyID0gZGF0YVR5cGUgPT09IFwib2JqZWN0XCIgfHwgZGF0YVR5cGUgPT09IFwiYXJyYXlcIjtcbiAgaWYgKCFpc0NvbnRhaW5lcikge1xuICAgIHJldHVybiBkaWZmUHJpbWl0aXZlKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG4gIH1cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJzZXRcIixcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogaXRlbUJcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4gZGF0YVR5cGUgPT09IFwiYXJyYXlcIiA/IGRpZmZBcnJheShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZk9iamVjdChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xufVxuZnVuY3Rpb24gZGlmZk9iamVjdChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3QgYXRSb290ID0gcGF0aC5sZW5ndGggPT09IDA7XG4gIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoaXRlbUEpLmZpbHRlcihhdFJvb3QgPyBpc05vdElnbm9yZWRLZXkgOiB5ZXMpLm1hcChrZXkgPT4gdmFsaWRhdGVQcm9wZXJ0eShrZXksIGl0ZW1BW2tleV0sIHBhdGgpKTtcbiAgY29uc3QgYUtleXNMZW5ndGggPSBhS2V5cy5sZW5ndGg7XG4gIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoaXRlbUIpLmZpbHRlcihhdFJvb3QgPyBpc05vdElnbm9yZWRLZXkgOiB5ZXMpLm1hcChrZXkgPT4gdmFsaWRhdGVQcm9wZXJ0eShrZXksIGl0ZW1CW2tleV0sIHBhdGgpKTtcbiAgY29uc3QgYktleXNMZW5ndGggPSBiS2V5cy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYUtleXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGFLZXlzW2ldO1xuICAgIGlmICghKGtleSBpbiBpdGVtQikpIHtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICAgIHBhdGg6IHBhdGguY29uY2F0KGtleSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBiS2V5c1tpXTtcbiAgICBkaWZmSXRlbShpdGVtQVtrZXldLCBpdGVtQltrZXldLCBvcHRpb25zLCBwYXRoLmNvbmNhdChba2V5XSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBpZiAoaXRlbUIubGVuZ3RoID4gaXRlbUEubGVuZ3RoKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcImluc2VydFwiLFxuICAgICAgYWZ0ZXI6IHBhdGguY29uY2F0KFstMV0pLFxuICAgICAgaXRlbXM6IGl0ZW1CLnNsaWNlKGl0ZW1BLmxlbmd0aCkubWFwKChpdGVtLCBpKSA9PiBudWxsaWZ5VW5kZWZpbmVkKGl0ZW0sIHBhdGgsIGksIG9wdGlvbnMpKVxuICAgIH0pO1xuICB9XG4gIGlmIChpdGVtQi5sZW5ndGggPCBpdGVtQS5sZW5ndGgpIHtcbiAgICBjb25zdCBpc1NpbmdsZSA9IGl0ZW1BLmxlbmd0aCAtIGl0ZW1CLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCB1bnNldEl0ZW1zID0gaXRlbUEuc2xpY2UoaXRlbUIubGVuZ3RoKTtcbiAgICBpZiAoaXNSZXZpc2lvbkxvY2tlZChvcHRpb25zKSB8fCAhaXNVbmlxdWVseUtleWVkKHVuc2V0SXRlbXMpKSB7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdChbaXNTaW5nbGUgPyBpdGVtQi5sZW5ndGggOiBbaXRlbUIubGVuZ3RoLCBcIlwiXV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hlcy5wdXNoKC4uLnVuc2V0SXRlbXMubWFwKGl0ZW0gPT4gKHtcbiAgICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgICAgcGF0aDogcGF0aC5jb25jYXQoe1xuICAgICAgICAgIF9rZXk6IGl0ZW0uX2tleVxuICAgICAgICB9KVxuICAgICAgfSkpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1CW2ldKSkge1xuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIk11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIHBhdGguY29uY2F0KGkpLCBpdGVtQltpXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG92ZXJsYXBwaW5nID0gTWF0aC5taW4oaXRlbUEubGVuZ3RoLCBpdGVtQi5sZW5ndGgpO1xuICBjb25zdCBzZWdtZW50QSA9IGl0ZW1BLnNsaWNlKDAsIG92ZXJsYXBwaW5nKTtcbiAgY29uc3Qgc2VnbWVudEIgPSBpdGVtQi5zbGljZSgwLCBvdmVybGFwcGluZyk7XG4gIHJldHVybiBpc1VuaXF1ZWx5S2V5ZWQoc2VnbWVudEEpICYmIGlzVW5pcXVlbHlLZXllZChzZWdtZW50QikgPyBkaWZmQXJyYXlCeUtleShzZWdtZW50QSwgc2VnbWVudEIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZkFycmF5QnlJbmRleChzZWdtZW50QSwgc2VnbWVudEIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5QnlJbmRleChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQS5sZW5ndGg7IGkrKykge1xuICAgIGRpZmZJdGVtKGl0ZW1BW2ldLCBudWxsaWZ5VW5kZWZpbmVkKGl0ZW1CW2ldLCBwYXRoLCBpLCBvcHRpb25zKSwgb3B0aW9ucywgcGF0aC5jb25jYXQoaSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5QnlLZXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGtleWVkQSA9IGluZGV4QnlLZXkoaXRlbUEpO1xuICBjb25zdCBrZXllZEIgPSBpbmRleEJ5S2V5KGl0ZW1CKTtcbiAgaWYgKCFhcnJheUlzRXF1YWwoa2V5ZWRBLmtleXMsIGtleWVkQi5rZXlzKSkge1xuICAgIHJldHVybiBkaWZmQXJyYXlCeUluZGV4KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXllZEIua2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleWVkQi5rZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlQSA9IGtleWVkQS5pbmRleFtrZXldO1xuICAgIGNvbnN0IHZhbHVlQiA9IG51bGxpZnlVbmRlZmluZWQoa2V5ZWRCLmluZGV4W2tleV0sIHBhdGgsIGksIG9wdGlvbnMpO1xuICAgIGRpZmZJdGVtKHZhbHVlQSwgdmFsdWVCLCBvcHRpb25zLCBwYXRoLmNvbmNhdCh7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9KSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREaWZmTWF0Y2hQYXRjaChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQsXG4gICAgbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmUsXG4gICAgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGVcbiAgfSA9IG9wdGlvbnMuZGlmZk1hdGNoUGF0Y2g7XG4gIGNvbnN0IHNlZ21lbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghZW5hYmxlZCB8fFxuICAvLyBEb24ndCB1c2UgZm9yIGFueXRoaW5nIGJ1dCBzdHJpbmdzXG4gIHR5cGVvZiBpdGVtQSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaXRlbUIgIT09IFwic3RyaW5nXCIgfHxcbiAgLy8gRG9uJ3QgdXNlIGZvciBgX2tleWAsIGBfcmVmYCBldGNcbiAgdHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIgJiYgc2VnbWVudFswXSA9PT0gXCJfXCIgfHxcbiAgLy8gRG9uJ3QgdXNlIG9uIHNob3J0IHN0cmluZ3NcbiAgaXRlbUIubGVuZ3RoIDwgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBzdHJQYXRjaCA9IFwiXCI7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaC5tYWtlRGlmZihpdGVtQSwgaXRlbUIpO1xuICAgIGNvbnN0IGRpZmYgPSBkaWZmTWF0Y2hQYXRjaC5jbGVhbnVwRWZmaWNpZW5jeShwYXRjaCk7XG4gICAgc3RyUGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaC5zdHJpbmdpZnlQYXRjaGVzKGRpZmZNYXRjaFBhdGNoLm1ha2VQYXRjaGVzKGRpZmYpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gc3RyUGF0Y2gubGVuZ3RoID4gaXRlbUIubGVuZ3RoICogbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmUgPyB2b2lkIDAgOiB7XG4gICAgb3A6IFwiZGlmZk1hdGNoUGF0Y2hcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlOiBzdHJQYXRjaFxuICB9O1xufVxuZnVuY3Rpb24gZGlmZlByaW1pdGl2ZShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3QgZG1wID0gZ2V0RGlmZk1hdGNoUGF0Y2goaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoKTtcbiAgcGF0Y2hlcy5wdXNoKGRtcCB8fCB7XG4gICAgb3A6IFwic2V0XCIsXG4gICAgcGF0aCxcbiAgICB2YWx1ZTogaXRlbUJcbiAgfSk7XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gaXNOb3RJZ25vcmVkS2V5KGtleSkge1xuICByZXR1cm4gaWdub3JlZEtleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGNoZXMocGF0Y2hlcywgb3B0aW9ucykge1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIGlmUmV2aXNpb25JRFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2V0ID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwic2V0XCIpO1xuICBjb25zdCB1bnNldCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcInVuc2V0XCIpO1xuICBjb25zdCBpbnNlcnQgPSBwYXRjaGVzLmZpbHRlcihwYXRjaCA9PiBwYXRjaC5vcCA9PT0gXCJpbnNlcnRcIik7XG4gIGNvbnN0IGRtcCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcImRpZmZNYXRjaFBhdGNoXCIpO1xuICBjb25zdCB3aXRoU2V0ID0gc2V0Lmxlbmd0aCA+IDAgJiYgc2V0LnJlZHVjZSgocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgcGF0Y2guc2V0W3BhdGhdID0gaXRlbS52YWx1ZTtcbiAgICByZXR1cm4gcGF0Y2g7XG4gIH0sIHtcbiAgICBpZCxcbiAgICBzZXQ6IHt9XG4gIH0pO1xuICBjb25zdCB3aXRoVW5zZXQgPSB1bnNldC5sZW5ndGggPiAwICYmIHVuc2V0LnJlZHVjZSgocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgcGF0Y2gudW5zZXQucHVzaChwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2g7XG4gIH0sIHtcbiAgICBpZCxcbiAgICB1bnNldDogW11cbiAgfSk7XG4gIGNvbnN0IHdpdGhJbnNlcnQgPSBpbnNlcnQucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBhZnRlciA9IHBhdGhUb1N0cmluZyhpdGVtLmFmdGVyKTtcbiAgICByZXR1cm4gYWNjLmNvbmNhdCh7XG4gICAgICBpZCxcbiAgICAgIGluc2VydDoge1xuICAgICAgICBhZnRlcixcbiAgICAgICAgaXRlbXM6IGl0ZW0uaXRlbXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB3aXRoRG1wID0gZG1wLmxlbmd0aCA+IDAgJiYgZG1wLnJlZHVjZSgocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgcGF0Y2guZGlmZk1hdGNoUGF0Y2hbcGF0aF0gPSBpdGVtLnZhbHVlO1xuICAgIHJldHVybiBwYXRjaDtcbiAgfSwge1xuICAgIGlkLFxuICAgIGRpZmZNYXRjaFBhdGNoOiB7fVxuICB9KTtcbiAgY29uc3QgcGF0Y2hTZXQgPSBbd2l0aFNldCwgd2l0aFVuc2V0LCB3aXRoRG1wLCAuLi53aXRoSW5zZXJ0XS5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBmYWxzZSk7XG4gIHJldHVybiBwYXRjaFNldC5tYXAoKHBhdGNoLCBpKSA9PiAoe1xuICAgIHBhdGNoOiBpZlJldmlzaW9uSUQgJiYgaSA9PT0gMCA/IHtcbiAgICAgIC4uLnBhdGNoLFxuICAgICAgaWZSZXZpc2lvbklEXG4gICAgfSA6IHBhdGNoXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVW5pcXVlbHlLZXllZChhcnIpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcnJbaV0pO1xuICAgIGlmICgha2V5IHx8IGtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEtleShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmIG9iai5fa2V5O1xufVxuZnVuY3Rpb24gaW5kZXhCeUtleShhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGFjYy5rZXlzLnB1c2goaXRlbS5fa2V5KTtcbiAgICBhY2MuaW5kZXhbaXRlbS5fa2V5XSA9IGl0ZW07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge1xuICAgIGtleXM6IFtdLFxuICAgIGluZGV4OiB7fVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNFcXVhbChpdGVtQSwgaXRlbUIpIHtcbiAgcmV0dXJuIGl0ZW1BLmxlbmd0aCA9PT0gaXRlbUIubGVuZ3RoICYmIGl0ZW1BLmV2ZXJ5KChpdGVtLCBpKSA9PiBpdGVtQltpXSA9PT0gaXRlbSk7XG59XG5mdW5jdGlvbiBudWxsaWZ5VW5kZWZpbmVkKGl0ZW0sIHBhdGgsIGluZGV4LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGlmICghb3B0aW9ucy5oaWRlV2FybmluZ3MpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF0aCA9IHBhdGhUb1N0cmluZyhwYXRoLmNvbmNhdChpbmRleCkpO1xuICAgIGNvbnNvbGUud2FybihcInVuZGVmaW5lZCB2YWx1ZSBpbiBhcnJheSBjb252ZXJ0ZWQgdG8gbnVsbCAoYXQgJ1wiLmNvbmNhdChzZXJpYWxpemVkUGF0aCwgXCInKVwiKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1JldmlzaW9uTG9ja2VkKG9wdGlvbnMpIHtcbiAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5pZlJldmlzaW9uSUQpO1xufVxuZnVuY3Rpb24geWVzKF8pIHtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLkRpZmZFcnJvciA9IERpZmZFcnJvcjtcbmV4cG9ydHMuZGlmZkl0ZW0gPSBkaWZmSXRlbTtcbmV4cG9ydHMuZGlmZlBhdGNoID0gZGlmZlBhdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.cjs\n");

/***/ })

};
;