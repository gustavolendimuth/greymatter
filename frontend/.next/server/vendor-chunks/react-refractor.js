"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-refractor";
exports.ids = ["vendor-chunks/react-refractor"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-refractor/lib/Refractor.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-refractor/lib/Refractor.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\nvar fract = __webpack_require__(/*! refractor/core.js */ \"(ssr)/./node_modules/refractor/core.js\");\n\nvar mapChildren = __webpack_require__(/*! ./mapChildren */ \"(ssr)/./node_modules/react-refractor/lib/mapChildren.js\");\n\nvar addMarkers = __webpack_require__(/*! ./addMarkers */ \"(ssr)/./node_modules/react-refractor/lib/addMarkers.js\"); // eslint-disable-next-line id-length\n\n\nvar h = React.createElement;\n\nfunction Refractor(props) {\n  if (true) {\n    if (!fract.registered(props.language)) {\n      // eslint-disable-next-line no-console\n      console.warn(\"No language definitions for \\\"\".concat(props.language, \"\\\" seems to be registered, did you forget to call `Refractor.registerLanguage()`?\"));\n    }\n  }\n\n  var langClassName = \"language-\".concat(props.language);\n  var codeProps = {\n    className: langClassName\n  };\n  var preProps = {\n    className: [props.className, langClassName].filter(Boolean).join(' ')\n  };\n\n  if (props.inline) {\n    codeProps.style = {\n      display: 'inline'\n    };\n    codeProps.className = props.className;\n  }\n\n  var ast = fract.highlight(props.value, props.language);\n\n  if (props.markers && props.markers.length > 0) {\n    ast = addMarkers(ast, {\n      markers: props.markers\n    });\n  }\n\n  var value = ast.length === 0 ? props.value : ast.map(mapChildren.depth(0));\n  var code = h('code', codeProps, value);\n  return props.inline ? code : h('pre', preProps, code);\n}\n\nRefractor.propTypes = {\n  className: PropTypes.string,\n  inline: PropTypes.bool,\n  language: PropTypes.string.isRequired,\n  value: PropTypes.string.isRequired,\n  markers: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    line: PropTypes.number.isRequired,\n    className: PropTypes.string,\n    component: PropTypes.oneOfType([PropTypes.node, PropTypes.func])\n  })]))\n};\nRefractor.defaultProps = {\n  className: 'refractor',\n  inline: false\n};\n\nRefractor.registerLanguage = function (lang) {\n  return fract.register(lang);\n};\n\nRefractor.hasLanguage = function (lang) {\n  return fract.registered(lang);\n};\n\nmodule.exports = Refractor;\n//# sourceMappingURL=Refractor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2xpYi9SZWZyYWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBWTs7QUFFcEMsWUFBWSxtQkFBTyxDQUFDLGlFQUFtQjs7QUFFdkMsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7O0FBRXpDLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFjLEdBQUc7OztBQUcxQzs7QUFFQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyZXltYXR0ZXItdjIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2xpYi9SZWZyYWN0b3IuanM/MmU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIGZyYWN0ID0gcmVxdWlyZSgncmVmcmFjdG9yL2NvcmUuanMnKTtcblxudmFyIG1hcENoaWxkcmVuID0gcmVxdWlyZSgnLi9tYXBDaGlsZHJlbicpO1xuXG52YXIgYWRkTWFya2VycyA9IHJlcXVpcmUoJy4vYWRkTWFya2VycycpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaWQtbGVuZ3RoXG5cblxudmFyIGggPSBSZWFjdC5jcmVhdGVFbGVtZW50O1xuXG5mdW5jdGlvbiBSZWZyYWN0b3IocHJvcHMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIWZyYWN0LnJlZ2lzdGVyZWQocHJvcHMubGFuZ3VhZ2UpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiTm8gbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgZm9yIFxcXCJcIi5jb25jYXQocHJvcHMubGFuZ3VhZ2UsIFwiXFxcIiBzZWVtcyB0byBiZSByZWdpc3RlcmVkLCBkaWQgeW91IGZvcmdldCB0byBjYWxsIGBSZWZyYWN0b3IucmVnaXN0ZXJMYW5ndWFnZSgpYD9cIikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5nQ2xhc3NOYW1lID0gXCJsYW5ndWFnZS1cIi5jb25jYXQocHJvcHMubGFuZ3VhZ2UpO1xuICB2YXIgY29kZVByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogbGFuZ0NsYXNzTmFtZVxuICB9O1xuICB2YXIgcHJlUHJvcHMgPSB7XG4gICAgY2xhc3NOYW1lOiBbcHJvcHMuY2xhc3NOYW1lLCBsYW5nQ2xhc3NOYW1lXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpXG4gIH07XG5cbiAgaWYgKHByb3BzLmlubGluZSkge1xuICAgIGNvZGVQcm9wcy5zdHlsZSA9IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUnXG4gICAgfTtcbiAgICBjb2RlUHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICB9XG5cbiAgdmFyIGFzdCA9IGZyYWN0LmhpZ2hsaWdodChwcm9wcy52YWx1ZSwgcHJvcHMubGFuZ3VhZ2UpO1xuXG4gIGlmIChwcm9wcy5tYXJrZXJzICYmIHByb3BzLm1hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgIGFzdCA9IGFkZE1hcmtlcnMoYXN0LCB7XG4gICAgICBtYXJrZXJzOiBwcm9wcy5tYXJrZXJzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBhc3QubGVuZ3RoID09PSAwID8gcHJvcHMudmFsdWUgOiBhc3QubWFwKG1hcENoaWxkcmVuLmRlcHRoKDApKTtcbiAgdmFyIGNvZGUgPSBoKCdjb2RlJywgY29kZVByb3BzLCB2YWx1ZSk7XG4gIHJldHVybiBwcm9wcy5pbmxpbmUgPyBjb2RlIDogaCgncHJlJywgcHJlUHJvcHMsIGNvZGUpO1xufVxuXG5SZWZyYWN0b3IucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGxhbmd1YWdlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIG1hcmtlcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbGluZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjb21wb25lbnQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pXG4gIH0pXSkpXG59O1xuUmVmcmFjdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAncmVmcmFjdG9yJyxcbiAgaW5saW5lOiBmYWxzZVxufTtcblxuUmVmcmFjdG9yLnJlZ2lzdGVyTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZykge1xuICByZXR1cm4gZnJhY3QucmVnaXN0ZXIobGFuZyk7XG59O1xuXG5SZWZyYWN0b3IuaGFzTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZykge1xuICByZXR1cm4gZnJhY3QucmVnaXN0ZXJlZChsYW5nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVmcmFjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmcmFjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-refractor/lib/Refractor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-refractor/lib/addMarkers.js":
/*!********************************************************!*\
  !*** ./node_modules/react-refractor/lib/addMarkers.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar filter = __webpack_require__(/*! unist-util-filter */ \"(ssr)/./node_modules/unist-util-filter/index.js\");\n\nvar visit = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/index.js\");\n\nvar NodeMap = __webpack_require__(/*! ./map */ \"(ssr)/./node_modules/react-refractor/lib/map.js\");\n\nfunction lineNumberify(ast) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lineNumber: 1\n  };\n  return ast.reduce(function (result, node) {\n    var lineStart = context.lineNumber;\n\n    if (node.type === 'text') {\n      if (node.value.indexOf('\\n') === -1) {\n        node.lineStart = lineStart;\n        node.lineEnd = lineStart;\n        result.nodes.push(node);\n        return result;\n      }\n\n      var lines = node.value.split('\\n');\n\n      for (var i = 0; i < lines.length; i++) {\n        var lineNum = i === 0 ? context.lineNumber : ++context.lineNumber;\n        result.nodes.push({\n          type: 'text',\n          value: i === lines.length - 1 ? lines[i] : \"\".concat(lines[i], \"\\n\"),\n          lineStart: lineNum,\n          lineEnd: lineNum\n        });\n      }\n\n      result.lineNumber = context.lineNumber;\n      return result;\n    }\n\n    if (node.children) {\n      var processed = lineNumberify(node.children, context);\n      var firstChild = processed.nodes[0];\n      var lastChild = processed.nodes[processed.nodes.length - 1];\n      node.lineStart = firstChild ? firstChild.lineStart : lineStart;\n      node.lineEnd = lastChild ? lastChild.lineEnd : lineStart;\n      node.children = processed.nodes;\n      result.lineNumber = processed.lineNumber;\n      result.nodes.push(node);\n      return result;\n    }\n\n    result.nodes.push(node);\n    return result;\n  }, {\n    nodes: [],\n    lineNumber: context.lineNumber\n  });\n}\n\nfunction unwrapLine(markerLine, nodes) {\n  var tree = {\n    type: 'root',\n    children: nodes\n  };\n  var headMap = new NodeMap();\n  var lineMap = new NodeMap();\n  var tailMap = new NodeMap();\n  var cloned = [];\n\n  function addCopy(map, node, ancestors) {\n    cloned.push(node);\n    ancestors.forEach(function (ancestor) {\n      if (!map.has(ancestor)) {\n        map.set(ancestor, Object.assign({}, ancestor, {\n          children: []\n        }));\n\n        if (ancestor !== tree) {\n          cloned.push(ancestor);\n        }\n      }\n    });\n    var i = ancestors.length;\n\n    while (i--) {\n      var ancestor = map.get(ancestors[i]);\n      var child = ancestors[i + 1];\n      var leaf = map.get(child) || node;\n\n      if (ancestor.children.indexOf(leaf) === -1) {\n        ancestor.children.push(leaf);\n      }\n    }\n  }\n\n  visit(tree, function (node, ancestors) {\n    if (node.children) {\n      return;\n    } // These nodes are on previous lines, but nested within the same structure\n\n\n    if (node.lineStart < markerLine) {\n      addCopy(headMap, node, ancestors);\n      return;\n    } // These nodes are on the target line\n\n\n    if (node.lineStart === markerLine) {\n      addCopy(lineMap, node, ancestors);\n      return;\n    } // If we have shared ancestors with some of the cloned elements,\n    // create another tree of the remaining nodes\n\n\n    if (node.lineEnd > markerLine && cloned.some(function (clone) {\n      return ancestors.indexOf(clone) !== -1;\n    })) {\n      addCopy(tailMap, node, ancestors);\n    }\n  }); // Get the remaining nodes - the ones who were not part of the same tree\n\n  var filtered = filter(tree, function (node) {\n    return cloned.indexOf(node) === -1;\n  });\n\n  var getChildren = function getChildren(map) {\n    var rootNode = map.get(tree);\n\n    if (!rootNode) {\n      return [];\n    }\n\n    visit(rootNode, function (leaf, ancestors) {\n      if (leaf.children) {\n        leaf.lineStart = 0;\n        leaf.lineEnd = 0;\n        return;\n      }\n\n      ancestors.forEach(function (ancestor) {\n        ancestor.lineStart = Math.max(ancestor.lineStart, leaf.lineStart);\n        ancestor.lineEnd = Math.max(ancestor.lineEnd, leaf.lineEnd);\n      });\n    });\n    return rootNode.children;\n  };\n\n  var merged = [].concat(getChildren(headMap), getChildren(lineMap), getChildren(tailMap), filtered ? filtered.children : []);\n  headMap.clear();\n  lineMap.clear();\n  tailMap.clear();\n  return merged;\n}\n\nfunction wrapBatch(children, marker, options) {\n  var className = marker.className || 'refractor-marker';\n  return {\n    type: 'element',\n    tagName: marker.component || 'div',\n    properties: marker.component ? Object.assign({}, options, {\n      className: className\n    }) : {\n      className: className\n    },\n    children: children,\n    lineStart: marker.line,\n    lineEnd: children[children.length - 1].lineEnd,\n    isMarker: true\n  };\n}\n\nfunction wrapLines(treeNodes, markers, options) {\n  if (markers.length === 0 || treeNodes.length === 0) {\n    return treeNodes;\n  }\n\n  var ast = markers.reduce(function (acc, marker) {\n    return unwrapLine(marker.line, acc);\n  }, treeNodes); // Container for the new AST\n\n  var wrapped = []; // Note: Markers are already sorted by line number (ascending)\n\n  var astIndex = 0;\n\n  for (var m = 0; m < markers.length; m++) {\n    var marker = markers[m]; // Start by eating all AST nodes with line numbers up to the given marker\n\n    for (var node = ast[astIndex]; node && node.lineEnd < marker.line; node = ast[++astIndex]) {\n      wrapped.push(node);\n    } // Now proceed to find all _contiguous_ nodes on the same line\n\n\n    var batch = [];\n\n    for (var _node = ast[astIndex]; _node && _node.lineEnd === marker.line; _node = ast[++astIndex]) {\n      batch.push(_node);\n    } // Now add that batch, if we have anything\n\n\n    if (batch.length > 0) {\n      wrapped.push(wrapBatch(batch, marker, options));\n    }\n  } // Now add the remaining AST nodes\n\n\n  while (astIndex < ast.length) {\n    wrapped.push(ast[astIndex++]);\n  }\n\n  return wrapped;\n}\n\nfunction addMarkers(ast, options) {\n  var markers = options.markers.map(function (marker) {\n    return marker.line ? marker : {\n      line: marker\n    };\n  }).sort(function (nodeA, nodeB) {\n    return nodeA.line - nodeB.line;\n  });\n  var numbered = lineNumberify(ast).nodes;\n  return wrapLines(numbered, markers, options);\n}\n\nmodule.exports = addMarkers;\n//# sourceMappingURL=addMarkers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2xpYi9hZGRNYXJrZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRXhDLFlBQVksbUJBQU8sQ0FBQyx3RkFBMEI7O0FBRTlDLGNBQWMsbUJBQU8sQ0FBQyw4REFBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsY0FBYzs7QUFFakIsb0JBQW9COztBQUVwQjs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLDZCQUE2Qjs7QUFFN0IsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBLE1BQU07OztBQUdOOztBQUVBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWZyYWN0b3IvbGliL2FkZE1hcmtlcnMuanM/YzBjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGZpbHRlciA9IHJlcXVpcmUoJ3VuaXN0LXV0aWwtZmlsdGVyJyk7XG5cbnZhciB2aXNpdCA9IHJlcXVpcmUoJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cycpO1xuXG52YXIgTm9kZU1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cbmZ1bmN0aW9uIGxpbmVOdW1iZXJpZnkoYXN0KSB7XG4gIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgbGluZU51bWJlcjogMVxuICB9O1xuICByZXR1cm4gYXN0LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBub2RlKSB7XG4gICAgdmFyIGxpbmVTdGFydCA9IGNvbnRleHQubGluZU51bWJlcjtcblxuICAgIGlmIChub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgaWYgKG5vZGUudmFsdWUuaW5kZXhPZignXFxuJykgPT09IC0xKSB7XG4gICAgICAgIG5vZGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBub2RlLmxpbmVFbmQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZXMgPSBub2RlLnZhbHVlLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZU51bSA9IGkgPT09IDAgPyBjb250ZXh0LmxpbmVOdW1iZXIgOiArK2NvbnRleHQubGluZU51bWJlcjtcbiAgICAgICAgcmVzdWx0Lm5vZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB2YWx1ZTogaSA9PT0gbGluZXMubGVuZ3RoIC0gMSA/IGxpbmVzW2ldIDogXCJcIi5jb25jYXQobGluZXNbaV0sIFwiXFxuXCIpLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZU51bSxcbiAgICAgICAgICBsaW5lRW5kOiBsaW5lTnVtXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQubGluZU51bWJlciA9IGNvbnRleHQubGluZU51bWJlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBwcm9jZXNzZWQgPSBsaW5lTnVtYmVyaWZ5KG5vZGUuY2hpbGRyZW4sIGNvbnRleHQpO1xuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBwcm9jZXNzZWQubm9kZXNbMF07XG4gICAgICB2YXIgbGFzdENoaWxkID0gcHJvY2Vzc2VkLm5vZGVzW3Byb2Nlc3NlZC5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIG5vZGUubGluZVN0YXJ0ID0gZmlyc3RDaGlsZCA/IGZpcnN0Q2hpbGQubGluZVN0YXJ0IDogbGluZVN0YXJ0O1xuICAgICAgbm9kZS5saW5lRW5kID0gbGFzdENoaWxkID8gbGFzdENoaWxkLmxpbmVFbmQgOiBsaW5lU3RhcnQ7XG4gICAgICBub2RlLmNoaWxkcmVuID0gcHJvY2Vzc2VkLm5vZGVzO1xuICAgICAgcmVzdWx0LmxpbmVOdW1iZXIgPSBwcm9jZXNzZWQubGluZU51bWJlcjtcbiAgICAgIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQubm9kZXMucHVzaChub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGxpbmVOdW1iZXI6IGNvbnRleHQubGluZU51bWJlclxuICB9KTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGluZShtYXJrZXJMaW5lLCBub2Rlcykge1xuICB2YXIgdHJlZSA9IHtcbiAgICB0eXBlOiAncm9vdCcsXG4gICAgY2hpbGRyZW46IG5vZGVzXG4gIH07XG4gIHZhciBoZWFkTWFwID0gbmV3IE5vZGVNYXAoKTtcbiAgdmFyIGxpbmVNYXAgPSBuZXcgTm9kZU1hcCgpO1xuICB2YXIgdGFpbE1hcCA9IG5ldyBOb2RlTWFwKCk7XG4gIHZhciBjbG9uZWQgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRDb3B5KG1hcCwgbm9kZSwgYW5jZXN0b3JzKSB7XG4gICAgY2xvbmVkLnB1c2gobm9kZSk7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoIW1hcC5oYXMoYW5jZXN0b3IpKSB7XG4gICAgICAgIG1hcC5zZXQoYW5jZXN0b3IsIE9iamVjdC5hc3NpZ24oe30sIGFuY2VzdG9yLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoYW5jZXN0b3IgIT09IHRyZWUpIHtcbiAgICAgICAgICBjbG9uZWQucHVzaChhbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgaSA9IGFuY2VzdG9ycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtYXAuZ2V0KGFuY2VzdG9yc1tpXSk7XG4gICAgICB2YXIgY2hpbGQgPSBhbmNlc3RvcnNbaSArIDFdO1xuICAgICAgdmFyIGxlYWYgPSBtYXAuZ2V0KGNoaWxkKSB8fCBub2RlO1xuXG4gICAgICBpZiAoYW5jZXN0b3IuY2hpbGRyZW4uaW5kZXhPZihsZWFmKSA9PT0gLTEpIHtcbiAgICAgICAgYW5jZXN0b3IuY2hpbGRyZW4ucHVzaChsZWFmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2aXNpdCh0cmVlLCBmdW5jdGlvbiAobm9kZSwgYW5jZXN0b3JzKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZXNlIG5vZGVzIGFyZSBvbiBwcmV2aW91cyBsaW5lcywgYnV0IG5lc3RlZCB3aXRoaW4gdGhlIHNhbWUgc3RydWN0dXJlXG5cblxuICAgIGlmIChub2RlLmxpbmVTdGFydCA8IG1hcmtlckxpbmUpIHtcbiAgICAgIGFkZENvcHkoaGVhZE1hcCwgbm9kZSwgYW5jZXN0b3JzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZXNlIG5vZGVzIGFyZSBvbiB0aGUgdGFyZ2V0IGxpbmVcblxuXG4gICAgaWYgKG5vZGUubGluZVN0YXJ0ID09PSBtYXJrZXJMaW5lKSB7XG4gICAgICBhZGRDb3B5KGxpbmVNYXAsIG5vZGUsIGFuY2VzdG9ycyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBoYXZlIHNoYXJlZCBhbmNlc3RvcnMgd2l0aCBzb21lIG9mIHRoZSBjbG9uZWQgZWxlbWVudHMsXG4gICAgLy8gY3JlYXRlIGFub3RoZXIgdHJlZSBvZiB0aGUgcmVtYWluaW5nIG5vZGVzXG5cblxuICAgIGlmIChub2RlLmxpbmVFbmQgPiBtYXJrZXJMaW5lICYmIGNsb25lZC5zb21lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgcmV0dXJuIGFuY2VzdG9ycy5pbmRleE9mKGNsb25lKSAhPT0gLTE7XG4gICAgfSkpIHtcbiAgICAgIGFkZENvcHkodGFpbE1hcCwgbm9kZSwgYW5jZXN0b3JzKTtcbiAgICB9XG4gIH0pOyAvLyBHZXQgdGhlIHJlbWFpbmluZyBub2RlcyAtIHRoZSBvbmVzIHdobyB3ZXJlIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyZWVcblxuICB2YXIgZmlsdGVyZWQgPSBmaWx0ZXIodHJlZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVkLmluZGV4T2Yobm9kZSkgPT09IC0xO1xuICB9KTtcblxuICB2YXIgZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihtYXApIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBtYXAuZ2V0KHRyZWUpO1xuXG4gICAgaWYgKCFyb290Tm9kZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZpc2l0KHJvb3ROb2RlLCBmdW5jdGlvbiAobGVhZiwgYW5jZXN0b3JzKSB7XG4gICAgICBpZiAobGVhZi5jaGlsZHJlbikge1xuICAgICAgICBsZWFmLmxpbmVTdGFydCA9IDA7XG4gICAgICAgIGxlYWYubGluZUVuZCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYW5jZXN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGFuY2VzdG9yKSB7XG4gICAgICAgIGFuY2VzdG9yLmxpbmVTdGFydCA9IE1hdGgubWF4KGFuY2VzdG9yLmxpbmVTdGFydCwgbGVhZi5saW5lU3RhcnQpO1xuICAgICAgICBhbmNlc3Rvci5saW5lRW5kID0gTWF0aC5tYXgoYW5jZXN0b3IubGluZUVuZCwgbGVhZi5saW5lRW5kKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbiAgfTtcblxuICB2YXIgbWVyZ2VkID0gW10uY29uY2F0KGdldENoaWxkcmVuKGhlYWRNYXApLCBnZXRDaGlsZHJlbihsaW5lTWFwKSwgZ2V0Q2hpbGRyZW4odGFpbE1hcCksIGZpbHRlcmVkID8gZmlsdGVyZWQuY2hpbGRyZW4gOiBbXSk7XG4gIGhlYWRNYXAuY2xlYXIoKTtcbiAgbGluZU1hcC5jbGVhcigpO1xuICB0YWlsTWFwLmNsZWFyKCk7XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIHdyYXBCYXRjaChjaGlsZHJlbiwgbWFya2VyLCBvcHRpb25zKSB7XG4gIHZhciBjbGFzc05hbWUgPSBtYXJrZXIuY2xhc3NOYW1lIHx8ICdyZWZyYWN0b3ItbWFya2VyJztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgdGFnTmFtZTogbWFya2VyLmNvbXBvbmVudCB8fCAnZGl2JyxcbiAgICBwcm9wZXJ0aWVzOiBtYXJrZXIuY29tcG9uZW50ID8gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9KSA6IHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbGluZVN0YXJ0OiBtYXJrZXIubGluZSxcbiAgICBsaW5lRW5kOiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS5saW5lRW5kLFxuICAgIGlzTWFya2VyOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHdyYXBMaW5lcyh0cmVlTm9kZXMsIG1hcmtlcnMsIG9wdGlvbnMpIHtcbiAgaWYgKG1hcmtlcnMubGVuZ3RoID09PSAwIHx8IHRyZWVOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJlZU5vZGVzO1xuICB9XG5cbiAgdmFyIGFzdCA9IG1hcmtlcnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG1hcmtlcikge1xuICAgIHJldHVybiB1bndyYXBMaW5lKG1hcmtlci5saW5lLCBhY2MpO1xuICB9LCB0cmVlTm9kZXMpOyAvLyBDb250YWluZXIgZm9yIHRoZSBuZXcgQVNUXG5cbiAgdmFyIHdyYXBwZWQgPSBbXTsgLy8gTm90ZTogTWFya2VycyBhcmUgYWxyZWFkeSBzb3J0ZWQgYnkgbGluZSBudW1iZXIgKGFzY2VuZGluZylcblxuICB2YXIgYXN0SW5kZXggPSAwO1xuXG4gIGZvciAodmFyIG0gPSAwOyBtIDwgbWFya2Vycy5sZW5ndGg7IG0rKykge1xuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW21dOyAvLyBTdGFydCBieSBlYXRpbmcgYWxsIEFTVCBub2RlcyB3aXRoIGxpbmUgbnVtYmVycyB1cCB0byB0aGUgZ2l2ZW4gbWFya2VyXG5cbiAgICBmb3IgKHZhciBub2RlID0gYXN0W2FzdEluZGV4XTsgbm9kZSAmJiBub2RlLmxpbmVFbmQgPCBtYXJrZXIubGluZTsgbm9kZSA9IGFzdFsrK2FzdEluZGV4XSkge1xuICAgICAgd3JhcHBlZC5wdXNoKG5vZGUpO1xuICAgIH0gLy8gTm93IHByb2NlZWQgdG8gZmluZCBhbGwgX2NvbnRpZ3VvdXNfIG5vZGVzIG9uIHRoZSBzYW1lIGxpbmVcblxuXG4gICAgdmFyIGJhdGNoID0gW107XG5cbiAgICBmb3IgKHZhciBfbm9kZSA9IGFzdFthc3RJbmRleF07IF9ub2RlICYmIF9ub2RlLmxpbmVFbmQgPT09IG1hcmtlci5saW5lOyBfbm9kZSA9IGFzdFsrK2FzdEluZGV4XSkge1xuICAgICAgYmF0Y2gucHVzaChfbm9kZSk7XG4gICAgfSAvLyBOb3cgYWRkIHRoYXQgYmF0Y2gsIGlmIHdlIGhhdmUgYW55dGhpbmdcblxuXG4gICAgaWYgKGJhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIHdyYXBwZWQucHVzaCh3cmFwQmF0Y2goYmF0Y2gsIG1hcmtlciwgb3B0aW9ucykpO1xuICAgIH1cbiAgfSAvLyBOb3cgYWRkIHRoZSByZW1haW5pbmcgQVNUIG5vZGVzXG5cblxuICB3aGlsZSAoYXN0SW5kZXggPCBhc3QubGVuZ3RoKSB7XG4gICAgd3JhcHBlZC5wdXNoKGFzdFthc3RJbmRleCsrXSk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuZnVuY3Rpb24gYWRkTWFya2Vycyhhc3QsIG9wdGlvbnMpIHtcbiAgdmFyIG1hcmtlcnMgPSBvcHRpb25zLm1hcmtlcnMubWFwKGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLmxpbmUgPyBtYXJrZXIgOiB7XG4gICAgICBsaW5lOiBtYXJrZXJcbiAgICB9O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgICByZXR1cm4gbm9kZUEubGluZSAtIG5vZGVCLmxpbmU7XG4gIH0pO1xuICB2YXIgbnVtYmVyZWQgPSBsaW5lTnVtYmVyaWZ5KGFzdCkubm9kZXM7XG4gIHJldHVybiB3cmFwTGluZXMobnVtYmVyZWQsIG1hcmtlcnMsIG9wdGlvbnMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1hcmtlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRNYXJrZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-refractor/lib/addMarkers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-refractor/lib/map.js":
/*!*************************************************!*\
  !*** ./node_modules/react-refractor/lib/map.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Weird \"map\" polyfill, that's weak if possible\n */\nmodule.exports = typeof WeakMap === 'function' ? HappyMap : SadMap; // Happy path! Fakes a `clear()` if possible (noop)\n\nfunction HappyMap() {\n  this.map = new WeakMap();\n}\n\nHappyMap.prototype.has = function (key) {\n  return this.map.has(key);\n};\n\nHappyMap.prototype.set = function (key, value) {\n  this.map.set(key, value);\n  return this;\n};\n\nHappyMap.prototype.get = function (key) {\n  return this.map.get(key);\n};\n\nHappyMap.prototype.clear = function () {// intentional noop, since we dont need to/cant clear\n}; // Sad path! Use less stylish approach\n\n\nfunction SadMap() {\n  this.keys = [];\n  this.values = [];\n}\n\nSadMap.prototype.has = function (key) {\n  return this.keys.indexOf(key) !== -1;\n};\n\nSadMap.prototype.set = function (key, value) {\n  var index = this.keys.indexOf(key);\n\n  if (index === -1) {\n    this.keys.push(key);\n    this.values.push(value);\n  } else {\n    this.values[index] = value;\n  }\n\n  return this;\n};\n\nSadMap.prototype.get = function (key) {\n  var index = this.keys.indexOf(key);\n  return index === -1 ? undefined : this.values[index];\n};\n\nSadMap.prototype.clear = function () {\n  this.keys = [];\n  this.values = [];\n};\n//# sourceMappingURL=map.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2xpYi9tYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JleW1hdHRlci12Mi8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWZyYWN0b3IvbGliL21hcC5qcz9iZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFdlaXJkIFwibWFwXCIgcG9seWZpbGwsIHRoYXQncyB3ZWFrIGlmIHBvc3NpYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBIYXBweU1hcCA6IFNhZE1hcDsgLy8gSGFwcHkgcGF0aCEgRmFrZXMgYSBgY2xlYXIoKWAgaWYgcG9zc2libGUgKG5vb3ApXG5cbmZ1bmN0aW9uIEhhcHB5TWFwKCkge1xuICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG59XG5cbkhhcHB5TWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KTtcbn07XG5cbkhhcHB5TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSGFwcHlNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xufTtcblxuSGFwcHlNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgey8vIGludGVudGlvbmFsIG5vb3AsIHNpbmNlIHdlIGRvbnQgbmVlZCB0by9jYW50IGNsZWFyXG59OyAvLyBTYWQgcGF0aCEgVXNlIGxlc3Mgc3R5bGlzaCBhcHByb2FjaFxuXG5cbmZ1bmN0aW9uIFNhZE1hcCgpIHtcbiAgdGhpcy5rZXlzID0gW107XG4gIHRoaXMudmFsdWVzID0gW107XG59XG5cblNhZE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG59O1xuXG5TYWRNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy52YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblNhZE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgaW5kZXggPSB0aGlzLmtleXMuaW5kZXhPZihrZXkpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy52YWx1ZXNbaW5kZXhdO1xufTtcblxuU2FkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5rZXlzID0gW107XG4gIHRoaXMudmFsdWVzID0gW107XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-refractor/lib/map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-refractor/lib/mapChildren.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-refractor/lib/mapChildren.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction mapChild(child, i, depth) {\n  if (child.tagName) {\n    var className = child.properties && Array.isArray(child.properties.className) ? child.properties.className.join(' ') : child.properties.className;\n    return React.createElement(child.tagName, Object.assign({\n      key: \"fract-\".concat(depth, \"-\").concat(i)\n    }, child.properties, {\n      className: className\n    }), child.children && child.children.map(mapWithDepth(depth + 1)));\n  }\n\n  return child.value;\n}\n\nfunction mapWithDepth(depth) {\n  return function mapChildrenWithDepth(child, i) {\n    return mapChild(child, i, depth);\n  };\n}\n\nexports.depth = mapWithDepth;\n//# sourceMappingURL=mapChildren.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2xpYi9tYXBDaGlsZHJlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyZXltYXR0ZXItdjIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2xpYi9tYXBDaGlsZHJlbi5qcz8xN2NkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBtYXBDaGlsZChjaGlsZCwgaSwgZGVwdGgpIHtcbiAgaWYgKGNoaWxkLnRhZ05hbWUpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gY2hpbGQucHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KGNoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lKSA/IGNoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lLmpvaW4oJyAnKSA6IGNoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGNoaWxkLnRhZ05hbWUsIE9iamVjdC5hc3NpZ24oe1xuICAgICAga2V5OiBcImZyYWN0LVwiLmNvbmNhdChkZXB0aCwgXCItXCIpLmNvbmNhdChpKVxuICAgIH0sIGNoaWxkLnByb3BlcnRpZXMsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSksIGNoaWxkLmNoaWxkcmVuICYmIGNoaWxkLmNoaWxkcmVuLm1hcChtYXBXaXRoRGVwdGgoZGVwdGggKyAxKSkpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYXBXaXRoRGVwdGgoZGVwdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1hcENoaWxkcmVuV2l0aERlcHRoKGNoaWxkLCBpKSB7XG4gICAgcmV0dXJuIG1hcENoaWxkKGNoaWxkLCBpLCBkZXB0aCk7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVwdGggPSBtYXBXaXRoRGVwdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBDaGlsZHJlbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-refractor/lib/mapChildren.js\n");

/***/ })

};
;